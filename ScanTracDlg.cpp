//ScanTrac Side View Source File
// ScanTracDlg.cpp : implementation file
//
//vSystemData.vITIPCDig->vOriginalImage is the image shown on the screen in other menus
//vSystemData.vITIPCDig->vImageToDisplayOnMainMenu is the image to display on the Main Menu
//vSystemData.vITIPCDig->vNextImageToDisplay is the next image to show from image process thread

#include "stdafx.h"
#include "winuser.h"
#include "string.h"
#include "io.h"
#include <iostream>
#include "stdio.h"
#include "stdlib.h"
#include "math.h"
#include "Winioctl.h"
#include "direct.h"  //for _getcwd get current working directory
#include <locale.h>
#include "ScanTrac.h"
#include "ScanTracDlg.h"
#include "EasySelectProductDialog.h"
#include "ScanTracConfigureDialog.h"
#include "NoticeDialog.h"
#include "NewDiagnosticDialog.h"
#include "NewImageDisplayDialog.h"
#include "AlphaEntryDialog.h"
#include "PasswordEntryDialog.h"
#include "YesNoDialog.h"
#include "HelpDialog.h"
#include "SerialPort.h"
#include "ImageAquisitionThread.h"
#include "ProcessQuickLearnImagesThread.h"
#include "BackupHardDriveThread.h"
#include "DisplayDialogThread.h"
#include "MapiMessages.h"
#include "MapiSession.h"
#include "HistogramDisplayDialog.h"
#include "NumericEntryDialog.h"
#include "SelectItemDialog.h"
#include "SpellmanDXMXRaySourcePort.h"
#include "ACPowerMoniter.h"
#include "DisplaySavedRejects.h"
#include "CheckWeighDialog.h"
#include "XRaySource.h"
#include "Inspection.h" //needed for curve fitting
#include "SerialPortReview.h" //needed for curve fitting
#include "FillerSeamerSamplingDialog.h"
#include "SamplingDialog.h"
#include "SerialPortGuardMaster.h"
#include "SerialPortPowerFlex40.h"
#include "CheyneyMonoBlock.h"
#include "ProductionSummaryDialog.h"
#include "SerialPortVjtMonoBlock.h"

#include "Process.h" //for _execl or _spawn
#ifdef UseIFCDLLs
	#include "mvtools.h"
#endif
#include "FBWF_info.h"
#include "Spellman100WattMonoBlock.h"
#include "UsersDialog.h"
#include "SerialPortRFIdeasBadgeReader.h"
#include "EditUser.h"
#ifdef CompileInHTTPClientOperationsGuardian
#include "SendNextOGMessageThread.h"
#endif
#include "afxwin.h"

//#include "colors.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

// mod for read ip values directly Visual Studios 2010 kjh 2/22/2012
// for TCPIP
#ifndef WIN32_LEAN_AND_MEAN 
#define WIN32_LEAN_AND_MEAN 
#endif 

#include <windows.h> 

#include <winsock2.h> 
#include <iphlpapi.h> 
#include <icmpapi.h>
#include <ws2tcpip.h> 

#include <stdio.h> 
#include <malloc.h>
#include <stdlib.h>  //
#include "GetCoreTempInfo.h"
#include "ProcessEvaluateImagesThread.h"
#include "SoftKeyMenu.h"

#pragma comment(lib, "Ws2_32.lib") 
#pragma comment(lib, "iphlpapi.lib")
#pragma comment(lib, "comsuppw.lib")
//#pragma comment(lib, "Kernel32.lib")

#define  AFFINITYMASK_MAIN_WINDOW				0x2	// processor #
#define  AFFINITYMASK_DISPLAY						0x2	// processor #
#define  AFFINITYMASK_SERIAL						0x8 // processor #
#define  AFFINITYMASK_POWER_MONITOR			0x8 // processor #
#define  AFFINITYMASK_IMAGE_AQUISITION	0x4 // processor #3
#define  AFFINITYMASK_QUICK_LEARN				0x8	// processor #
#define  AFFINITYMASK_BACKUP_HARDDRIVE	0x8	// processor #

#define cMicroControllerPort 1
#define cXRayPort	3
#define ACPowerMonitorPort 4

const BYTE cNumberOfCalibrationResults = 20;

//changed 4/1/04, was 4000 //change from 5000 to 6000 on 12/2/2005
const WORD cSourceStabilizeWaitTime = 7000; //5/31/2013

#ifdef CompileInHTTPClientOperationsGuardian
	extern DWORD vGlobalOGSendMessageexceptionCount;
	extern DWORD vGlobalOGSendMessageErrorCount;
	extern DWORD vGlobalOGSendMessageGoodCount;
	extern int vGlobalLastOGServerWriteStatusCode;
	extern CSendNextOGMessageThread *vGlobalSendNextOGMessageThread;
	extern CString vGlobalOperationsGuardianServer;
	extern DWORD vGlobalOGMessageSendCounter;
	extern WORD vGlobalOGQueueHead;
	extern WORD vGlobalOGQueueTail;
	extern std::wstring vGlobalOGQueueMessage[cOGQueueLength];
	extern std::wstring vGlobalOGQueueKeyWord[cOGQueueLength];
	extern CString vGlobalOGLocationString;
	extern CString vGlobalOGLimitString;
	extern WORD vGlobalOGErrorCode;
extern CString vGlobalNewOperationsGuardianErrorMessage;
#endif

extern bool vGlobalClosePasswordDialog;
extern CString vGlobalPasswordToEnter;
extern bool vGlobalRunningCheckDisk;
extern bool vGlobalGaveHardDriveLowOnMemoryWarning;
extern BYTE vGlobalScanTracType;
extern bool vGlobalFPGAVersion18point0orAbove;
extern DWORD vGlobalCopyFileCount;
extern BYTE vGlobalCopyDone;
extern CSerialPortPowerFlex40 *vGlobalPowerFlex40;
extern CSerialPortGuardMaster *vGlobalGuardMaster;
extern BYTE vGlobalLanguage;
extern bool vGlobalInWindowsDialog;
extern BYTE vGlobalEndOfLineTimeOutMargin;
extern BYTE vGlobalNormalLearnDilateTimes;
extern BYTE vGlobalQuickLearnDilateTimes;
extern CProcessEvaluateImagesThread *vGlobalProcessEvaluateImagesThread;
extern WORD vGlobalDisplaySizeH;
extern WORD vGlobalDisplaySizeV;
extern bool vGlobalUse1024By768Display;
extern CSystemConfigurationData *vGlobalConfigurationData;
extern CScanTracSystemRunningData *vGlobalRunningData;
extern CITIPCDig *vGlobalITIPCDig;
extern BYTE vGlobalEjectorConfirmMask[cNumberOfEjectors];
extern BYTE vGlobalAllowVoidInspection;
//extern bool vGlobalUseHalconLibrary;
extern BYTE vGlobalErrorCount;
extern CString vGlobalRegistryTCPIPKeyPath;
extern BYTE vGlobalScanTracType;
extern CString vGlobalTopString;
extern CString vGlobalBottomString;
extern BYTE vGlobalPCRunningWindowsXP;
extern WORD vGlobalPasswordTimeOut;
extern BYTE vGlobalLearnState;
extern bool vGlobalEvenSecond;
//extern BYTE vGlobalMouseMoveCounter;
//extern WORD vGlobalUnderRemoteControl;
extern BYTE vGlobalInAutoSize;
extern bool vGlobalInAutoExposure;
extern BYTE vGlobalUseCommaForDecimalPoint;
extern BYTE vGlobalShiftKeyDown;
extern DWORD vGlobalAmountOfFreeMemory;
extern BYTE vGlobalGaveMemoryError;
//extern BYTE vGlobalUseMetric;
extern BYTE vGlobalDemoMode;
extern CSerialPort *vGlobaluCSerialPort;
extern CXRaySource *vGlobalMonoBlockXRayPort;
extern CSpellmanDXMXRaySourcePort *vGlobalDXMXRayPort;
extern CACPowerMoniter *vGlobalACPowerMoniter;
extern CSerialPortRFIDEASBadgeReader *vGlobalRFIDEASBadgeReaderSerialPort;
extern CImageAquisitionThread *vGlobalImageAquisitionThread;
extern CProcessQuickLearnImagesThread *vGlobalProcessQuickLearnImagesThread;
extern CBackupHardDriveThread *vGlobalBackupHardDriveThread;
extern CDisplayDialogThread *vGlobalDisplayDialogThread;
extern CProduct *vGlobalCurrentProduct;
extern CScanTracDlg *vGlobalMainWindowPointer;
extern bool vGlobalShowDebugWindows;
extern CString vGlobalCurrentDirectory;
//extern int vGlobalArchiveVersionNumber;
extern HICON vGlobalIcon;
extern HICON vGlobalIconSmall;
extern CLifeTimeCounters *vGlobalLifeTimeCounters;
extern bool vGlobalFPGAVersion10Point0OrHigher;
extern bool vGlobalFPGAVersion10Point87OrHigher;
extern bool vGlobalFPGAVersion11Point0OrHigher;
extern bool vGlobalFPGAVersion15Point2OrHigher;
extern bool vGlobalFPGAVersion15Point31OrHigher;
extern bool vGlobalFPGAVersion15point42orAbove;
extern bool vGlobalFPGAVersion16point0orAbove;
extern unsigned long vGlobalDialogTitleColor;
//9/30/2009
extern CString vGlobalDHCPString[2];
extern CString vGlobalIPAddressString;
extern CString vGlobalIPSubNetMaskString;
extern CString vGlobalIPDefaultGatewayString;
extern CString vGlobalIPDNSAddressString1;
extern CString vGlobalIPDNSAddressString2;
extern BYTE vGlobalIPDHCPEnabled;
extern CString vGlobalIPDHCPServer;
extern CString vGlobalNetworkBoardCode;
extern CString vGlobalRegistryKeyPath;
extern int vGlobalPasswordLevel;
extern DWORD vGlobalProcessAffinityMask;
extern DWORD vGlobalSystemAffinityMask;
extern double vGlobalHardDriveTotalBytes;
extern UINT vGlobalProcessTimePercent;
extern UINT vGlobalThreadTimePercent;
extern HANDLE vGlobalMyProcessHandle;
extern BYTE vGlobalFrameGrabberType;
extern DWORD vGlobalFBWFEnable;
double DetermineHardDiskSize(CString TempCheckDirectory);	// 
extern HMODULE vGlobalhLibFBWFNetwork;
extern unsigned int vGlobalShadowImages;
extern int vGlobalCountErrorMsgPossibleDirectoryNotAvailableSent;
extern BOOL vGlobalHaveDDrive;
extern const LPCTSTR cRejectedImagesDirectoryDDrive;
extern const LPCTSTR cRejectedImagesDirectoryCDrive;
	// kjh added for product slip
extern unsigned char vGlobalProductSlipArray[cSlipArraySize];
extern int vGlobalProductSlipErrorSent;
extern int vGlobalProductSlipCount;
extern int vGlobalProductSlipArrayLocation;
extern unsigned int vGlobalTrackSensors;
extern unsigned int vOldGlobalTrackSensors;
extern CString vGlobalCurrentUser;
extern CFont * vGlobalCurrentFonts;
extern CFont vGlobalFixedFont;
extern CFont vGlobalTextFont;
extern double vGlobalPercentToResizeX;
extern double vGlobalPercentToResizeY;

// kjh added for com ports monitor
extern int vGlobalSerialPortNumberMicroController;	//default = 1
extern int vGlobalSerialPortNumberACPowerMonitor;		//default = 4
extern int vGlobalSerialPortNumberXRaySource;			//default = 3
extern int vGlobalGuardMasterPortNumber;		//default = 5
extern int vGlobalFirstMicroControllerCommCheck;
extern char vGlobalPortHereOK[PORTS_EVAL];
extern int vGlobalXrayNoCommMessageRcvdEver;

extern CString vGlobalBadgeReaderRFIDString;
ULONG MemoryUsageFBWFCheck();

IMPLEMENT_DYNCREATE(CScanTracDlg, CDialog)

CScanTracDlg *vDialogPointer;

/////////////////////////////////////////////////////////////////////////////
// CScanTracDlg dialog

//Constructor
CScanTracDlg::CScanTracDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CScanTracDlg::IDD, pParent)
{
	vModBusTCPIPInterfaceThread = NULL;

#ifdef CompileInHTTPClientOperationsGuardian
	vOldLastOGServerWriteStatusCode = -4;
	vLastOGSensitivity = "-";
	vLastOGBeltRate = 0;
	vLastOGShiftRateCPM = 0;
	vLastOGBeltRate = 0;
	vLastOGContainerRate = 0;
	vLastOGShiftRateCPM = 0;
	vLastOGRunDuration = 0;
	vLastOGEjectCountTotal = 0;
	vLastOGTotalContainers = 0;
	vLastOGTimeSinceLastStop = 0;
	vLastOGXRaySourceRunDuration = 0;
	vLastOGRejectCountTotal = 0;
	vLastOGStopDuration = 0;
	vLastOGPercentEjected = 0;
	vLastOGPercentRejected = 0;
	vGaveOGOverFlowError = false;
#endif
	vSetGraphicRed1 = false;
	vSetGraphicRed2 = false;
	vSetGraphicYellow1 = false;
	vSetGraphicYellow2 = false;
	vSetGraphicBlue = false;

	vEjectorNumberToTurnOff = 0;
	vOldSamplesToGo = 0;
	vOldPipeStatus = cNoPipeStatus;
		//vMostRecentActiveWindowName = "None";
		//vPreviousActiveWindowName = "None";
		//vMostRecentActiveWindow = NULL;
		//vScanTracIsNotTheActiveWindow = 0;
		vSubFunction4ButtonEnable = true;

		vLastProductionReportCount = 0;
		vLastProductionReportType = 0;
		vProductionReportString = "-";

		vSupportContractStatus = 0;
/*		HMONITOR hMonitor;
		POINT pt;
		DWORD dwFlags;
		MONITORINFO MonitorInfo;
		LPMONITORINFO lpmi;
		MonitorInfo.cbSize = sizeof(MONITORINFO);
		lpmi = &MonitorInfo;
		pt.x = 125l;
		pt.y = 125l;
		dwFlags = MONITOR_DEFAULTTOPRIMARY;
		hMonitor = MonitorFromPoint(pt,dwFlags);
		if (GetMonitorInfo(hMonitor,lpmi))
		{
			if (lpmi->rcMonitor.right >= 1024)
				vGlobalUse1024By768Display = true;
			vGlobalDisplaySizeH = (WORD)lpmi->rcMonitor.right;
			vGlobalDisplaySizeV = (WORD)lpmi->rcMonitor.bottom;
		}
*/	//{{AFX_DATA_INIT(CScanTracDlg)
	m_ClockText = _T("");
	//}}AFX_DATA_INIT
	// Note that LoadIcon does not require a subsequent DestroyIcon in Win32
	//vIdleCounter = 0;
	//test
	//vLast10MilliSecondTimerTime = -1;
	vAbortCalibration = false;
	//vLast10MilliSecondSpan = 0;
	vOldProcessingQuickLearn = false;
	vConditioningBeforeRun = false;
	hCT = NULL; //clears the point to the DLL library
	vNumberOfBadPixels = 0;
	vCalibratePixelResultsDisplayString = "-";
	vShowingPipeEmpty = false;
	vShowingAirInPipe = false;
	vOldDownStreamSignalSaysConveyorOn = false;
	vGlobalFrameGrabberType = cNoFrameGrabber;
	vMaximum10MilliSecondSpan = 0;
	vOldMaximum10MilliSecondSpan = 0;
	vOldLast10MilliSecondSpan = 0;
	vAirConditioningLogSecond = 0;
	 
	vGaveHardDriveFailedMessageToday = false;
	vLanAdaptorIDString = "Local Area Connection";
	vSelectProductAgain = false;
	WriteARejectToTheHardDriveLastTimeString = "";
	WriteARejectToTheHardDriveLastMultipleSecondFileCount = 0;
	vLastLearnState = 0;
	vBackgroundCount = 10;
	vOldAdjustingBrightnessBeforeLearning = false;
	vBackupHardDisk = false;
	vOldCPMString = "";
	//vHaveCheckWeighInspection = 0;
	vNumberOfWeighInspections = 0;
	vShowuControllerStatusInRed = false;
	vSystemData.vTotalContainers = 0;
	//vOldUnderRemoteControl = 0;
	vBodyTriggerActiveTimer = 0;
	vGaveBodyTriggerJammedMessage = false;
	vShutterFailedLastTest = false;
	vGlobalProcessQuickLearnImagesThread = NULL;
	vGlobalBackupHardDriveThread = NULL;
	vGlobalInAutoSize = false;
	vGlobalInAutoExposure = false;
	vGlobalLifeTimeCounters = NULL;
	vOldNoCommunicationsWithDXM = false;
	vHoldDriftCompensationADCOffset = 0;
	vHoldDriftCompensationDACOffset = 0;
	vEnteringPecoPasswordMode = false;
	vPasswordEntryString = "";
	vListeningSocket = NULL;
	vOldLearnCount = 0;
	vLastHour = 0;
	vLastMinute = 0;
	vHaveRejects = false;
	vTriggerIndicatorCount = 0;
	vOldTriggerIndicatorCount = 0;
	vCPMNotRunning = 0;
	vOldCPMNotRunning = 0;
	//vNewDisplay = true;
	//vHaveNotBackedUpYet = true;
	vOldShuttingDownIndicatorValue = true;
	vShuttingDownIndicatorValue = true;
	vOldTriggerIndicatorValue = 0;
	vTriggerIndicatorValue = 0;
	vOldGlobalPasswordOK = false;
	vOldAverageEnabled = false;
	vOldCalibrateBodyTriggerReferenceEnabled = false;
	vOldStructureEnabled = false;
	vErrorMessageHeadUIT = 0;
	vErrorMessageTailUIT = 0;
	vBackupNoticeDialog = NULL;
	vTurnOffSourceWhenStopRunning = true;
	vTest = 0;
	vEMailMessage = "";
	vMainImageRejectReason = 255;
	vMainImageWeight = "";
	vMainImageRejectDisable = false;
	vMainImageLane = 0;
	//vMainImageImproveLearn = false;

	vMainImageRejected = false;
	vWaitForScreenUpdate = false;
	vReportedBeltSpeedTooFast = false;
	vOldTestModesActive = false;
	vCalibrationAverageImage = NULL;

	vOldAmountOfFreeMemory = 0;
	vLastTimeShowedBeltRate = 0;
	vOldXRayOnNotice = false;

	vLastDateString = "1";
	vSystemData.vContainerCollection = &vContainerCollection;
	vWaitToLoadProductNoticeDialog = NULL;
	vAutoProductLoad = false;
	vGlobalDXMXRayPort = NULL;
	vGlobalMonoBlockXRayPort = NULL;
	vGlobalACPowerMoniter = NULL;
	vGlobaluCSerialPort = NULL;
	vGlobalImageAquisitionThread = NULL;
	vGlobalDisplayDialogThread = NULL;
	vGlobalCurrentProduct = NULL;
	SetNumLock(true);

	//LPTSTR vCopyDirectoryFromLPTSTR;
	vCopyDirectoryFromString = "";
	vCopyDirectoryToString = "";
	vCopyDirectoryNextFileIndex = 0;
	//WIN32_FIND_DATA vCopyDirectoryFindFileData;
	vCopyDirectoryFindHandle = 0;
	vCopyNextFilesTimerHandle = 988;

	vSplashScreenTimerHandle = 987;
	vGoodCountTimerHandle = 986;
	vEjectCountTimerHandle = 985;
	vBeltPositionTimerHandle = 984;
	vSendSyncCommandTimerHandle = 983;
	vUpdateDisplayTimerHandle = 982;
	vSimulateOneContainerTimer = 981;
	vRampXRayTimerHandle = 980;
	vSourceStabilizeTimerHandle = 979;
	vWaitForScreenUpdateTimerHandle = 978;
	vShowSourceStrengthTimerHandle = 977;
	vCheckLampsTimerHandle = 976;
	vSetupProductTimerHandle = 975;
	vStopRunningTimerHandle = 974;
	vExitTimerHandle = 989;
	vStopRunningTimerActive = false;
	vEndCalibrateDetectorsTimerHandle = 973;
	vEndMeasureSourceStrengthTimerHandle = 972;
	vBackupTimerHandle = 971;
	vSetWindowActiveTimerHandle = 970;
	vCheckForErrorMessagesTimerHandle = 969;
	vConveyorStartTimerHandle = 968;
	vTurnDiverterOnTimerHandle = 967;
	vTriggerIndicatorTimerHandle = 966;
	vTurnDiverterOffTimerHandle = 965;
	vEnableErrorMessagesTimerHandle = 964;
	vReCalibrateOffsetTimerHandle = 963;
	vClearSlippedTimerHandle = 962;
	vConveyorStartStopSignalOffTimerHandle = 961;
	vClearRejectHiddenTimerHandle = 960;
	vCheckHVPSVoltageSoonTimerHandle = 959;
	v50HertzTimerHandle = 444444;
	vXRayTubeHasCooledTimerHandle = 958;
	vTestDACsTimerHandle = 31347;
	vTestADCsTimerHandle = 31348;
	vNeedToTestDACsTimerHandle = 31349;
	vSendPrintScreenMessageSoon = 31354;
	vTurnOffEjectorIn100mSecTimerHandle = 31355;
//	vScreenShot1TimerHandle = 945;
//	vScreenShot2TimerHandle = 946;
	vCheckACBeforeThisYellowMessageTimerHandle = 947;
	vShowSafetyViolationMessageTimer = 948;
	vDisableEjectorsTimerHandle = 949;
	vOperatorPasswordTimerHandle = 950;
	vCheckInterlocksIn200MSTimerHandle = 951;
	vSetupDataBackupTimerHandle = 952;
	vFlashYellowLightTimerHandle = 953;
	vOneHourUpdatesTimerHandle = 954;
	vCheckHardDrivesTimerHandle = 955;
	vClearScreenCaptureNoticeTimerHandle = 956;
	vBackupToBackupHardDriveTimer = 990;
	vCheckForNewImageToDisplayTimerHandle = 997;
	vStartRunningTimerHandle = 992;
	vWaitToCalibrateForXRaysToSettleTimer = 993;
	vTrackingCheckWeighMinuteData = false;

	vConfigurationData = NULL;
	vEMailType = 0;
	vUpdateGainAndOffsetConfiguration = false;
	vRunButtonPressedLastNotStop = false;
	//vNeedToTurnOffSimulatedEncoderAfterCalibration = 0;
	vCalibrateClipboardNumberOfLines = 0;
	vCalibrateHoldCurrentProduct = NULL;
	vCalibrationDataFile = NULL;
	vCalibrateCurrent = 0;
	vCalibrateCurrentStep = 0;
	vLastTimeReadEncoderRate = 0;
	vThisTimeReadEncoderRate = 0;
	TestBC = NULL;
	vDisplayingVersion = true;
	vWaitForScreenUpdate = false;
	vReadInConfigurationDataPointer = NULL;
	vReadInLifeTimeCounterDataPointer = NULL;
	vGlobalPasswordLevel = 0;
	vGlobalDialogTitleColor = cDarkBlue;

	//9/30/2009
	vGlobalIPAddressString =		"IP Address Not Read ";	//need to start with initial lengths for strings
	vGlobalIPSubNetMaskString =		"Mask Not Read       ";
	vGlobalIPDefaultGatewayString =	"Gateway Not Read    ";
	vGlobalIPDHCPServer =	"Gateway Not Read    ";
	vGlobalIPDHCPEnabled = 2;
	vGlobalNetworkBoardCode = "Unknown";
	vGlobalRegistryKeyPath = "Unknown";
	vGlobalFlagSendOnceThreadError = true;
	vTemperatureSecondTime = 0;
	vACPowerMonitorTroubleCount = 0;
	vACPowerMonitorDoesNotExistsCount = 0;
	vACPowerMoniterPortCommCheckState = 0;

	vLocalCWndCollection.Add(&m_Date);
	vLocalCWndCollection.Add(&m_TotalEjectsLabelStaticTextControl);
	vLocalCWndCollection.Add(&m_TotalUnConfirmLabel);
	vLocalCWndCollection.Add(&m_DoNotShutOffPower);
	vLocalCWndCollection.Add(&m_AutoImproving);
	vLocalCWndCollection.Add(&m_LearnState);
	vLocalCWndCollection.Add(&m_ChatMessage);
	vLocalCWndCollection.Add(&m_DemoHelpButton);
	vLocalCWndCollection.Add(&m_TotalRejectsPercentLabel);
	vLocalCWndCollection.Add(&m_TotalRejectsPercent);//10
	vLocalCWndCollection.Add(&m_TriggerIndicator);
	vLocalCWndCollection.Add(&m_TotalRejectsStaticText);
	vLocalCWndCollection.Add(&m_TotalRejectsLabelStaticText);

	vLocalCWndCollection.Add(&m_ThresholdReduction);
	vLocalCWndCollection.Add(&m_ThresholdIncrease);
	vLocalCWndCollection.Add(&m_DensityCompensation);
	vLocalCWndCollection.Add(&m_RejectReason);
	vLocalCWndCollection.Add(&m_StatusLine);

	vLocalCWndCollection.Add(&m_Function1Button);
	vLocalCWndCollection.Add(&m_Function2Button);//20
	vLocalCWndCollection.Add(&m_Function3Button);
	vLocalCWndCollection.Add(&m_Function4Button);
	vLocalCWndCollection.Add(&m_Function5Button);

	vLocalCWndCollection.Add(&m_SubFunction1Button);
	vLocalCWndCollection.Add(&m_SubFunction2Button);
	vLocalCWndCollection.Add(&m_SubFunction3Button);
	vLocalCWndCollection.Add(&m_SubFunction4Button);
	vLocalCWndCollection.Add(&m_SubFunction5Button);
	vLocalCWndCollection.Add(&m_SubFunction6Button);
	vLocalCWndCollection.Add(&m_SubFunction7Button);//30
	vLocalCWndCollection.Add(&m_SubFunction8Button);

	vLocalCWndCollection.Add(&m_TestModesActive);
	vLocalCWndCollection.Add(&m_EjectorsDisabled);

	vLocalCWndCollection.Add(&m_ShowingRejects);
	vLocalCWndCollection.Add(&m_Calibrating);
	vLocalCWndCollection.Add(&m_XRaysOn);
	vLocalCWndCollection.Add(&m_TotalUnConfirmed);
	vLocalCWndCollection.Add(&m_MainBackground2);
	vLocalCWndCollection.Add(&m_MainBackground);
	vLocalCWndCollection.Add(&m_CurrentProductLabel);//40
	vLocalCWndCollection.Add(&m_uControllerStatus);
	vLocalCWndCollection.Add(&m_Clock);
	vLocalCWndCollection.Add(&m_TotalContainersLabelControl);
	vLocalCWndCollection.Add(&m_TotalContainersControl);
	vLocalCWndCollection.Add(&m_ShiftControl);
	vLocalCWndCollection.Add(&m_PercentRejectedLabelControl);
	vLocalCWndCollection.Add(&m_PercentRejectedControl);

	vLocalCWndCollection.Add(&m_ContainersPerMinuteControl);

	vLocalCWndCollection.Add(&m_ProductLabelControl);
	vLocalCWndCollection.Add(&m_TotalGoodStaticText);
	vLocalCWndCollection.Add(&m_TotalEjectsStaticText);
	vLocalCWndCollection.Add(&m_BackGroundStaticText);
	vLocalCWndCollection.Add(&m_DialogTitleStaticText1);
	vLocalCWndCollection.Add(&m_TotalGoodLabelStaticTextControl);
	vLocalCWndCollection.Add(&m_SupportContract);
	vLocalCWndCollection.Add(&m_SupportContract2);
	vLocalCWndCollection.Add(&m_NonStandardSystemSetting);	//do not add anything after here as remove these last items below so only get called once
	vLocalCWndCollection.Add(&m_InspxMessage);							//do not add anything after here as remove these last items below so only get called once
	vLocalCWndCollection.Add(&m_DensityLockTooFarOff);			//do not add anything after here as remove these last items below so only get called once
	vLocalCWndCollection.Add(&m_DensityNotLockedIndicator); //do not add anything after here as remove these last items below so only get called once
	//for (BYTE TempLoop = 0; TempLoop < vLocalCWndCollection.GetCount(); TempLoop++)
	//	ItemRECTArray[TempLoop].bottom = 0;
	// kjh added for com ports monitor 9/2014
	TestSerialPortsValid();
	vGlobalFirstMicroControllerCommCheck = cInitializeSearchForSerialPort;

	// track Xray port initialization
	vXRayPortTry = 0;
	vDXMPortInitState = 0;
	vMonoPortInitState = 0;
	vCheckPortsCount = 0;
	vDisplayPortVerifyMessage = 0;
	vGlobalXrayNoCommMessageRcvdEver = cNoCommSeenEver;
#ifdef _DEBUG
	vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;
#endif
}

BOOL CScanTracDlg::DestroyWindow() 
{
	// TODO: Add your specialized code here and/or call the base class
	return CDialog::DestroyWindow();
}

void CScanTracDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CScanTracDlg)
	DDX_Control(pDX, IDC_NonStandardSystemSetting, m_NonStandardSystemSetting);
	DDX_Control(pDX, IDC_DoNotShutOffPower, m_DoNotShutOffPower);
	DDX_Control(pDX, IDC_AutoImproving, m_AutoImproving);
	DDX_Control(pDX, IDC_LearnState, m_LearnState);
	DDX_Control(pDX, IDC_ChatMessage, m_ChatMessage);
	DDX_Control(pDX, IDC_DensityLockTooFarOff, m_DensityLockTooFarOff);
	DDX_Control(pDX, IDC_DemoHelpButton, m_DemoHelpButton);
	DDX_Control(pDX, IDC_TotalRejectsPercentLabel, m_TotalRejectsPercentLabel);
	DDX_Control(pDX, IDC_TotalRejectsPercent, m_TotalRejectsPercent);
	DDX_Control(pDX, IDC_DensityNotLockedIndicator, m_DensityNotLockedIndicator);
	DDX_Control(pDX, IDC_InspxMessage, m_InspxMessage);
	DDX_Control(pDX, IDC_TriggerIndicator, m_TriggerIndicator);
	DDX_Control(pDX, IDC_TotalRejectsStaticText, m_TotalRejectsStaticText);
	DDX_Control(pDX, IDC_TotalRejectsLabelStaticText, m_TotalRejectsLabelStaticText);
	DDX_Control(pDX, IDC_SubFunction3Button, m_SubFunction3Button);
	DDX_Control(pDX, IDC_ThresholdReduction, m_ThresholdReduction);
	DDX_Control(pDX, IDC_ThresholdIncrease, m_ThresholdIncrease);
	DDX_Control(pDX, IDC_DensityCompensation, m_DensityCompensation);
	DDX_Control(pDX, IDC_SubFunction8Button, m_SubFunction8Button);
	DDX_Control(pDX, IDC_SubFunction7Button, m_SubFunction7Button);
	DDX_Control(pDX, IDC_Function4Button, m_Function4Button);
	DDX_Control(pDX, IDC_RejectReason, m_RejectReason);
	DDX_Control(pDX, IDC_StatusLine, m_StatusLine);
	DDX_Control(pDX, IDC_Function5Button, m_Function5Button);
	DDX_Control(pDX, IDC_Function1Button, m_Function1Button);
	DDX_Control(pDX, IDC_SubFunction2Button, m_SubFunction2Button);
	DDX_Control(pDX, IDC_TestModesActive, m_TestModesActive);
	DDX_Control(pDX, IDC_SubFunction4Button, m_SubFunction4Button);
	DDX_Control(pDX, IDC_SubFunction6Button, m_SubFunction6Button);
	DDX_Control(pDX, IDC_SubFunction5Button, m_SubFunction5Button);
	DDX_Control(pDX, IDC_SubFunction1Button, m_SubFunction1Button);
	DDX_Control(pDX, IDC_EjectorsDisabled, m_EjectorsDisabled);
	DDX_Control(pDX, IDC_ShowingRejects, m_ShowingRejects);
	DDX_Control(pDX, IDC_Calibrating, m_Calibrating);
	DDX_Control(pDX, IDC_XRaysOn, m_XRaysOn);
	DDX_Control(pDX, IDC_Date, m_Date);
	DDX_Control(pDX, IDC_TotalEjectsLabelStaticText, m_TotalEjectsLabelStaticTextControl);
	DDX_Control(pDX, IDC_TotalUnConfirmed, m_TotalUnConfirmed);
	DDX_Control(pDX, IDC_MainBackground2, m_MainBackground2);
	DDX_Control(pDX, IDC_MainBackground, m_MainBackground);
	DDX_Control(pDX, IDC_CurrentProductLabel, m_CurrentProductLabel);
	DDX_Control(pDX, IDC_uControllerStatus, m_uControllerStatus);
	DDX_Control(pDX, IDC_Clock, m_Clock);
	DDX_Control(pDX, IDC_TotalContainersLabel, m_TotalContainersLabelControl);
	DDX_Control(pDX, IDC_TotalContainers, m_TotalContainersControl);
	DDX_Control(pDX, IDC_Shift, m_ShiftControl);
	DDX_Control(pDX, IDC_PercentRejectLabel, m_PercentRejectedLabelControl);
	DDX_Control(pDX, IDC_PercentRejected, m_PercentRejectedControl);
	DDX_Control(pDX, IDC_ProductLabel, m_ProductLabelControl);
	DDX_Control(pDX, IDC_Function3Button, m_Function3Button);
	DDX_Control(pDX, IDC_TotalGoodStaticText, m_TotalGoodStaticText);
	DDX_Control(pDX, IDC_TotalEjectsStaticText, m_TotalEjectsStaticText);
	DDX_Control(pDX, IDC_BackGroundStatic, m_BackGroundStaticText);
	DDX_Control(pDX, IDC_Function2Button, m_Function2Button);
	DDX_Control(pDX, IDC_TotalGoodLabelStaticText, m_TotalGoodLabelStaticTextControl);
	DDX_Text(pDX, IDC_Clock, m_ClockText);
	DDV_MaxChars(pDX, m_ClockText, 25);
	DDX_Control(pDX, IDC_SupportContract, m_SupportContract);
	DDX_Control(pDX, IDC_SupportContract2, m_SupportContract2);
	DDX_Control(pDX, IDC_DialogTitleStaticText1, m_DialogTitleStaticText1);
	DDX_Control(pDX, IDC_TotalUnConfirmLabel, m_TotalUnConfirmLabel);
	DDX_Control(pDX, IDC_ContainersPerMinute, m_ContainersPerMinuteControl);
	
	//}}AFX_DATA_MAP
}

BEGIN_MESSAGE_MAP(CScanTracDlg, CDialog)
	//{{AFX_MSG_MAP(CScanTracDlg)
	ON_WM_PAINT()
	ON_BN_CLICKED(IDC_Function2Button, OnFunction2Button)
	ON_WM_TIMER()
	ON_BN_CLICKED(IDC_Function3Button, OnFunction3Button)
	ON_BN_CLICKED(IDC_Function1Button, OnFunction1Button)
	ON_BN_CLICKED(IDC_Function4Button, OnFunction4Button)
	ON_BN_CLICKED(IDC_Function5Button, OnFunction5Button)
	ON_WM_CTLCOLOR()
	ON_BN_CLICKED(IDC_SubFunction8Button, OnSubFunction8Button)
	ON_BN_CLICKED(IDC_SubFunction2Button, OnSubFunction2Button)
	ON_BN_CLICKED(IDC_SubFunction7Button, OnSubFunction7Button)
	ON_BN_CLICKED(IDC_SubFunction6Button, OnSubFunction6Button)
	ON_BN_CLICKED(IDC_SubFunction5Button, OnSubFunction5Button)
	ON_BN_CLICKED(IDC_SubFunction1Button, OnSubFunction1Button)
	ON_BN_CLICKED(IDC_SubFunction4Button, OnSubFunction4Button)
	ON_BN_CLICKED(IDC_SubFunction3Button, OnSubFunction3Button)
//	ON_BN_CLICKED(IDC_DialogTitleStaticText, OnDialogTitleStaticText)
	ON_BN_CLICKED(IDC_DemoHelpButton, OnDemoHelpButton)
	ON_WM_CLOSE()
	ON_WM_MOUSEMOVE()
	//}}AFX_MSG_MAP
	ON_STN_CLICKED(IDC_SupportContract2, &CScanTracDlg::OnSupportcontract2)
	ON_STN_CLICKED(IDC_SupportContract, &CScanTracDlg::OnSupportcontract)
	ON_WM_HOTKEY()
	ON_WM_MENUCHAR()
	ON_WM_INPUT()
	ON_WM_NCRBUTTONDOWN()
	ON_WM_SYSCHAR()
	ON_WM_SYSCOMMAND()
	ON_WM_SYSKEYDOWN()
	ON_WM_ACTIVATEAPP()
	ON_WM_MBUTTONDOWN()
	ON_STN_CLICKED(IDC_DialogTitleStaticText, &CScanTracDlg::OnDialogtitlestatictext)
	ON_STN_CLICKED(IDC_DialogTitleStaticText1, &CScanTracDlg::OnDialogtitlestatictext1)
	ON_STN_CLICKED(IDC_TotalContainersLabel, &CScanTracDlg::OnStnClickedTotalcontainerslabel)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CScanTracDlg message handlers

BOOL CScanTracDlg::OnInitDialog()
{
	CDialog::OnInitDialog();
	vDialogPointer = this;
	vGlobalCallingThreadID = GetCurrentThreadId();
	SetDlgItemText(IDC_uControllerStatus, _T(""));

	CDC* pDC = this->GetDC();

	if (vGlobalPCRunningWindowsXP <= cWindowsXP)
		vGlobalFixedFont.CreatePointFont(int(vGlobalPercentToResizeY * cFixedFontSize), cFixedFontXP, pDC);
	else
		vGlobalFixedFont.CreatePointFont(int(vGlobalPercentToResizeY * cFixedFontSize), cFixedFont, pDC);

	vGlobalTextFont.CreatePointFont(int(vGlobalPercentToResizeX * cSmallFont), cThinFont, pDC);

	CString TempRegistryValue = "ENG";
	CRegKey TempRegistryKey;
	RECT TempRect;
	TempRect.left = 0;
	TempRect.right = vGlobalDisplaySizeH;
	TempRect.bottom = 0;
	TempRect.top = vGlobalDisplaySizeV;

	this->MapDialogRect(&TempRect);
	this->SetWindowPos(NULL,0,0,vSystemData.vGlobalMonitorSizeX,vSystemData.vGlobalMonitorSizeY,SWP_NOZORDER);

	m_TriggerIndicator.SetWindowPos(NULL,470,454,168,20,SWP_NOZORDER);
	m_ShiftControl.SetWindowPos(NULL,0,407,640,14,SWP_NOZORDER);
	m_ContainersPerMinuteControl.SetWindowPos(NULL,365,380,159,20,SWP_NOZORDER);
	m_TotalContainersLabelControl.SetWindowPos(NULL,110,90,117,20,SWP_NOZORDER);
	m_TotalContainersControl.SetWindowPos(NULL,232,90,90,20,SWP_NOZORDER);
	m_LearnState.SetWindowPos(NULL,2,461,170,15,SWP_NOZORDER);
	m_PercentRejectedLabelControl.SetWindowPos(NULL,110,108,117,20,SWP_NOZORDER);
	m_TotalEjectsLabelStaticTextControl.SetWindowPos(NULL,110,126,117,20,SWP_NOZORDER);
	m_TotalEjectsStaticText.SetWindowPos(NULL,232,126,90,20,SWP_NOZORDER);
	m_TotalRejectsLabelStaticText.SetWindowPos(NULL,320,126,107,20,SWP_NOZORDER);
	m_TotalRejectsStaticText.SetWindowPos(NULL,432,126,90,20,SWP_NOZORDER);
	m_TotalRejectsPercentLabel.SetWindowPos(NULL,320,108,107,20,SWP_NOZORDER);
	m_TotalRejectsPercent.SetWindowPos(NULL,432,108,90,20,SWP_NOZORDER);
	m_TotalUnConfirmLabel.SetWindowPos(NULL,110,144,117,20,SWP_NOZORDER);
	m_TotalUnConfirmed.SetWindowPos(NULL,232,144,90,20,SWP_NOZORDER);
	m_MainBackground2.SetWindowPos(NULL,359,197,170,211,SWP_NOZORDER);
	m_SupportContract.SetWindowPos(NULL,364,205,160,20,SWP_NOZORDER);
	m_SupportContract2.SetWindowPos(NULL,364,225,160,20,SWP_NOZORDER);
	m_RejectReason.SetWindowPos(NULL,366,245,160,55,SWP_NOZORDER);
	m_ShowingRejects.SetWindowPos(NULL,370,342,153,24,SWP_NOZORDER);
	m_Date.SetWindowPos(NULL,367,300,159,20,SWP_NOZORDER);
	m_Clock.SetWindowPos(NULL,367,320,159,20,SWP_NOZORDER);
	m_MainBackground.SetWindowPos(NULL,cMainBackgroundLeft, cMainBackgroundTop,cMainBackgroundLength,131,SWP_NOZORDER);
	m_uControllerStatus.SetWindowPos(NULL,247,175,140,20,SWP_NOZORDER);
	m_TestModesActive.SetWindowPos(NULL,387,175,140,20,SWP_NOZORDER);
	m_EjectorsDisabled.SetWindowPos(NULL,107,175,140,20,SWP_NOZORDER);

	RECT TempRectEjector;
	RECT TempRectuController;
	RECT TempRectTestModesActive;

	m_EjectorsDisabled.GetWindowRect(&TempRectEjector);
	m_uControllerStatus.GetWindowRect(&TempRectuController);
	m_TestModesActive.GetWindowRect(&TempRectTestModesActive);

	if (TempRectEjector.right != TempRectuController.left)
	{
		int TempShiftLabelsRight = TempRectuController.left - TempRectEjector.right + 3;
		
		m_uControllerStatus.SetWindowPos(NULL, TempRectuController.left - TempShiftLabelsRight, TempRectEjector.top - 3, 
			TempRectuController.right - TempRectuController.left, TempRectuController.bottom - TempRectuController.top, SWP_NOZORDER);
		m_TestModesActive.SetWindowPos(NULL, TempRectTestModesActive.left - TempShiftLabelsRight, TempRectEjector.top - 3, 
			TempRectTestModesActive.right - TempRectTestModesActive.left, TempRectTestModesActive.bottom - TempRectTestModesActive.top, SWP_NOZORDER);
	}

	if ((vSystemData.vGlobalMonitorSizeX >= 1024) && (vSystemData.vGlobalMonitorSizeY >= 768) && (vSetGraphicRed2 == false))
	{
		vSetGraphicRed2 = true;
		m_DensityLockTooFarOff.SetBitmap(vInspxGraphicRedBigger);
		RECT TempRect;
		m_DensityLockTooFarOff.GetWindowRect(&TempRect);
		TempRect.top -= 10;
		TempRect.bottom -= 10;
		if ((vSystemData.vGlobalMonitorSizeX > 1024) && (vSystemData.vGlobalMonitorSizeY > 768))
		{
			TempRect.left -= 42;
			TempRect.right -= 42;

			TempRect.top -= 52;
			TempRect.bottom -= 52;
		}
		m_DensityLockTooFarOff.SetWindowPos(NULL, TempRect.left, TempRect.top, TempRect.right - TempRect.left, TempRect.bottom - TempRect.top, NULL);
	}

	//if ((vSystemData.vGlobalMonitorSizeX >= 1024) && (vSystemData.vGlobalMonitorSizeY >= 768)  && (vSetGraphicYellow1 == false))
	//{
	//	vSetGraphicYellow1 = true;
	//	m_InspxMessage.SetBitmap(vInspxGraphicYellowBigger);
	//	RECT TempRect;
	//	m_InspxMessage.GetWindowRect(&TempRect);
	//	TempRect.top -= 10;
	//	TempRect.bottom -= 10;
	//	TempRect.left += 25;
	//	TempRect.right += 25;
	//	m_InspxMessage.SetWindowPos(NULL, TempRect.left, TempRect.top, TempRect.right - TempRect.left, TempRect.bottom - TempRect.top, NULL);
	//}

	//if ((vSystemData.vGlobalMonitorSizeX >= 1024) && (vSystemData.vGlobalMonitorSizeY >= 768) && (vSetGraphicRed1 == false))
	//{
	//	vSetGraphicRed1 = true;
	//	m_NonStandardSystemSetting.SetBitmap(vInspxGraphicRedBigger);
	//	RECT TempRect;
	//	m_NonStandardSystemSetting.GetWindowRect(&TempRect);
	//	TempRect.top -= 10;
	//	TempRect.bottom -= 10;
	//	m_NonStandardSystemSetting.SetWindowPos(NULL, TempRect.left, TempRect.top, TempRect.right - TempRect.left, TempRect.bottom - TempRect.top, NULL);
	//}

	//if ((vSystemData.vGlobalMonitorSizeX >= 1024) && (vSystemData.vGlobalMonitorSizeY >= 768) && (vSetGraphicYellow2 == false))
	//{
	//	vSetGraphicYellow2 = true;
	//	m_DensityNotLockedIndicator.SetBitmap(vInspxGraphicYellowBigger);
	//	RECT TempRect;
	//	m_InspxMessage.GetWindowRect(&TempRect);
	//	TempRect.top -= 10;
	//	TempRect.bottom -= 10;
	//	TempRect.left += 25;
	//	TempRect.right += 25;
	//	if ((vSystemData.vGlobalMonitorSizeX > 1024) && (vSystemData.vGlobalMonitorSizeY > 768))
	//	{
	//		TempRect.left -= 109;
	//		TempRect.right -= 109;

	//		TempRect.top -= 52;
	//		TempRect.bottom -= 52;
	//	}
	//	m_DensityNotLockedIndicator.SetWindowPos(NULL, TempRect.left, TempRect.top, TempRect.right - TempRect.left, TempRect.bottom - TempRect.top, NULL);
	//}

	//if ((vSystemData.vGlobalMonitorSizeX >= 1024) && (vSystemData.vGlobalMonitorSizeY >= 768) && (vSetGraphicRed2 == false))
	//{
	//	vSetGraphicRed2 = true;
	//	m_DensityLockTooFarOff.SetBitmap(vInspxGraphicRedBigger);
	//	RECT TempRect;
	//	m_DensityLockTooFarOff.GetWindowRect(&TempRect);
	//	TempRect.top -= 10;
	//	TempRect.bottom -= 10;
	//	if ((vSystemData.vGlobalMonitorSizeX > 1024) && (vSystemData.vGlobalMonitorSizeY > 768))
	//	{
	//		TempRect.left -= 42;
	//		TempRect.right -= 42;

	//		TempRect.top -= 52;
	//		TempRect.bottom -= 52;
	//	}
	//	m_DensityLockTooFarOff.SetWindowPos(NULL, TempRect.left, TempRect.top, TempRect.right - TempRect.left, TempRect.bottom - TempRect.top, NULL);
	//}

	//if ((vSystemData.vGlobalMonitorSizeX >= 1024) && (vSystemData.vGlobalMonitorSizeY >= 768) && (vSetGraphicBlue == false))
	//{
	//	vSetGraphicBlue = true;
	//	m_AutoImproving.SetBitmap(vInspxGraphicBlueBigger);
	//	RECT TempRect;
	//	m_AutoImproving.GetWindowRect(&TempRect);
	//	TempRect.top -= 10;
	//	TempRect.bottom -= 10;
	//	if ((vSystemData.vGlobalMonitorSizeX > 1024) && (vSystemData.vGlobalMonitorSizeY > 768))
	//	{
	//		TempRect.left -= 42;
	//		TempRect.right -= 42;
	//	}
	//	m_AutoImproving.SetWindowPos(NULL, TempRect.left, TempRect.top, TempRect.right - TempRect.left, TempRect.bottom - TempRect.top, NULL);
	//}

	//if ((vSystemData.vGlobalMonitorSizeX >= 1024) && (vSystemData.vGlobalMonitorSizeY >= 768) && (vSetGraphicYellow2 == false))
	//{
	//	vSetGraphicYellow2 = true;
	//	m_DensityNotLockedIndicator.SetBitmap(vInspxGraphicYellowBigger);
	//	RECT TempRect;
	//	m_DensityNotLockedIndicator.GetWindowRect(&TempRect);
	//	TempRect.top -= 10;
	//	TempRect.bottom -= 10;
	//	TempRect.left += 25;
	//	TempRect.right += 25;
	//	if ((vSystemData.vGlobalMonitorSizeX > 1024) && (vSystemData.vGlobalMonitorSizeY > 768))
	//	{
	//		TempRect.left -= 109;
	//		TempRect.right -= 109;

	//		TempRect.top -= 52;
	//		TempRect.bottom -= 52;
	//	}
	//	m_DensityNotLockedIndicator.SetWindowPos(NULL, TempRect.left, TempRect.top, TempRect.right - TempRect.left, TempRect.bottom - TempRect.top, NULL);
	//}
	/*
const BYTE cPunyFont = 60;
const BYTE cTinyFont = 70;
const BYTE cSmallFont = 80;
const BYTE cMediumFont = 89;
const BYTE cNormalFont = 100;
const BYTE cMediumLargeFont = 124;
const BYTE cLargeFont = 150;
const BYTE cExtraLargeFont = 175;
const int cHugeFont = 250;
const int cExtraHugeFont = 300;
const LPCTSTR cThinFont = "Arial";
const LPCTSTR cBoldFont = "Impact";
const LPCTSTR cThickFont = "Arial Black";
	*/
	vSystemData.vCurrentPunyFont.CreatePointFont(int(vGlobalPercentToResizeY * cSmallFont * 0.7),cThinFont,NULL);
	vSystemData.vCurrentTinyFont.CreatePointFont(int(vGlobalPercentToResizeY * 0.7 * cMediumFont),cThickFont,NULL);
	vSystemData.vCurrentSmallFont.CreatePointFont(int(vGlobalPercentToResizeY * 0.7 * cNormalFont),cThickFont,NULL);
	vSystemData.vCurrentMediumFont.CreatePointFont(int(vGlobalPercentToResizeY * 0.7 * cMediumLargeFont),cThickFont,NULL);
	vSystemData.vCurrentFont.CreatePointFont(int(vGlobalPercentToResizeY * 0.7 * cNormalFont),cThickFont,NULL);
	vSystemData.vUnderlinedFont.CreateFont(int(vGlobalPercentToResizeY * 0.7 * 28), 0, 0, 0, FW_BOLD, 0, true, 0, DEFAULT_CHARSET, 0, 0, 0, 0, cThickFont);
	vSystemData.vCurrentMediumLargeFont.CreatePointFont(int(vGlobalPercentToResizeY * 0.7 * cMediumLargeFont),cThickFont,NULL);
	vSystemData.vCurrentLargeFont.CreatePointFont(int(vGlobalPercentToResizeY * 0.7 * cLargeFont),cThickFont,NULL);
	vSystemData.vCurrentExtraLargeFont.CreatePointFont(int(vGlobalPercentToResizeY * 0.7 * cExtraLargeFont),cThickFont,NULL);
	vSystemData.vCurrentHugeFont.CreatePointFont(int(vGlobalPercentToResizeY * 0.7 * cHugeFont),cThickFont,NULL);
	vSystemData.vCurrentExtraHugeFont.CreatePointFont(int(vGlobalPercentToResizeY * 0.7 * cExtraHugeFont),cThickFont,NULL);

	//write rejects to Hard Disk
	for (WORD TempLoop = 0; TempLoop < cNumberOfRejectImageBuffers; TempLoop++)
	{
		vSystemData.vRejectImageBuffer[TempLoop].vLogThisReject = false;
		vSystemData.vRejectImageBuffer[TempLoop].vEjectorsDisabled = false;
		vSystemData.vRejectImageBuffer[TempLoop].vContainerEjectInspection = 255;
		vSystemData.vRejectImageBuffer[TempLoop].vTime = 0;
		vSystemData.vRejectImageBuffer[TempLoop].vGreyImage = NULL;
		
		vSystemData.vRejectImageBuffer[TempLoop].vRedBoxCornerX = 0;
		vSystemData.vRejectImageBuffer[TempLoop].vRedBoxCornerY = 0;
		vSystemData.vRejectImageBuffer[TempLoop].vRedBoxWidth = 0;
		vSystemData.vRejectImageBuffer[TempLoop].vRedBoxHeight = 0;
	}
	vSystemData.vNextRejectToWrite = 0;
	vSystemData.vNextRejectToSave = 0;

	SetDlgItemText(IDC_uControllerStatus, _T(""));

	LONG TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Control\\Session Manager"));

	MemoryUsageFBWFCheck(); //need to call one time to get FBWF status
	
	if (TempErrorCode == ERROR_SUCCESS)
	{ //Clear the Run Autocheck flag
		TempErrorCode = TempRegistryKey.SetKeyValue(_T(""), TempRegistryValue, _T("BootExecute"));
/*
		if (TempErrorCode == ERROR_SUCCESS)
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nSuccessfully Cleared Run Autocheck";
			TempNoticeDialog.vType = cInformationMessage;
			TempNoticeDialog.DoModal();
		}
		else
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nFailed to clear Autocheck";
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
*/
	}

				//12/1/2005
	AfxOleInit();

	SetDlgItemText(IDC_TriggerIndicator, _T(""));
	m_TriggerIndicator.ShowWindow(SW_HIDE);
	CString TempText = " ";
	CString TempText2 = " ";
	vGlobalMainWindowPointer = (CScanTracDlg *)this;
	vConfigurationData = NULL;

	CWnd *TempWindowHandle;
	TempWindowHandle = FindWindow(NULL, _T("Inspx-ScanTrac"));
	bool TempReadConfigurationDataSucceeded = false;

	vGlobalRunningData = &vSystemData;

	if (!TempWindowHandle) 
		TempWindowHandle = FindWindow(NULL, _T("Version"));
	if (!TempWindowHandle) 
		TempWindowHandle = FindWindow(NULL, _T("Notice"));
	if (TempWindowHandle) 
	{
		LPCTSTR TempTextMessage = _T("ScanTrac is already running\nThis copy is aborting now.");
		LPCTSTR TempTitleMessage = _T("ScanTrac Notice");
		MessageBox(TempTextMessage, TempTitleMessage, MB_SETFOREGROUND);

		// We found another copy of ourself. Lets bring it up, and exit this copy:
		if (TempWindowHandle->IsIconic()) 
		{
			TempWindowHandle->ShowWindow(SW_RESTORE);
		}
		TempWindowHandle->SetForegroundWindow();

		vSystemData.vOKToCloseProgram = true;
		int TempTimerResult = SetTimer(vExitTimerHandle,500,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-Exit Timer Failed",cEMailInspx,32000);
	}
	else
	if (ReadInConfigurationDataFromFile(false)) //read from main config file, not from backup
	{
		TempReadConfigurationDataSucceeded = true;
	}
	else
	if (ReadInConfigurationDataFromFile(true))
	{
		TempReadConfigurationDataSucceeded = true;
	}
	else
	{
		CheckForErrorMessages();
		EndDialog(0);
	}

	try
	{
		// check for updates here before continueing load of program
		BOOL ZipFileExists = PathFileExists(_T("C:\\ScanTracExtra\\ScanTrac_New_Release\\ScanTracUpdate.zip"));
		BOOL UnZipExeFileExists = PathFileExists(_T("C:\\ScanTracExtra\\ScanTrac_New_Release\\UnZipFolderAndReplaceScanTrac.exe"));

		if ((ZipFileExists == TRUE) && (UnZipExeFileExists == TRUE))
		{
			intptr_t SpawnOk = _spawnl(_P_NOWAIT, "C:\\ScanTracExtra\\ScanTrac_New_Release\\UnZipFolderAndReplaceScanTrac.exe", "C:\\ScanTracExtra\\ScanTrac_New_Release\\UnZipFolderAndReplaceScanTrac.exe", NULL);
			if ((errno == ERROR_SUCCESS) && (SpawnOk != NULL))
			{
				exit(0);
			}
		}
	}
	catch ( char *strException)
	{
		CNoticeDialog TempNoticeDialog;
		CString TempAString;
		CString TempNoticeString;
		TempAString.Format(_T("\nException raised: %s"),strException);
		TempNoticeString = "\nUnzip file caused an Exception error." + TempAString + "\nCall Service";
		TempNoticeDialog.vNoticeText = TempNoticeString;
		TempNoticeDialog.vType = cErrorMessage;
		TempNoticeDialog.DoModal();
	}

	if (TempReadConfigurationDataSucceeded == true)
	{
		if (vConfigurationData == NULL)
		{
			if (ThereIsEnoughMemory(sizeof(CSystemConfigurationData), "Configuration Data"))
			{
				vConfigurationData = new (CSystemConfigurationData);
				vGlobalConfigurationData = vConfigurationData;
			}
		}

		
		vGlobalAllowVoidInspection = vConfigurationData->vAllowVoidInspection;

		ReadLifeTimeCounter();
		SetupLanguage();

		vGlobalAllowVoidInspection = vConfigurationData->vAllowVoidInspection;

		if (vSystemData.vITIPCDig == NULL)
		{
			if (ThereIsEnoughMemory(sizeof(CITIPCDig), "PCDig Object"))
			{
				vSystemData.vITIPCDig = new (CITIPCDig);
				if (vSystemData.vITIPCDig)
				{
					vGlobalITIPCDig = vSystemData.vITIPCDig;
				}
			}
		}
		if (vConfigurationData->vHVPSType == c210WMonoBlockHVPS)
			vGlobalPortHereOK[cDEFAULT_XRAY_SERIAL_PORT_NUMBER] = cCURRENT_COMM_XRAY_SERIAL_PORT_NUMBER;		

		PortSettingsSimple();		// initialize first port number to try for uC, Xray and AC monitor

		if ((vGlobalScanTracType == cUpSideDownSoloScanTrac) || (vGlobalScanTracType == cAtempoScanTrac) || (vGlobalScanTracType == cForteScanTrac) || 
			(vGlobalScanTracType == cAllegroScanTrac) || (vGlobalScanTracType == cCaseInspectorScanTrac))
			vSystemData.vITIPCDig->vDoBottomReferencing = true;

		vSystemData.vButton2ShowsError = cButton2Hidden;

		//change for speed test //if ((vConfigurationData->vDemoMode) || (!vConfigurationData->vShowOnlyRealImages))
		if (vConfigurationData->vDemoMode)
		{  //if demo mode, make ScanTrac normal priority
			HANDLE TempMyProcessHandle = GetCurrentProcess();
			DWORD TempApplicationPriority = GetPriorityClass(TempMyProcessHandle);
			SetPriorityClass(TempMyProcessHandle,NORMAL_PRIORITY_CLASS);
			
			DWORD TempApplicationPriority1 = GetPriorityClass(TempMyProcessHandle);
		}

		HANDLE TempMyProcessHandle = GetCurrentProcess();
		DWORD TempApplicationPriority = GetPriorityClass(TempMyProcessHandle);
		//SetPriorityClass(TempMyProcessHandle,BELOW_NORMAL_PRIORITY_CLASS);
		//SetPriorityClass(TempMyProcessHandle,ABOVE_NORMAL_PRIORITY_CLASS);
		SetPriorityClass(TempMyProcessHandle,REALTIME_PRIORITY_CLASS); //new 6/30/2016

		
		DWORD TempApplicationPriority1 = GetPriorityClass(TempMyProcessHandle);

		if (!vConfigurationData->vShowMouseCursor)
			int TempDisplayCursorCounter = ShowCursor(false);
		vSystemData.vLogFile.vLogSerialData = vConfigurationData->vLogSerialData;
		vSystemData.vLogFile.vLogSyncData = vConfigurationData->vLogSyncData;

		if (vSystemData.vLogFile.vLogSerialData)
		if (!vConfigurationData->vDemoMode)
		{
			vSystemData.vLogFile.vLogDirectory = vConfigurationData->vScanTracSerialLogsDirectory;
			if (!vSystemData.vLogFile.OpenLogFile())
			{
				ReportErrorMessage("Error-Could Not Open Serial Log File", cEMailInspx,32000); 
			}
			else
				CheckDiskSpaceFree("C:\\");
		}
		
//#ifdef UseHalconLibraries
//	HException::InstallHHandler(&ScanTracHalconExceptionHandler);
//#endif
		ReportErrorMessage("Started ScanTrac Software", cUserChanges,0);
		ReportErrorMessage("--Info Only--Started ScanTrac Software", cEMailInspx,32002); //32001 makes red in log, 32002 does not make yellow message

		
		//make serial port thread highest priority possible
		vGlobaluCSerialPort = (CSerialPort *)AfxBeginThread(RUNTIME_CLASS(CSerialPort), THREAD_PRIORITY_TIME_CRITICAL, 0, CREATE_SUSPENDED);
			//THREAD_PRIORITY_HIGHEST);
			//THREAD_PRIORITY_NORMAL);
		
		if (vGlobaluCSerialPort == NULL)
		{
			ReportErrorMessage("\nCould Not Create Serial Port Thread.\nRe-Seat Serial Board.\nCall Service.", cCritical, 0); 
			ReportErrorMessage("Could Not Create Serial Port Thread. Re-Seat Serial Board. Call Service.", cError, 0); 
			ReportErrorMessage("Could Not Create Serial Port Thread, Re-Seat Serial Board", cEMailInspx, 32000); 
		}
		else
		{
			ASSERT_VALID(vGlobaluCSerialPort);
			//vGlobaluCSerialPort-> assign values?

			vGlobaluCSerialPort->vLocalSystemData = &vSystemData;
			vGlobaluCSerialPort->vLocalConfigurationData = vConfigurationData;
			vGlobaluCSerialPort->vMainWindowPointer = this;

			//vGlobaluCSerialPort->vComPortNumber = 1;  //com1
			vGlobaluCSerialPort->vComPortNumber = vGlobalSerialPortNumberMicroController;

			if ((vConfigurationData->vDemoMode) || (vConfigurationData->vSimulateLightControlBoard))
				vGlobalFirstMicroControllerCommCheck = cFinishedSearchForNextSerialPort;

#ifdef _DEBUG
				vGlobalFirstMicroControllerCommCheck = cFinishedSearchForNextSerialPort;
#endif

			vGlobaluCSerialPort->OpenPort(vGlobaluCSerialPort->vComPortNumber);
			vGlobaluCSerialPort->ResumeThread();
		}
//#i fdef UseS erialPort
//#e ndif
		{
#ifndef ScanTracDemo
			if (!vGlobaluCSerialPort->vPortOpen)
			{
				LPCTSTR TempTextMessage = _T("Could not open port to micro-Controller");
				LPCTSTR TempTitleMessage = _T("ScanTrac Notice");
				MessageBox(TempTextMessage, TempTitleMessage, MB_SETFOREGROUND);
			}
			else
#endif
			{
				/*
				TempAfinity = (AFFINITYMASK_SERIAL & vGlobalSystemAffinityMask);
				if ((TempAfinity != 0) && (vGlobalSystemAffinityMask >= 0x0F))
				{
					if (vGlobalSystemAffinityMask == 0xFF)
					{
						DWORD TempOriginalAffinityMask = ::SetThreadAffinityMask(vGlobaluCSerialPort->m_hThread, 0x20);
						ReportErrorMessage("Set Affinity for 8 Cores", cAction,0);
					}
					else
					if (::SetThreadAffinityMask(vGlobaluCSerialPort->m_hThread,TempAfinity))
					{
						vReplyOK |= 0x02 ;
						ReportErrorMessage("Set Affinity for 4 Cores", cAction,0);
					}
				}
				*/
			}

			if ((!vGlobaluCSerialPort) || (!vGlobaluCSerialPort->vPortOpen))
			if (!vConfigurationData->vDemoMode)
			if (!vConfigurationData->vSimulateLightControlBoard)
			{
				CWnd *TempWindow = NULL;
				TempWindow = FindWindow(NULL, _T("Inspx-ScanTrac"));
				if (!TempWindow) 
					TempWindow = FindWindow(NULL, _T("Version"));
				if (!TempWindow) 
					TempWindow = FindWindow(NULL, _T("Notice"));

				if (TempWindow) 
				{
					EndDialog(true);  //other copy should be on top, so just exit
				}
				else
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n\nCould Not Open Serial Port To uC Board";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
					EndDialog(true);
				}
			}
		if (vConfigurationData->vRFIDEASBadgeReaderCommPort != 0)
		{
			
			vGlobalRFIDEASBadgeReaderSerialPort = (CSerialPortRFIDEASBadgeReader *)AfxBeginThread(RUNTIME_CLASS(CSerialPortRFIDEASBadgeReader), THREAD_PRIORITY_HIGHEST);

			if (vGlobalRFIDEASBadgeReaderSerialPort == NULL)
			{
				ReportErrorMessage("Could Not Create Badge Reader Serial Port Thread,", cError, 0); 
			}
			else
			{
				ASSERT_VALID(vGlobalRFIDEASBadgeReaderSerialPort);

				vGlobalRFIDEASBadgeReaderSerialPort->vLocalSystemData = &vSystemData;
				vGlobalRFIDEASBadgeReaderSerialPort->vLocalConfigurationData = vConfigurationData;
				//vGlobalRFIDEASBadgeReaderSerialPort->vMainWindowPointer = this;

				vGlobalRFIDEASBadgeReaderSerialPort->vComPortNumber = vConfigurationData->vRFIDEASBadgeReaderCommPort;

				//vGlobalRFIDEASBadgeReaderSerialPort->SetBaudRate(CBR_115200);
				vGlobalRFIDEASBadgeReaderSerialPort->SetBaudRate(CBR_9600);
				//vGlobalRFIDEASBadgeReaderSerialPort->SetBaudRate(CBR_19200);

				vGlobalRFIDEASBadgeReaderSerialPort->OpenPort(vGlobalRFIDEASBadgeReaderSerialPort->vComPortNumber);

				if (vGlobalRFIDEASBadgeReaderSerialPort->vPortOpen)
				{
					vGlobalPortHereOK[vGlobalRFIDEASBadgeReaderSerialPort->vComPortNumber] = vGlobalRFIDEASBadgeReaderSerialPort->vComPortNumber;
				}
				else
				{
					CString TempCString;
					TempCString.Format(_T("Could Not Open Serial Port %d to RFIDEAS Badge Reader"), vGlobalRFIDEASBadgeReaderSerialPort->vComPortNumber);
					ReportErrorMessage(TempCString, cEMailInspx,32000); 
				}
		//		if (vConfigurationData->vSimulateLightControlBoard)
		//			vGlobalRFIDEASBadgeReaderSerialPort->vNoCommunications = false;

				//if (vConfigurationData->vDominoIPAddress.GetLength() > 6)
				//	vGlobalDominoPrinterSerialPort->OpenSocket();
			}
		}

			//on a real system, set the user interface thread to lowest priority of application
			if (!vConfigurationData->vDemoMode)
			{
				CWinThread *TempThreadPointer = AfxGetThread();
				int TempThreadPriority = TempThreadPointer->GetThreadPriority();
				
				//TempThreadPointer->SetThreadPriority(THREAD_PRIORITY_BELOW_NORMAL);
				//TempThreadPointer->SetThreadPriority(THREAD_PRIORITY_ABOVE_NORMAL);
				//Main thread should be normal so Process quick learn can be below normal
				TempThreadPointer->SetThreadPriority(THREAD_PRIORITY_NORMAL);
				int TempThreadPriority1 = TempThreadPointer->GetThreadPriority();
			}

			tSerialCommand TempCommand;
			TempCommand[0] = 0x35;
			TempCommand[1] = 0x34;
			TempCommand[2] = 0x33;
			TempCommand[3] = 0x32;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(400);  // Must keep this, does not work at 100

			//SendInitializationToUController(false);
			//if sending a reset when run SBC, then don't need to intitialize, as reset message 
			//will cause it to initialize
			this->SetWindowText(_T("Inspx-ScanTrac"));

			//delete any files left over from restoring from a USB Memory Stick
			CFileStatus TempFileStatus;
			if ((CFile::GetStatus(_T("C:\\ScanTracExtra\\ScanTrac_New_Release"), TempFileStatus)))
			{
				DeleteFile(_T("C:\\ScanTrac\\Restore.bat"));
				DeleteFilesInDirectory("C:\\ScanTracExtra\\ScanTrac_New_Release");
				RemoveDirectory(_T("C:\\ScanTracExtra\\ScanTrac_New_Release"));
			}

			int TimerResult = SetTimer(vSplashScreenTimerHandle,4000,NULL);//cSplashScreenDelay,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Startup Timer Failed",cEMailInspx,32000);

			CString TempString1 = cLogDirectory;
			TempString1.Delete(TempString1.GetLength() -1, 1);
			LPTSTR TempString = TempString1.GetBuffer(TempString1.GetLength());
			if (!(CFile::GetStatus(TempString, TempFileStatus)))
			{
				if (!CreateDirectory(cLogDirectory,NULL))
				{
					DWORD TempErrorNumber = GetLastError();
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "Error creating Log Directory: " + 
						dtoa(TempErrorNumber,0);
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
			}

			TempString1 = vConfigurationData->vScanTracImagesDirectory;
			TempString1.Delete(TempString1.GetLength() -1, 1);
			TempString = TempString1.GetBuffer(TempString1.GetLength());
			if (vConfigurationData->vScanTracImagesDirectory.GetLength() > 4)
			if (!(CFile::GetStatus(TempString, TempFileStatus)))
				CreateDirectory(vConfigurationData->vScanTracImagesDirectory,NULL);

			CString TempStringSSD = vConfigurationData->vScanTracScreenShotDirectory;
			TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
			LPTSTR TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
			if (vConfigurationData->vScanTracScreenShotDirectory.GetLength() > 4)
			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
				CreateDirectory(vConfigurationData->vScanTracScreenShotDirectory,NULL);
			// kjh 8/28/2012 added to create a shadow directory for Screen shots if images stored on server
			// check if directory was created on C: or D: drive, if not create a directory on C:
			// set bit 1 in variable vGlobalShadowImages if true
			// clear bit 1 if false, cShadowScreenShotsBit
			if ((vConfigurationData->vScanTracScreenShotDirectory.GetAt(0) != 'C') && (vConfigurationData->vScanTracScreenShotDirectory.GetAt(0) != 'D') &&
				(vConfigurationData->vScanTracScreenShotDirectory.GetAt(0) != 'c') && (vConfigurationData->vScanTracScreenShotDirectory.GetAt(0) != 'd'))
			{
				SetBit(vGlobalShadowImages,cShadowScreenShotsBit);		// not copying files to local directory, try to set up shadow directory
				CString TempStringScreenShotShadowDirectory;
				if  (CheckDiskSpaceFree("C:\\") == 0)
				{
					ClrBit(vGlobalShadowImages,cShadowScreenShotsBit);	// dont echo to C: drive
				}
				else
				{
					TempStringScreenShotShadowDirectory = cScanTracScreenShotDirectory;  //"c:\\ScanTracScreenShots\\";	//				
					if (!(CFile::GetStatus(TempStringScreenShotShadowDirectory, TempFileStatus)))
					{
						BOOL TempDirectoryCreate = CreateDirectory(TempStringScreenShotShadowDirectory,NULL);
						if (TempDirectoryCreate == false)
							ClrBit(vGlobalShadowImages,cShadowScreenShotsBit);	// if directory is not created, no need to shadow
					}
				}
			}
			else
			{
				ClrBit(vGlobalShadowImages,cShadowScreenShotsBit);
			}

			//check if directory exists, if not, create it
			TempStringSSD = vConfigurationData->vScanTracProductionReportDirectory;
			TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
			TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
			if (vConfigurationData->vScanTracProductionReportDirectory.GetLength() > 4)
			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
				CreateDirectory(vConfigurationData->vScanTracProductionReportDirectory,NULL);
			// kjh 8/28/2012 added to create a shadow directory for Production Reports if stored on server
			// check if directory was created on C: or D: drive, if not create a directory on C:
			// set bit 3 in variable vGlobalShadowImages if true
			// clear bit 3 if false, cShadowProductionReportBit
			if ((vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'C') && (vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'D') &&
				(vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'c') && (vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'd'))
			{
				SetBit(vGlobalShadowImages,cShadowProductionReportBit);		// not copying files to local directory, try to set up shadow directory
				CString TempStringProductionReportDirectory;
				if  (CheckDiskSpaceFree("C:\\") == 0)
				{
					ClrBit(vGlobalShadowImages,cShadowProductionReportBit);	// dont echo to C: drive
				}
				else
				{
					TempStringProductionReportDirectory = cScanTracProductionReportDirectory;  //"c:\\ScanTracProductionReport\\";	//	
					TempStringProductionReportDirectory.Delete(TempStringProductionReportDirectory.GetLength() -1, 1);
					LPTSTR TempStringProductionReportDirectoryPtr = TempStringProductionReportDirectory.GetBuffer(TempStringProductionReportDirectory.GetLength());

					if (!(CFile::GetStatus(TempStringProductionReportDirectoryPtr, TempFileStatus)))
					{
						BOOL TempDirectoryCreate = CreateDirectory(TempStringProductionReportDirectoryPtr,NULL);
						if (TempDirectoryCreate == false)
							ClrBit(vGlobalShadowImages,cShadowProductionReportBit);	// if directory is not created, no need to shadow
					}
				}
			}
			else
			{
				ClrBit(vGlobalShadowImages,cShadowProductionReportBit);
			}


			TempStringSSD = cACPowerMoniterLogDirectory;
			TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
			TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
				CreateDirectory(cACPowerMoniterLogDirectory,NULL);

			//check if directory exists, if not, create it
			TempStringSSD = vConfigurationData->vScanTracEventLogDirectory;
			TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
			TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
			if (vConfigurationData->vScanTracEventLogDirectory.GetLength() > 4)
			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
				CreateDirectory(vConfigurationData->vScanTracEventLogDirectory,NULL);
			// kjh 8/28/2012 added to create a shadow directory for event log if files stored on server
			// check if directory was created on C: or D: drive, if not create a directory on C:
			// set bit 2 in variable vGlobalShadowImages if true
			// clear bit 2 if false, cShadowEventLogBit
			if ((vConfigurationData->vScanTracEventLogDirectory.GetAt(0) != 'C') && (vConfigurationData->vScanTracEventLogDirectory.GetAt(0) != 'D') &&
				(vConfigurationData->vScanTracEventLogDirectory.GetAt(0) != 'c') && (vConfigurationData->vScanTracEventLogDirectory.GetAt(0) != 'd'))
			{
				SetBit(vGlobalShadowImages,cShadowEventLogBit);		// not copying files to local directory, try to set up shadow directory
				CString TempStringEventLogShadowDirectory;
				if  (CheckDiskSpaceFree("C:\\") == 0)
				{
					ClrBit(vGlobalShadowImages,cShadowEventLogBit);	// don't echo to C: drive
				}
				else
				{
					TempStringEventLogShadowDirectory = cScanTracEventLogDirectory;  // "c:\\ScanTracEventLogs\\";					
					if (!(CFile::GetStatus(TempStringEventLogShadowDirectory, TempFileStatus)))
					{
						BOOL TempDirectoryCreate = CreateDirectory(TempStringEventLogShadowDirectory,NULL);
						if (TempDirectoryCreate == false)
							ClrBit(vGlobalShadowImages,cShadowEventLogBit);	// if directory is not created, no need to shadow
					}
				}
			}
			else
			{
				ClrBit(vGlobalShadowImages,cShadowEventLogBit);
			}

			//check if directory exists, if not, create it
			TempStringSSD = vConfigurationData->vScanTracRejectedImagesDirectory;
			TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
			TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
			if (vConfigurationData->vScanTracRejectedImagesDirectory.GetLength() > 4)
			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
			{
//				if (TempFileStatus.m_attribute != 0x10)		// if not a directory, create directory
					CreateDirectory(vConfigurationData->vScanTracRejectedImagesDirectory,NULL);
			}

			// kjh 8/28/2012 added to create a shadow directory for Rejected Images if images stored on server
			// check if directory was created on C: or D: drive, if not create a directory on D:
			// set variable vGlobalShadowImages = true or false at correct bit position
			if ((vConfigurationData->vScanTracRejectedImagesDirectory.GetAt(0) != 'C') && (vConfigurationData->vScanTracRejectedImagesDirectory.GetAt(0) != 'D') &&
				(vConfigurationData->vScanTracRejectedImagesDirectory.GetAt(0) != 'c') && (vConfigurationData->vScanTracRejectedImagesDirectory.GetAt(0) != 'd'))
			{
				SetBit(vGlobalShadowImages,cShadowRejectedImageBit);		// not copying files to local directory, try to set up shadow directory
				vGlobalCountErrorMsgPossibleDirectoryNotAvailableSent = 0;
				CString TempStringRejectedShadowDirectory;
				if  (CheckDiskSpaceFree("D:\\") == 0)
				{
					TempStringRejectedShadowDirectory = cRejectedImagesDirectoryCDrive;  //"c:\\ScanTracRejectedImages\\";	//
					vGlobalHaveDDrive = false;
				}
				else
				{
					TempStringRejectedShadowDirectory = cRejectedImagesDirectoryDDrive;  //"d:\\ScanTracRejectedImages\\";	//
					vGlobalHaveDDrive = true;
				}
				if (!(CFile::GetStatus(TempStringRejectedShadowDirectory, TempFileStatus)))
				{
					BOOL TempDirectoryCreate = CreateDirectory(TempStringRejectedShadowDirectory,NULL);
					if (TempDirectoryCreate == false)
						ClrBit(vGlobalShadowImages,cShadowRejectedImageBit);		// if directory is not created, no need to shadow
				}
			}
			else
			{
				ClrBit(vGlobalShadowImages,cShadowRejectedImageBit);
			}


			//check if directory exists, if not, create it
			TempStringSSD = vConfigurationData->vScanTracImagesDirectory;
			TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
			TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
			if (vConfigurationData->vScanTracImagesDirectory.GetLength() > 4)
			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
				CreateDirectory(vConfigurationData->vScanTracImagesDirectory,NULL);

			//check if directory exists, if not, create it
			TempStringSSD = vConfigurationData->vScanTracCalibrationImagesDirectory;
			TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
			TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
			if (vConfigurationData->vScanTracCalibrationImagesDirectory.GetLength() > 4)
			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
				CreateDirectory(vConfigurationData->vScanTracCalibrationImagesDirectory,NULL);

			//check if directory exists, if not, create it
			TempStringSSD = vConfigurationData->vScanTracSerialLogsDirectory;
			TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
			TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
			if (vConfigurationData->vScanTracSerialLogsDirectory.GetLength() > 4)
			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
				CreateDirectory(vConfigurationData->vScanTracSerialLogsDirectory,NULL);

			UpdateSubFunction8Button();

			vGlobalIcon = this->GetIcon(false);
			this->SetIcon(vGlobalIconSmall, false);
			this->SetIcon(vGlobalIcon, true);

			if (vConfigurationData->vAllowClientConnections)
				InitializeTCPIPServerSocket();

			if (vConfigurationData->vEnableModBusTCPIPInterface)
				OpenModBusTCPIPInterface();
			//load in error messages from inspx error log
			CString TempDirectoryString = cLogDirectory;
			TempDirectoryString = TempDirectoryString + "ScanTracCriticalLog.txt";
			LPCTSTR TempFileName = TempDirectoryString;
			CFileException TempFileException;
			if (ThereIsEnoughMemory(sizeof(CFile), "Critical Log File"))
			{
				CFile *TempCriticalLogFile = new CFile;
				if (TempCriticalLogFile)
				{
					if (TempCriticalLogFile->Open(TempFileName, (CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException))
					{
						char TempBuffer[50000];
						DWORD TempBytesRead = TempCriticalLogFile->Read(TempBuffer, 50000);

						USES_CONVERSION;
						LPCTSTR TempStringJustRead = A2W(TempBuffer);

						CString TempCurrentFile = TempStringJustRead;
						TempCurrentFile.GetBufferSetLength(TempBytesRead);
						DWORD TempFileSize = TempCurrentFile.GetLength();
						if (TempBytesRead)
						{
							CString TempResult = " ";
							DWORD TempPreviousPosition = 0;
							DWORD TempPosition = TempCurrentFile.Find((char)0x0D,0);
							if (TempPosition)
							while (TempPosition < TempBytesRead)
							{
								CStringBufferObject *TempErrorObject = NULL;
								TempErrorObject = new CStringBufferObject;
								if (TempErrorObject)
								{
									TempResult = TempCurrentFile.Mid(TempPreviousPosition,TempPosition - TempPreviousPosition);
									TempErrorObject->vTheString = TempResult;
									TempPreviousPosition = TempPosition + 2;
									TempPosition = TempCurrentFile.Find((char)0x0D,TempPreviousPosition + 5);
									TempErrorObject->vTheType = cEMailInspx;
									vSystemData.vInspxLog.AddTail(TempErrorObject);
								}
								else
									TempPosition = TempBytesRead;
							}
						}
						TempCriticalLogFile->Close();
					}
					delete TempCriticalLogFile;
				}
			}
			ResetCounters();

			AutoDeleteLogFiles();
			//DeleteOldLogFiles(20,vConfigurationData->vScanTracSerialLogsDirectory);
			MoveFoldersToNewFormatIfNeeded();

			SetTimer(vTriggerIndicatorTimerHandle,10,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Trigger Indicator Timer Failed",cEMailInspx,32000);
		}
// before assigning more ports is first port assigned the micro controller port?
		if (vConfigurationData->vHVPSType == cXLFHVPS)
		{
			if ((vGlobalSerialPortNumberXRaySource != cDEFAULT_XRAY_SERIAL_PORT_NUMBER) &&
					((vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] == cCURRENT_TRY_XRAY_SERIAL_PORT_NUMBER) || (vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] == cCURRENT_COMM_XRAY_SERIAL_PORT_NUMBER)))
				vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] = cFOUND_PORT_AVALIBLE;
			vGlobalSerialPortNumberXRaySource = cDEFAULT_XRAY_SERIAL_PORT_NUMBER;
			vGlobalPortHereOK[cDEFAULT_XRAY_SERIAL_PORT_NUMBER] = cCURRENT_COMM_XRAY_SERIAL_PORT_NUMBER;
			vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen; 
		}

		if ((vConfigurationData->vHVPSType == cDXMHVPS) || (vConfigurationData->vHVPSType == cMNXHVPS))
		{
			vGlobalDXMXRayPort = (CSpellmanDXMXRaySourcePort *)AfxBeginThread(
				RUNTIME_CLASS(CSpellmanDXMXRaySourcePort),
				THREAD_PRIORITY_TIME_CRITICAL, 0, CREATE_SUSPENDED);
				//THREAD_PRIORITY_HIGHEST);
				//THREAD_PRIORITY_NORMAL);

			if (vGlobalDXMXRayPort == NULL)
			{
				ReportErrorMessage("Could Not Create DXM Port Thread.\nRe-Seat Serial Board.\nCall Service.", cCritical, 0); 
				ReportErrorMessage("Could Not Create DXM Thread. Re-Seat Serial Board. Call Service.", cError, 0); 
				ReportErrorMessage("Could Not Create DXM Port Thread", cEMailInspx, 32000); 
				//socketio DXM 

			}
			else
			{
				ASSERT_VALID(vGlobalDXMXRayPort);
				//vGlobaluCSerialPort-> assign values?

				vGlobalDXMXRayPort->vLocalSystemData = &vSystemData;
				vGlobalDXMXRayPort->vLocalConfigurationData = vConfigurationData;

				vGlobalDXMXRayPort->vComPortNumber = vGlobalSerialPortNumberXRaySource;	//3; //com3

				if ((vConfigurationData->vDemoMode) || (vConfigurationData->vSimulateLightControlBoard))
					vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen; 

				vGlobalDXMXRayPort->OpenPort(vGlobalDXMXRayPort->vComPortNumber);
				if (vGlobalDXMXRayPort->vPortOpen)
				{
					//kjh priority
					TempAfinity = (AFFINITYMASK_SERIAL & vGlobalSystemAffinityMask);
					/*
					if ((TempAfinity != 0) && (vGlobalSystemAffinityMask >= 0x0F))
					{
						if (vGlobalSystemAffinityMask == 0xFF)
							DWORD TempOriginalAffinityMask = ::SetThreadAffinityMask(vGlobalDXMXRayPort->m_hThread, 0x10);
						else
						if (::SetThreadAffinityMask(vGlobalDXMXRayPort->m_hThread,TempAfinity))
							vReplyOK |= 0x08;
					}
					*/
					InitializeDXM();
				}
				else
				{
					CString TempAString;
					TempAString.Format(_T("%d"),vGlobalDXMXRayPort->vComPortNumber);
					ReportErrorMessage("Could Not Open Serial Port " + TempAString + " to " + vGlobalDXMXRayPort->vHVPSType + " X-Ray HVPS", cEMailInspx,32000); 
//					ReportErrorMessage("Could Not Open Serial Port 3 to " + vGlobalDXMXRayPort->vHVPSType + " X-Ray HVPS", cEMailInspx,32000); 
//					vGlobalXrayNoCommMessageRcvdEver = cNoCommSeenEver;  // try different ports elsewhere
					
				}
				if (vConfigurationData->vSimulateLightControlBoard)
					vGlobalDXMXRayPort->vNoCommunications = false;

				vGlobalDXMXRayPort->ResumeThread();
			}
		}
		else  //if not DXM then XLF, and can not be a piccolo
		if (vConfigurationData->vHVPSType == c100WMonoBlockHVPS)
		{
			vGlobalDXMXRayPort = (CSpellman100WattMonoBlock *)AfxBeginThread(RUNTIME_CLASS(CSpellman100WattMonoBlock), THREAD_PRIORITY_TIME_CRITICAL, 0, CREATE_SUSPENDED);

			if (vGlobalDXMXRayPort == NULL)
			{
				ReportErrorMessage("Could Not Create XRB100W MonoBlock Port Thread.\nRe-Seat Serial Board.\nCall Service.", cCritical, 0); 
				ReportErrorMessage("Could Not Create XRB100 Thread. Re-Seat Serial Board. Call Service.", cError, 0); 
				ReportErrorMessage("Could Not Create XRB100W MonoBlock Port Thread", cEMailInspx, 32000); 
			}
			else
			{
				ASSERT_VALID(vGlobalDXMXRayPort);

				vGlobalDXMXRayPort->vLocalSystemData = &vSystemData;
				vGlobalDXMXRayPort->vLocalConfigurationData = vConfigurationData;
				
//				if (vGlobalSerialPortNumberXRaySource != cDEFAULT_XRAY_SERIAL_PORT_NUMBER)
//					vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] = cFOUND_PORT_AVALIBLE;
//				vGlobalSerialPortNumberXRaySource = cDEFAULT_XRAY_SERIAL_PORT_NUMBER;
//				vGlobalDXMXRayPort->vComPortNumber = cDEFAULT_XRAY_SERIAL_PORT_NUMBER;		// = 3;
//				vGlobalPortHereOK[cDEFAULT_XRAY_SERIAL_PORT_NUMBER] = cCURRENT_COMM_XRAY_SERIAL_PORT_NUMBER;
				vGlobalDXMXRayPort->vComPortNumber = vGlobalSerialPortNumberXRaySource;		// = default = 3;

//				vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;
//				vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] = cCURRENT_TRY_XRAY_SERIAL_PORT_NUMBER;

				if ((vConfigurationData->vDemoMode) || (vConfigurationData->vSimulateLightControlBoard))
					vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;
#ifdef _DEBUG
					vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;
#endif

				vGlobalDXMXRayPort->OpenPort(vGlobalDXMXRayPort->vComPortNumber);
				if (vGlobalDXMXRayPort->vPortOpen)
				{
					//Affinity left at default
					InitializeDXM();
				}
				else
				{
					CString TempAString;
					TempAString.Format(_T("%d"),vGlobalDXMXRayPort->vComPortNumber);
					ReportErrorMessage("Could Not Open Serial Port " + TempAString + " to XRB100W MonoBlock", cEMailInspx,32000); 
//					ReportErrorMessage("Could Not Open Serial Port 3 to XRB100W MonoBlock", cEMailInspx,32000); 
//					if (vGlobalDXMXRayPort)
//						vGlobalXrayNoCommMessageRcvdEver = cNoCommSeenEver;
				}
				if (vConfigurationData->vSimulateLightControlBoard)
					vGlobalDXMXRayPort->vNoCommunications = false;

				vGlobalDXMXRayPort->ResumeThread();
			}
		}
		else  //if not DXM then XLF, and can not be a piccolo
		if (vConfigurationData->vHVPSType == cCheyneyMonoBlock)
		{
				vGlobalDXMXRayPort = (CCheyneyMonoBlock *)AfxBeginThread(RUNTIME_CLASS(CCheyneyMonoBlock), THREAD_PRIORITY_TIME_CRITICAL, 0, CREATE_SUSPENDED);

				if (vGlobalDXMXRayPort == NULL)
				{
						ReportErrorMessage("Could Not Create Cheyney MonoBlock Port Thread.\nRe-Seat Serial Board.\nCall Service.", cCritical, 0);
						ReportErrorMessage("Could Not Create Cheyney MonoBlock Thread. Re-Seat Serial Board. Call Service.", cError, 0);
						ReportErrorMessage("Could Not Create Cheyney  MonoBlock Port Thread", cEMailInspx, 32000);
				}
				else
				{
						ASSERT_VALID(vGlobalDXMXRayPort);

						vGlobalDXMXRayPort->vLocalSystemData = &vSystemData;
						vGlobalDXMXRayPort->vLocalConfigurationData = vConfigurationData;

						//				if (vGlobalSerialPortNumberXRaySource != cDEFAULT_XRAY_SERIAL_PORT_NUMBER)
						//					vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] = cFOUND_PORT_AVALIBLE;
						//				vGlobalSerialPortNumberXRaySource = cDEFAULT_XRAY_SERIAL_PORT_NUMBER;
						//				vGlobalDXMXRayPort->vComPortNumber = cDEFAULT_XRAY_SERIAL_PORT_NUMBER;		// = 3;
						//				vGlobalPortHereOK[cDEFAULT_XRAY_SERIAL_PORT_NUMBER] = cCURRENT_COMM_XRAY_SERIAL_PORT_NUMBER;
						vGlobalDXMXRayPort->vComPortNumber = vGlobalSerialPortNumberXRaySource;		// = default = 3;

																																												//				vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;
																																												//				vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] = cCURRENT_TRY_XRAY_SERIAL_PORT_NUMBER;

						if ((vConfigurationData->vDemoMode) || (vConfigurationData->vSimulateLightControlBoard))
								vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;

						vGlobalDXMXRayPort->OpenPort(vGlobalDXMXRayPort->vComPortNumber);
						if (vGlobalDXMXRayPort->vPortOpen)
						{
								//Affinity left at default
								InitializeDXM();
						}
						else
						{
								CString TempAString;
								TempAString.Format(_T("%d"), vGlobalDXMXRayPort->vComPortNumber);
								ReportErrorMessage("Could Not Open Serial Port " + TempAString + " to XRB100W MonoBlock", cEMailInspx, 32000);
								//					ReportErrorMessage("Could Not Open Serial Port 3 to XRB100W MonoBlock", cEMailInspx,32000); 
								//					if (vGlobalDXMXRayPort)
								//						vGlobalXrayNoCommMessageRcvdEver = cNoCommSeenEver;
						}
						if (vConfigurationData->vSimulateLightControlBoard)
								vGlobalDXMXRayPort->vNoCommunications = false;

						vGlobalDXMXRayPort->ResumeThread();
				}
		}
		else  //if not DXM then XLF, and can not be a piccoloc1000WVjtMonoBlockHVPS
		if (vConfigurationData->vHVPSType == c100WVJTMonoBlockHVPS)
		{
				vGlobalDXMXRayPort = (CSerialPortVjtMonoBlock *)AfxBeginThread(RUNTIME_CLASS(CSerialPortVjtMonoBlock), THREAD_PRIORITY_TIME_CRITICAL, 0, CREATE_SUSPENDED);

				if (vGlobalDXMXRayPort == NULL)
				{
						ReportErrorMessage("Could Not Create VJT MonoBlock Port Thread.\nRe-Seat Serial Board.\nCall Service.", cCritical, 0);
						ReportErrorMessage("Could Not Create VJT MonoBlock Thread. Re-Seat Serial Board. Call Service.", cError, 0);
						ReportErrorMessage("Could Not Create VJT  MonoBlock Port Thread", cEMailInspx, 32000);
				}
				else
				{
						ASSERT_VALID(vGlobalDXMXRayPort);

						vGlobalDXMXRayPort->vLocalSystemData = &vSystemData;
						vGlobalDXMXRayPort->vLocalConfigurationData = vConfigurationData;

						//				if (vGlobalSerialPortNumberXRaySource != cDEFAULT_XRAY_SERIAL_PORT_NUMBER)
						//					vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] = cFOUND_PORT_AVALIBLE;
						//				vGlobalSerialPortNumberXRaySource = cDEFAULT_XRAY_SERIAL_PORT_NUMBER;
						//				vGlobalDXMXRayPort->vComPortNumber = cDEFAULT_XRAY_SERIAL_PORT_NUMBER;		// = 3;
						//				vGlobalPortHereOK[cDEFAULT_XRAY_SERIAL_PORT_NUMBER] = cCURRENT_COMM_XRAY_SERIAL_PORT_NUMBER;
						vGlobalDXMXRayPort->vComPortNumber = vGlobalSerialPortNumberXRaySource;		// = default = 3;

																																												//				vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;
																																												//				vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] = cCURRENT_TRY_XRAY_SERIAL_PORT_NUMBER;

						if ((vConfigurationData->vDemoMode) || (vConfigurationData->vSimulateLightControlBoard))
								vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;

						vGlobalDXMXRayPort->OpenPort(vGlobalDXMXRayPort->vComPortNumber);
						if (vGlobalDXMXRayPort->vPortOpen)
						{
								//Affinity left at default
								InitializeDXM();
						}
						else
						{
								CString TempAString;
								TempAString.Format(_T("%d"), vGlobalDXMXRayPort->vComPortNumber);
								ReportErrorMessage("Could Not Open Serial Port " + TempAString + " to VJT100W MonoBlock", cEMailInspx, 32000);
								//					ReportErrorMessage("Could Not Open Serial Port 3 to XRB100W MonoBlock", cEMailInspx,32000); 
								//					if (vGlobalDXMXRayPort)
								//						vGlobalXrayNoCommMessageRcvdEver = cNoCommSeenEver;
						}
						if (vConfigurationData->vSimulateLightControlBoard)
								vGlobalDXMXRayPort->vNoCommunications = false;

						vGlobalDXMXRayPort->ResumeThread();
				}
		}
		else  //if not DXM then XLF, and can not be a piccolo
		if ((vConfigurationData->vScanTracType == cPiccoloScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac))
		//if configured for a 50 watt system, then have a conflict so give an error
		if (!vConfigurationData->vSimulateLightControlBoard)
			ReportErrorMessage("Configuration Problem! check HVPS and ScanTrac Type",cEMailInspx,32000);

		if (vConfigurationData->vHVPSType == c210WMonoBlockHVPS)
		{
			vGlobalMonoBlockXRayPort = (CXRaySource *)AfxBeginThread(
				RUNTIME_CLASS(CXRaySource),
				THREAD_PRIORITY_TIME_CRITICAL, 0, CREATE_SUSPENDED);
				//THREAD_PRIORITY_HIGHEST);
				//THREAD_PRIORITY_NORMAL);

			if (vGlobalMonoBlockXRayPort == NULL)
			{
				ReportErrorMessage("Could Not Create XRB210W MonoBlock Port Thread", cCritical,32000); 
				ReportErrorMessage("Could Not Create XRB210W Thread. Re-Seat Serial Board. Call Service.", cError, 0); 
				ReportErrorMessage("Could Not Create XRB210W MonoBlock Port Thread", cEMailInspx, 32000); 
			}
			else
			{
				ASSERT_VALID(vGlobalMonoBlockXRayPort);
				//vGlobalMonoBlockXRayPort-> assign values?

				vGlobalMonoBlockXRayPort->vLocalSystemData = &vSystemData;
				vGlobalMonoBlockXRayPort->vLocalConfigurationData = vConfigurationData;

				if ((vGlobalSerialPortNumberXRaySource != cDEFAULT_XRAY_SERIAL_PORT_NUMBER) &&
					((vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] == cCURRENT_TRY_XRAY_SERIAL_PORT_NUMBER) || (vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] == cCURRENT_COMM_XRAY_SERIAL_PORT_NUMBER)))
					vGlobalPortHereOK[vGlobalSerialPortNumberXRaySource] = cFOUND_PORT_AVALIBLE;
				vGlobalSerialPortNumberXRaySource = cDEFAULT_XRAY_SERIAL_PORT_NUMBER;
				vGlobalMonoBlockXRayPort->vComPortNumber = cDEFAULT_XRAY_SERIAL_PORT_NUMBER;		// = 3;
				vGlobalPortHereOK[cDEFAULT_XRAY_SERIAL_PORT_NUMBER] = cCURRENT_COMM_XRAY_SERIAL_PORT_NUMBER;

//				vGlobalMonoBlockXRayPort->vComPortNumber = vGlobalSerialPortNumberXRaySource;		// = default = 3;
//				vGlobalMonoBlockXRayPort->OpenPort(vGlobalMonoBlockXRayPort->vComPortNumber);

				vGlobalMonoBlockXRayPort->vBaudRate = CBR_9600;
				vGlobalMonoBlockXRayPort->OpenPort(vGlobalMonoBlockXRayPort->vComPortNumber);
				if (vGlobalMonoBlockXRayPort->vPortOpen)
				{
					//kjh priority
					TempAfinity = (AFFINITYMASK_SERIAL & vGlobalSystemAffinityMask);
					/*
					if ((TempAfinity != 0) && (vGlobalSystemAffinityMask >= 0x0F))
					{
						if (vGlobalSystemAffinityMask == 0xFF)
							DWORD TempOriginalAffinityMask = ::SetThreadAffinityMask(vGlobalMonoBlockXRayPort->m_hThread, 0x10);
						else
						if (::SetThreadAffinityMask(vGlobalMonoBlockXRayPort->m_hThread,TempAfinity))
							vReplyOK |= 0x08;
					}
					*/
					//Initialize();  //none on MonoBlock
				}
				else
				{
					CString TempAString;
					TempAString.Format(_T("%d"),vGlobalMonoBlockXRayPort->vComPortNumber);
					ReportErrorMessage("Could Not Open Serial Port " + TempAString + " to XRB210W MonoBlock X-Ray HVPS", cEMailInspx,32000); 
//					ReportErrorMessage("Could Not Open Serial Port 3 to XRB210W MonoBlock X-Ray HVPS", cEMailInspx,32000); 
//					if (vGlobalMonoBlockXRayPort)
//						vGlobalXrayNoCommMessageRcvdEver = cGiveUpOnCommPort;
				}
				if (vConfigurationData->vSimulateLightControlBoard)
					vGlobalMonoBlockXRayPort->vNoCommunications = false;
				vGlobalMonoBlockXRayPort->ResumeThread();
			}
		}
		else  //if not MonoBlock then XLF, and can not be a piccolo
		if ((vConfigurationData->vScanTracType == cForteScanTrac) || (vConfigurationData->vScanTracType == cCaseInspectorScanTrac))
		//if configured for a 50 watt system, then have a conflict so give an error
		if (!vConfigurationData->vSimulateLightControlBoard)
			ReportErrorMessage("Configuration Problem! check HVPS and ScanTrac Type",cEMailInspx,32000);

		//open Com4 to AC Power Monitor
		vGlobalACPowerMoniter = (CACPowerMoniter *)AfxBeginThread(
			RUNTIME_CLASS(CACPowerMoniter),
			//THREAD_PRIORITY_TIME_CRITICAL);
			THREAD_PRIORITY_HIGHEST); //, 0, CREATE_SUSPENDED);
			//THREAD_PRIORITY_NORMAL);

		if (vGlobalACPowerMoniter == NULL)
		{
			ReportErrorMessage("Could Not Create AC Power Monitor Port Thread.\nRe-Seat Serial Board.\nCall Service.", cCritical, 0); 
			ReportErrorMessage("Could Not Create AC Power Monitor Thread. Re-Seat Serial Board. Call Service.", cEMailMaintenance, 0); 
			ReportErrorMessage("Could Not Create AC Power Monitor Port Thread", cEMailInspx,32000); 
		}
		else
		{
			ASSERT_VALID(vGlobalACPowerMoniter);
			//vGlobaluCSerialPort-> assign values?

			vGlobalACPowerMoniter->vLocalSystemData = &vSystemData;
			vGlobalACPowerMoniter->vLocalConfigurationData = vConfigurationData;

			//9/4/2009
			vGlobalACPowerMoniter->vComPortNumber = vGlobalSerialPortNumberACPowerMonitor;	// default = 4;
			//vGlobalACPowerMoniter->vComPortNumber = 5; //com4

			vGlobalACPowerMoniter->SetBaudRate(CBR_19200);

			if ((vConfigurationData->vDemoMode) || (vConfigurationData->vSimulateLightControlBoard))
				vGlobalACPowerMoniter->vTestACPowerMoniterExists = cYesCommSeen;	

			vGlobalACPowerMoniter->OpenPort(vGlobalACPowerMoniter->vComPortNumber);
			vACPowerMoniterPortCommCheckState = 0;
			//vGlobalACPowerMoniter->ResumeThread();

			if (vGlobalACPowerMoniter->vPortOpen)
			{
				//kjh priority
				TempAfinity = (AFFINITYMASK_POWER_MONITOR & vGlobalSystemAffinityMask);
				
				//if ((TempAfinity != 0) && (vGlobalSystemAffinityMask >= 0x0F))
				//{
				//	if (vGlobalSystemAffinityMask >= 0x0F)
				//		DWORD TempOriginalAffinityMask = ::SetThreadAffinityMask(vGlobalACPowerMoniter->m_hThread, 0x08);
				//	else
				//	if (::SetThreadAffinityMask(vGlobalACPowerMoniter->m_hThread,TempAfinity))
				//		vReplyOK |= 0x08;
				//}
				
				vGlobalACPowerMoniter->InitializeACPowerMoniter();
			}
			else
			{
				CString TempCString;
				TempCString.Format(_T("Could Not Open Serial Port %d to AC Power Monitor"),vGlobalSerialPortNumberACPowerMonitor);
				ReportErrorMessage(TempCString, cEMailInspx,32000); 
			}
			if (vConfigurationData->vSimulateLightControlBoard)
				vGlobalACPowerMoniter->vNoCommunications = false;
		}

		//open Com5 to Allen Bradley Guard Master Interlock system
		vGlobalGuardMaster = (CSerialPortGuardMaster *)AfxBeginThread(
			RUNTIME_CLASS(CSerialPortGuardMaster),
			//THREAD_PRIORITY_TIME_CRITICAL);
			THREAD_PRIORITY_HIGHEST); //, 0, CREATE_SUSPENDED);
			//THREAD_PRIORITY_NORMAL);

		if (vGlobalGuardMaster == NULL)
		{
			//brh if serial number high enough, or FPGA high enough could give message in future

			//ReportErrorMessage("Could Not Create Guard Master Port Thread.\nRe-Seat Serial Board.\nCall Service.", cCritical, 0); 
			//ReportErrorMessage("Could Not Create Guard Master Thread. Re-Seat Serial Board. Call Service.", cEMailMaintenance, 0); 
			//ReportErrorMessage("Could Not Create Guard Master Port Thread", cEMailInspx,32000); 
			ReportErrorMessage("Could Not Create Guard Master Port Thread, using uC Board Interlocks", cWriteToLog, 0); 
		}
		else
		{
			ASSERT_VALID(vGlobalGuardMaster);

			vGlobalGuardMaster->vLocalSystemData = &vSystemData;
			vGlobalGuardMaster->vLocalConfigurationData = vConfigurationData;
			vGlobalGuardMaster->vMainWindowPointer = this;

			if (vConfigurationData->vDetectedValidGuardMasterDevice) //if previously had detected the device, it must still be in use.
				vGlobalGuardMaster->vDetectedValidGuardMasterDevice = true;

			vGlobalGuardMaster->vComPortNumber = 5;	// default = 5;

			vGlobalGuardMaster->SetBaudRate(CBR_19200);

			vGlobalGuardMaster->OpenPort(vGlobalGuardMaster->vComPortNumber);

			if (vGlobalGuardMaster->vPortOpen)
			{
				//TempAfinity = (AFFINITYMASK_POWER_MONITOR & vGlobalSystemAffinityMask);
				vGlobalPortHereOK[vGlobalGuardMaster->vComPortNumber] = vGlobalGuardMaster->vComPortNumber;
			}
			else
			{
				CString TempCString;
				TempCString.Format(_T("Could Not Open Serial Port %d to Guard Master"), vGlobalGuardMaster->vComPortNumber);
				ReportErrorMessage(TempCString, cEMailInspx,32000); 
			}
			if (vConfigurationData->vSimulateLightControlBoard)
				vGlobalGuardMaster->vNoCommunications = false;
		}

		
	//	if (vGlobalScanTracType == cAllegroScanTrac)
	//	//if ((vConfigurationData->vScanTracType == cForteScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || (vConfigurationData->vScanTracType == cCaseInspectorScanTrac)) //if a top down
	//	{
	//		////open Com2 to Allen Bradley Power Flex 40 Conveyor Motor Controller
	//		vGlobalPowerFlex40 = (CSerialPortPowerFlex40 *)AfxBeginThread(
	//			RUNTIME_CLASS(CSerialPortPowerFlex40),
	//			//THREAD_PRIORITY_TIME_CRITICAL);
	//			THREAD_PRIORITY_HIGHEST); //, 0, CREATE_SUSPENDED);
	//			//THREAD_PRIORITY_NORMAL);

	//		if (vGlobalPowerFlex40 == NULL)
	//		{
	//			//brh if serial number high enough, or FPGA high enough could give message in future

	//			//ReportErrorMessage("Could Not Create Guard Master Port Thread.\nRe-Seat Serial Board.\nCall Service.", cCritical, 0); 
	//			//ReportErrorMessage("Could Not Create Guard Master Thread. Re-Seat Serial Board. Call Service.", cEMailMaintenance, 0); 
	//			//ReportErrorMessage("Could Not Create Guard Master Port Thread", cEMailInspx,32000); 
	//			ReportErrorMessage("Could Not Create Power Flex 40 Port Thread, using uC Board Interlocks", cWriteToLog, 0); 
	//		}
	//		else
	//		{
	//			ASSERT_VALID(vGlobalPowerFlex40);

	//			vGlobalPowerFlex40->vLocalSystemData = &vSystemData;
	//			vGlobalPowerFlex40->vLocalConfigurationData = vConfigurationData;

	//			vGlobalPowerFlex40->vComPortNumber = 2;	// default = 2;

	//			vGlobalPowerFlex40->SetBaudRate(CBR_9600);

	//			vGlobalPowerFlex40->OpenPort(vGlobalPowerFlex40->vComPortNumber);

	//			if (vGlobalPowerFlex40->vPortOpen)
	//			{
	//				//TempAfinity = (AFFINITYMASK_POWER_MONITOR & vGlobalSystemAffinityMask);
	//				vGlobalPortHereOK[vGlobalPowerFlex40->vComPortNumber] = vGlobalPowerFlex40->vComPortNumber;
	//			}
	//			else
	//			{
	//				CString TempCString;
	//				TempCString.Format("Could Not Open Serial Port %d to Conveyor Controller", vGlobalPowerFlex40->vComPortNumber);
	//				ReportErrorMessage(TempCString, cEMailInspx,32000); 
	//			}
	//			if (vConfigurationData->vSimulateLightControlBoard)
	//				vGlobalPowerFlex40->vNoCommunications = false;
	//		}
	//}
		
		if (vConfigurationData->vAutoImproveEnabled)
		{
			//if (!vConfigurationData->vAutoImproveReduceThresholdFactor)
			//	vConfigurationData->vAutoImproveReduceThresholdFactor = 5;
			if (vConfigurationData->vAutoImproveNumberToAddToLearn < 500)
				vConfigurationData->vAutoImproveNumberToAddToLearn = 4000;
		}
			
		vSystemData.LoadUserList();
		//vGlobalMouseMoveCounter = 0;
	}

	SetDlgItemText(IDC_DensityCompensation, _T(""));
	SetDlgItemText(IDC_ThresholdReduction, _T(""));
	SetDlgItemText(IDC_ThresholdIncrease, _T(""));
	
	TempText.LoadString(IDS_NoCurrentProduct);
	SetDlgItemText(IDC_ProductLabel," " + TempText);
	
	m_TestModesActive.ShowWindow(SW_HIDE);

	//initialize current system data
 	SetDlgItemText(IDC_StatusLine, _T(""));
	TempText.LoadString(IDS_VersionDisplayString);
	TempText2.LoadString(IDS_PleaseWait);
	TempText = "\n\n" + TempText2 + "\n\n" + TempText;
	TempText2.LoadString(IDS_StartingSystem);
	TempText = TempText2 + TempText;
	SetDlgItemText(IDC_BackGroundStatic,TempText);
	vLastTimeReadEncoderRate = 0;
	vThisTimeReadEncoderRate = 0;

	ReadBIOSVersionFromRegistry();
	vSystemData.vChangedSizeOfProduct = false;
  vSystemData.vChangedSizeOfProductCheckDensityROI = 0;	
	bool TempSuccess = false;
	if ((PathFileExists(_T("C:\\Program Files\\Elo Touch Solutions"))) && (vGlobalDisplaySizeH > 640))
		TempSuccess = true;
	if ((PathFileExists(_T("C:\\Program Files\\Elo TouchSystems"))) && (vGlobalDisplaySizeH > 640))
		TempSuccess = true;

	if (PathFileExists((_T("C:\\Program Files\\eGalax Touch"))) && (vGlobalDisplaySizeH > 640))
		TempSuccess = true;

	if (PathFileExists((_T("C:\\Program Files\\eGalaxTouch"))) && (vGlobalDisplaySizeH > 640))
		TempSuccess = true;

	if (TempSuccess == true)
		vSystemData.vTouchScreen = true;

	m_ChatMessage.SetWindowPos(NULL,0,459,634,15,SWP_NOZORDER);

	//done in SetupProduct now SetupBulkModeAndMainMenuScreen();  


	//int TempCount = vLocalCWndCollection.GetCount(); //remove last items so dont get set again as setup called again
	//if (TempCount > 5)
	//	vLocalCWndCollection.RemoveAt(TempCount - 5, 4);

	//if ((vSystemData.vGlobalMonitorSizeX >= 1024) && (vSystemData.vGlobalMonitorSizeY >= 768))
	//{
	//	if ((vSystemData.vGlobalMonitorSizeX >= 1280) && (vSystemData.vGlobalMonitorSizeY >= 1024))
	//	{
	//		vInspxGraphicBlueBigger.LoadBitmap(IDB_InspxGraphicBlue4xBigger);
	//		vInspxGraphicRedBigger.LoadBitmap(IDB_InspxGraphicRed4xBigger);
	//		vInspxGraphicYellowBigger.LoadBitmap(IDB_InspxGraphicYellow4xBigger);
	//	}
	//	else
	//	{
	//		vInspxGraphicBlueBigger.LoadBitmap(IDB_InspxGraphicBlue2xBigger);
	//		vInspxGraphicRedBigger.LoadBitmap(IDB_InspxGraphicRed2xBigger);
	//		vInspxGraphicYellowBigger.LoadBitmap(IDB_InspxGraphicYellow2xBigger);
	//	}
	//}

	//Operations Guardian.  If enabled, connect to Internet Server
#ifdef CompileInHTTPClientOperationsGuardian
	if (vConfigurationData)
	if (vConfigurationData->vEnableOperationsGuardian)
		CreateOGServerSendMessageThread();
#else
	if (vConfigurationData)
		vConfigurationData->vEnableOperationsGuardian = false;
#endif
	return true;  // return true  unless you set the focus to a control
}

bool CScanTracDlg::ReadInConfigurationDataFromFile(bool TempReadBackup)
{
	bool TempOK = true;
	CString TempThisErrorText = "";
	char TempChars[500];
	_getcwd(TempChars,500);
	vGlobalCurrentDirectory = TempChars;
	wchar_t TempEndString = vGlobalCurrentDirectory.GetAt(vGlobalCurrentDirectory.GetLength()-1);
	if (TempEndString != '\\')
		vGlobalCurrentDirectory = vGlobalCurrentDirectory + "\\";
	bool TempUsingLocalSetupDataFile = false;
	//if (!ReadConfigurationDataFromINIFile())
	{
		CArchive *TempProductArchive = NULL; 
		CFile *PTempProductFile = NULL;
		WIN32_FIND_DATA FindFileData;
		CFileException TempFileException;

		//see if a local setup file exists, if it does, use it and notify user, otherwise use common
		CString TempProductFileNameString = "Products.STR";
		if (TempReadBackup == true)
		{
			TempProductFileNameString = "ProductsB.STR";
		}

		LPTSTR TempProductFileName = TempProductFileNameString.GetBuffer(TempProductFileNameString.GetLength());
		HANDLE hFind = FindFirstFile(TempProductFileName, &FindFileData);
		if (hFind == INVALID_HANDLE_VALUE)
			//if did not find Products.STR in current directory, 
			//look in c:\ScanTracSetupData
		{
			//10/8/2009
//#ifdef _DEBUG  //alex wanted only in debug mode, but now want for File Write Filter to protect ScanTrac Folder
			TempProductFileNameString = cSetupDataDirectory;
			if (TempReadBackup == false)
				TempProductFileNameString = TempProductFileNameString + "Products.STR";
			else
				TempProductFileNameString = TempProductFileNameString + "ProductsB.STR";

			TempProductFileName = TempProductFileNameString.
				GetBuffer(TempProductFileNameString.GetLength());
			hFind = FindFirstFile(TempProductFileName, &FindFileData);
			vGlobalCurrentDirectory = cSetupDataDirectory;
//#endif
		}
		else
		{ //found products.str in current directory with ScanTrac.EXE
			TempUsingLocalSetupDataFile = true;
			/*
			CNoticeDialog TempNoticeDialog;
			TempText.LoadString(IDS_UsingLocalSetupDataFile);
			TempNoticeDialog.vNoticeText = TempText;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.vAutoClose = 4000;
			TempNoticeDialog.DoModal();
			*/
		}
		//did not find products.STR anywhere, so warn operator
		if (hFind == INVALID_HANDLE_VALUE) 
		{
			if (TempReadBackup == true)
			{
				//did not find ProductsB.STR in correct folder
				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\nConfiguration file could not be read.\nCall Service";
				TempNoticeDialog.vType = cErrorMessage;
				TempNoticeDialog.DoModal();
				TempOK = false;
				ReportErrorMessage("Error-Configuration file could not be read 7 (not found): ProductsB.STR", cWriteToLog, 0);
				/*
				TempText.LoadString(IDS_UsingLocalSetupDataFile);
				TempText = "Product Setup File: " + TempProductFileNameString + 
					" Not Found\nUsing default setup values\nThere are no products\nThere are no system inputs\nAbort Now Recomended";

				CYesNoDialog TempYesNoDialog;
				TempYesNoDialog.vNoticeText = TempText;
				TempYesNoDialog.vQuestionType = cConfirmAbandon;
				TempYesNoDialog.vYesButtonText = "Abort";
				TempYesNoDialog.vNoButtonText = "Continue";
				int TempResult = TempYesNoDialog.DoModal();
				TempText = "";
				//if user said OK
				if (TempResult == IDOK)
				{
					TempOK = false;
					ReportErrorMessage("ProductsB.STR not found 1. User is Aborting.",cEMailInspx, 32000);
				}
				else
					ReportErrorMessage("ProductsB.STR not found 1. User is not Aborting.",cEMailInspx, 32000);
				*/
			}
			else
			{
				ReportErrorMessage("Products.STR not found 7, trying Backup",cEMailInspx,32000);
				TempText = "";
				TempOK = false;
			}
		}
		else
		{  //found products.STR
			FindClose(hFind);
			CString TempString1 = cSetupDataDirectory;
			TempString1.Delete(TempString1.GetLength() -1, 1);
			LPTSTR TempString = TempString1.GetBuffer(TempString1.GetLength());
			CFileStatus TempFileStatus;
			if (!(CFile::GetStatus(TempString, TempFileStatus)))
			//if (!TempUsingLocalSetupDataFile)
				CreateDirectory(cSetupDataDirectory,NULL);

			bool TempArchiveReadOK = false;
			TRY
			{
				CFile TempProductFile(TempProductFileName,CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone);
				TRY
				{
					//open configuration file and read in system configuration
					//and product data
					PTempProductFile = &TempProductFile;
					if (ThereIsEnoughMemory(sizeof(CArchive), "Archive 2"))
					{
						TempProductArchive = new CArchive(PTempProductFile,CArchive::load);
						if (TempProductArchive)
						if (ThereIsEnoughMemory(sizeof(CProduct), "New Product for Read Config"))
						{
							CObject *TempProductPointer = new CProduct;
							CFile *TempArchiveFilePointer = TempProductArchive->GetFile();

							//get system configuration class type to read in data
							if (TempProductPointer)
							if (ThereIsEnoughMemory(sizeof(CSystemConfigurationData), "Configuration Data"))
							{
								CSystemConfigurationData *TempConfigData = new (CSystemConfigurationData);
								CRuntimeClass *TempConfigDataRunTimeClass = TempConfigData->GetRuntimeClass();

								//Read in system configuration data
								vReadInConfigurationDataPointer = TempProductArchive->ReadObject(TempConfigDataRunTimeClass);
								delete TempConfigData;
								//delete TempConfigDataRunTimeClass;

								//set our configuration data pointer to configuration data just read
								vConfigurationData = (CSystemConfigurationData*)vReadInConfigurationDataPointer;
								vGlobalConfigurationData = vConfigurationData;

								if ((vConfigurationData) && (vConfigurationData->vScanTracConfigurationFileType != 0x00))
								{
									CString TempString = " ";
									TempString = " ";
									if (vConfigurationData->vScanTracConfigurationFileType == cTopDownScanTrac)
										TempString = "\n\nConfiguration file for a Top Down ScanTrac";
									else
									if (vConfigurationData->vScanTracConfigurationFileType == cMultiImageScanTrac)
										TempString = "\n\nConfiguration file for a Dual Beam ScanTrac";
									else
									if (vConfigurationData->vScanTracConfigurationFileType == cCrescendoScanTrac)
										TempString = "\n\nConfiguration file for a Crescendo ScanTrac";
									else
										TempString = "\n\nConfiguration file ScanTrac type not defined: " +
										dtoa(vConfigurationData->vScanTracConfigurationFileType,0) + ".  \nProducts.STR probably corrupted.  \nCall Service.";
									
									vConfigurationData = NULL;
									TempThisErrorText = TempString;
									TempThisErrorText.Remove('\n');

									if (TempReadBackup == true)
									{
										//wrong ScanTrac Type in file
										CNoticeDialog TempNoticeDialog;
										TempNoticeDialog.vNoticeText = TempString;
										TempNoticeDialog.vType = cErrorMessage;
										TempNoticeDialog.DoModal();
										TempArchiveReadOK = true;
										TempOK = false;
										ReportErrorMessage("Error-Configuration file could not be read 9 (wrong ScanTrac Type): ProductsB.STR", cWriteToLog, 0);
										/*
										TempString = TempString + "\nAbort Now Recomended!";

										CYesNoDialog TempYesNoDialog;
										TempYesNoDialog.vNoticeText = TempString;
										TempYesNoDialog.vQuestionType = cConfirmAbandon;
										TempYesNoDialog.vYesButtonText = "Abort";
										TempYesNoDialog.vNoButtonText = "Continue";
										int TempResult = TempYesNoDialog.DoModal();
										//if user said OK
										if (TempResult == IDOK)
										{
											TempOK = false;
											ReportErrorMessage(TempThisErrorText + " ProductsB.STR, User is Aborting.",cEMailInspx,32000);
										}
										else
											ReportErrorMessage(TempThisErrorText + " ProductsB.STR, User is Not Aborting.",cEMailInspx,32000);
										TempArchiveReadOK = true;
										*/
									}
									else
									{
										ReportErrorMessage(TempThisErrorText + "9 Products.STR, trying Backup",cEMailInspx,32000);
										TempOK = false;
									}
								}
								else
								if (!vConfigurationData) //I don't expect to ever get here
								{
									if (TempReadBackup == true)
									{
										CNoticeDialog TempNoticeDialog;
										TempNoticeDialog.vNoticeText = "\n\nConfiguration file could not be read.\nCall Service";
										TempNoticeDialog.vType = cErrorMessage;
										TempNoticeDialog.DoModal();
										TempArchiveReadOK = true;
										TempOK = false;
										ReportErrorMessage("Error-Configuration file could not be read 1: ProductsB.STR", cWriteToLog, 0);
										/*
										CYesNoDialog TempYesNoDialog;
										TempYesNoDialog.vNoticeText = 
											"\n\nConfiguration file could not be read. \nUsing Default Setups.\nAbort Now Recomended!";
										TempYesNoDialog.vQuestionType = cConfirmAbandon;
										TempYesNoDialog.vYesButtonText = "Abort";
										TempYesNoDialog.vNoButtonText = "Continue";
										int TempResult = TempYesNoDialog.DoModal();
										//if user said OK
										if (TempResult == IDOK)
										{
											TempOK = false;
											ReportErrorMessage("Configuration file could not be read. ProductsB.STR, User is Aborting",cEMailInspx,32000);
										}
										else
											ReportErrorMessage("Configuration file could not be read. ProductsB.STR, User is Not Aborting.",cEMailInspx,32000);
										TempArchiveReadOK = true;
										*/
									}
									else
									{
										ReportErrorMessage("Configuration file could not be read 1. Products.STR, trying Backup",cEMailInspx, 32000);
										TempOK = false;
									}
								}

								if (TempOK)
								{
									if (vConfigurationData)
									{
										vGlobalShowMouseCursor = vConfigurationData->vShowMouseCursor;
										vGlobalDemoMode = vConfigurationData->vDemoMode;
										//vGlobalUseMetric = vConfigurationData->vUseMetric;
									}

									//create PCDig class type
									vSystemData.vITIPCDig = new CITIPCDig;
									if (vSystemData.vITIPCDig)
									{
										vSystemData.vITIPCDig->vUsingLocalSetupDataFile = TempUsingLocalSetupDataFile;
										vGlobalITIPCDig = vSystemData.vITIPCDig;
									}

									if (vConfigurationData)
									{
										vSystemData.vITIPCDig->vNumberOfLastRejectImages = vConfigurationData->vNumberOfLastRejectImages;
										vSystemData.vITIPCDig->vShowOnlyRealImages = vConfigurationData->vShowOnlyRealImages;
									}

									//Read in product class type info to verify correct
									CRuntimeClass *TempProductRunTimeClass = TempProductPointer->GetRuntimeClass();
									CRuntimeClass *Temp1ProductRunTimeClass = TempProductArchive->ReadClass(TempProductRunTimeClass);

									//loop through reading product data until get an exception 
									//and set flag to end reading
									bool TempEOF = false;
									while(!TempEOF)
									{
										try
										{
											//Read in one product data object
											TempProductPointer = TempProductArchive->ReadObject(TempProductRunTimeClass);
											//throw( CFileException, CArchiveException, CMemoryException );
											//if the read fails, it will throw and exception which 
											//will be caught below

											//if the data read was the right kind, call the required
											//set methods, then add to the product collection
											if (TempProductPointer == NULL)
												TempEOF = true;
											else
											if (TempProductPointer->IsKindOf(TempProductRunTimeClass))
											{
												AddProduct(((CProduct *)TempProductPointer));
												TempArchiveReadOK = true;
											}
											else
												TempEOF = true;
										}
										catch(CFileException)
										{
											//got an exception on reading product, so end of file
											TempEOF = true;
										}
									}
								}
							}
						}
						if (TempProductArchive)
						{
							delete TempProductArchive;
							TempProductArchive = NULL;
						}
					}
				}
				CATCH(CFileException, TempFileException)
				{
					TempOK = false;
					if (TempFileException->m_cause == 2)
					{
						TempThisErrorText = "Product Configuration File Not Found\nUsing default setup values\nThere are no products\nThere are no system inputs\nAbort Now Recommended!";
						if (TempReadBackup == true)
						{
							CNoticeDialog TempNoticeDialog;
							TempNoticeDialog.vNoticeText = "\n\nConfiguration file could not be read.\nCall Service";
							TempNoticeDialog.vType = cErrorMessage;
							TempNoticeDialog.DoModal();
							TempArchiveReadOK = true;
							TempOK = false;
							ReportErrorMessage("Error-Configuration file could not be read 2: ProductsB.STR", cWriteToLog, 0);
							/*
							CYesNoDialog TempYesNoDialog;
							TempYesNoDialog.vNoticeText = TempThisErrorText;
							TempYesNoDialog.vQuestionType = cConfirmAbandon;
							TempYesNoDialog.vYesButtonText = "Abort";
							TempYesNoDialog.vNoButtonText = "Continue";
							int TempResult = TempYesNoDialog.DoModal();
							//if user said OK
							if (TempResult == IDOK)
							{
								TempOK = false;
								ReportErrorMessage("ProductsB.STR not found 2, User is Aborting",cEMailInspx, 32000);
							}
							else
								ReportErrorMessage("ProductsB.STR not found 2, User is Not Aborting.",cEMailInspx, 32000);
							TempArchiveReadOK = true;
							*/
						}
						else
						{
							TempThisErrorText.Replace(_T("\n"),_T(" "));
							ReportErrorMessage("Products.STR not found 2, trying Backup", cEMailInspx, 32000);
						}
					}
					else
					{
						TempThisErrorText = "Product Configuration File Not Found\nUsing default setup values\nThere are no products\nThere are no system inputs\nAbort Now Recommended!";
						if (TempReadBackup == true)
						{
							CNoticeDialog TempNoticeDialog;
							TempNoticeDialog.vNoticeText = "\n\nConfiguration file could not be read.\nCall Service";
							TempNoticeDialog.vType = cErrorMessage;
							TempNoticeDialog.DoModal();
							TempArchiveReadOK = true;
							TempOK = false;
							ReportErrorMessage("Error-Configuration file could not be read 3: ProductsB.STR", cWriteToLog, 0);
						/*	
							CYesNoDialog TempYesNoDialog;
							TempYesNoDialog.vNoticeText = TempThisErrorText;
							TempYesNoDialog.vQuestionType = cConfirmAbandon;
							TempYesNoDialog.vYesButtonText = "Abort";
							TempYesNoDialog.vNoButtonText = "Continue";
							int TempResult = TempYesNoDialog.DoModal();
							//if user said OK
							if (TempResult == IDOK)
							{
								TempOK = false;
								ReportErrorMessage("Error 3 in ProductsB.STR, User is Aborting", cEMailInspx, 32000);
							}
							else
								ReportErrorMessage("Error 3 in ProductsB.STR, User is Not Aborting.",cEMailInspx, 32000);
							TempArchiveReadOK = true;
							*/
						}
						else
						{
							ReportErrorMessage("Error 3 in Products.STR, trying Backup", cEMailInspx, 32000);
						}
					}
					 #ifdef _DEBUG
							afxDump << "Configuration file could not be opened " << TempFileException->m_cause << "\n";
					 #endif
				}
				END_CATCH
			}
			CATCH_ALL(TempException)
			{
				wchar_t TempChars[255];
				TempException->GetErrorMessage(TempChars,255,NULL);
				CString TempErrorString(TempChars);
				if ((TempErrorString == "An attempt was made to access an unnamed file past its end.") || (TempErrorString == "Attempted to access an unnamed file past its end."))
					TempArchiveReadOK = true;
				else
				{
					if (TempReadBackup == true)
					{
						//file corrupted and not correct
						CNoticeDialog TempNoticeDialog;
						TempNoticeDialog.vNoticeText = "\n\nConfiguration file could not be read.\nCall Service";
						TempNoticeDialog.vType = cErrorMessage;
						TempNoticeDialog.DoModal();
						TempArchiveReadOK = true;
						TempOK = false;
						ReportErrorMessage("Error-Configuration file could not be read 4 (corrupted): ProductsB.STR", cWriteToLog, 0);
						/*
						TempThisErrorText = "Product Configuration File Not Found\nUsing default setup values\nThere are no products\nThere are no system inputs\nAbort Now Recommended!";
						CYesNoDialog TempYesNoDialog;
						TempYesNoDialog.vNoticeText = TempThisErrorText;
						TempYesNoDialog.vQuestionType = cConfirmAbandon;
						TempYesNoDialog.vYesButtonText = "Abort";
						TempYesNoDialog.vNoButtonText = "Continue";
						int TempResult = TempYesNoDialog.DoModal();
						//if user said OK
						if (TempResult == IDOK)
						{
							TempOK = false;
							ReportErrorMessage("Error 1 in ProductsB.STR, User is Aborting",cEMailInspx, 32000);
						}
						else
						{
							TempOK = false;
							ReportErrorMessage("Error 1 in ProductsB.STR, User is Not Aborting.",cEMailInspx, 32000);
						}
						TempArchiveReadOK = true;
						*/
					}
					else
					{
						ReportErrorMessage("Error 4 in Products.STR, trying Backup", cEMailInspx, 32000);
						TempOK = false;
					}
				}
			 #ifdef _DEBUG
					afxDump << "Finished Reading in Configuration file "  << "\n";
			 #endif
			}
			END_CATCH_ALL
			if (TempOK)
			{
				if (TempProductArchive)
				{
					//if (PTempProductFile)
					//	PTempProductFile->Close();
					//TempProductArchive->Close();
					//delete TempProductArchive;
				}
				if (!TempArchiveReadOK)
				{
					TempOK = false;
					if (TempReadBackup == true)
					{
						CNoticeDialog TempNoticeDialog;
						TempNoticeDialog.vNoticeText = "\n\nConfiguration file could not be read.\nCall Service";
						TempNoticeDialog.vType = cErrorMessage;
						TempNoticeDialog.DoModal();
						TempArchiveReadOK = true;
						TempOK = false;
						ReportErrorMessage("Error-Configuration file could not be read 5: ProductsB.STR", cWriteToLog, 0);
					}
					else
						ReportErrorMessage("Error 5 in Products.STR, trying Backup", cEMailInspx, 32000);
				}
		#ifdef ScanTracDemo
				if (vConfigurationData)
				{
					vConfigurationData->vSimulateLightControlBoard = true;
					vConfigurationData->vDemoMode = true;
					vSystemData.vITIPCDig->vShowOnlyRealImages = false;
					vConfigurationData->vSimulateLightControlBoard = true;
					vSystemData.vFPGASimulateEncoderRate = 900; //1500 hertz is 
					vSystemData.vSimulateContainersRate = 800;  //changed to 960 cpm for demo
					vConfigurationData->vAutoXRaySourceOffEnabled = 2;
				}
		#endif
				if (vConfigurationData)
				for (BYTE TempLoop = 0; TempLoop < cMaximumNumberOfDetectors12; TempLoop++)
				{
					vSystemData.vADCDetectorOffset[TempLoop] = vConfigurationData->vADCDetectorOffset[TempLoop];
					vSystemData.vDACDetectorOffset[TempLoop] = vConfigurationData->vDACDetectorOffset[TempLoop];
				}
				if (!vConfigurationData)
				{
					if (TempReadBackup == true)
					{
						//zero length configuration file ProductsB.STR
						CNoticeDialog TempNoticeDialog;
						TempNoticeDialog.vNoticeText = "\n\nConfiguration file could not be read.\nCall Service";
						TempNoticeDialog.vType = cErrorMessage;
						TempNoticeDialog.DoModal();
						TempArchiveReadOK = true;
						TempOK = false;
						ReportErrorMessage("Error-Configuration file could not be read 6 (zero length): ProductsB.STR", cWriteToLog, 0);
						/*
						TempThisErrorText = "Product Configuration File Not Found\nUsing default setup values\nThere are no products\nThere are no system inputs\nAbort Now Recommended!";
						CYesNoDialog TempYesNoDialog;
						TempYesNoDialog.vNoticeText = TempThisErrorText;
						TempYesNoDialog.vQuestionType = cConfirmAbandon;
						TempYesNoDialog.vYesButtonText = "Abort";
						TempYesNoDialog.vNoButtonText = "Continue";
						int TempResult = TempYesNoDialog.DoModal();
						//if user said OK
						if (TempResult == IDOK)
						{
							TempOK = false;
							ReportErrorMessage("Error 2 in ProductsB.STR, User is Aborting",cEMailInspx, 32000);
						}
						else
							ReportErrorMessage("Error 2 in ProductsB.STR, User is Not Aborting.",cEMailInspx, 32000);
						TempArchiveReadOK = true;
						*/
					}
					else
					{
						ReportErrorMessage("Error 6 in Products.STR, trying Backup", cEMailInspx, 32000);
						TempOK = false;
					}
				}
				if (vConfigurationData)
				{
					if (vConfigurationData->vDemoMode)
					{
						vSystemData.vFPGAMajorVersionNumber = 2;
						vSystemData.vFPGAMinorVersionNumber = 3;
						vSystemData.vFPGASelfTest = 255;
						vSystemData.vuCMainLoopCounter = 255;
						vSystemData.vuCMajorVersionNumber = 1;
						vSystemData.vuCMinorVersionNumber = 2;
						vSystemData.vuCLEDGYR = 7;
					}

					if ((vConfigurationData) && (vConfigurationData->vSimulateLightControlBoard))
					{
						if (vGlobalFPGAVersion10Point0OrHigher)
						{
							vSystemData.vTemperatureSurface = cuCNormalVoltageValue;
							vSystemData.vTemperatureLiquid = cuCNormalVoltageValue;
							vSystemData.vTemperatureAirInside = cuCNormalVoltageValue;
							vSystemData.vTemperatureuC = cuCNormalVoltageValue;
							vSystemData.vTemperatureAirOutside = cuCNormalVoltageValue;  
							//vSystemData.vCoolantPressure = cuCNormalVoltageValue;  
						}
						else
						{
							vSystemData.vTemperatureSurface = 193;
							vSystemData.vTemperatureLiquid = 193;
							vSystemData.vTemperatureAirInside = 193;
							vSystemData.vTemperatureuC = 193;
							vSystemData.vTemperatureAirOutside = 193;  
							//vSystemData.vCoolantPressure = 193; 
						}
						vSystemData.vRawInterlockInput = 0xFF77;
					}
					vSystemData.vSourceInterLocks = vSystemData.vRawInterlockInput;
					//added for KJH Office Testing
					if (vConfigurationData->vHVPSType == cXLFHVPS)
						vSystemData.vSourceInterLocks = vSystemData.vSourceInterLocks | 0x0020;  //Spellman XLF so set interlock OK

					SetUsePipeFlowInput(vConfigurationData->vUsePipeFlowInput);
					SendConveyorOnOffToUController(false);

					if (vConfigurationData->vSimulateLightControlBoard) //must comment out to test monoblock in the office
						vSystemData.vSourceInterLocks = 0xFFFF;
				}
			}
#ifdef CompileInHTTPClientOperationsGuardian
		if (vConfigurationData)
			vGlobalOperationsGuardianServer = vConfigurationData->vOperationsGuardianServer;
#endif
		} //end of found products.str
	}
	return TempOK;
}
// If you add a minimize button to your dialog, you will need the code below
//  to draw the icon.  For MFC applications using the document/view model,
//  this is automatically done for you by the framework.

void CScanTracDlg::OnPaint() 
{
	/*
	if (IsIconic())
	{
		CPaintDC dc(this); // device context for painting

		SendMessage(WM_ICONERASEBKGND, (WPARAM) dc.GetSafeHdc(), 0);

		// Center icon in client rectangle
		int cxIcon = GetSystemMetrics(SM_CXICON);
		int cyIcon = GetSystemMetrics(SM_CYICON);
		CRect rect;
		GetClientRect(&rect);
		int x = (rect.Width() - cxIcon + 1) / 2;
		int y = (rect.Height() - cyIcon + 1) / 2;

		// Draw the icon
		dc.DrawIcon(x, y, m_hIcon);
	}
	else
	{
	*/
	CPaintDC dc(this); // device context for painting
	
	
		// TODO: Add your message handler code here
	if (IsIconic())
		ReportErrorMessage("Error-Program is iconic",cEMailInspx,32000);
	else
	if (vSystemData.vMainDisplayMode == cMainDisplayImage)
	{
		if (vSystemData.vITIPCDig->vMainImageDisplayBuffer)
		if ((dc.m_ps.rcPaint.top <= vSystemData.vITIPCDig->vMainDisplayImageSizeY +
			vSystemData.vITIPCDig->vMainDisplayImageOffsetY) &&
			(dc.m_ps.rcPaint.bottom >= vSystemData.vITIPCDig->vMainDisplayImageOffsetY) &&
			(dc.m_ps.rcPaint.left <= vSystemData.vITIPCDig->vMainDisplayImageSizeX +
			vSystemData.vITIPCDig->vMainDisplayImageOffsetX) &&
			(dc.m_ps.rcPaint.right >= vSystemData.vITIPCDig->vMainDisplayImageOffsetX))
		{
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("STD-OnPaintMainImage-Start",cDebugMessage);
			UpdateRejectReasonOnScreen();

			//initialize bitmap to write image to the screen with one system call
			CDC TempCompatableDeviceContext;
			TempCompatableDeviceContext.CreateCompatibleDC(&dc);
			HBITMAP TempBitmapOfReject = CreateCompatibleBitmap ( dc, vSystemData.vITIPCDig->vMainDisplayImageSizeX, vSystemData.vITIPCDig->vMainDisplayImageSizeY );
			BITMAPINFO TempBitmapInfo = {0};		
			TempBitmapInfo.bmiHeader.biSize = sizeof(TempBitmapInfo.bmiHeader);
			int TempBitmapColorArraySize = vSystemData.vITIPCDig->vMainDisplayImageSizeX * vSystemData.vITIPCDig->vMainDisplayImageSizeY * 4;
			int TempIterator = TempBitmapColorArraySize;
			
			if (0 == GetDIBits(dc, TempBitmapOfReject, 0, 0, NULL, &TempBitmapInfo, DIB_RGB_COLORS))  //get just bitmap info header
			{
				int r = 0;
			}
			TempBitmapInfo.bmiHeader.biBitCount = 32;  
			TempBitmapInfo.bmiHeader.biCompression = BI_RGB;  

			BYTE* TempBitmapColorArray = new BYTE[TempBitmapColorArraySize];
			if (TempBitmapColorArray)
			{
				GetDIBits(dc, TempBitmapOfReject, 0, TempBitmapInfo.bmiHeader.biHeight, (LPVOID)TempBitmapColorArray, &TempBitmapInfo, DIB_RGB_COLORS);
				//initialized bitmap

				RECT TempRectangle;
				TempRectangle.left = vSystemData.vITIPCDig->vMainDisplayImageOffsetX - 1;
				TempRectangle.top = vSystemData.vITIPCDig->vMainDisplayImageOffsetY - 1;
				TempRectangle.right = vSystemData.vITIPCDig->vMainDisplayImageOffsetX +
					vSystemData.vITIPCDig->vMainDisplayImageSizeX + 1;
				TempRectangle.bottom = vSystemData.vITIPCDig->vMainDisplayImageOffsetY +
					vSystemData.vITIPCDig->vMainDisplayImageSizeY + 1;
				CBrush TempBrush(cWhite);
				dc.FrameRect(&TempRectangle, &TempBrush);
				TempRectangle.left = vSystemData.vITIPCDig->vMainDisplayImageOffsetX - 2;
				TempRectangle.top = vSystemData.vITIPCDig->vMainDisplayImageOffsetY - 2;
				TempRectangle.right = vSystemData.vITIPCDig->vMainDisplayImageOffsetX +
					vSystemData.vITIPCDig->vMainDisplayImageSizeX + 2;
				TempRectangle.bottom = vSystemData.vITIPCDig->vMainDisplayImageOffsetY + vSystemData.vITIPCDig->vMainDisplayImageSizeY + 2;
				dc.FrameRect(&TempRectangle, &TempBrush);
				BYTE *TempDataPoint;
				TempDataPoint = vSystemData.vITIPCDig->vMainImageDisplayBuffer;

				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Main Paint Image", cDebugMessage);
				Sleep(1);

				bool TempCanShowInspectionInRed = (((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu) && (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectThreshold)));

				//don't have an image so may show gray patter with red inspx logo on top
				if (((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu) && (!vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vTop)) || (!vGlobalCurrentProduct))
					TempCanShowInspectionInRed = true;
				else
				if (TempCanShowInspectionInRed)
				{
					BYTE TempInspectionNumber = vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectInspection;
					if (TempInspectionNumber >= vGlobalCurrentProduct->vNumberOfInspections)
						TempCanShowInspectionInRed = false;
					else
					if (vGlobalCurrentProduct->vInspection[TempInspectionNumber])
					if ((vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cDensityInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cCheckWeighInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cMissingLidInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cUnderfillByWeightInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cOverfillByWeightInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cUnderfillInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cOverfillInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cStandardDeviationInspection))
							TempCanShowInspectionInRed = false;
				}

				if ((vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectInRedBox) || (vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectsInRedBoxes)) //if not showing red on all images, then don't show on this one as not correct image
					TempCanShowInspectionInRed = true;

				if ((vSystemData.vITIPCDig->vMainDisplayIsDefaultImage) && (TempBitmapColorArray))
				{//have average image on screen, so anything over 240 show in yellow
					TempIterator = TempBitmapColorArraySize - vSystemData.vITIPCDig->vMainDisplayImageSizeX * 4;
					for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vMainDisplayImageSizeY; TempLoopY++)
					{
						for (WORD TempLoopX = 0; TempLoopX < vSystemData.vITIPCDig->vMainDisplayImageSizeX; TempLoopX++)
						{
							if (TempIterator + 3 >= TempBitmapColorArraySize)
								ReportErrorMessage("Main Menu Image Write Index Error A: " + dtoa(TempIterator, 0), cEMailInspx, 32000);
							else
								if (*TempDataPoint > 240)  //white pixel
								{
									if ((vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX <= dc.m_ps.rcPaint.right) &&
										(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX >= dc.m_ps.rcPaint.left) &&
										(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY >= dc.m_ps.rcPaint.top) &&
										(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY <= dc.m_ps.rcPaint.bottom))
									{
										TempBitmapColorArray[TempIterator] = 0;//blUE
										TempBitmapColorArray[TempIterator + 1] = 255;//green
										TempBitmapColorArray[TempIterator + 2] = 255;//red
										TempBitmapColorArray[TempIterator + 3] = 255;//alpha
										//dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
										//vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, 
										//RGB(0xFF,0xFF,0)); //draw pixel in yellow
									}
								}
								else
								{
									if ((vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX <= dc.m_ps.rcPaint.right) &&
										(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX >= dc.m_ps.rcPaint.left) &&
										(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY >= dc.m_ps.rcPaint.top) &&
										(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY <= dc.m_ps.rcPaint.bottom))
									{
										TempBitmapColorArray[TempIterator] = *TempDataPoint;//blUE
										TempBitmapColorArray[TempIterator + 1] = *TempDataPoint;//green
										TempBitmapColorArray[TempIterator + 2] = *TempDataPoint;//red
										TempBitmapColorArray[TempIterator + 3] = 255;//alpha
										//dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
										//	vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, 
										//	RGB(*TempDataPoint,*TempDataPoint,*TempDataPoint)); //draw pixel in intensity
									}
								}
							TempDataPoint++;
							TempIterator = TempIterator + 4;
						}
						TempIterator = TempIterator - vSystemData.vITIPCDig->vMainDisplayImageSizeX * 8;
					}
				}
				else
					//enum {cDefectsInNoColor, cDefectsInPseudoColor, cDefectsInRed, cDefectInRedBox, cDefectsInRedBoxes};
				if ((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu) && (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vTop) &&
					(vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectsInPseudoColor) && (TempCanShowInspectionInRed))
				{//Draw PseudoColor image on screen
					BYTE *TempPseudoColorDataPoint = vSystemData.vITIPCDig->vMainImagePseudoColorDisplayBuffer;
					TempIterator = TempBitmapColorArraySize - vSystemData.vITIPCDig->vMainDisplayImageSizeX * 4;
					for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vMainDisplayImageSizeY; TempLoopY++)
					{
						for (WORD TempLoopX = 0; TempLoopX < vSystemData.vITIPCDig->vMainDisplayImageSizeX; TempLoopX++)
						{
							if (TempIterator + 3 >= TempBitmapColorArraySize)
								ReportErrorMessage("Main Menu Image Write Index Error B: " + dtoa(TempIterator, 0), cEMailInspx, 32000);
							else
							if ((vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX <= dc.m_ps.rcPaint.right) &&
								(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX >= dc.m_ps.rcPaint.left) &&
								(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY >= dc.m_ps.rcPaint.top) &&
								(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY <= dc.m_ps.rcPaint.bottom))
							{
								BYTE TempThreshold = 255;
								if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu)
									if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectThreshold)
										TempThreshold = (BYTE)vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectThreshold;

								if (*TempPseudoColorDataPoint < TempThreshold) //Pseudo Color pixel
								{
									BYTE TempAmountPixelBelowThreshold = TempThreshold - *TempPseudoColorDataPoint;

									if (TempAmountPixelBelowThreshold < 16) //blue
									{
										TempBitmapColorArray[TempIterator] = 255 - TempAmountPixelBelowThreshold;//blUE
										TempBitmapColorArray[TempIterator + 1] = 0;//green
										TempBitmapColorArray[TempIterator + 2] = 0;//red
										TempBitmapColorArray[TempIterator + 3] = 255;//alpha
										dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
											vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, cBlue); //draw pixel in blue
									}
									else
									if (TempAmountPixelBelowThreshold < 36) //green
									{
										TempBitmapColorArray[TempIterator] = 0;//blUE
										TempBitmapColorArray[TempIterator + 1] = 255 - TempAmountPixelBelowThreshold;//green
										TempBitmapColorArray[TempIterator + 2] = 0;//red
										TempBitmapColorArray[TempIterator + 3] = 255;//alpha
										//dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
										//	vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, cGreen); //draw pixel in green
									}
									else
									if (TempAmountPixelBelowThreshold < 66) //orange
									{
										TempBitmapColorArray[TempIterator] = 0;//blUE
										TempBitmapColorArray[TempIterator + 1] = 128 - TempAmountPixelBelowThreshold;//green
										TempBitmapColorArray[TempIterator + 2] = 255 - TempAmountPixelBelowThreshold;//red
										TempBitmapColorArray[TempIterator + 3] = 255;//alpha
										//dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
										//	vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, cOrange); //draw pixel in yellow
									}
									else //red
									{
										TempBitmapColorArray[TempIterator] = 0;//blUE
										TempBitmapColorArray[TempIterator + 1] = 0;//green
										TempBitmapColorArray[TempIterator + 2] = 255;//red
										TempBitmapColorArray[TempIterator + 3] = 255;//alpha
										//dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
										//	vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, cRed); //draw pixel in red
									}
								}
								else
								{
									TempBitmapColorArray[TempIterator] = *TempDataPoint;//blUE
									TempBitmapColorArray[TempIterator + 1] = *TempDataPoint;//green
									TempBitmapColorArray[TempIterator + 2] = *TempDataPoint;//red
									TempBitmapColorArray[TempIterator + 3] = 255;//alpha
									//		dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
									//		vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, 
									//	RGB(*TempDataPoint,*TempDataPoint,*TempDataPoint));//draw pixel in intensity
								}
							}
							TempDataPoint++;
							TempPseudoColorDataPoint++;
							TempIterator = TempIterator + 4;
						}
						TempIterator = TempIterator - vSystemData.vITIPCDig->vMainDisplayImageSizeX * 8;
					}
				}
				else
				if (TempCanShowInspectionInRed)
				{//normal image on screen
					TempIterator = TempBitmapColorArraySize - vSystemData.vITIPCDig->vMainDisplayImageSizeX * 4;
					for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vMainDisplayImageSizeY; TempLoopY++)
					{
						for (WORD TempLoopX = 0; TempLoopX < vSystemData.vITIPCDig->vMainDisplayImageSizeX; TempLoopX++)
						{
							if (TempIterator + 3 >= TempBitmapColorArraySize)
								ReportErrorMessage("Main Menu Image Write Index Error C: " + dtoa(TempIterator, 0), cEMailInspx, 32000);
							else
							if (*TempDataPoint == 0) //black pixel
							{
								if ((vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX <= dc.m_ps.rcPaint.right) &&
									(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX >= dc.m_ps.rcPaint.left) &&
									(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY >= dc.m_ps.rcPaint.top) &&
									(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY <= dc.m_ps.rcPaint.bottom))
								{
									TempBitmapColorArray[TempIterator] = 0;//blUE
									TempBitmapColorArray[TempIterator + 1] = 0;//green
									TempBitmapColorArray[TempIterator + 2] = 255;//red
									TempBitmapColorArray[TempIterator + 3] = 255;//alpha
									//dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
									//	vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, 
									//	RGB(0xFF,0,0)); //draw pixel in red
								}
							}
							else
							{
								if ((vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX <= dc.m_ps.rcPaint.right) &&
									(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX >= dc.m_ps.rcPaint.left) &&
									(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY >= dc.m_ps.rcPaint.top) &&
									(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY <= dc.m_ps.rcPaint.bottom))
								{
									TempBitmapColorArray[TempIterator] = *TempDataPoint;//blUE
									TempBitmapColorArray[TempIterator + 1] = *TempDataPoint;//green
									TempBitmapColorArray[TempIterator + 2] = *TempDataPoint;//red
									TempBitmapColorArray[TempIterator + 3] = 255;//alpha
									//dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
									//	vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, 
									//	RGB(*TempDataPoint,*TempDataPoint,*TempDataPoint));//draw pixel in intensity
								}
							}
							TempDataPoint++;
							TempIterator = TempIterator + 4;
						}
						TempIterator = TempIterator - vSystemData.vITIPCDig->vMainDisplayImageSizeX * 8;
					}
				}
				else
				{//normal image on screen, no red
					TempIterator = TempBitmapColorArraySize - vSystemData.vITIPCDig->vMainDisplayImageSizeX * 4;
					for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vMainDisplayImageSizeY; TempLoopY++)
					{
						for (WORD TempLoopX = 0; TempLoopX < vSystemData.vITIPCDig->vMainDisplayImageSizeX; TempLoopX++)
						{
							if (TempIterator + 3 >= TempBitmapColorArraySize)
								ReportErrorMessage("Main Menu Image Write Index Error D: " + dtoa(TempIterator, 0), cEMailInspx, 32000);
							else
							if ((vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX <= dc.m_ps.rcPaint.right) &&
								(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX >= dc.m_ps.rcPaint.left) &&
								(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY >= dc.m_ps.rcPaint.top) &&
								(vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY <= dc.m_ps.rcPaint.bottom))
							{
								TempBitmapColorArray[TempIterator] = *TempDataPoint;//blUE
								TempBitmapColorArray[TempIterator + 1] = *TempDataPoint;//green
								TempBitmapColorArray[TempIterator + 2] = *TempDataPoint;//red
								TempBitmapColorArray[TempIterator + 3] = 255;//alpha
								//dc.SetPixelV(vSystemData.vITIPCDig->vMainDisplayImageOffsetX + TempLoopX,
								//	vSystemData.vITIPCDig->vMainDisplayImageOffsetY + TempLoopY, 
								//	RGB(*TempDataPoint,*TempDataPoint,*TempDataPoint));//draw pixel in intensity
							}
							TempDataPoint++;
							TempIterator = TempIterator + 4;
						}
						TempIterator = TempIterator - vSystemData.vITIPCDig->vMainDisplayImageSizeX * 8;
					}
				}
				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("STD-OP-End", cDebugMessage);

				SetDIBits(dc, TempBitmapOfReject, 0, TempBitmapInfo.bmiHeader.biHeight, (LPVOID)TempBitmapColorArray, &TempBitmapInfo, DIB_RGB_COLORS);
				free(TempBitmapColorArray);
			}

			TempCompatableDeviceContext.SelectObject(TempBitmapOfReject);
			dc.BitBlt(vSystemData.vITIPCDig->vMainDisplayImageOffsetX, vSystemData.vITIPCDig->vMainDisplayImageOffsetY,
				 TempBitmapInfo.bmiHeader.biWidth, TempBitmapInfo.bmiHeader.biHeight, &TempCompatableDeviceContext, 0, 0, SRCCOPY);

			DeleteObject(TempCompatableDeviceContext);
			DeleteObject(TempBitmapOfReject);
		}

		if (vSystemData.vMainDisplayMode == cMainDisplayImage)
		if (vSystemData.vNumberOfSensitivities)
		{
			const WORD cTotalWidth = (WORD) ResizeXCoor(160);
			const WORD cTotalHeight = (WORD) ResizeYCoor(39);
			const WORD cLeft = (WORD) ResizeXCoor(5);
			WORD cBottom = (WORD) ResizeYCoor(460);
			if ((vGlobalDisplaySizeH > 1024) && (vGlobalDisplaySizeV > 678))
				cBottom = cBottom + 8;
			else if ((vGlobalDisplaySizeH > 640) && (vGlobalDisplaySizeV > 480))
				cBottom = cBottom + 4;
			const WORD cTop = (WORD)(cBottom - ResizeYCoor(39));
			const WORD cRight = (WORD) ResizeXCoor(5 + 160);
			WORD TempColumnWidth = (WORD) ResizeXCoor(8);
			WORD TempColumnSpacing = (WORD) ResizeXCoor(10);
			WORD TempWidthUsed = cTotalWidth;
			//Paint sensitivities 
			//blank area on screen
			if (vGlobalCurrentProduct)
			{
				TempWidthUsed = TempColumnSpacing * vSystemData.vNumberOfSensitivities;
				dc.SelectObject(vSystemData.vGreyPen);
			}
			else
				dc.SelectObject(vSystemData.vLightGreyPen);
			WORD TempLeftOffset = (cTotalWidth - TempWidthUsed) / 2;

			for (BYTE TempLoop = 0; TempLoop < cTotalHeight; TempLoop++)
			{
				dc.MoveTo(cLeft + TempLeftOffset - 2, cBottom - TempLoop);
				dc.LineTo(cLeft + TempLeftOffset + TempWidthUsed,  cBottom - TempLoop); //blank out area on screen
			}
				//100% to 75% green
				//75% to 50% yellowd
				//<50% red
			if (vGlobalCurrentProduct)
			if (vSystemData.vNumberOfSensitivities)
			{
				BYTE TempSensitivityDrawing = 0;
				//draw each inspection sensitivity 
				for (BYTE TempLoopInspection = 0; TempLoopInspection < vGlobalCurrentProduct->vNumberOfInspections; TempLoopInspection++)
				if (vGlobalCurrentProduct->vInspection[TempLoopInspection])
				if (vSystemData.vThresholdSensitivities[TempLoopInspection] < 0xFF)
				{
					if (vSystemData.vThresholdSensitivities[TempLoopInspection] >= 61)
						dc.SelectObject(vSystemData.vMediumDarkGreenPen);
					else
					if (vSystemData.vThresholdSensitivities[TempLoopInspection] >= 31)
						dc.SelectObject(vSystemData.vYellowPen);
					else
						dc.SelectObject(vSystemData.vRedPen);

					WORD TempBarHeight = (BYTE)(vSystemData.vThresholdSensitivities[TempLoopInspection] / 2.56);
					if (TempBarHeight < 6) //don't have the bar less than 6 pixels in height so can be easily seen
						TempBarHeight = (BYTE) (6);
					if ((vGlobalCurrentProduct->vInspection[TempLoopInspection]->vThreshold == 0) || (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vThreshold == 255)) //if threshold is zero, make the bar the full height
						TempBarHeight = (BYTE)( INT(100 / 2.56));

					TempBarHeight = (WORD) ResizeYCoor(TempBarHeight);

					for (BYTE TempLoop = 0; TempLoop < TempColumnWidth; TempLoop++)  //draw 4 lines for each inspection bar
					{
						dc.MoveTo(cLeft + TempLeftOffset + (TempColumnSpacing * TempSensitivityDrawing) + TempLoop, cBottom);
						dc.LineTo(cLeft + TempLeftOffset + (TempColumnSpacing * TempSensitivityDrawing) + TempLoop, cBottom - TempBarHeight); //draw average sensitivity
					}
					TempSensitivityDrawing++;
				}
				dc.SelectObject(vSystemData.vBlackPen);
				dc.MoveTo(cLeft + TempLeftOffset -2, cBottom);
				dc.LineTo(cLeft + TempLeftOffset + TempWidthUsed, cBottom);
				dc.LineTo(cLeft + TempLeftOffset + TempWidthUsed, cTop);
				dc.LineTo(cLeft + TempLeftOffset - 2, cTop);
				dc.LineTo(cLeft + TempLeftOffset - 2, cBottom);
			}
		}  //end sensitivities
	}
}

// The system calls this to obtain the cursor to display while the user drags
//  the minimized window.
//HCURSOR CScanTracDlg::OnQueryDragIcon()
//{
//	return (HCURSOR) m_hIcon;
//}

void CScanTracDlg::OnTimer(UINT nIDEvent) 
{
	// TODO: Add your message handler code here and/or call default
		BYTE TempErrorCount = 0;
	if (nIDEvent == vTurnOffEjectorIn100mSecTimerHandle)
	{
		KillTimer(vTurnOffEjectorIn100mSecTimerHandle);
		ReportErrorMessage("Stop Pulse to De-activate Diverter: " + dtoa(vEjectorNumberToTurnOff, 0), cAction, 0);
		//vEjectorNumberToTurnOff = 0;

		if ((vEjectorNumberToTurnOff > 1) && (vEjectorNumberToTurnOff < 4))
		{
			//terminate the pulse
			tSerialCommand TempCommand;
			TempCommand[0] = 0x23;  //write to FPGA Address
			TempCommand[1] = 0x9C;  //FPGA address 0x900C
			TempCommand[2] = 0;
			if (vEjectorNumberToTurnOff == 3)
				vSystemData.vCurrentEjectorOnStatus = vSystemData.vCurrentEjectorOnStatus & 0xFB;
			else
				vSystemData.vCurrentEjectorOnStatus = vSystemData.vCurrentEjectorOnStatus & 0xFD;
			TempCommand[3] = (BYTE)vSystemData.vCurrentEjectorOnStatus;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);
		}
	}
	else
	if (nIDEvent == vSendPrintScreenMessageSoon)
	{
		KillTimer(vSendPrintScreenMessageSoon);
		MSG TempMessage;
		TempMessage.message = WM_KEYDOWN;
		TempMessage.lParam = 36;  //code for Print Screen Button
		TempMessage.wParam = 36;
		PreTranslateMessage(&TempMessage);
	}
	else
	if (nIDEvent == vTestDACsTimerHandle)
	{
		KillTimer(vTestDACsTimerHandle);

		//ReportErrorMessage("DAC Test Timer: " + dtoa(vSystemData.vVerifyDACValues, 0), cAction, 0);

		if (vSystemData.vDACChannelWrote >= vConfigurationData->vNumberOfXRayDetectors)
			vSystemData.vDACChannelWrote = 0;
		else
			vSystemData.vDACChannelWrote++;

		if (vSystemData.vVerifyDACValues == 1) //read all the values, so generate the report
		{
			vSystemData.vVerifyDACValues = 0;

			//Generate Report
			CString vReportString = "";
			CString vErrorString = "";
			for (BYTE TempLoopD = 0; TempLoopD < vConfigurationData->vNumberOfXRayDetectors; TempLoopD++)
			{
				vReportString = vReportString + "\nDetector " + dtoa(TempLoopD + 1, 0) + "> Programmed: " + 
					WordToHex(vSystemData.vLastProgrammedDACDetectorOffset[TempLoopD]) + ", Read: " + WordToHex(vSystemData.vLatestDACValueRead[TempLoopD]);
				if (vSystemData.vLatestDACValueRead[TempLoopD] != vSystemData.vLastProgrammedDACDetectorOffset[TempLoopD])
				{
					vReportString = vReportString + " ERROR";
					TempErrorCount++;
					vErrorString = vErrorString + "\nERROR >> Detector " + dtoa(TempLoopD + 1, 0) + "> Programmed: " + 
						WordToHex(vSystemData.vLastProgrammedDACDetectorOffset[TempLoopD]) + ", Read: " + WordToHex(vSystemData.vLatestDACValueRead[TempLoopD]);
				}
			}


			vReportString = dtoa(TempErrorCount, 0) + " DAC Verify Error(s):" + vErrorString + "\nFull DAC Verify Data:" + vReportString;

			if (vSystemData.vGenerateDACVerifyReport)
			{
				if (TempErrorCount)
					ReportErrorMessage(dtoa(TempErrorCount, 0) + " DAC Verify Error(s) on Manual Test", cEMailInspx, 0);
				else
					ReportErrorMessage(dtoa(TempErrorCount, 0) + " DAC Verify Error(s) on Manual Test", cAction, 0);

				vSystemData.vGenerateDACVerifyReport = false;

				CHelpDialog * IHelpDialog;
				IHelpDialog = new(CHelpDialog);
				IHelpDialog->vHelpContext = 16;
				IHelpDialog->vHelpType = 0;
				IHelpDialog->vWindowType = cTextWindow;
				IHelpDialog->vLocalSystemData = &vSystemData;
				IHelpDialog->vMainWindowPointer = this;
				IHelpDialog->vLocalConfigurationData = vConfigurationData;
				IHelpDialog->vProductPointer = vGlobalCurrentProduct;

				IHelpDialog->vTitleString = "Verify DAC Result";
				IHelpDialog->vTextString = vReportString;
				int TempResult = IHelpDialog->DoModal();
				delete IHelpDialog;
				if (TempResult == 10)
				{
					//Main Menu button pressed
					Sleep(1); //is the equivelent of a yeild statement;
					CDialog::EndDialog(TempResult);
				}
			}
		}
		else
		if (vGlobaluCSerialPort)
		{
			//for (BYTE TempLoop = 0; TempLoop < vSystemData.vNumberOfXRayDetectorsUsing; TempLoop++)
			if (vSystemData.vVerifyDACValues) 
			{
				vSystemData.vVerifyDACValues--; //if verifying current values, then don't send a new value, just decrement a counter
			}
			else
			{
				vSystemData.vDACTestValue = vSystemData.vDACTestValue + 0x0001;
				//vSystemData.vDACTestValue = vSystemData.vDACTestValue & 0x01FF; //clip to 9 bit
				vSystemData.vDACTestValue = vSystemData.vDACTestValue & 0x0FFF; //clip to 12 bit

				vSystemData.vDACTestValueSent = vSystemData.vDACTestValue;

				vGlobaluCSerialPort->SendAbsoluteDACDetectorOffset(vSystemData.vDACChannelWrote, vSystemData.vDACTestValueSent);
				vSystemData.vDACTestCount++;

				Sleep(10);//WAS 1	
			}

			//read DAC Value Back
			vGlobaluCSerialPort->ReadDACDetectorOffset(vSystemData.vDACChannelWrote);

			BYTE TempCount = 0;
			while ((vSystemData.vWaitingForDACValueReturn) && (TempCount < 200))
			{
				Sleep(10); //wait for reply // was 20
				TempCount++;
			}
		}

		if ((vSystemData.vOldVerifyDACValues) && (!vSystemData.vVerifyDACValues)) //if were reading out values, but 
		{
			if (TempErrorCount)
				ReportErrorMessage("Finished DAC Verify Values, " + dtoa(TempErrorCount, 0) + " Errors", cWriteToLog, 0);
			else
			{
				ReportErrorMessage("Finished DAC Verify Values, all verified OK", cWriteToLog, 0);

				if (vSystemData.vVerifyDACErros)
				if (!vSystemData.vGenerateDACVerifyReport)
					ReportErrorMessage("Reprogrammed DACs worked, Verified all DACs OK", cEMailInspx, 0); 
			}

			if (vGlobalFPGAVersion15Point31OrHigher)
			{
				vGlobaluCSerialPort->ReadDACErrorCount();
			}
		}
		else
		{ //do next DAC test after timer
			int TempTimerResult = SetTimer(vTestDACsTimerHandle,50,NULL);//was 10
			if (!TempTimerResult)
				ReportErrorMessage("Error-Hold Sent Test Display Timer Failed",cEMailInspx,32000);
		}
		vSystemData.vOldVerifyDACValues = vSystemData.vVerifyDACValues;
	}
	else
	if (nIDEvent == vTestADCsTimerHandle)
	{
		KillTimer(vTestADCsTimerHandle);

		if (vSystemData.vADCChannelWrote >= vConfigurationData->vNumberOfXRayDetectors - 1)
			vSystemData.vADCChannelWrote = 0;
		else
			vSystemData.vADCChannelWrote++;

		if (vSystemData.vVerifyADCValues == 1) //read all the values, so generate the report
		{
			vSystemData.vVerifyADCValues = 0;

			//Generate Report
			BYTE TempErrorCount = 0;
			CString vReportString = "";
			CString vErrorString = "";
			for (BYTE TempLoopD = 0; TempLoopD < vConfigurationData->vNumberOfXRayDetectors; TempLoopD++)
			{
				vReportString = vReportString + "\n" + "Detector " + dtoa(TempLoopD + 1, 0) + "> Programmed: " + 
					WordToHex(vSystemData.vLastProgrammedADCDetectorOffset[TempLoopD]) + ", Read: " + WordToHex(vSystemData.vLatestADCValueRead[TempLoopD]);
				if (vSystemData.vLatestADCValueRead[TempLoopD] != vSystemData.vLastProgrammedADCDetectorOffset[TempLoopD])
				{
					vReportString = vReportString + " ERROR";
					TempErrorCount++;
					vErrorString = vErrorString + "\nERROR >> Detector " + dtoa(TempLoopD + 1, 0) + "> Programmed: " + 
						WordToHex(vSystemData.vLastProgrammedADCDetectorOffset[TempLoopD]) + ", Read: " + WordToHex(vSystemData.vLatestADCValueRead[TempLoopD]);
				}
			}

			if (TempErrorCount)
				ReportErrorMessage(dtoa(TempErrorCount, 0) + " ADC Verify Errors", cEMailInspx, 0);
			else
				ReportErrorMessage(dtoa(TempErrorCount, 0) + " ADC Verify Errors", cAction, 0);

			vReportString = dtoa(TempErrorCount, 0) + " ADC Verify Error(s):" + vErrorString + "\nFull ADC Verify Data:\nNotice: Only 8 msbits of 10 bit value are read back" + vReportString;

			CHelpDialog * IHelpDialog;
			IHelpDialog = new(CHelpDialog);
			IHelpDialog->vHelpContext = 16;
			IHelpDialog->vHelpType = 0;
			IHelpDialog->vWindowType = cTextWindow;
			IHelpDialog->vLocalSystemData = &vSystemData;
			IHelpDialog->vMainWindowPointer = this;
			IHelpDialog->vLocalConfigurationData = vConfigurationData;
			IHelpDialog->vProductPointer = vGlobalCurrentProduct;

			IHelpDialog->vTitleString = "Verify ADC Offset Result";
			IHelpDialog->vTextString = vReportString;
			int TempResult = IHelpDialog->DoModal();
			delete IHelpDialog;
			if (TempResult == 10)
			{
				//Main Menu button pressed
				Sleep(1); //is the equivelent of a yeild statement;
				CDialog::EndDialog(TempResult);
			}
		}
		else
		if (vGlobaluCSerialPort)
		{
			if (vSystemData.vVerifyADCValues) 
			{
				vSystemData.vVerifyADCValues--; //if verifying current values, then don't send a new value, just decrement a counter
			}
			else
			{
				if (vGlobalFPGAVersion18point0orAbove)
				{
					vSystemData.vADCTestValue = vSystemData.vADCTestValue++; //9 LSbits of data are sent and read back
				}
				else
				{
					vSystemData.vADCTestValue = vSystemData.vADCTestValue + 0x0004;
					vSystemData.vADCTestValue = vSystemData.vADCTestValue & 0x03FC; //clip to 10 bit and ignore two LSBits since can't readout two LSBits
				}

				vSystemData.vADCTestValueSent = vSystemData.vADCTestValue;

				vGlobaluCSerialPort->SendAbsoluteADCDetectorOffset(vSystemData.vADCChannelWrote, vSystemData.vADCTestValueSent);
				vSystemData.vADCTestCount++;

				Sleep(10);//WAS 1	
			}
			//read ADC Value Back
			vGlobaluCSerialPort->ReadADCDetectorOffset(vSystemData.vADCChannelWrote);

			BYTE TempCount = 0;
			while ((vSystemData.vWaitingForADCValueReturn) && (TempCount < 200))
			{
				Sleep(100); //wait for reply // was 20
				TempCount++;
			}
			//if (vGlobalFPGAVersion15Point31OrHigher)
			//	vGlobaluCSerialPort->ReadADCErrorCount();

			if ((vSystemData.vOldVerifyADCValues) && (!vSystemData.vVerifyADCValues)) //if were reading out values, but 
			{
				ReportErrorMessage("Finish ADC Verify Values", cWriteToLog, 0);
			}
			else
			{ //do next ADC test after timer
				int TempTimerResult = SetTimer(vTestADCsTimerHandle,1,NULL);//was 10
				if (!TempTimerResult)
					ReportErrorMessage("Error-Send ADC Test Timer Failed",cEMailInspx,32000);
			}
			vSystemData.vOldVerifyADCValues = vSystemData.vVerifyADCValues;
		}
	}
	else
	if (nIDEvent == vNeedToTestDACsTimerHandle)
	{
		KillTimer(vNeedToTestDACsTimerHandle);

		ReportErrorMessage("Check if can Verify DACs, Mode: " + dtoa(vSystemData.vSystemRunMode, 0), cWriteToLog, 0);

		if (vGlobalFPGAVersion15Point31OrHigher) //does a verify of the DACs against the last programmed value  //vGlobalFPGAVersion15point42orAbove
 		if ((vSystemData.vSystemRunMode == cAutoSetupRunningSystem) || (vSystemData.vSystemRunMode == cRunningSystemMode)) 
		if (vConfigurationData->vShowOnlyRealImages)
		{
			if ((!vSystemData.vSendADCValues) && (!vSystemData.vSendDACValues)) //if not programming them for some other reason, start verify
			{
				vSystemData.vDACChannelWrote = vConfigurationData->vNumberOfXRayDetectors;

				for (BYTE TempLoopD = 0; TempLoopD < cMaximumNumberOfDetectors12; TempLoopD++)
					vSystemData.vLatestDACValueRead[TempLoopD] = 0;

				vSystemData.vVerifyDACValues = vConfigurationData->vNumberOfXRayDetectors + 1; //add one extra, so when done, value is one and can generate report
				vSystemData.vOldVerifyDACValues = vSystemData.vVerifyDACValues;
				ReportErrorMessage("Start DAC Verify Values While Inspecting", cWriteToLog, 0);

				StartDACTest();
			}
			else
			{ //do next ADC test after timer
				ReportErrorMessage("Check if can Verify DACs, Send DAC: " + dtoa(vSystemData.vSendDACValues, 0) + ", Send ADC: " + dtoa(vSystemData.vSendADCValues, 0), cWriteToLog, 0);
				int TempTimerResult = SetTimer(vNeedToTestDACsTimerHandle,1000,NULL);	//check in another second if ready
				if (!TempTimerResult)
					ReportErrorMessage("Error-Send ADC Test Timer Failed",cEMailInspx,32000);
			}
		}
		else
		if ((vSystemData.vSystemRunMode == cTestShutterMode) || (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode)) //if testing shutter wait, or ramping up source wait
		{ //do next ADC test after timer
			int TempTimerResult = SetTimer(vNeedToTestDACsTimerHandle,1000,NULL);	//check in another second if ready
			if (!TempTimerResult)
				ReportErrorMessage("Error-Send ADC Test Timer Failed",cEMailInspx,32000);
		}
	}
	else
	if (nIDEvent == vTriggerIndicatorTimerHandle)
	{
		if (vSystemData.vITIPCDig)
		if (vSystemData.vITIPCDig->vCaptureModule)
		if (!vConfigurationData->vDemoMode)
		//if (vSystemData.vSystemRunMode == cStoppedSystemMode)
 		if ((vSystemData.vSystemRunMode != cAutoSetupRunningSystem) &&
			(vSystemData.vSystemRunMode != cRunningSystemMode))
		{
			vTriggerIndicatorValue = ((BYTE)vSystemData.vITIPCDig->vCaptureModule->InportVal(0)) & 1;
			if ((!vConfigurationData->vBodyTrigger[0].vActiveHigh) && 
				(!vSystemData.vFPGAVersion10Point7OrHigher)) //always active high in 10.7 or above
				vTriggerIndicatorValue = !vTriggerIndicatorValue;
			if (vOldTriggerIndicatorValue != vTriggerIndicatorValue)
			{
				vOldTriggerIndicatorValue = vTriggerIndicatorValue;
				if (vTriggerIndicatorValue)
				{
					vTriggerIndicatorCount++;
					//if (!vCPMNotRunning)
					//	vCPMNotRunning = 1;  //force it to re-calculate the CPM
					vSystemData.vCPMDataNotRunning[vSystemData.vCPMDataIndexNotRunning]++;
				}
			}
		}
	}
	else
	if (nIDEvent == vClearRejectHiddenTimerHandle)
	{
		KillTimer(vClearRejectHiddenTimerHandle);
		UpdateCustomerNameLine();
	}
	else
	if (nIDEvent == vOperatorPasswordTimerHandle)
	{
		KillTimer(vOperatorPasswordTimerHandle);
		vSystemData.vOperatorPasswordOK = false;
	}
	else
	if (nIDEvent == vCheckACBeforeThisYellowMessageTimerHandle)
	{
		KillTimer(vCheckACBeforeThisYellowMessageTimerHandle);
		if (vSystemData.vACPowerOn)
		if (vSystemData.vCheckACBeforeThisYellowMessage.GetLength())
		{
			ReportErrorMessage(vSystemData.vCheckACBeforeThisYellowMessage, vSystemData.vCheckACBeforeThisYellowMessageTempLevel, vSystemData.vCheckACBeforeThisYellowMessageTempErrorCode);
		}
		vSystemData.vCheckACBeforeThisYellowMessage = "";
	}
	else
	if (nIDEvent == vClearSlippedTimerHandle)
	{
		if ((!vSystemData.vPipeIsEmpty) && (!vSystemData.vAirBubblesInPipe))
		{
			KillTimer(vClearSlippedTimerHandle);
			vShowingPipeEmpty = false;
			vShowingAirInPipe = false;
 			SetDlgItemText(IDC_TriggerIndicator, _T(""));
			m_TriggerIndicator.ShowWindow(SW_HIDE);
		}
	}
	else
	if (nIDEvent == vFlashYellowLightTimerHandle)
	{
		//flashes yellow light //happens when system unable to eject rejects because ejectors disabled
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->TurnOnOffYellowLamp(!(vSystemData.vCurrentLampStatus & 2));
		
		//and flash blue and yellow lights if system is not x-raying properly also
		if (vSystemData.vCantInspectError)
		{
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->TurnOnOffBlueLamp(!(vSystemData.vCurrentLampStatus & 2));
		}
	}
	else
	if (nIDEvent == vSetupDataBackupTimerHandle)
	{
		KillTimer(vSetupDataBackupTimerHandle);
		WriteConfigurationDataToFile(true); //write to backup config file
	}
	else
	if (nIDEvent == vCheckInterlocksIn200MSTimerHandle)
	{
		KillTimer(vCheckInterlocksIn200MSTimerHandle);
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->CheckInterlocks(false);
		if ((vGlobalMonoBlockXRayPort) && (vGlobalMonoBlockXRayPort->vHadLowCurrent))
		{
			if (vSystemData.vSystemRunMode != cStoppedSystemMode)
			{
				if (vGlobalMonoBlockXRayPort->vHadLowCurrent == 2) //PC software saw current low, so check voltage soon
				{
					::PostThreadMessage(vGlobalCallingThreadID,cCheckHVPSVoltageSoonMessage,0,0);
					ReportErrorMessage("Error - X-Ray Source Low Current.", cError,9);
					ReportErrorMessage("Error - X-Ray Source Low Current.", cEMailInspx,9);
				}
				else //Monoblock said current was low so shut down
				{
					if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
					{
						::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
						ReportErrorMessage("Error - X-Ray Source Low Current - Inspection Stopped", cError,9);
						ReportErrorMessage("Error - X-Ray Source Low Current - Inspection Stopped", cEMailInspx,9);
#ifdef CompileInHTTPClientOperationsGuardian
						if (vConfigurationData->vEnableOperationsGuardian)
						{
							vGlobalOGErrorCode = 101;
							vGlobalOGLocationString = "xray";
							::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageXRayFault, cOGSevereMessageXRayFault);
						}
#endif
					}
					else
					{
						ReportErrorMessage("Error - X-Ray Source Low Current", cError,9);
						ReportErrorMessage("Error - X-Ray Source Low Current", cEMailInspx,9);
					}
				}
			}
			vGlobalMonoBlockXRayPort->vHadLowCurrent = false;
		}
		else
		if ((vGlobalMonoBlockXRayPort) && (vGlobalMonoBlockXRayPort->vHadLowVoltage))
		{
			if (vSystemData.vSystemRunMode != cStoppedSystemMode)
			{
				if (vGlobalMonoBlockXRayPort->vHadLowVoltage == 2) //PC software saw voltage low, so check voltage soon
				{
					::PostThreadMessage(vGlobalCallingThreadID,cCheckHVPSVoltageSoonMessage,0,0);
				}
				else //Monoblock said voltage was low so shut down
				{
					if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
					{
						::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
						ReportErrorMessage("Error - X-Ray Source Low Voltage - Inspection Stopped", cError,9);
						ReportErrorMessage("Error - X-Ray Source Low Voltage - Inspection Stopped", cEMailInspx,9);
#ifdef CompileInHTTPClientOperationsGuardian
						if (vConfigurationData->vEnableOperationsGuardian)
						{
							vGlobalOGErrorCode = 108;
							vGlobalOGLocationString = "xray";
							::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageXRayFault, cOGSevereMessageXRayFault);
						}
#endif
					}
					else
					{
						ReportErrorMessage("Error - X-Ray Source Low Voltage", cError,9);
						ReportErrorMessage("Error - X-Ray Source Low Voltage", cEMailInspx,9);
					}
				}
			}
			vGlobalMonoBlockXRayPort->vHadLowVoltage = false;
		}
	}
	else
	if (nIDEvent == vReCalibrateOffsetTimerHandle)
	{
 		ReCalibrateWhileRunning();
	}
	else
	if (nIDEvent == vTurnDiverterOnTimerHandle)
	{
		KillTimer(vTurnDiverterOnTimerHandle);
 		TurnDiverterOn();
	}
	else
	if (nIDEvent == vTurnDiverterOffTimerHandle)
	{
		KillTimer(vTurnDiverterOffTimerHandle);
 		TurnDiverterOff();
	}
	else
	if (nIDEvent == vSetWindowActiveTimerHandle)
	{
		KillTimer(vSetWindowActiveTimerHandle);
		ClearVersionDisplay();

		ReportErrorMessage("vSetWindowActiveTimerHandle---SetForegroundWindow", cWriteToLog, 0);
		this->SetForegroundWindow();

		if (vGlobalCurrentProduct)
		if (CheckSystemFullyConfigured(vConfigurationData))
			CheckProductFullyConfigured(vGlobalCurrentProduct);
	}
	else
	if (nIDEvent == vCopyNextFilesTimerHandle)
	{
		if (vCopyDirectoryNextFileIndex)
			CopyNextFilesInDirectoryToDirectory();
		else
			KillTimer(vCopyNextFilesTimerHandle);
	}
	else
	if (nIDEvent == vBackupToBackupHardDriveTimer) //30 minutes after power on ScanTrac program, make backup if not inspecting
	{
		KillTimer(vBackupToBackupHardDriveTimer);
		if ((vSystemData.vSystemRunMode == cStoppedSystemMode))
			StartCopyAllScanTracFoldersToBackupHardDrive();
	}
	else
//	if (nIDEvent == vScreenShot1TimerHandle)
//	{
//		KillTimer(vScreenShot1TimerHandle);
//		PrintScreen1();
//	}
//	if (nIDEvent == vScreenShot2TimerHandle)
//	{
//		KillTimer(vScreenShot2TimerHandle);
//		PrintScreen2();												//print screen request
//	}
	if (nIDEvent == vSplashScreenTimerHandle)
  {
		KillTimer(vSplashScreenTimerHandle);
#ifdef IFC59Driver
		CheckForIFC59();
		CheckForCorrectMemorySize();
#endif
		{
			CProduct *TempProduct = GetProductByName(vConfigurationData->vLastProduct);

			if (!TempProduct)
			{
				TempProduct = GetProductByNumber(1);
				SetupProduct(TempProduct, false);
			}

			if (TempProduct)
			{
				SetupProduct(TempProduct, false);
				vSystemData.vITIPCDig->DeleteUndoStructureLearnFiles(vGlobalCurrentProduct);
				ReportErrorMessage("Starting up, load product: " + vSystemData.vCurrentProductName, cUserChanges,0);
			}
		}
		//ClearVersionDisplay();
		int TimerResult = SetTimer(vSetWindowActiveTimerHandle,5000,NULL); //was 100
		if (!TimerResult)
			ReportErrorMessage("Error-Startup Timer Failed",cEMailInspx,32000);
	}
  else
  if (nIDEvent == vDisableEjectorsTimerHandle)
  {
		KillTimer(vDisableEjectorsTimerHandle);
		EnableDisableEjectors(false);
		//ReportErrorMessage("Disable Ejectors after Test Eject",cAction,0);
	}
	else
  if (nIDEvent == vCheckLampsTimerHandle)
  {
		KillTimer(vCheckLampsTimerHandle);
		bool TempNeedToStartTimer = false;
		if (vSystemData.vACPowerOn)  //if not shutting down
		{
			if (vSystemData.vSourceInterLocks & 0x0001)
				vSystemData.vRedLampBrokenCounter = 0;
			else
			{
				if (vSystemData.vRedLampBrokenCounter < 200)
					vSystemData.vRedLampBrokenCounter++;

				TempNeedToStartTimer = true;

				if (vSystemData.vRedLampBrokenCounter > 9)
				if (vSystemData.vOpenInterlock.GetLength() == 0)
					vSystemData.vOpenInterlock.LoadString(IDS_RedLight);

				if (vSystemData.vRedLampBrokenCounter == 10)
				{
					CString TempText = " ";
					TempText.LoadString(IDS_RedLightFilamentBroken);
					if (vSystemData.vSystemRunMode != cStoppedSystemMode)
					{
						EmergencyShutXRaysDown(0);

						CString TempText1 = " ";
						TempText1.LoadString(IDS_XRaysShutDown);
						TempText = TempText + " - " + TempText1;
						ReportErrorMessage(TempText, cError,1);
					}
					else
					{
						ReportErrorMessage(TempText, cEMailMaintenance,1);
					}
				}
			}

			if (vSystemData.vSourceInterLocks & 0x0002) //yellow lamp
				vSystemData.vYellowLampBrokenCounter = 0;
			else
			{
				if (vSystemData.vYellowLampBrokenCounter < 200)
					vSystemData.vYellowLampBrokenCounter++;
				TempNeedToStartTimer = true;
				if (vSystemData.vYellowLampBrokenCounter > 9)
				if (vSystemData.vOpenInterlock.GetLength() == 0)
					vSystemData.vOpenInterlock.LoadString(IDS_YellowLight);
			}

			if (vSystemData.vSourceInterLocks & 0x0004) //blue lamp OK
				vSystemData.vBlueLampBrokenCounter = 0;
			else
			{
				if (vSystemData.vBlueLampBrokenCounter < 200)
					vSystemData.vBlueLampBrokenCounter++;
				TempNeedToStartTimer = true;
				if (vSystemData.vBlueLampBrokenCounter > 9)
				if (vSystemData.vOpenInterlock.GetLength() == 0)
					vSystemData.vOpenInterlock.LoadString(IDS_BlueLight);
			}

			if (TempNeedToStartTimer)
			{
				int TimerResult = SetTimer(vCheckLampsTimerHandle,1000,NULL);
				if (!TimerResult)
					ReportErrorMessage("Error-Check Lamps Timer Failed",cEMailInspx,32000);
			}
		}
	}
  else
  if (nIDEvent == vBackupTimerHandle)
  {
		KillTimer(vBackupTimerHandle);
		WriteConfigurationDataToFile(false); //write to main config file	
		WriteLifeTimeCounter();
		MakeSetupBackup();
	}
  else
  if (nIDEvent == vSetupProductTimerHandle)
  {
		KillTimer(vSetupProductTimerHandle);
		
		if (vSystemData.vHadErrorTryRestart)
			ReportErrorMessage("Reload Product after Calibration Failed",cWriteToLog, 0);

		if (vSystemData.vModeToRunAfterCalibrateOffset == cMeasureSourceStrengthMode)
			LoadMeasureSourceStrengthProduct();
		else
		if (vSystemData.vModeToRunAfterCalibrateOffset == cCalibratingDetectorGainMode)
			LoadCalibrateOffsetProduct();
		else
		if (vSystemData.vModeToRunAfterCalibrateOffset == cCalibratingDetectorEdgesMode)
			LoadCalibrateEdgesProduct();
		else
			SetupProduct(vGlobalCurrentProduct, false);
	}
  else
  if (nIDEvent == vShowSourceStrengthTimerHandle)
  {
		KillTimer(vShowSourceStrengthTimerHandle);
		ShowSourceStrengthData();
  }
  else
  if (nIDEvent == vEnableErrorMessagesTimerHandle)
	{
		KillTimer(vEnableErrorMessagesTimerHandle);
		vConfigurationData->vSuppressWarningMessages = vHoldSuppressWarningMessages;
  }
  else
  if (nIDEvent == vConveyorStartTimerHandle)
	{
		KillTimer(vConveyorStartTimerHandle);
		vSystemData.vCheckConveyor = true;
		if (vGlobalFPGAVersion15Point31OrHigher)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->ReadDACErrorCount();
  }
  else
  if (nIDEvent == vConveyorStartStopSignalOffTimerHandle)
	{
		KillTimer(vConveyorStartStopSignalOffTimerHandle);
		//clear the two pulse bits and leave the other bits as they were.
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & 0xFFF3;
		Send0x9ACommand();
	}
  else	
  if (nIDEvent == vExitTimerHandle)
	{
		if (vSystemData.vSystemRunMode == cStoppedSystemMode)
		{
			KillTimer(vExitTimerHandle);
			ExitProgram();
		}
  }
  else
  if (nIDEvent == vWaitForScreenUpdateTimerHandle)
  {
		KillTimer(vWaitForScreenUpdateTimerHandle);
		vWaitForScreenUpdate = false;
		if (vSystemData.vMainDisplayMode == cMainDisplayImage)
		{
			RECT TempRectangle;
			TempRectangle.left = vSystemData.vITIPCDig->vMainDisplayImageOffsetX;
			TempRectangle.top = vSystemData.vITIPCDig->vMainDisplayImageOffsetY;
			TempRectangle.right = vSystemData.vITIPCDig->vMainDisplayImageOffsetX + 
				vSystemData.vITIPCDig->vMainDisplayImageSizeX;
			TempRectangle.bottom = vSystemData.vITIPCDig->vMainDisplayImageOffsetY + 
				vSystemData.vITIPCDig->vMainDisplayImageSizeY;
			this->InvalidateRect(&TempRectangle,false);
		}
  }
  else
  if (nIDEvent == vCheckHVPSVoltageSoonTimerHandle)
  {
		KillTimer(vCheckHVPSVoltageSoonTimerHandle);
		if (vSystemData.vSystemRunMode)  //don't report values if X-Rays shut off by now
		{
			CString TempVoltageMinimum = "--";
			CString TempVoltageMaximum = "--";
			CString TempCurrentMinimum = "--";
			CString TempCurrentMaximum = "--";

			if (vSystemData.vSourceVoltageMin < 250)
				TempVoltageMinimum = dtoa(vSystemData.vSourceVoltageMin * 6, 2);

			if ((vSystemData.vSourceVoltageMax > 0) && (vSystemData.vSourceVoltageMax < 250))
				TempVoltageMaximum = dtoa(vSystemData.vSourceVoltageMax * 6, 2);

			if (vSystemData.vSourceCurrentMin < 250)
				TempCurrentMinimum = dtoa(vSystemData.vSourceCurrentMin, 2);

			if ((vSystemData.vSourceCurrentMax > 0) && (vSystemData.vSourceCurrentMax < 250))
				TempCurrentMaximum = dtoa(vSystemData.vSourceCurrentMax, 2);

			ReportErrorMessage("HVPS Setting Voltage: " + dtoa(vSystemData.vRampXRayVoltageAmount * 6,2) + ", Current: " + 
				dtoa(vSystemData.vRampXRayCurrentAmount,2),cEMailInspx,32000);

			ReportErrorMessage("HVPS Voltage Min-Max: " + TempVoltageMinimum + " - " + 
				TempVoltageMaximum + ", Current Min-Max: " + dtoa(vSystemData.vSourceCurrentMin,2) + " - " + 
				dtoa(vSystemData.vSourceCurrentMax,2),cEMailInspx,32000);

			if ((vSystemData.vSourceCurrent < .2) && (vSystemData.vRampXRayCurrentAmount > .5) &&  //zero current, resonable voltage
				(vSystemData.vRampXRayVoltageAmount > 19 / 6) && (vSystemData.vSourceVoltage > 19 / 6))
			{
				if (vGlobalDXMXRayPort)
				if ((vGlobalDXMXRayPort->vFilamentCurrentMin > 9999990) || (vGlobalDXMXRayPort->vFilamentCurrentMax == 0)) //6/29/2011
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " Filament Current: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentFeedbackMonitor, 2) + " Min: --- Max: ---", cEMailInspx, 32000);
				else
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " Filament Current: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentFeedbackMonitor, 2) +
						" Min: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentMin, 2) + " Max: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentMax, 2), cEMailInspx, 32000);

				if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
				{
					::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);

					ReportErrorMessage("Error-No X-Ray Current - Inspection Stopped", cEMailInspx, 32000);
					ReportErrorMessage("Error-No X-Ray Current - Inspection Stopped", cError, 0);
#ifdef CompileInHTTPClientOperationsGuardian
						if (vConfigurationData->vEnableOperationsGuardian)
						{
							vGlobalOGErrorCode = 112;
							vGlobalOGLocationString = "xray";
							::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageXRayFault, cOGSevereMessageXRayFault);
						}
#endif
					}
				else
				{
					ReportErrorMessage("Error-No X-Ray Current", cEMailInspx, 32000);
					ReportErrorMessage("Error-No X-Ray Current", cError, 0);
				}
			}
			else
			if ((vSystemData.vSourceCurrent < vSystemData.vRampXRayCurrentAmount / 2) && (vSystemData.vRampXRayCurrentAmount > 1) &&  //half current, resonable voltage
				(vSystemData.vRampXRayVoltageAmount > 19 / 6) && (vSystemData.vSourceVoltage > 19 / 6))
			{
				if (vGlobalDXMXRayPort)
				if ((vGlobalDXMXRayPort->vFilamentCurrentMin > 9999990) || (vGlobalDXMXRayPort->vFilamentCurrentMax == 0)) //6/29/2011
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " Filament Current: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentFeedbackMonitor, 2) + " Min: --- Max: ---", cEMailInspx, 32000);
				else
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " Filament Current: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentFeedbackMonitor, 2) +
						" Min: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentMin, 2) + " Max: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentMax, 2), cEMailInspx, 32000);

				if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
				{
					::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);

					ReportErrorMessage("Error-X-Ray Current low - Inspection Stopped: " + dtoa(vSystemData.vSourceCurrent, 2), cEMailInspx, 32000);
					ReportErrorMessage("Error-X-Ray Current low - Inspection Stopped: " + dtoa(vSystemData.vSourceCurrent, 2), cError, 0);
#ifdef CompileInHTTPClientOperationsGuardian
						if (vConfigurationData->vEnableOperationsGuardian)
						{
							vGlobalOGErrorCode = 101;
							vGlobalOGLocationString = "xray";
							::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageXRayFault, cOGSevereMessageXRayFault);
						}
#endif
					}
				else
				{
					ReportErrorMessage("Error-X-Ray Current low: " + dtoa(vSystemData.vSourceCurrent, 2), cEMailInspx, 32000);
					ReportErrorMessage("Error-X-Ray Current low: " + dtoa(vSystemData.vSourceCurrent, 2), cError, 0);
				}
			}
			else
			if ((vSystemData.vRampXRayVoltageAmount > 19 / 6) && (vSystemData.vSourceVoltage < vSystemData.vRampXRayVoltageAmount * 0.8)) //low voltage
			{
				if (vGlobalDXMXRayPort)
				if ((vGlobalDXMXRayPort->vFilamentCurrentMin > 9999990) || (vGlobalDXMXRayPort->vFilamentCurrentMax == 0)) //6/29/2011
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " Filament Current: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentFeedbackMonitor, 2) + " Min: --- Max: ---", cEMailInspx, 32000);
				else
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " Filament Current: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentFeedbackMonitor, 2) +
						" Min: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentMin, 2) + " Max: " + dtoa(vGlobalDXMXRayPort->vFilamentCurrentMax, 2), cEMailInspx, 32000);

				if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
				{
					::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);

					ReportErrorMessage("Error-X-Ray Voltage low - Inspection Stopped: " + dtoa(vSystemData.vSourceVoltage * 6, 2), cEMailInspx, 32000);
					ReportErrorMessage("Error-X-Ray Voltage low - Inspection Stopped: " + dtoa(vSystemData.vSourceVoltage * 6, 2), cError, 0);
#ifdef CompileInHTTPClientOperationsGuardian
						if (vConfigurationData->vEnableOperationsGuardian)
						{
							vGlobalOGErrorCode = 112;
							vGlobalOGLocationString = "xray";
							::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageXRayFault, cOGSevereMessageXRayFault);
						}
#endif
				}
				else
				{
					ReportErrorMessage("Error-X-Ray Voltage low: " + dtoa(vSystemData.vSourceVoltage * 6, 2), cEMailInspx, 32000);
					ReportErrorMessage("Error-X-Ray Voltage low: " + dtoa(vSystemData.vSourceVoltage * 6, 2), cError, 0);
				}
			}
		}
  }
  else
  if (nIDEvent == vSourceStabilizeTimerHandle)
  {
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("vSourceStabilizeTimerHandle",cDebugMessage);
		KillTimer(vSourceStabilizeTimerHandle);
		//if (vGlobaluCSerialPort)
		//{
			//vGlobaluCSerialPort->vBeltPositionBodyTriggerWentActive = 0;
			//if (vSystemData.vBodyTriggerLines)
			//	vGlobaluCSerialPort->vBeltPositionBodyTriggerWentActive = 
			//	vSystemData.vCurrentBeltPosition;
		//}
		vSystemData.vSourceRampedUp = true;
		vSystemData.vRampXRayStep = 0;

		if ((vSystemData.vRampXRayVoltageAmount) || (vSystemData.vRampXRayCurrentAmount))
		{
			vSystemData.vSourceVoltageMin = 254;
			vSystemData.vSourceVoltageMax = 0;
			vSystemData.vSourceCurrentMin = 254;
			vSystemData.vSourceCurrentMax = 0;
		}
		if (vGlobalDXMXRayPort)
		{
			vGlobalDXMXRayPort->vFilamentCurrentMin = 9999999;
			vGlobalDXMXRayPort->vFilamentCurrentMax = 0;
		}
		/*
				if ((vSystemData.vFPGASimulateEncoderRate) || (vConfigurationData->vContinuousFeedEncoderRate))
					TurnSimulatedEncoderOn();
				else
					SetSimulatedEncoderTo16TimesConveyor();
					*/

		//br h?  Need to only do if mask is zero for when Inspx temp change voltage
		if ((!vSystemData.vCurrentBodyTriggerMask) || (vSystemData.vSystemRunMode == cTestShutterMode))
		{
			StartImageAcquisition();
		}
		if (vSystemData.vXRayOnNotice)
		if (vSystemData.vSystemRunMode == cRunningSystemMode)
		if (vSystemData.vLastXRayCommandOn)
		{
			TempText.LoadString(IDS_XRAYSON);
			SetDlgItemText(IDC_Calibrating,TempText);
			m_Calibrating.ShowWindow(SW_SHOW);
			vSystemData.vXRayState = 26;
			::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,26,0); //trigger was just activated
			ReportErrorMessage("X-Rays Starting Up Step: 26", cWriteToLog, 0);
		}
		if (vSystemData.vSystemRunMode == cTestShutterMode)
		{
			int TimerResult = SetTimer(vSimulateOneContainerTimer,50,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Timer Failed",cEMailInspx,32000);
		}
		else
		if ((vSystemData.vSimulateContainersRate) || (vConfigurationData->vContinuousFeedContainerRate) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || 
			(vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
		if ((vSystemData.vActualEncoderRate > 0) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || 
			(vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
		if ((vSystemData.vSystemRunMode == cRunningSystemMode) || (vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
			TurnSimulatedContainersOn();

		if (vSystemData.vSystemRunMode == cMeasureSourceStrengthMode)
		{
			int TimerResult = SetTimer(vSimulateOneContainerTimer,2000,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Timer Failed",cEMailInspx,32000);
		}
		if ((vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode) ||
			(vSystemData.vSystemRunMode == cCalibratingDetectorGainMode))
		{
			int TimerResult = SetTimer(vSimulateOneContainerTimer,1000,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Timer Failed",cEMailInspx,32000);
		}
  }
  else
  if (nIDEvent == vStartRunningTimerHandle)
  {
		KillTimer(vStartRunningTimerHandle);

		if (vSystemData.vHadErrorTryRestart)
		{
			vSystemData.vHadErrorTryRestart = 0;
			ReportErrorMessage("Try Calibrating Again after Calibrate Error", cWriteToLog, 0);
		}

		vSystemData.vCalibrateADCAfterDAC = true;
		vSystemData.vAutoCalibrate = true;
		if (vConfigurationData->vUseDACAndADCinDensityCompensation)
			CalibrateDACDetectorOffset();
		else
			CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
  }
	else
  if (nIDEvent == vRampXRayTimerHandle)
  {
		if (vSystemData.vSystemRunMode)
			NextSourceRampUpStep();
		else
			KillTimer(vRampXRayTimerHandle);
  }
	else
	if (nIDEvent == v50HertzTimerHandle)
	{
		KillTimer(v50HertzTimerHandle);

		DoBackGroundWork();

		int TempTimerResult = SetTimer(v50HertzTimerHandle,20,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-50 Hz Timer Failed",cEMailInspx, 32000);
	}
	else
	//test
	/*
	if (nIDEvent == v10MilliSecondTimerHandle)
	{
		double TempEndTime = CIFCOS::GetSystimeMillisecs();
		if (vLast10MilliSecondTimerTime > 1)
		{
			m_TriggerIndicator.ShowWindow(SW_SHOW);
			vLast10MilliSecondSpan = TempEndTime - vLast10MilliSecondTimerTime;

			if (vMaximum10MilliSecondSpan < vLast10MilliSecondSpan)
				vMaximum10MilliSecondSpan = vLast10MilliSecondSpan;
		}
			
		vLast10MilliSecondTimerTime = CIFCOS::GetSystimeMillisecs();
	}
	else
	*/
	// end for test serial log >12GB stop
	if (nIDEvent == vOneHourUpdatesTimerHandle)
	{
		if (vGlobalACPowerMoniter)
			vGlobalACPowerMoniter->IACPowerMoniterLogFile.LogFileObjectBackground();
		if ((vGlobaluCSerialPort) && (vSystemData.vLogFile.vLogSerialData))
		{
			//if (CalculateDirectorySize(vConfigurationData->vScanTracSerialLogsDirectory) > cMaxSerialLogDirectorySize)
			//{
			//	vSystemData.vLogFile.CloseLogFile();
			//	vSystemData.vLogFile.vLogSerialData = false;
			//	ReportErrorMessage("Closed Serial Log File, 12 GB Directory Size Exceeded", cEMailInspx,32002); //write message to inpsx log file 
			//}
		}
	}
	else
	if (nIDEvent == vXRayTubeHasCooledTimerHandle)
	{
		KillTimer(vXRayTubeHasCooledTimerHandle);
		vConfigurationData->vXRayTubeHasCooled = true;	
		WriteConfigurationDataToFile(false); //write to main config file
		
		WriteLifeTimeCounter();
	}
	else
	if (nIDEvent == vShowSafetyViolationMessageTimer)
	{
		KillTimer(vShowSafetyViolationMessageTimer);
		ShowSafetyViolationMessage();
	}
	else
  if (nIDEvent == vSimulateOneContainerTimer)
  {
		if ((vSystemData.vSourceRampedUp) ||
			(vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) ||
			(vSystemData.vSystemRunMode == cCalibratingDetectorGainMode) ||
			(vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode) ||
			(vSystemData.vSystemRunMode == cTestShutterMode) ||
			(vSystemData.vSystemRunMode == cAlignTubeMode) ||
			(vSystemData.vSystemRunMode == cAutoSetupRunningSystem) ||
			(vSystemData.vSystemRunMode == cMeasureSourceStrengthMode))
		{
			//ReportErrorMessage("Simulate a container now", cWriteToLog, 0);
			KillTimer(vSimulateOneContainerTimer);
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Simulate a container event mode: " + dtoa(vSystemData.vSystemRunMode), cDebugMessage);
			SimulateOneContainer();
		}
		else 
		{
			if (vSystemData.vSystemRunMode == cStoppedSystemMode)
			{
				//not in correct mode so kill timer, otherwise, ramping up, so try next time
				KillTimer(vSimulateOneContainerTimer);
				ReportErrorMessage("Simulate a container now, but mode stopped, so will cancel", cWriteToLog, 0);
			}
			else
			if (vSystemData.vSystemRunMode != cRunningSystemMode)
				ReportErrorMessage("Simulate a container now, but not correct mode, so try later", cWriteToLog, 0);
		}
  }
	else
  if (nIDEvent == vSendSyncCommandTimerHandle)
	{
		OneSecondDisplayUpdate();
	}
	else
	if (nIDEvent == vSystemData.vSimulatedContainerTimerHandle)
  {
		//command uController to simulate a body trigger
		KillTimer(vSystemData.vSimulatedContainerTimerHandle);
		if (vSystemData.vActualEncoderRate)
		if (vSystemData.vSourceRampedUp)
		if ((vSystemData.vSystemRunMode == cRunningSystemMode) ||
			(vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
			//don't simulate containers if calibrating, as it simulates containers at it's own rate.
			SimulateOneContainer();
		//stop timer and start over in case real late
		if (vSystemData.vSimulatedContainerTimerDelay > 0)
		{
			int TimerResult = SetTimer(vSystemData.vSimulatedContainerTimerHandle,
				vSystemData.vSimulatedContainerTimerDelay,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Container Timer Failed",cEMailInspx,32000);
		}
  }
  else
  if (nIDEvent == vBeltPositionTimerHandle)
  {
    //vSystemData.SetGoodCountTotal(vSystemData.vGoodCountTotal + 1);
		vSystemData.vCurrentBeltPosition = vSystemData.vCurrentBeltPosition + 29;
		//if (vSystemData.vSystemRunMode == cRunningSystemMode)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->CheckContainers(vSystemData.vCurrentBeltPosition);
  }
  else
	if (nIDEvent == vCheckHardDrivesTimerHandle)
	{
		KillTimer(vCheckHardDrivesTimerHandle);
		if (!vDisplayingVersion)
		if ((vSystemData.vCurrentLampStatus & 2) == 0)//if yellow light is off
			CheckHardDrives();
	}
	else
  if (nIDEvent == vStopRunningTimerHandle)
  {
		if ((vSystemData.vContainerCollection->GetCount() == 0) ||
			(vSystemData.vActualEncoderRate == 0))
		{
			if (vStopRunningTimerActive == 0)
				vStopRunningTimerActive++;
			else
			if (vStopRunningTimerActive == 1)
			{
				SendConveyorOnOffToUController(0);
				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Stop simulated encoder at end of run and clear tunnel",cDebugMessage);
				TurnSimulatedEncoderOff();
				vStopRunningTimerActive++;
				if (vSystemData.vITIPCDig->vCaptureModule)
					vSystemData.vITIPCDig->vCaptureModule->ClearFrameBuffer();
			}
			else
			//if (vStopRunningTimerActive == 2)
			{
				KillTimer(vStopRunningTimerHandle);
				vStopRunningTimerActive = false;
				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Enable Run Button",cDebugMessage);
				UpdateRunButton();
				
				if (vAbortCalibration)
					vSelectProductAgain = false;

				if (vSelectProductAgain)
				{
					ResetCounters();  //7/17/2013
					vSaveProductCodeTemp = vSystemData.vShiftProductCode;
					// save and clear product code
					vSystemData.vShiftProductCode = " ";		
					SetupProduct(vGlobalCurrentProduct,false);

					if (PrepareToRun())
					{
						//run
						vSystemData.vModeToRunAfterCalibrateOffset = cRunningSystemMode;
						vSystemData.vCalibrateErrorCount = 0;
						vSystemData.vHadErrorTryRestart = 0;
						vSystemData.vCalibrateADCAfterDAC = true;
						vSystemData.vAutoCalibrate = true;
						vSystemData.vAutoCalibrateWhileRunning = false;
						vSystemData.vFullDetectorCalibration = false;
						if (vConfigurationData->vUseDACAndADCinDensityCompensation)
							CalibrateDACDetectorOffset();
						else
							CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
					}

					vSelectProductAgain = false;
				}
			}
		}
  }
  else
  if (nIDEvent == vEndMeasureSourceStrengthTimerHandle)
  {
		if ((vSystemData.vContainerCollection->GetCount() == 0) ||
			(vSystemData.vActualEncoderRate == 0))
		{
			KillTimer(vEndMeasureSourceStrengthTimerHandle);
			FinishMeasureSourceStrength(vTurnOffSourceWhenStopRunning);
		}
  }
  else
  if (nIDEvent == vEndCalibrateDetectorsTimerHandle)
  {
		if ((vSystemData.vContainerCollection->GetCount() == 0) ||
			(vSystemData.vActualEncoderRate == 0))
		{
			KillTimer(vEndCalibrateDetectorsTimerHandle);
			FinishCalibrateDetectorEdges(vTurnOffSourceWhenStopRunning);  //TempAbort
		}
  }
  else
  if (nIDEvent == vUpdateDisplayTimerHandle)
	{
		KillTimer(vUpdateDisplayTimerHandle);
		UpdateDisplay();
		int TempTimerResult = SetTimer(vUpdateDisplayTimerHandle,500,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-Display Timer Failed",cEMailInspx,32000);
	}
  else
  if (nIDEvent == vCheckForErrorMessagesTimerHandle)
		CheckForErrorMessages();
	else
	if (nIDEvent == vClearScreenCaptureNoticeTimerHandle)		
	{
		KillTimer(vClearScreenCaptureNoticeTimerHandle);
		if (vGlobalDisplayDialogThread)
		{
			vGlobalDisplayDialogThread->ExitDisplayThread();
			vGlobalDisplayDialogThread = NULL;
		}
	}
	else
	if (nIDEvent == vCheckForNewImageToDisplayTimerHandle)		
	{
		KillTimer(vCheckForNewImageToDisplayTimerHandle);
		CheckForNewImageToDisplay();
		int TimerResult = SetTimer(vCheckForNewImageToDisplayTimerHandle,250,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-Check For New Image Timer Failed",cEMailInspx,32000);
	}
	else
	if (nIDEvent == vWaitToCalibrateForXRaysToSettleTimer)		
	{
		KillTimer(vWaitToCalibrateForXRaysToSettleTimer);

		ReportErrorMessage("Calibrate Pixels, set current to Zero to begin", cWriteToLog, 0);
		SendSourceCurrentToUController(vSystemData.vRampXRayCurrentAmount);		

		if (vConfigurationData->vHVPSType == c100WMonoBlockHVPS)
		{
			if (vGlobalDXMXRayPort)
				vGlobalDXMXRayPort->TurnOnOffXRays(true);
			ReportErrorMessage("100Watt MonoBlock, turn on X-Rays before Calibrate", cWriteToLog, 0);
			//vSystemData.vSourceRampedUp = true;
		}

		int TimerResult = SetTimer(vSimulateOneContainerTimer,cCalibrateEdgesTimeInterval,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx,32000);
	}
	
	CDialog::OnTimer(nIDEvent);
}

//puts ip address values from local computer into global variables vGlobalIPAddressString, vGlobalIPDefaultGatewayString, 
																//vGlobalIPSubNetMaskString, vGlobalIPDHCPEnabled
																//vGlobalNetworkBoardCode, vGlobalRegistryKeyPath
	//9/30/2009
// mod for read ip values directly Visual Studios 2010 kjh 2/22/2012
//

void CScanTracDlg::GetCurrentMachineIPAddressValuesFromRegistry()
{
	//vGlobalIPAddressString =		"IP Address Not Read ";	//need to start with initial lengths for strings
	//vGlobalIPSubNetMaskString =		"Mask Not Read       ";
	//vGlobalIPDefaultGatewayString =	"Gateway Not Read    ";
	//vGlobalIPDHCPEnabled =			"Static / Dynamic	 ";
	//vGlobalIPDHCPServer =	"Gateway Not Read    ";
	
	//vGlobalNetworkBoardCode = "Unknown";
	//vGlobalRegistryKeyPath = "Unknown";
	//find out which kind of network board is in the registry
	// is this an NT machine added kjh 3/1/2012
	if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
	{

		CRegKey TempRegistryKey;
		long TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\"));
	
		//Try SEAVO Mother Board
		TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("Hardware\\Resourcemap\\OtherDrivers\\RTL8139"));
		DWORD TempWord = 0;
		if (TempErrorCode == ERROR_SUCCESS)
		{
			TempErrorCode = TempRegistryKey.QueryDWORDValue(_T("\\Device\\RTL81391.Raw"), TempWord);
			if ((TempErrorCode == ERROR_SUCCESS) || (TempErrorCode == 234))
			{
				vGlobalNetworkBoardCode = "RTL81391 (Seavo MB)";
				vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\RTL81391\\Parameters\\Tcpip";
				TempErrorCode = ERROR_SUCCESS;
			}
		}
		if (TempErrorCode != ERROR_SUCCESS) //try FoxConn
		{
			//TempErrorCode = vRegistryKey.Open(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\RTL81697\\Parameters\\Tcpip");
			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("Hardware\\Resourcemap\\OtherDrivers\\RTL8169"));
			if (TempErrorCode == ERROR_SUCCESS)
			{
				TempErrorCode = TempRegistryKey.QueryDWORDValue(_T("\\Device\\RTL81697.Raw"), TempWord);
				if ((TempErrorCode == ERROR_SUCCESS) || (TempErrorCode == 234))
				{
					vGlobalNetworkBoardCode = "RTL81697(FoxConnMB)";
					vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\RTL81697\\Parameters\\Tcpip";
					TempErrorCode = ERROR_SUCCESS;
				}
				else
				{ //test for dragon mother board
					TempErrorCode = TempRegistryKey.QueryDWORDValue(_T("\\Device\\RTL81691.Raw"), TempWord);
					if ((TempErrorCode == ERROR_SUCCESS) || (TempErrorCode == 234))
					{
						vGlobalNetworkBoardCode = "RTL81691(Dragon MB)";
						vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\RTL81691\\Parameters\\Tcpip";
						TempErrorCode = ERROR_SUCCESS;
					}
				}
			}
		}
		if (TempErrorCode != ERROR_SUCCESS) //try MSI
		{
			//TempErrorCode = vRegistryKey.Open(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\RTL81395\\Parameters\\Tcpip");
			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("Hardware\\Resourcemap\\OtherDrivers\\RTL8139"));
			if (TempErrorCode == ERROR_SUCCESS)
			{
				TempErrorCode = TempRegistryKey.QueryDWORDValue(_T("\\Device\\RTL81395.Raw"), TempWord);
				if ((TempErrorCode == ERROR_SUCCESS) || (TempErrorCode == 234))
				{
					vGlobalNetworkBoardCode = "RTL81395 (MSI MB)";
					vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\RTL81395\\Parameters\\Tcpip";
					TempErrorCode = ERROR_SUCCESS;
				}
			}
		}
// XP system
//	if (TempErrorCode != ERROR_SUCCESS)
//	{  //see if Windows XP on Seavo Motherboard
//		TempErrorCode = 
//			TempRegistryKey.Open(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces\\{E4370063-F18F-439F-B54A-B9F8D4ECE26B}");
//		if (TempErrorCode == ERROR_SUCCESS)
//		{
//			vGlobalNetworkBoardCode = "WindowsXP Seavo MB";	//kjh 5/3/10 added {} in string below
//			vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces\\{E4370063-F18F-439F-B54A-B9F8D4ECE26B}";
//		}
//	}
//	//9/30/2008
// XP system
//	if (TempErrorCode != ERROR_SUCCESS)
//	{  //see if Windows XP on Seavo Motherboard
//		TempErrorCode = 
//			TempRegistryKey.Open(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\{4E998AA0-D1C5-4B8A-80B2-D97F82C6F1F5}");
//		if (TempErrorCode == ERROR_SUCCESS)
//		{
//			vGlobalNetworkBoardCode = "WindowsXP Brian Dev";
//			vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\{4E998AA0-D1C5-4B8A-80B2-D97F82C6F1F5}\\Parameters\\TCPIP";
//		}
//	}
// XP system
//	//for ping check debug on dev computer, next 10 lines adds read of dev xp computer ip info 9/21/09
//	if (TempErrorCode != ERROR_SUCCESS)
//	{  //see if dev xp computer for testing 
//		TempErrorCode = 
//			TempRegistryKey.Open(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces\\{581C255B-15F5-4B70-A7D8-5277BA72B4A9}");
//		if (TempErrorCode == ERROR_SUCCESS)
//		{
//			vGlobalNetworkBoardCode = " WindowsXP DEV BD";	//kjh 5/3/10 added {} in string below
//			vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces\\{581C255B-15F5-4B70-A7D8-5277BA72B4A9}";
//		}
//	}
// XP system
//	if (TempErrorCode != ERROR_SUCCESS)
//	{  //see if dev xp quad core computer for testing 
//		TempErrorCode = 
//			TempRegistryKey.Open(HKEY_LOCAL_MACHINE, "SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces\\{2D4E55F0-2D5F-4E82-9715-15F0CB798A86}");
//		if (TempErrorCode == ERROR_SUCCESS)
//		{
//			vGlobalNetworkBoardCode = " WindowsXP DEV BD";
//			vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces\\{2D4E55F0-2D5F-4E82-9715-15F0CB798A86}";
//		}
//	}
		if (TempErrorCode != ERROR_SUCCESS)
		{  //see if board type is in registry
			if (TempErrorCode = GetNetworkCardName())
			{
				vGlobalRegistryKeyPath = vGlobalRegistryTCPIPKeyPath;
				TempErrorCode = ERROR_SUCCESS;

				TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, vGlobalRegistryTCPIPKeyPath,KEY_ALL_ACCESS );
				if (TempErrorCode == ERROR_SUCCESS)
				{
					vGlobalNetworkBoardCode = vGlobalRegistryKeyPath.Right(20);
				}
				
			}	//end found network card
			else
			{
				ReportErrorMessage("Network Card Not Found", cEMailInspx, 32000);
			}
		}

		//IP
		bool TempIPDHCPEnabled = false;
		DWORD dwType = REG_MULTI_SZ;

		if (TempErrorCode == ERROR_SUCCESS)
		{	//Get Values
			//bool dynamic
					//Addressing format:000.000.000.000
			DWORD TempCount = 20;
			LPTSTR TempString = vGlobalIPAddressString.GetBuffer(vGlobalIPAddressString.GetLength());
			LPTSTR TempKeyString = _T("IPAddress");
			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, vGlobalRegistryKeyPath);
			LONG lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);

			if (lRes == 0)
	//		if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
			{
				vGlobalIPAddressString = TempString;
				vGlobalIPAddressString = vGlobalIPAddressString.GetBufferSetLength(TempCount);
			}

			DWORD TempWord = 0;
			TempRegistryKey.QueryDWORDValue(_T("EnableDHCP"), TempWord);
			if (TempWord)
				TempIPDHCPEnabled = true;//dynamic - remote network access difficult
			else
				TempIPDHCPEnabled = false;//static
	//		DWORD TempWord = 0;
	//		long TempSuccess = TempRegistryKey.QueryValue(TempWord,"EnableDHCP");
	//		if (TempSuccess != ERROR_SUCCESS)
	//		{
	//			ReportErrorMessage("The Static/Dynamic Registry Entry Was Improperly Read: " + dtoa(TempSuccess) ,cEMailInspx, 32000);//write to inpsx message
	//		}

			if (TempIPDHCPEnabled)
			{
				vGlobalIPDHCPEnabled = true;

		//		CNoticeDialog TempNoticeDialog;
		//		TempNoticeDialog.vNoticeText = "\n\nLocal Machine is dynamic" + dtoa(TempIPDHCPEnabled);
		//		TempNoticeDialog.vType = cInformationMessage;
		//		TempNoticeDialog.DoModal();

				DWORD TempCount = 20;
				TempString = vGlobalIPAddressString.GetBuffer(vGlobalIPAddressString.GetLength());
				LPTSTR TempKeyString = _T("DHCPIPAddress");
				TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, vGlobalRegistryKeyPath);
				LONG lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);

				if (lRes == 0)
	//			if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
				{
					vGlobalIPAddressString = TempString;
					wchar_t TempLastChar = TempString[TempCount - 1];
					wchar_t TempNextChar = TempString[TempCount - 2];
					if ((TempLastChar < 48) || (TempLastChar > 57))
						TempCount--;

					vGlobalIPAddressString = vGlobalIPAddressString.GetBufferSetLength(TempCount);
				}

				TempCount = 20;
				TempString = vGlobalIPSubNetMaskString.GetBuffer(vGlobalIPSubNetMaskString.GetLength());
				TempKeyString = _T("DHCPSubnetMask");
				TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, vGlobalRegistryKeyPath);
				lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);

				if (lRes) //0 = no error
	//			if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
				{
					TempCount = 20;
					TempString = vGlobalIPSubNetMaskString.GetBuffer(vGlobalIPSubNetMaskString.GetLength());
					TempKeyString = _T("Subnetmask");
					TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, vGlobalRegistryKeyPath);
					lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);
				}

				if (lRes == 0)
	//			if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
				{
					vGlobalIPSubNetMaskString = TempString;
					vGlobalIPSubNetMaskString = vGlobalIPSubNetMaskString.GetBufferSetLength(TempCount);
				}

				TempCount = 20;
				TempString = vGlobalIPDefaultGatewayString.GetBuffer(vGlobalIPDefaultGatewayString.GetLength());
				TempKeyString = _T("DHCPDefaultGateway");
				TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, vGlobalRegistryKeyPath);
				lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);

				if (lRes) //0 = no error
				{
					TempCount = 20;
					TempString = vGlobalIPDefaultGatewayString.GetBuffer(vGlobalIPDefaultGatewayString.GetLength());
					TempKeyString = _T("DefaultGateway");
					TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, vGlobalRegistryKeyPath);
					lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);
				}

				if (lRes == 0)
	//			if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
				{
					vGlobalIPDefaultGatewayString = TempString;
					vGlobalIPDefaultGatewayString = vGlobalIPDefaultGatewayString.GetBufferSetLength(TempCount);
				}

				TempCount = 20;
				TempString = vGlobalIPDHCPServer.GetBuffer(vGlobalIPDHCPServer.GetLength());
				TempKeyString = _T("DHCPServer");
				TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, vGlobalRegistryKeyPath);
				lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);

				if (lRes == 0)
	//			if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
				{
					vGlobalIPDHCPServer = TempString;
					vGlobalIPDHCPServer = vGlobalIPDHCPServer.GetBufferSetLength(TempCount);
				}
			}
			else
			{
				vGlobalIPDHCPEnabled = false;

		//		CNoticeDialog TempNoticeDialog;
		//		TempNoticeDialog.vNoticeText = "\n\nLocal Machine is static" + dtoa(TempIPDHCPEnabled);
		//		TempNoticeDialog.vType = cInformationMessage;
		//		TempNoticeDialog.DoModal();


			//Mask
				//default mask:255.255.255.0 , mask needs to have at least 255.255
				TempCount = 20;
				TempString = vGlobalIPSubNetMaskString.GetBuffer(vGlobalIPSubNetMaskString.GetLength());
				TempKeyString = _T("SubnetMask");
				lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);

	//		code not used next 6 lines	if (lRes != 0)
	//			{
	//				TempCount = 20;
	//				TempString = vGlobalIPDefaultGatewayString.GetBuffer(vGlobalIPDefaultGatewayString.GetLength());
	//				TempKeyString = "Subnetmask";
	//				lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);
	//			}

				if (lRes == 0)
	//			if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
				{
					vGlobalIPSubNetMaskString = TempString;
					vGlobalIPSubNetMaskString = vGlobalIPSubNetMaskString.GetBufferSetLength(TempCount);
				}

			//Gateway
				TempCount = 20;
				TempString = vGlobalIPDefaultGatewayString.GetBuffer(vGlobalIPDefaultGatewayString.GetLength());
				TempKeyString = _T("DefaultGateway");
				lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);

				if (lRes == 0)
	//			if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
				{
					vGlobalIPDefaultGatewayString = TempString;
					vGlobalIPDefaultGatewayString = vGlobalIPDefaultGatewayString.GetBufferSetLength(TempCount);
				}

				//
				TempCount = 20;
				TempString = vGlobalIPDNSAddressString1.GetBuffer(vGlobalIPDNSAddressString1.GetLength());
				TempKeyString = _T("NameServer");
				lRes = RegQueryValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, &dwType, (LPBYTE)TempString, &TempCount);

				if (lRes == 0)
				{
					vGlobalIPDNSAddressString1 = TempString;
					vGlobalIPDNSAddressString1 = vGlobalIPDNSAddressString1.GetBufferSetLength(TempCount);
				}

			}
		}
	}	//end if NT System
	else
	{		// here if XP system
		//set these values

		// static
		// vGlobalIPSubNetMaskString
		// vGlobalIPDefaultGatewayString
		// vGlobalIPDNSAddressString
		// vGlobalIPDHCPEnabled = "Static";

		// dynamic   vGlobalIPDHCPServer vGlobalIPDefaultGatewayString vGlobalIPSubNetMaskString vGlobalIPAddressString
		// vGlobalIPAddressString
		// vGlobalIPSubNetMaskString
		// vGlobalIPDefaultGatewayString
		// vGlobalIPDHCPServer

		// vGlobalIPDHCPEnabled = "Dynamic";
		UseIPHelperForIPInfo();

		//default, check for known Network Board Code
		// ******************************** GetInterfaceInfo Start *********************** /
		IP_INTERFACE_INFO*  pInfoInterface;
		ULONG               ulOutBufLen;
		DWORD               dwRetVal;
//			int                 i;
		LPTSTR	 TempNetworkAdapterID;

		pInfoInterface = (IP_INTERFACE_INFO *) malloc( sizeof(IP_INTERFACE_INFO) );
		if (pInfoInterface)
		{
			ulOutBufLen = sizeof(IP_INTERFACE_INFO);

			if (GetInterfaceInfo(pInfoInterface, &ulOutBufLen) == ERROR_INSUFFICIENT_BUFFER)
			{
				free(pInfoInterface);
				pInfoInterface = (IP_INTERFACE_INFO *)malloc(ulOutBufLen);
			}

			if ((dwRetVal = GetInterfaceInfo(pInfoInterface, &ulOutBufLen)) != NO_ERROR)
			{
				//				printf("GetInterfaceInfo failed with error: %d\n", dwRetVal);

				//				printf("Num Adapters: %ld\n", pInfoInterface->NumAdapters);

				//				for (i=0; i < (int) pInfoInterface->NumAdapters; i++) 
				//				{
				//				  printf("\tAdapter Index[%d]: %ld\n", i, pInfoInterface->Adapter[i].Index);
				//				  printf("\tAdapter Name[%d]:  %ws\n\n", i, pInfoInterface->Adapter[i].Name);
				//				}
				TempNetworkAdapterID = _T("Network Card not found");		// looks like \Device\TCPIP_{581C255B-15F5-4B70-A7D8-5277BA72B4A9} if found
			}
			else
			{
				//				TempNetworkAdapterID = (LPBYTE)(pInfoInterface->Adapter[0].Name);		// looks like \Device\TCPIP_{581C255B-15F5-4B70-A7D8-5277BA72B4A9}
				// convert from wchar to *char
				//char aTempString[128];
				//size_t vTempStringALength = wcslen((pInfoInterface->Adapter[0].Name)) + 1;
				//const size_t vTempNewSize = 100;
				//size_t vTempConvertedChars = 0;
				//wcstombs_s(&vTempConvertedChars, aTempString, vTempStringALength, (pInfoInterface->Adapter[0].Name), _TRUNCATE);
				//				LPTSTR	 TempNetworkAdapterID;
				TempNetworkAdapterID = pInfoInterface->Adapter[0].Name;
				//				printf("GetInterfaceInfo succeeded.\n");
			}
		}
		if (pInfoInterface)
			free(pInfoInterface);

		//important - in install files use "Read_IP_Address.Exe to get the adaptor ID
		vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces\\{581C255B-15F5-4B70-A7D8-5277BA72B4A9}";

		// seavo motherboard
		if (TempNetworkAdapterID == _T("\\Device\\TCPIP_{E4370063-F18F-439F-B54A-B9F8D4ECE26B}"))
		{
			vGlobalNetworkBoardCode = "WindowsXP Seavo MB";
		//		vGlobalNetworkBoardCode = "WindowsXP Seavo MB";		//kjh 5/4/10 added {} in string below
			vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces\\{E4370063-F18F-439F-B54A-B9F8D4ECE26B}";
		}
		else 
		if (TempNetworkAdapterID == _T("\\Device\\TCPIP_{4E998AA0-D1C5-4B8A-80B2-D97F82C6F1F5}"))
		{
			vGlobalNetworkBoardCode = "WindowsXP Brian Dev old";  //kjh 5/4/10 added {} in string below
		//		vGlobalNetworkBoardCode = "WindowsXP Brian Dev";  //kjh 5/4/10 added {} in string below
			vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\{4E998AA0-D1C5-4B8A-80B2-D97F82C6F1F5}\\Parameters\\TCPIP";
		}
		else 
		if (TempNetworkAdapterID == _T("\\DEVICE\\TCPIP_{6B0B1599-B187-47CB-97A2-4F500E9BD2AB}"))
		{
			vGlobalNetworkBoardCode = "WindowsXP Brian Dev";  //kjh 5/4/10 added {} in string below
		//		vGlobalNetworkBoardCode = "WindowsXP Brian Dev";  //kjh 5/4/10 added {} in string below
			vGlobalRegistryKeyPath = "SYSTEM\\CurrentControlSet\\Services\\{6B0B1599-B187-47CB-97A2-4F500E9BD2AB}\\Parameters\\TCPIP";
		}
		else
			 
		{
			vGlobalNetworkBoardCode = " WindowsXP DEV BD";	//kjh 5/3/10 added {} in string below
		}
	}	
}

	// set the local computer with the values in vGlobalIPAddressString, vGlobalIPDefaultGatewayString, vGlobalIPSubNetMaskString, vGlobalIPDHCPEnabled
	// 9/11/2009
	// if windows xp, dont need to reboot use cmd and netsh
	// for dynamic
	// netsh interface ip set address name="Local Area Connection" dhcp > save.txt
	//			  <<<puts output in save.txt
	// for static
	// netsh interface ip set address name="Local Area Connection" static 192.168.1.48 255.255.255.0 192.168.1.1 1 > save.txt
	//				  <<<puts output in save.txt
	//
void CScanTracDlg::SetIPSettingsInRegistryAndReboot()
{
	if (vGlobalPCRunningWindowsXP == cWindows7)
		vLanAdaptorIDString = "Local Area Connection 3";

	if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
	{
		CRegKey TempRegistryKey;
		long TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, vGlobalRegistryKeyPath);

		if (TempErrorCode == ERROR_SUCCESS)
		{
			ATLASSERT(TempRegistryKey.m_hKey != NULL);
				
			if (vConfigurationData->vIPDHCPEnabled) 
			{//dynamic addressing
					//clear static ip adressing info
				vConfigurationData->vIPDHCPEnabled = true;
				vConfigurationData->vIPAddressString = "0.0.0.0";
				vConfigurationData->vIPDefaultGatewayString = "";
				vConfigurationData->vIPSubNetMaskString = "0.0.0.0";

				vGlobalIPAddressString =		"IP Address Not Read ";	//need to start with initial lengths for strings
				vGlobalIPSubNetMaskString =		"Mask Not Read       ";
				vGlobalIPDefaultGatewayString =	"Gateway Not Read    ";
		
					//set dynamic
				long TempSuccess = TempRegistryKey.SetDWORDValue(_T("EnableDHCP"), 1);
				ReportErrorMessage("Set EnableDHCP to true for dynamic: " + dtoa(TempSuccess),cUserChanges, 0);//write to inpsx message

				// if (TempSuccess == ERROR_SUCCESS)  //set the IP Address to nothing if set to use DHCP
				{
					LPTSTR TempKeyString = _T("IPAddress");
					CString TempDefaultIPAddressString = "0.0.0.0";
					TempDefaultIPAddressString = TempDefaultIPAddressString + (char)0x00 + (char)0x00;
					LPTSTR TempString = TempDefaultIPAddressString.GetBuffer(TempDefaultIPAddressString.GetLength());
					BYTE TempLength = TempDefaultIPAddressString.GetLength();
	//type is REG_BINARY, REG_DWORD, or REG_MULTI_SZ, or REG_SZ
					TempSuccess = RegSetValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, REG_MULTI_SZ, (BYTE * const)TempString, TempLength);
				}

				//if (TempSuccess == ERROR_SUCCESS)  //set the Mask to nothing if set to use DHCP
				{
					LPTSTR TempKeyString = _T("SubnetMask");
					CString TempDefaultMaskString = "0.0.0.0";
					TempDefaultMaskString = TempDefaultMaskString + (char)0x00 + (char)0x00;
					LPTSTR TempString = TempDefaultMaskString.GetBuffer(TempDefaultMaskString.GetLength());
					BYTE TempLength = TempDefaultMaskString.GetLength();

					TempSuccess = RegSetValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, REG_MULTI_SZ, (BYTE * const)TempString, TempLength);
				}

				//if (TempSuccess == ERROR_SUCCESS)  //set the IP Address to nothing if set to use DHCP
				{
					ATLASSERT(TempRegistryKey.m_hKey != NULL);
					LPTSTR TempKeyString = _T("DefaultGateway");
					CString TempDefaultGatewayString = "0.0.0.0";
					TempDefaultGatewayString = TempDefaultGatewayString + (char)0x00 + (char)0x00;
					LPTSTR TempString = TempDefaultGatewayString.GetBuffer(TempDefaultGatewayString.GetLength());
					BYTE TempLength = TempDefaultGatewayString.GetLength();

					TempSuccess = RegSetValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, REG_MULTI_SZ, (BYTE * const)TempString, TempLength);
				}

				if (TempSuccess == ERROR_SUCCESS)
				{
					CYesNoDialog TempYesNoDialog;
					TempYesNoDialog.vNoticeText = _T("Network Dynamic Addressing\nset in Registry\nYou Must Reboot for this to take effect.\nReboot Now?");
					TempYesNoDialog.vYesButtonText = "Reboot Now!";
					TempYesNoDialog.vNoButtonText = "Reboot Later";
					TempYesNoDialog.vQuestionType = cConfirmQuestion;
					int TempResult = TempYesNoDialog.DoModal();
					if (TempResult == IDOK)
					{
						WriteConfigurationDataToFile(false);
						SystemShutDown(cReboot);
					}
				}
				else
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n\nFailed to set Network Dynamic Addressing in Registry";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
			}		//end set dynamic for windows NT
			else //NT Static
			{
				long TempSuccess = TempRegistryKey.SetDWORDValue(_T("EnableDHCP"), (DWORD)0);
				ReportErrorMessage("Set EnableDHCP to false for static: " + dtoa(TempSuccess),cUserChanges, 0);//write to inpsx message

					//remove dynamic info
				LPTSTR TempKeyString = _T("DhcpDefaultGateway");
				TempSuccess = RegDeleteValue(TempRegistryKey.m_hKey, TempKeyString);

				TempKeyString = _T("DhcpIPAddress");
				TempSuccess = RegDeleteValue(TempRegistryKey.m_hKey, TempKeyString);

				TempKeyString = _T("DhcpSubnetMask");
				TempSuccess = RegDeleteValue(TempRegistryKey.m_hKey, TempKeyString);

				TempKeyString = _T("DhcpSubnetMaskOpt");
				TempSuccess = RegDeleteValue(TempRegistryKey.m_hKey, TempKeyString);

				TempKeyString = _T("Lease");
				TempSuccess = RegDeleteValue(TempRegistryKey.m_hKey, TempKeyString);

				TempKeyString = _T("LeaseObtainedTime");
				TempSuccess = RegDeleteValue(TempRegistryKey.m_hKey, TempKeyString);

				TempKeyString = _T("LeaseTerminatesTime");
				TempSuccess = RegDeleteValue(TempRegistryKey.m_hKey, TempKeyString);

					//set ip address
				TempKeyString = _T("IPAddress");
				vConfigurationData->vIPDHCPEnabled = true;
				CString TempIPAddressString = vConfigurationData->vIPAddressString + (char)0x00  + (char)0x00;
				LPTSTR TempString = TempIPAddressString.GetBuffer(TempIPAddressString.GetLength());
				BYTE TempLength = TempIPAddressString.GetLength();

				TempSuccess = RegSetValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, REG_MULTI_SZ, (BYTE * const)TempString, TempLength);
				
				if (TempSuccess != ERROR_SUCCESS)
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n\nError, Failed to set IP Address in Registry";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
				
					//set subnet mask
				TempKeyString = _T("SubnetMask");
				CString TempIPSubNetMaskString = vConfigurationData->vIPSubNetMaskString + (char)0x00 + (char)0x00;
				TempString = TempIPSubNetMaskString.GetBuffer(TempIPSubNetMaskString.GetLength());
				TempLength = TempIPSubNetMaskString.GetLength();

				TempSuccess = RegSetValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, REG_MULTI_SZ, (BYTE * const)TempString, TempLength);
				
				if (TempSuccess != ERROR_SUCCESS)
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n\nError, Failed to set Subnet Mask in Registry";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}

					//set default gateway
				TempKeyString = _T("DefaultGateway");
				CString TempIPDefaultGatewayString = vConfigurationData->vIPDefaultGatewayString + (char)0x00  + (char)0x00;
				TempString = TempIPDefaultGatewayString.GetBuffer(TempIPDefaultGatewayString.GetLength());
				TempLength = TempIPDefaultGatewayString.GetLength();
				
				TempSuccess = RegSetValueEx(TempRegistryKey.m_hKey, TempKeyString, NULL, REG_MULTI_SZ, (BYTE * const)TempString, TempLength);
				
				if (TempSuccess != ERROR_SUCCESS)
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n\nError, Failed to set Default Gateway in Registry";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
				
				else
				{
					CYesNoDialog TempYesNoDialog;
					TempYesNoDialog.vNoticeText = _T("IP Address, Subnet Mask and Default Gateway\nset in Registry\nYou Must Reboot for this to take effect.\nReboot Now?");
					TempYesNoDialog.vYesButtonText = "Reboot Now!";
					TempYesNoDialog.vNoButtonText = "Reboot Later";
					TempYesNoDialog.vQuestionType = cConfirmQuestion;
					int TempResult = TempYesNoDialog.DoModal();
					if (TempResult == IDOK)
					{
						WriteConfigurationDataToFile(false);
						SystemShutDown(cReboot);
					}
				}
			}
		}
	}
	else	// 5/5/10 kjh, if here, xp computer, system is dynamic want to send correct command to cmd.exe
	{
		if (vConfigurationData->vIPDHCPEnabled) 
		{//dynamic addressing
			CString vOutputTextString = " ";
			DeleteFile(_T("c:\\ScanTracLogs\\TCPIPdynamic.bat"));

			//check if batch file exists, if so no need to rewrite it
			//If CreateFile() successfully creates the file, a valid HANDLE to that Win32 file object is returned; otherwise, INVALID_HANDLE_VALUE is returned

			HANDLE hBatchFileTCPIPupdate = CreateFile(_T("\\ScanTracLogs\\TCPIPdynamic.bat"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ |FILE_SHARE_WRITE, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);
			// file contents below
			//netsh interface ip set address name="Local Area Connection" dhcp 
			//netsh interface ip set dns name="Local Area Connection" dhcp
			//ipconfig /renew 
			if (hBatchFileTCPIPupdate != INVALID_HANDLE_VALUE) // returns invalid handle if doesn't open, don't need ((ErrorMsg = GetLastError()) != ERROR_FILE_EXISTS))
			{	// if file does not exist, write it 
				CString BufferToWrite = _T("@ECHO OFF\n");
				BufferToWrite += _T("title Configuring Network . . . Please wait until window closes\n");
				BufferToWrite += _T("cls\n");
				//BufferToWrite += _T("ECHO Configuring Network . . . Please wait until window closes\n");
				//BufferToWrite += _T("@ECHO ON\n");
				BufferToWrite += _T("netsh interface ip set address name=");
				BufferToWrite += (char)0x22;
				BufferToWrite +=  vLanAdaptorIDString; //_T("Local Area Connection") ;
				BufferToWrite += (char)0x22;
				BufferToWrite +=  _T(" dhcp \n");
				BufferToWrite +=  _T("netsh interface ip set dns name=");
				BufferToWrite += (char)0x22;
				BufferToWrite +=  vLanAdaptorIDString; //_T("Local Area Connection") ;
				BufferToWrite += (char)0x22;
				BufferToWrite +=  _T(" dhcp\n");
				BufferToWrite +=  _T("netsh interface ip reset c:\\ScanTracLogs\\resetlog.txt\n");
				BufferToWrite += _T("netsh interface ip set address name=");
				BufferToWrite += (char)0x22;
				BufferToWrite +=  vLanAdaptorIDString; //_T("Local Area Connection") ;
				BufferToWrite += (char)0x22;
				BufferToWrite +=  _T(" dhcp \n");
				BufferToWrite += _T("@ECHO OFF\n");
				BufferToWrite += _T("ECHO Renewing IP Address . . . Please wait until window closes\n");
				//BufferToWrite += _T("@ECHO ON\n");
				BufferToWrite += _T("ipconfig /renew \n \0\0");

				DWORD BytesToWrite = BufferToWrite.GetLength();
				DWORD BytesWritten; 
			
				CW2A TempStringToWrite(BufferToWrite);
				WriteFile(hBatchFileTCPIPupdate, TempStringToWrite, BytesToWrite, &BytesWritten, NULL);					
			}
			CloseHandle(hBatchFileTCPIPupdate);

			CFileStatus TempFileStatus;
			Sleep(100);
			WORD TimeOut = 0;
			while ((((!CFile::GetStatus(_T("C:\\ScanTracLogs\\TCPIPstatic.bat"), TempFileStatus))) || (TempFileStatus.m_size == 0)) && (TimeOut < 100))
			{
				Sleep(100);
				TimeOut++;
			}

			// file name below must match file created above
			int TempError = _spawnl(_P_NOWAIT, "C:\\ScanTracLogs\\TCPIPdynamic.bat", "C:\\ScanTracLogs\\TCPIPdynamic.bat", NULL);
			
			// pause for task to complete
			Sleep(1000);
			if (errno)
			{
					LPVOID ErrorMsgBuf;
					vOutputTextString.Format(_T("Could Not Run TCPIP update: Error %d.  \n"),errno);

					FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,NULL, GetLastError(), 
												MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &ErrorMsgBuf,0,NULL);

					vOutputTextString = vOutputTextString + (LPTSTR) ErrorMsgBuf;

					LocalFree(ErrorMsgBuf);
			}
			else
			{
					vOutputTextString.Format(_T("\nUpdated TCPIP values\n\nNetwork Address Display will update over\nnext 30 seconds as networking established"));
					vGlobalIPAddressString = vConfigurationData->vIPAddressString;
					vGlobalIPSubNetMaskString = vConfigurationData->vIPSubNetMaskString;
					vGlobalIPDefaultGatewayString = vConfigurationData->vIPDefaultGatewayString;
					vGlobalIPDNSAddressString1 = vConfigurationData->vIPDefaultDNSAddressString;
					vGlobalIPDHCPEnabled = vConfigurationData->vIPDHCPEnabled;
			}

			// delay for ip update . . . using interaction with user					
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = vOutputTextString ;
			TempNoticeDialog.vType = cInformationMessage;

			TempNoticeDialog.DoModal();
			ReportErrorMessage("Changed IP Address to Dynamic Addressing (DHCP)", cUserAction, 0);
			CheckIPSettingsAndDisplayInHelpDialog(false);		//for debug help in XP write new ip values to help diag
		}		// end dynamic for xp and nt
		else
		{// 5/5/10 kjh, if here system is static want to send correct command to cmd.exe for windows xp
			DeleteFile(_T("c:\\ScanTracLogs\\TCPIPstatic.bat"));
			CString vOutputTextString = "-";
			CString vOutput2TextString = "-";

			//rewrite batch file with correct ip information
			//If CreateFile() successfully creates the file, a valid HANDLE to that Win32 file object is returned; otherwise, INVALID_HANDLE_VALUE is returned
			HANDLE hBatchFileTCPIPupdate = CreateFile(_T("\\ScanTracLogs\\TCPIPstatic.bat"), GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ |FILE_SHARE_WRITE, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);

			// below three lines of batch file always change static ip address correctly
			//netsh interface ip reset resetlog.txt
			//netsh interface ip set address name="Local Area Connection" static 192.168.1.47 255.255.255.0 192.168.1.1 1
			//netsh interface ip set dns name="Local Area Connection" static 208.67.222.222

			if (hBatchFileTCPIPupdate != INVALID_HANDLE_VALUE) // returns invalid handle if doesn't open, don't need ((ErrorMsg = GetLastError()) != ERROR_FILE_EXISTS))
			{	// if file does exist, over write it with current ip values
				CString BufferToWrite = _T("@ECHO OFF\n");
				BufferToWrite += _T("\ntitle Configuring Network . . . Please wait until window closes\n");
				BufferToWrite += _T("\ncls\n");
				//BufferToWrite += _T("ECHO Configuring Network . . . Please wait until window closes\n");
				//BufferToWrite += _T("@ECHO ON\n");
				BufferToWrite += _T("netsh interface ip reset c:\\ScanTracLogs\\resetlog.txt\n");
				BufferToWrite += _T("netsh interface ip set address name=");
				BufferToWrite += (char)0x22;
				BufferToWrite += vLanAdaptorIDString; //_T("Local Area Connection") ;
				BufferToWrite += (char)0x22;
				BufferToWrite += _T(" static ");
				BufferToWrite += vConfigurationData->vIPAddressString;
				BufferToWrite += (char)0x20;
				BufferToWrite += vConfigurationData->vIPSubNetMaskString;
				BufferToWrite += (char)0x20;
				BufferToWrite += vConfigurationData->vIPDefaultGatewayString;
				BufferToWrite += _T(" 1 \n") ;				// > c:\\ScanTracLogs\\tcpip_info.txt \0\0") ;		//\0\0 add nulls ??
				CString TempDNSArray[10];
				BYTE TempCurrentIndex = 0;
				vConfigurationData->vIPDefaultDNSAddressString = vGlobalIPDNSAddressString1;
				TempDNSArray[TempCurrentIndex] = vConfigurationData->vIPDefaultDNSAddressString;

				int TempGoogle1Position = vConfigurationData->vIPDefaultDNSAddressString.Find(_T("8.8.8.8"), 0);
				int TempGoogle2Position = vConfigurationData->vIPDefaultDNSAddressString.Find(_T("8.8.4.4"), 0);

				int TempPosition = TempDNSArray[TempCurrentIndex].Find(',', 0);
				while (TempPosition > 5)
				{
					TempDNSArray[TempCurrentIndex + 1] = TempDNSArray[TempCurrentIndex].Right(TempDNSArray[TempCurrentIndex].GetLength() - TempPosition - 1);
					TempDNSArray[TempCurrentIndex] = TempDNSArray[TempCurrentIndex].Left(TempPosition);
					TempCurrentIndex++;
					TempPosition = TempDNSArray[TempCurrentIndex].Find(',', 0);
				}
				if (TempGoogle1Position == -1)
				{
					TempCurrentIndex++;
					TempDNSArray[TempCurrentIndex] = "8.8.8.8";
				}
				if (TempGoogle2Position == -1)
				{
					TempCurrentIndex++;
					TempDNSArray[TempCurrentIndex] = "8.8.4.4";
				}
				TempCurrentIndex++;
				TempDNSArray[TempCurrentIndex].Empty();

				TempCurrentIndex = 0;
				while ((!TempDNSArray[TempCurrentIndex].IsEmpty()) && (TempCurrentIndex < 9))
				{
					if (!TempCurrentIndex) //first DNS Server
					{
						BufferToWrite += _T("netsh interface ip set dns name=");
						BufferToWrite += (char)0x22;
						BufferToWrite += vLanAdaptorIDString; //_T("Local Area Connection") ;
						BufferToWrite += (char)0x22;
						BufferToWrite += _T(" static ");
						BufferToWrite += TempDNSArray[TempCurrentIndex];
					}
					else
					{
						//write the other DNS Servers
						BufferToWrite += _T("\n") ;				// > cLogDirectory + tcpip_info.txt \0\0") ;		//\0\0 add nulls ??
						BufferToWrite += _T("netsh interface ip add dns ");
						BufferToWrite += (char)0x22;
						BufferToWrite += vLanAdaptorIDString; //_T("Local Area Connection") ;
						BufferToWrite += (char)0x22; // double quote
						BufferToWrite += (char)0x20; //space
						BufferToWrite += TempDNSArray[TempCurrentIndex];
					}
					TempCurrentIndex++;
				}

				BufferToWrite += _T("\n \0\0") ;				// > c:\\ScanTracLogs\\tcpip_info.txt \0\0") ;		//\0\0 add nulls ??
				DWORD BytesToWrite = BufferToWrite.GetLength();
				DWORD BytesWritten; 
			
				CW2A TempStringToWrite(BufferToWrite);
				WriteFile(hBatchFileTCPIPupdate, TempStringToWrite, BytesToWrite, &BytesWritten, NULL);
			}
			CloseHandle(hBatchFileTCPIPupdate);

			CFileStatus TempFileStatus;
			Sleep(100);
			BYTE TimeOut = 0;
			while ((((!CFile::GetStatus(_T("C:\\ScanTracLogs\\TCPIPstatic.bat"), TempFileStatus))) || (TempFileStatus.m_size == 0)) && (TimeOut < 100))
			{
				Sleep(100);
				TimeOut++;
			}

			//filename for batchfile below must match batch file created above
			int TempError = _spawnl(_P_NOWAIT, "C:\\ScanTracLogs\\TCPIPstatic.bat", "C:\\ScanTracLogs\\TCPIPstatic.bat", NULL);
			
			// pause for task to complete
			if (errno)
			{
					LPVOID ErrorMsgBuf;
					vOutputTextString.Format(_T("Could Not Run TCPIP update: Error %d.  \n"),errno);

					FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,NULL, GetLastError(), 
												MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &ErrorMsgBuf,0,NULL);

					vOutputTextString = vOutputTextString + (LPTSTR) ErrorMsgBuf;

					LocalFree(ErrorMsgBuf);
			}
			else
			{
					vOutputTextString.Format(_T("\nUpdated TCPIP values\n\nNetwork Address Display will update over\nnext 30 seconds as networking established"));
									//set static data
					// kjh 5/12/10
					vGlobalIPDHCPEnabled = vConfigurationData->vIPDHCPEnabled;
					vGlobalIPAddressString = vConfigurationData->vIPAddressString;
					vGlobalIPSubNetMaskString = vConfigurationData->vIPSubNetMaskString;
					vGlobalIPDefaultGatewayString = vConfigurationData->vIPDefaultGatewayString;
					vGlobalIPDNSAddressString1 = vConfigurationData->vIPDefaultDNSAddressString;
					ReportErrorMessage("Changed IP Address to Static Addressing: " + vConfigurationData->vIPAddressString, cUserChanges, 0);
			}

			// delay for ip update . . . using interaction with user					
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = vOutputTextString ;
			TempNoticeDialog.vType = cInformationMessage;

			TempNoticeDialog.DoModal();
			CheckIPSettingsAndDisplayInHelpDialog(false);	// for debug help in XP
		}	//end static for xp
	}	//end else for static or dynamic selection 
}

// for debugging problems with TCPIP in XP, in general not needed
void CScanTracDlg::CheckIPSettingsAndDisplayInHelpDialog(bool TempDisplayInHelpDialog)
{
	CString vOutputTextString = " ";
	if (vGlobalPCRunningWindowsXP == cWindowsNT)	// netsh sets regedit for xp
	{
		vOutputTextString = "Could Not IP status from Registry";
		GetCurrentMachineIPAddressValuesFromRegistry();

		if ((vGlobalNetworkBoardCode != "Unknown") && (vGlobalRegistryKeyPath != "Unknown"))
		{
			vOutputTextString = "\n\nMother Board Network Type: " + vGlobalNetworkBoardCode
				+ "\nRegistry Path: " + vGlobalRegistryKeyPath;

			if (vGlobalIPDHCPEnabled)
			{
				vOutputTextString = vOutputTextString + "\n\nWindows IP Settings"
					+ "\n    " + vGlobalDHCPString[vGlobalIPDHCPEnabled] 
					+ "\n    DHCP IP Address: " + vGlobalIPAddressString
					+ "\n    DHCP SubNet Mask: " + vGlobalIPSubNetMaskString
					+ "\n    DHCP Default Gateway: " + vGlobalIPDefaultGatewayString;
			}
			else
			{
				vOutputTextString = vOutputTextString + "\n\nWindows IP Settings"
					+ "\n    " + vGlobalDHCPString[vGlobalIPDHCPEnabled]
					+ "\n    IP Address: " + vGlobalIPAddressString
					+ "\n    SubNet Mask: " + vGlobalIPSubNetMaskString
					+ "\n    Default Gateway: " + vGlobalIPDefaultGatewayString
					+ "\n    Default DNS: " + vGlobalIPDNSAddressString1;
			}

			if ((vGlobalIPDHCPEnabled == vConfigurationData->vIPDHCPEnabled) && (vGlobalIPAddressString == vConfigurationData->vIPAddressString) && 
				(vGlobalIPSubNetMaskString == vConfigurationData->vIPSubNetMaskString) && (vGlobalIPDefaultGatewayString == vConfigurationData->vIPDefaultGatewayString))
			{
				vOutputTextString = vOutputTextString + "\n\n    ScanTrac IP Settings are the same as Windows";
			}
			else
			if (vConfigurationData->vIPDHCPEnabled)
				vOutputTextString = vOutputTextString + "\n\nScanTrac IP Settings\n    Dynamic";
			else
				vOutputTextString = vOutputTextString + "\n\nScanTrac IP Settings\n    Static";

			vOutputTextString = vOutputTextString + "\n\n    IP Address: " + vConfigurationData->vIPAddressString
				+ "\n    SubNet Mask: " + vConfigurationData->vIPSubNetMaskString
				+ "\n    Default Gateway: " + vConfigurationData->vIPDefaultGatewayString;
		}
	}
	else
	{//windows XP
/* use different read ip settings kjh 2/23/12
		DeleteFile("C:\\ScanTracLogs\\TCPIP_look.bat");
		DeleteFile("C:\\ScanTracLogs\\tcpip_rslts.txt");
		DeleteFile("C:\\ScanTracLogs\\tcpip_rslts2.txt");
		int TempLength;
		char TempChars[101];
		int LoopCount;
		CString FileNameToDisplay = "tcpip_rslts.txt"; 
		CString FileNameToDisplay2 = "tcpip_rslts2.txt"; 

			//check if batch file exists, if so skip creation, if not create file
		//If CreateFile() successfully creates the file, a valid HANDLE to that Win32 file object is returned; otherwise, INVALID_HANDLE_VALUE is returned
		HANDLE hBatchFileTCPIPstatus = CreateFile("c:\\ScanTracLogs\\TCPIP_look.bat", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ |FILE_SHARE_WRITE, NULL, CREATE_NEW, FILE_ATTRIBUTE_NORMAL, NULL);

		if (hBatchFileTCPIPstatus != INVALID_HANDLE_VALUE) // returns invalid handle if doesn't open, don't need ((ErrorMsg = GetLastError()) != ERROR_FILE_EXISTS))
		{	// if file does not exist, create it

			CString BufferToWrite = _T("@ECHO OFF\n");
			BufferToWrite += _T("title Reading Network Configuration.......Please wait until window closes\n");
			//BufferToWrite += _T("ECHO Reading Network Configuration . . . Please wait until window closes\n");
			//BufferToWrite += _T("@ECHO ON\n");
			BufferToWrite += _T("ipconfig > c:\\scantraclogs\\tcpip_rslts.txt \n");
			BufferToWrite += _T("netsh interface ip show config > c:\\scantraclogs\\tcpip_rslts2.txt \0\0");

			DWORD BytesToWrite = BufferToWrite.GetLength();
			DWORD BytesWritten; 
			WriteFile(hBatchFileTCPIPstatus, BufferToWrite, BytesToWrite, &BytesWritten, NULL);

		}
		CloseHandle(hBatchFileTCPIPstatus);

		Sleep(100);
		CFileStatus TempFileStatus;
		BYTE TimeOut = 0;
		while ((((!CFile::GetStatus("C:\\ScanTracLogs\\TCPIP_look.bat", TempFileStatus))) || (TempFileStatus.m_size == 0)) && (TimeOut < 100))
		{
			Sleep(100);
			TimeOut++;
		}

		//NOTE FILE NAME IN BAT MUST MATCH file name in CString FileNameToDisplay = "tcpip_status.txt"
		//NOTE DIRECTORY NAME IN BAT MUST MATCH directory name in cLogDirectory c:\ScanTracLogs
		int TempError = _spawnl(_P_NOWAIT, "\\ScanTracLogs\\TCPIP_look.bat", "\\ScanTracLogs\\TCPIP_look.bat", NULL);

		// wait for batch file to complete
		if (errno)
		{
				LPVOID ErrorMsgBuf;
				vOutputTextString.Format(_T("Could Not Run TCPIP status: Error %d.  \n"),errno);

				FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ALLOCATE_BUFFER,NULL, GetLastError(), 
											MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR) &ErrorMsgBuf,0,NULL);

				vOutputTextString = vOutputTextString + (LPTSTR) ErrorMsgBuf;

				LocalFree(ErrorMsgBuf);
		}
	//	else
	//	{
	//		vOutputTextString.Format(_T("Update TCPIP values\n"));
	//	}

		//	LPCTSTR cLogDirectory log file directory;					
		CString TempString1 = cLogDirectory + FileNameToDisplay;
		CString TempFileName = TempString1.GetBuffer(TempString1.GetLength());


		Sleep(100);
		TimeOut = 0;
		while (((!CFile::GetStatus(TempFileName, TempFileStatus)) || (TempFileStatus.m_size == 0)) && (TimeOut < 100))
		{
			Sleep(100);
			TimeOut++;
		}
		Sleep(1000);

		// NO_ERROR
		if (!(CFile::GetStatus(TempFileName, TempFileStatus)))
		{
			DWORD TempErrorNumber = GetLastError();
			vOutputTextString.Format(_T("Error reading TCP IP Update Results from ipconfig: %ld \n"),TempErrorNumber);
			ReportErrorMessage("Read IP Address Can't open file: " + TempFileName,cEMailInspx, 32000);//write to inpsx message
		}
		else
		{
			vOutputTextString ="TCP IP Update Results from ipconfig:";
			if (ThereIsEnoughMemory(sizeof(CFile), "TCP IP Log File"))
			{
				CFile TempTCPIPReportFile;
				CFileException TempException;

				if (TempTCPIPReportFile)
				if (TempTCPIPReportFile.Open(TempFileName, CFile::modeRead, &TempException ))
				{
					do
					{
						TempLength = TempTCPIPReportFile.Read(TempChars,100);
						//want only valid chars
						for(LoopCount=0; LoopCount<TempLength; LoopCount++)
							vOutputTextString += TempChars[LoopCount];
					}
					while (TempLength > 99);
					TempTCPIPReportFile.Close();
				}
				else
				{
					ReportErrorMessage("Read IP Address Can't open file2: " + TempFileName,cEMailInspx, 32000);//write to inpsx message
				}
			}
			else
			{
				vOutputTextString = "Memory too low for reading Log Directory";
				ReportErrorMessage("Read IP Address Low Memory",cEMailInspx, 32000);//write to inpsx message
			}

		}

		//	LPCTSTR cLogDirectory log file directory;					
		TempString1 = cLogDirectory + FileNameToDisplay2;
		TempFileName = TempString1.GetBuffer(TempString1.GetLength());

		CFileStatus TempFileStatus2;
		Sleep(100);
		TimeOut = 0;
		while ((((!CFile::GetStatus(TempFileName, TempFileStatus2))) || (TempFileStatus2.m_size == 0)) && (TimeOut < 100))
		{
			Sleep(100);
			TimeOut++;
		}
		Sleep(2000);

		if (!(CFile::GetStatus(TempFileName, TempFileStatus2)))
		{
			DWORD TempErrorNumber = GetLastError();
			vOutputTextString.Format(_T("Error reading TCP IP Update Results from netsh: %ld \n"),TempErrorNumber);
			ReportErrorMessage("Read IP Address Can't open file 3: " + TempFileName,cEMailInspx, 32000);//write to inpsx message
		}
		else
		{
			vOutputTextString +="\nTCP IP Update Results 2 from netsh: ";
			if (ThereIsEnoughMemory(sizeof(CFile), "TCP IP Log2 File"))
			{
				CFile TempTCPIPReportFile;
				CFileException TempException;

				if (TempTCPIPReportFile)
				if (TempTCPIPReportFile.Open(TempFileName, CFile::modeRead, &TempException ))
				{
					do
					{
						TempLength = TempTCPIPReportFile.Read(TempChars,100);
						//want only valid chars
						for(LoopCount=0; LoopCount<TempLength; LoopCount++)
							vOutputTextString += TempChars[LoopCount] ;
					}
					while (TempLength > 99);

					ParseSettingFromFileString(vOutputTextString);
					TempTCPIPReportFile.Close();

					int TempErrorPosition = vGlobalIPAddressString.Find('f',0);
					if ((TempErrorPosition < 200) && (TempErrorPosition >= 0))
					{
						vGlobalIPAddressString = "IP Not Granted";
					}
				}
				else
				{
					vOutputTextString += "\nFile did not open\n";
					ReportErrorMessage("Read IP Address Can't open file 4: " + TempFileName,cEMailInspx, 32000);//write to inpsx message
				}
			}
			else
			{
				vOutputTextString += "\nMemory too low for reading Log Directory";
				ReportErrorMessage("Read IP Address Low Memory 2",cEMailInspx, 32000);//write to inpsx message
			}

		}
	}

*/
		UseIPHelperForIPInfo();
		
		vOutputTextString = ' ';

		if (vGlobalIPDHCPEnabled)
		{
			vOutputTextString = vOutputTextString + "\n\nWindows IP Settings"
				+ "\n    " + vGlobalDHCPString[vGlobalIPDHCPEnabled] 
				+ "\n    DHCP IP Address: " + vGlobalIPAddressString
				+ "\n    DHCP SubNet Mask: " + vGlobalIPSubNetMaskString
				+ "\n    DHCP Default Gateway: " + vGlobalIPDefaultGatewayString
				+ "\n    DNS Server: " + vGlobalIPDNSAddressString1;
		}
		else
		{
			vOutputTextString = vOutputTextString + "\n\nWindows IP Settings"
				+ "\n    " + vGlobalDHCPString[vGlobalIPDHCPEnabled]
				+ "\n    IP Address: " + vGlobalIPAddressString
				+ "\n    SubNet Mask: " + vGlobalIPSubNetMaskString
				+ "\n    Default Gateway: " + vGlobalIPDefaultGatewayString
				+ "\n    Default DNS: " + vGlobalIPDNSAddressString1;
		}
	}

	if (TempDisplayInHelpDialog)
	{
		// read file in and display to text screen
		CHelpDialog * IHelpDialog;
		IHelpDialog = new(CHelpDialog);
		IHelpDialog->vHelpContext = 16;
		IHelpDialog->vHelpType = 0;
		IHelpDialog->vWindowType = cTextWindow;
		IHelpDialog->vLocalSystemData = &vSystemData;
		IHelpDialog->vMainWindowPointer = this;
		IHelpDialog->vLocalConfigurationData = vConfigurationData;
		IHelpDialog->vProductPointer = vGlobalCurrentProduct;

		IHelpDialog->vTitleString = "TCP IP update values results";
		IHelpDialog->vTextString = vOutputTextString ;
		int TempResult = IHelpDialog->DoModal();
		delete IHelpDialog;
		if (TempResult == 10)
		{
			//Main Menu button pressed
			Sleep(1); //is the equivelent of a yeild statement;
			CDialog::EndDialog(TempResult);
		}
	}
	//else
	////check if google IP Address is in for DNS server, and if not, add and set in Windows
	//if (vGlobalPCRunningWindowsXP >= cWindows7)
	//if (!vGlobalIPDHCPEnabled)
	//{
	//	int TempPosition = vGlobalIPDNSAddressString1.Find(_T("8.8.8.8"), 0);
	//	if (TempPosition < 0)
	//	{
	//		vGlobalIPDNSAddressString1 = vGlobalIPDNSAddressString1 + ", 8.8.8.8, 8.8.4.4";
	//		SetIPSettingsInRegistryAndReboot();

	//	}
	//}
}

void CScanTracDlg::UseIPHelperForIPInfo(void)
{
	CString TempString = "-";
	ULONG            ulOutBufLen = 0;
	DWORD            dwRetVal = 0;
	IP_ADAPTER_INFO  *pAdapterInfo = NULL;
	PIP_ADAPTER_INFO pAdapter;
	BOOL TempAdapterZeroIP = true;

	ulOutBufLen = sizeof(IP_ADAPTER_INFO);
	pAdapterInfo = (IP_ADAPTER_INFO *) malloc(ulOutBufLen);

	if (pAdapterInfo)
	{
		dwRetVal = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen);
		if (dwRetVal != ERROR_SUCCESS)
		{
			free(pAdapterInfo);
			pAdapterInfo = (IP_ADAPTER_INFO *)malloc(ulOutBufLen);
			dwRetVal = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen);
		}
		if (dwRetVal == ERROR_SUCCESS)
		{
			pAdapter = pAdapterInfo;

			// just get info for first network card
			while ((pAdapter) && (TempAdapterZeroIP))  // save first non zero ip address sequence
			{
				vGlobalIPAddressString = pAdapter->IpAddressList.IpAddress.String;
				if (vGlobalIPAddressString != "0.0.0.0")
				{
					TempAdapterZeroIP = false;

					vGlobalIPSubNetMaskString = pAdapter->IpAddressList.IpMask.String;

					vGlobalIPDefaultGatewayString = pAdapter->GatewayList.IpAddress.String;

					if (pAdapter->DhcpEnabled)
					{
						vGlobalIPDHCPEnabled = 1;
						vGlobalIPDHCPServer = pAdapter->DhcpServer.IpAddress.String;
						ReportErrorMessage("Read IP Address is Dynamic(DHCP): " + vGlobalIPAddressString, cAction, 0);
					}
					else
					{
						vGlobalIPDHCPEnabled = 0;
						ReportErrorMessage("Read IP Address is Static: " + vGlobalIPAddressString, cAction, 0);
					}
				}
				pAdapter = pAdapter->Next;
			}	// end while loop
		}
		else
			ReportErrorMessage("Failed to Read IP Address", cEMailInspx, 32000);
	}
	if (pAdapterInfo)
		free(pAdapterInfo);

// get DNS server information
	// iphelper usage
	FIXED_INFO *pFixedInfo;
	IP_ADDR_STRING *pIPAddr;
	// above ULONG ulOutBufLen;
	// above DWORD dwRetVal;
	
	pFixedInfo = (FIXED_INFO *) malloc(sizeof (FIXED_INFO));
	if (pFixedInfo)
	{
		ulOutBufLen = sizeof(FIXED_INFO);

		if (GetNetworkParams(pFixedInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW)
		{
			free(pFixedInfo);
			pFixedInfo = (FIXED_INFO *)malloc(ulOutBufLen);
			//			if (pFixedInfo == NULL) 
			//			{
			//				_tprintf(_T("Error allocating memory needed to call GetNetworkParams\n"));
			//			}
		}

		if (pFixedInfo != NULL)
		{
			if (dwRetVal = GetNetworkParams(pFixedInfo, &ulOutBufLen) != NO_ERROR)
			{
				//			printf("GetNetworkParams failed with error %d\n", dwRetVal);
				free(pFixedInfo);
			}
			else	// read GetNetworkParams
			{
				//	printf("\tHost Name: %s\n", pFixedInfo->HostName);
				//	printf("\tDomain Name: %s\n", pFixedInfo->DomainName);
				//	printf("\tDNS Servers:\n");
				//	printf("\t\t%s\n", pFixedInfo->DnsServerList.IpAddress.String);

				vGlobalIPDNSAddressString1 = pFixedInfo->DnsServerList.IpAddress.String;

				pIPAddr = pFixedInfo->DnsServerList.Next;
				while (pIPAddr)
				{
					//	printf("\t\t%s\n", pIPAddr->IpAddress.String);
					// add to vGlobalIPDNSAddressString1, comma delimited
					vGlobalIPDNSAddressString1 = vGlobalIPDNSAddressString1 + ',' + ' ' + (pIPAddr->IpAddress.String);
					pIPAddr = pIPAddr->Next;
				}
			}
		}
		else
		{
			ReportErrorMessage("Failed to Read IP Address", cEMailInspx, 32000);
		}
	}
	if (pFixedInfo) 
		free(pFixedInfo);
}

// added kjh 3/6/2012 for easier ip read
/*
void CScanTracDlg::UseIPHelperForIPInfo(void)
{
	CString TempString = "-";
	ULONG            ulOutBufLen = 0;
	DWORD            dwRetVal = 0;
	IP_ADAPTER_INFO  *pAdapterInfo = NULL;
	PIP_ADAPTER_INFO pAdapter;

	ulOutBufLen = sizeof(IP_ADAPTER_INFO);
	pAdapterInfo = (IP_ADAPTER_INFO *) malloc(ulOutBufLen);

	dwRetVal = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen);
	if (dwRetVal != ERROR_SUCCESS) 
	{
		free (pAdapterInfo);
		pAdapterInfo = (IP_ADAPTER_INFO *) malloc ( ulOutBufLen );
		dwRetVal = GetAdaptersInfo(pAdapterInfo, &ulOutBufLen);
	}
	if (dwRetVal == ERROR_SUCCESS) 
	{
		pAdapter = pAdapterInfo;

		// just get info for first network card
	//	while (pAdapter)
	//	{
	//		printf("Adapter Name: %s\n", pAdapter->AdapterName);
	//		printf("Adapter Desc: %s\n", pAdapter->Description);
	//		printf("\tAdapter Addr: \t");
	//		for (UINT i = 0; i < pAdapter->AddressLength; i++) 
	//		{
	//			if (i == (pAdapter->AddressLength - 1))
	//				printf("%.2X\n",(int)pAdapter->Address[i]);
	//			else
	//				printf("%.2X-",(int)pAdapter->Address[i]);
	//		}
	//		printf("IP Address: %s\n", pAdapter->IpAddressList.IpAddress.String);

			vGlobalIPAddressString = pAdapter->IpAddressList.IpAddress.String;

	//		printf("IP Mask: %s\n", pAdapter->IpAddressList.IpMask.String);

			vGlobalIPSubNetMaskString = pAdapter->IpAddressList.IpMask.String;

	//		printf("\tGateway: \t%s\n", pAdapter->GatewayList.IpAddress.String);

			vGlobalIPDefaultGatewayString = pAdapter->GatewayList.IpAddress.String;

	//		printf("\t***\n");
	//		if (pAdapter->DhcpEnabled) 
	//		{
	//			printf("\tDHCP Enabled: Yes\n");
	//			printf("\t\tDHCP Server: \t%s\n", pAdapter->DhcpServer.IpAddress.String);
	//		}
	//		else
	//		{
	//		  printf("\tDHCP Enabled: No\n");
	//		}
		if (pAdapter->DhcpEnabled) 
		{
			vGlobalIPDHCPEnabled = true;
			vGlobalIPDHCPServer = pAdapter->DhcpServer.IpAddress.String;
			ReportErrorMessage("Read IP Address is Dynamic Addressing (DHCP): " + vGlobalIPAddressString, cAction, 0);
		}
		else
		{
			vGlobalIPDHCPEnabled = false;
			ReportErrorMessage("Read IP Address is Static Addressing: " + vGlobalIPAddressString, cAction, 0);
		}


	//	  pAdapter = pAdapter->Next;
	//	}	// end while loop
	
		if (pAdapterInfo)
		{
				free(pAdapterInfo);
		}
	}

// get DNS server information
	// iphelper usage
	FIXED_INFO *pFixedInfo;
	IP_ADDR_STRING *pIPAddr;
	// above ULONG ulOutBufLen;
	// above DWORD dwRetVal;
	
	pFixedInfo = (FIXED_INFO *) malloc(sizeof (FIXED_INFO));
	ulOutBufLen = sizeof (FIXED_INFO);
	
	if (GetNetworkParams(pFixedInfo, &ulOutBufLen) == ERROR_BUFFER_OVERFLOW) 
	{
		free(pFixedInfo);
		pFixedInfo = (FIXED_INFO *) malloc(ulOutBufLen);
//			if (pFixedInfo == NULL) 
//			{
//				_tprintf(_T("Error allocating memory needed to call GetNetworkParams\n"));
//			}
	}

	if (pFixedInfo != NULL) 
	{	
		if (dwRetVal = GetNetworkParams(pFixedInfo, &ulOutBufLen) != NO_ERROR) 
		{
//			printf("GetNetworkParams failed with error %d\n", dwRetVal);
			free(pFixedInfo);
		}
		else	// read GetNetworkParams
		{
			//	printf("\tHost Name: %s\n", pFixedInfo->HostName);
			//	printf("\tDomain Name: %s\n", pFixedInfo->DomainName);
			//	printf("\tDNS Servers:\n");
			//	printf("\t\t%s\n", pFixedInfo->DnsServerList.IpAddress.String);
		
			vGlobalIPDNSAddressString1 = pFixedInfo->DnsServerList.IpAddress.String;

			pIPAddr = pFixedInfo->DnsServerList.Next;
			while (pIPAddr) 
			{
			//	printf("\t\t%s\n", pIPAddr->IpAddress.String);
			// add to vGlobalIPDNSAddressString1, comma delimited
				vGlobalIPDNSAddressString1 = vGlobalIPDNSAddressString1 + ',' + ' ' + (pIPAddr->IpAddress.String) ;
				pIPAddr = pIPAddr->Next;
			}

			if (pFixedInfo) 
			{
				free(pFixedInfo);
			}
		}
	}
}
*/
void CScanTracDlg::VerifyScanTracIPAddress()
{
	//GetCurrentMachineIPAddressValuesFromRegistry();

	if (((vGlobalNetworkBoardCode == "Unknown") || (vGlobalRegistryKeyPath == "Unknown")) && (vGlobalPCRunningWindowsXP == cWindowsNT))	// netsh sets regedit for xp
	{
		//9/11/2009
		if (!vConfigurationData->vDemoMode)
		if (!vConfigurationData->vSimulateLightControlBoard)
		{
			ReportErrorMessage("Failed to determine which Network Board is active.",cEMailInspx, 32000);//write to inpsx message
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\nFailed to determine which\nNetwork Board is active in machine.\n\nCall Service.";
			TempNoticeDialog.vType = cInformationMessage;
			TempNoticeDialog.DoModal();
		}
		return;
	}
	else
	if (vConfigurationData->vIPAddressString == "")
	{
		//this is the first time this version has been run on this scantrac machine, so accept windows values
		
		vConfigurationData->vIPDHCPEnabled = vGlobalIPDHCPEnabled;
		vConfigurationData->vIPAddressString = vGlobalIPAddressString;
		vConfigurationData->vIPSubNetMaskString = vGlobalIPSubNetMaskString;
		vConfigurationData->vIPDefaultGatewayString = vGlobalIPDefaultGatewayString;
		vConfigurationData->vIPDefaultDNSAddressString = vGlobalIPDNSAddressString1;
		ReportErrorMessage("First time running new IP Address code. ScanTrac IP Address had no value. Using Windows Values.",cEMailInspx, 32000);
	}
	else
	if (vGlobalIPAddressString == "IP Not Granted")
	{
		ReportErrorMessage("Network IP Address Not Granted by Router",cAction, 0);
	}
	else
	{
		BYTE TempScanTracIPDHCPEnabled = (vConfigurationData->vIPDHCPEnabled);
		BYTE TempWindowsIPDHCPEnabled = vGlobalIPDHCPEnabled;
		
			//check if Registry values match stream values for ip Addressing variables
		if ((TempScanTracIPDHCPEnabled != TempWindowsIPDHCPEnabled) || ((TempScanTracIPDHCPEnabled == 0) && 
			((vConfigurationData->vIPAddressString != vGlobalIPAddressString) || 
			(vConfigurationData->vIPSubNetMaskString !=	vGlobalIPSubNetMaskString) || 
			(vConfigurationData->vIPDefaultGatewayString !=	vGlobalIPDefaultGatewayString))))
		{		
				//query if different
			CSelectItemDialog ISelectItemDialog;  
			bool TempChangedDiagnosticLines = false;
			ISelectItemDialog.vTitleString = "Choose IP Address Settings";
			ISelectItemDialog.m_DialogTitleStaticText2 = "Error: IP Address Conflict Detected - Select Correct Settings";
			ISelectItemDialog.m_DialogTitleStaticText3 = "IP Settings in Windows are different from IP Settings in ScanTrac Application";
			ISelectItemDialog.vBackgroundColor = cYellow;
			ISelectItemDialog.vShowExit = true;
			ISelectItemDialog.vNumberOfItems = 3;
			
				//change nothing option in query message
			ISelectItemDialog.vItems[0] = "I don't know, Don't Change Any Settings";

				//set scantrac values option in query message
			if (TempScanTracIPDHCPEnabled)
			{			
				ISelectItemDialog.vItems[1] = "ScanTrac - Dynamic";
			}
			else
			{
					ISelectItemDialog.vItems[1] = "ScanTrac-Static, IP:" + vConfigurationData->vIPAddressString 
					+ ", Mask:" + vConfigurationData->vIPSubNetMaskString 
					+ ", Gate:" + vConfigurationData->vIPDefaultGatewayString;
			}
				
				//set windows values option in query message
			if (TempWindowsIPDHCPEnabled)
			{
				ISelectItemDialog.vItems[2] = "Windows - " + vGlobalDHCPString[vGlobalIPDHCPEnabled]; //+ ", DHCPIP:" + vGlobalIPAddressString + ", DHCPM:" + vGlobalIPSubNetMaskString
					//+ ", DHCPG:" + vGlobalIPDefaultGatewayString;
			}
			else
			{
				ISelectItemDialog.vItems[2] = "Windows-" + vGlobalDHCPString[vGlobalIPDHCPEnabled] + ", IP:" + vGlobalIPAddressString + ", Mask:" + 
					vGlobalIPSubNetMaskString + ", Gateway:" + vGlobalIPDefaultGatewayString;
			}

			ReportErrorMessage(ISelectItemDialog.vItems[1],cEMailInspx, 32000);//write to inpsx message
			ReportErrorMessage(ISelectItemDialog.vItems[2],cEMailInspx, 32000);//write to inpsx message

			int nResponse = ISelectItemDialog.DoModal();
			//dialog box is now closed, if user pressed select do this
			//if user pressed cancel, do nothing
			if (nResponse == IDOK)
			{
				if (ISelectItemDialog.vItemNumberSelected == 1)	//answered 'I don't know, keep same'
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\nCall Service, \nReport IP Address Conflict on this ScanTrac.\n\nTo set later, power system off and back on.";
					TempNoticeDialog.vType = cInformationMessage;
					TempNoticeDialog.DoModal();

					ReportErrorMessage("Windows and ScanTrac IP Addresses Don't Match.  Operator chose 'Do Nothing'",cEMailInspx, 32000);//write to inpsx message
				}
				else 
				if (ISelectItemDialog.vItemNumberSelected == 2)	//answered 'use ScanTrac's streamed IP values'
				{		//set values, tell to reboot
					ReportErrorMessage("Windows and ScanTrac IP Addresses Don't Match.  Operator chose ScanTrac Values.",cEMailInspx, 32000);//write to inpsx message
					//9/11/2009

					//9/30/2009
					if (TempScanTracIPDHCPEnabled)
					{//Dynamic
						vConfigurationData->vIPAddressString = "0.0.0.0";
						vConfigurationData->vIPSubNetMaskString = "0.0.0.0";
						vConfigurationData->vIPDefaultGatewayString = "";
						vGlobalIPAddressString =		"IP Address Not Read ";	//need to start with initial lengths for strings
						vGlobalIPSubNetMaskString =		"Mask Not Read       ";
						vGlobalIPDefaultGatewayString =	"Gateway Not Read    ";
						vGlobalIPDHCPEnabled = true;
						ReportErrorMessage("Windows and ScanTrac IP Addresses Don't Match.  Operator chose ScanTrac Values, Dynamic.",cEMailInspx, 32000);//write to inpsx message
					}
					else
					{  //static
						vGlobalIPAddressString =		"IP Address Not Read ";	//need to start with initial lengths for strings
						vGlobalIPSubNetMaskString =		"Mask Not Read       ";
						vGlobalIPDefaultGatewayString =	"Gateway Not Read    ";
						vGlobalIPDNSAddressString1 =	"DNS Not Read    ";

						vGlobalIPDHCPEnabled = false;	//static/Fixed IP Addressing
						ReportErrorMessage("Windows and ScanTrac IP Addresses Don't Match.  Operator chose ScanTrac Values, Static.",cEMailInspx, 32000);//write to inpsx message
					}
					vGlobalIPDNSAddressString1 = vConfigurationData->vIPDefaultDNSAddressString;
					SetIPSettingsInRegistryAndReboot();
				}
				else
				if (ISelectItemDialog.vItemNumberSelected == 3)	//answered 'use local windows machine's IP values'
				{
					if (TempWindowsIPDHCPEnabled)	//dynamic
					{
							//save dynamic values
						vConfigurationData->vIPDHCPEnabled = vGlobalIPDHCPEnabled;
						vConfigurationData->vIPAddressString = vGlobalIPAddressString;
						vConfigurationData->vIPSubNetMaskString = vGlobalIPSubNetMaskString;
						vConfigurationData->vIPDefaultGatewayString = vGlobalIPDefaultGatewayString;
						vConfigurationData->vIPDefaultDNSAddressString = vGlobalIPDNSAddressString1;
					}
					else
					{
						//put static ip addressing info into configuration data stream
						vConfigurationData->vIPDHCPEnabled = vGlobalIPDHCPEnabled;
						vConfigurationData->vIPAddressString = vGlobalIPAddressString;
						vConfigurationData->vIPSubNetMaskString = vGlobalIPSubNetMaskString;
						vConfigurationData->vIPDefaultGatewayString = vGlobalIPDefaultGatewayString;
						vConfigurationData->vIPDefaultDNSAddressString = vGlobalIPDNSAddressString1;
					}						
					WriteConfigurationDataToFile(false);
					ReportErrorMessage("Windows and ScanTrac IP Addresses Don't Match.  Operator chose 'Windows Values'",cEMailInspx, 32000);//write to inpsx message
				}
			}
		}
	}
}

//11/23/2009
void CScanTracDlg::CheckForErrorMessages() 
{
	CMemoryException TempException;
	TRY
	{
		CString TempLastString = "None";
		while (vErrorMessageTailUIT != vErrorMessageHeadUIT)
		{
			BYTE TempErrorLevel = 0;
			WORD TempErrorCode = 0;
			{
				TempLastString = vTheErrorMessageStringUIT[vErrorMessageTailUIT];
				if (vSystemData.vMissedErrorMessages)
				{
					TempLastString = "*" + TempLastString;
					vSystemData.vMissedErrorMessages = false;
				}
				TempErrorLevel = vTheErrorMessageTypeUIT[vErrorMessageTailUIT];
				TempErrorCode = vTheErrorMessageCodeUIT[vErrorMessageTailUIT];
				vErrorMessageTailUIT++;
				if (vErrorMessageTailUIT >= cMaximumNumberOfErrorMessages)
					vErrorMessageTailUIT = 0;

				if (TempErrorLevel < 12)
					HandleErrorMessage(TempLastString,TempErrorLevel, TempErrorCode);
			}
		}
	}
	CATCH_ALL(TempException)
	{
	 #ifdef _DEBUG
			afxDump << "Error-Lost Error Message"  << "\n";
	 #endif
	}
	END_CATCH_ALL
}

void CScanTracDlg::CheckLearningStatus() 
{
	if (vGlobalCurrentProduct)
	if (vOldCalibrateBodyTriggerReferenceEnabled != vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled)
	{
		if (vOldCalibrateBodyTriggerReferenceEnabled)
		{
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Learn Reference Done, Calculate References",cDebugMessage);
		}
		if (vSystemData.vITIPCDig->vReferenceRightAverage)
		{
			int TempWidth = (int)(vSystemData.vITIPCDig->vReferenceRightAverage - vSystemData.vITIPCDig->vReferenceLeftAverage);
			int TempWidthDelta = (int)vGlobalCurrentProduct->vReferenceWidth - TempWidth;
			
			if ((vGlobalCurrentProduct->vReferenceRight == 0) || (TempWidthDelta > 4) || (TempWidthDelta < -4))
			{
				if ((vSystemData.vInAutoSetup) || (!vGlobalCurrentProduct->vReferenceRight) || (!vGlobalCurrentProduct->vReferenceTop))
				{
					vGlobalCurrentProduct->vReferenceRight = (int)vSystemData.vITIPCDig->vReferenceRightAverage;
					vGlobalCurrentProduct->vReferenceLeft = (int)vSystemData.vITIPCDig->vReferenceLeftAverage;
					vGlobalCurrentProduct->vReferenceTop = (int)vSystemData.vITIPCDig->vReferenceTopAverage;
					vGlobalCurrentProduct->vReferenceBottom = (int)vSystemData.vITIPCDig->vReferenceBottomAverage;
					vGlobalCurrentProduct->vReferenceWidth = (int)vGlobalCurrentProduct->vReferenceRight - vGlobalCurrentProduct->vReferenceLeft;


					if (vSystemData.vLogFile.vLogSerialData)
						vSystemData.vLogFile.WriteToLogFile("Set Reference G Right: " + dtoa(vGlobalCurrentProduct->vReferenceRight, 2) + ", Left: " + dtoa(vGlobalCurrentProduct->vReferenceLeft, 2) +
						", Width: " + dtoa(vGlobalCurrentProduct->vReferenceWidth, 2), cDebugMessage);
					//if (vGlobalCurrentProduct->vProductLockOutWidth > 
					//	(vGlobalCurrentProduct->vReferenceWidth / vGlobalPixelsPerUnit))
					//	vGlobalCurrentProduct->SetProductLockOutWidth(
					//		(float)(vGlobalCurrentProduct->vReferenceWidth / 
					//		(vGlobalPixelsPerUnit * vGlobalCurrentProduct->vOverScanMultiplier)));
				}
			}
			//start next step
			if (vConfigurationData->vAverageDisableCount)
			//if (!vSystemData.vInAutoSetup)
			{
				vSystemData.vITIPCDig->MakeAverageImageBuffer();
				vSystemData.vWrongWidthsDuringLearn = 0;
				vSystemData.vWrongBrightnessDuringLearn = 0;
				vSystemData.vRejectsDuringLearn = 0;
				vSystemData.vITIPCDig->vAverageEnabled = true;
				vOldAverageEnabled = true;
			}
			//finished finding reference location, so set all ROIs if changed size
			//if (vSystemData.vChangedSizeOfProduct)
			//{
			//	bool TempMakeInspectionsFullImage = true;
			//	if ((vGlobalScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vGlobalScanTracType == cUpSideDownSoloScanTrac))
			//		TempMakeInspectionsFullImage = false;

			//	vGlobalCurrentProduct->SetupAllInspectionROIsFromReference(vSystemData.vITIPCDig->vOriginalImage, vSystemData.vChangedSizeOfProductCheckDensityROI, TempMakeInspectionsFullImage, vSystemData.vITIPCDig->vProductAverageImage);
			//}
			//else
			{
				vGlobalCurrentProduct->CheckAllROIs(vSystemData.vITIPCDig->vProductAverageImage);
			}
			vSystemData.vChangedSizeOfProduct = false;
			vSystemData.vChangedSizeOfProductCheckDensityROI = 0;
		}
		vOldCalibrateBodyTriggerReferenceEnabled = vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled;
	}
 	if (vSystemData.vITIPCDig->vAverageEnabled != vOldAverageEnabled)
	{
		if (vOldAverageEnabled)
		{
			if (vSystemData.vITIPCDig->vAverageCount >= vConfigurationData->vAverageDisableCount)
			{
				bool TempSaveAverageNow = vSystemData.vInAutoSetup;
				if (!vSystemData.vImprovingLearn)
				if ((!vSystemData.vInAutoSetup) && (!vConfigurationData->vStructureDisableCount))
				{
					CYesNoDialog TempYesNoDialog;
					CString TempString = "\n\nUse new Learn Image Data?\n(This change is permanent if made.)";
					TempYesNoDialog.vNoticeText = TempString;
					TempYesNoDialog.vQuestionType = cConfirmSave;
					int TempResult = TempYesNoDialog.DoModal();
					//if user said OK
					if (TempResult == IDOK)
						TempSaveAverageNow = true;
					if (TempSaveAverageNow)
						ReportErrorMessage("Finished Relearn and operator saved for Product: " + vSystemData.vCurrentProductName, cUserChanges,0);
					else
						ReportErrorMessage("Finished Relearn while inspecting, but did not use for Product: " + vSystemData.vCurrentProductName, cUserChanges,0);
				}

				if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
				{  //end of collecting average, Save average image if in auto setup, or no structure, 
					if (vSystemData.vLogFile.vLogSerialData)
					{
						vSystemData.vLogFile.WriteToLogFile("Make Product Average, Average Count: " + dtoa(vSystemData.vITIPCDig->vAverageCount,0),cDebugMessage);
					}
					if (TempSaveAverageNow)
					{
						if (vSystemData.vITIPCDig->MakeProductAverageImage())
						{
							//just finished taking average learn, backup if there is one
							vSystemData.vITIPCDig->RenameAverageFileToBackup(vGlobalCurrentProduct);

							vSystemData.vITIPCDig->SaveAverageImageToFile(vGlobalCurrentProduct);
							vGlobalCurrentProduct->vSetupHistoryAverageDensity = 0;

							if (vGlobalCurrentProduct->vHistogramThreshold > 0)
								vSystemData.vITIPCDig->SaveProcess4ImageData(vGlobalCurrentProduct);

							vGlobalCurrentProduct->vSetupHistoryAverageCount = vConfigurationData->vAverageDisableCount;
							vSystemData.vITIPCDig->CalculateAverageDriftDensity(vGlobalCurrentProduct);
							vSystemData.vIndexForDriftDensityOfLastNImages = 0;
							if (vGlobalCurrentProduct->vSetupHistoryAverageDensity > 255)
								vGlobalCurrentProduct->vSetupHistoryAverageDensity = 0;
							vGlobalCurrentProduct->vSetupHistoryContainerTriggerStandardDeviation = vSystemData.vBodyTriggerWidthStandardDeviation;

							vSystemData.vITIPCDig->vLearnedAverageDensity = vGlobalCurrentProduct->vSetupHistoryAverageDensity;
						}
					}
					else
					if (!vSystemData.vInAutoSetup)
					if (vSystemData.vITIPCDig->vAverageImage)
					{//relearning normal learn so must keep new learned density to adjust images
						//that you are learning to it.
						DWORD *TempSourcePointer = vSystemData.vITIPCDig->vAverageImage;
						if (vSystemData.vITIPCDig->vLearnedProductAverageImage)
						{
							delete vSystemData.vITIPCDig->vLearnedProductAverageImage;
							vSystemData.vITIPCDig->vLearnedProductAverageImage = NULL;
						}
						vSystemData.vITIPCDig->vLearnedProductAverageImage = new CImageData;

						if (vSystemData.vITIPCDig->vLearnedProductAverageImage)
						if (vSystemData.vITIPCDig->vAverageCount)
						{
							vSystemData.vITIPCDig->vLearnedProductAverageImage->MakeGreyImage(vSystemData.vITIPCDig->vOriginalBufferSize);

							if (vSystemData.vITIPCDig->vLearnedProductAverageImage->vGreyImage)
							{
								BYTE *TempPointer = vSystemData.vITIPCDig->vLearnedProductAverageImage->vGreyImage;
								for (DWORD TempLoop = 0; TempLoop < vSystemData.vITIPCDig->vOriginalBufferSize; TempLoop++)
									*TempPointer++ = (BYTE)(((*TempSourcePointer++ / (double)vSystemData.vITIPCDig->vAverageCount)) + .5);

								if (vGlobalCurrentProduct->vDriftDensityInspection)
								{
									vSystemData.vITIPCDig->vLearnedAverageDensity = vSystemData.vITIPCDig->CalculateInspectionDensity(
										vSystemData.vITIPCDig->vLearnedProductAverageImage->vGreyImage, vGlobalCurrentProduct->vDriftDensityInspection); 
								}
							}
						}
					}

					//start accumulating structure
					if (vConfigurationData->vStructureDisableCount)
					{
						if (vSystemData.vInAutoSetup)
							vSystemData.vITIPCDig->RenameStructureFilesToBackup(vGlobalCurrentProduct);

						vSystemData.vITIPCDig->MakeStructureImageBuffer();
						/*
						if (vSystemData.vITIPCDig->vProductGlassHistogramImage != NULL)
						{
							delete vSystemData.vITIPCDig->vProductGlassHistogramImage;
							vSystemData.vITIPCDig->vProductGlassHistogramImage = NULL;
						}
						vSystemData.vITIPCDig->CreateProductGlassStructureImage();
						*/
						vSystemData.vWrongWidthsDuringLearn = 0;
						vSystemData.vWrongBrightnessDuringLearn = 0;
						vSystemData.vRejectsDuringLearn = 0;

						vSystemData.vITIPCDig->vStructureEnabled = true;
						vOldStructureEnabled = true;
						vSystemData.vITIPCDig->vDriftCompensationLocked = true;
						if (vSystemData.vLogFile.vLogSerialData)
						{
							vSystemData.vLogFile.WriteToLogFile("Start Accumulating Structure",cDebugMessage);
						}
					}
					vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();		
				}
			}
		}
		vOldAverageEnabled = vSystemData.vITIPCDig->vAverageEnabled;
	}
	if (vSystemData.vITIPCDig->vStructureEnabled != vOldStructureEnabled)
	{  //end of collecting Structure, Save Structure image collected
		if (vOldStructureEnabled)
		{
			vOldStructureEnabled = false;
			if (vSystemData.vITIPCDig->vStructureCount >= vConfigurationData->vStructureDisableCount)
			{
				bool TempOKToSave = true;
				if (!vSystemData.vInAutoSetup)
				{
					int TempResult = IDOK;
					if (!vSystemData.vImprovingLearn)
					{
						CString TempText = " (included)";

						if (!vSystemData.vIncludeRejectsInAverageAndStructure)
							TempText = " (excluded)";

						TempText = dtoa(vSystemData.vRejectsDuringLearn,0) + " Rejects during Learn" + TempText;

						CYesNoDialog TempYesNoDialog;

						CString TempString = "Use new Normal Learn Image Data?\n(This change is permanent if made.)\n" +
							dtoa(vSystemData.vWrongWidthsDuringLearn,0) + " Wrong Widths during Learn (excluded)\n" +
							dtoa(vSystemData.vWrongBrightnessDuringLearn,0) + " Wrong Brightness during Learn (excluded)\n" + TempText;

						TempYesNoDialog.vNoticeText = TempString;
						TempYesNoDialog.vQuestionType = cConfirmSave;
						TempResult = TempYesNoDialog.DoModal();
					}
					//if user said OK
					if (TempResult == IDOK)
					{
						if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
						{  //end of collecting structure, Save structure image
					
							if (vSystemData.vITIPCDig->MakeProductAverageImage())
							{
								if (vSystemData.vLogFile.vLogSerialData)
								{
									vSystemData.vLogFile.WriteToLogFile("Make Product Average1, Average Count: " + dtoa(vSystemData.vITIPCDig->vAverageCount,0),cDebugMessage);
								}
								vSystemData.vITIPCDig->SaveAverageImageToFile(vGlobalCurrentProduct);
								vGlobalCurrentProduct->vSetupHistoryAverageDensity = 0;

								if (vGlobalCurrentProduct->vHistogramThreshold > 0)
									vSystemData.vITIPCDig->SaveProcess4ImageData(vGlobalCurrentProduct);

								vGlobalCurrentProduct->vSetupHistoryAverageCount = vConfigurationData->vAverageDisableCount;
								vSystemData.vITIPCDig->CalculateAverageDriftDensity(vGlobalCurrentProduct);
								vSystemData.vIndexForDriftDensityOfLastNImages = 0;
								if (vGlobalCurrentProduct->vSetupHistoryAverageDensity > 255)
									vGlobalCurrentProduct->vSetupHistoryAverageDensity = 0;

								vGlobalCurrentProduct->vSetupHistoryContainerTriggerStandardDeviation = vSystemData.vBodyTriggerWidthStandardDeviation;
							}
							if (vSystemData.vInAutoSetup)
								vSystemData.vITIPCDig->RenameStructureFilesToBackup(vGlobalCurrentProduct);

							vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();		
						}
					}
					else
						TempOKToSave = false;
				}

				if (TempOKToSave)
				{
					if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
					{  //end of collecting structure, Save structure image
						DWORD TempStructureCount = vSystemData.vITIPCDig->vStructureCount;

						vSystemData.vITIPCDig->DeleteUndoStructureLearnFiles(vGlobalCurrentProduct);

						if (vSystemData.vITIPCDig->MakeProductStructureImage())
						{
							vSystemData.vITIPCDig->SaveContaminant2StructureImageToFile(vGlobalCurrentProduct, vSystemData.vITIPCDig->vContaminant2StructureImage, true);

							vGlobalCurrentProduct->vSetupHistoryStructureCount = TempStructureCount;
							vGlobalCurrentProduct->vNeedToRelearn = 0;
							vSystemData.vITIPCDig->SaveStructureImageToFile(vGlobalCurrentProduct, true);

							if (vConfigurationData->vDriftCompensationEnabled)
							{
								vSystemData.vKeepDensityFeedbackLoopLocked = true;
								vSystemData.vITIPCDig->vDriftCompensationLocked = true;
							}
							ReportErrorMessage("Save Standard Learn For Product: " + vSystemData.vCurrentProductName, cUserChanges,0);
						}
						if (vSystemData.vITIPCDig->MakeVoidProductStructureImage())
						{
							vSystemData.vITIPCDig->SaveVoidStructureImageToFile(vGlobalCurrentProduct, true);
						}
						vSystemData.vITIPCDig->LoadStructureImagesFromFiles(false, false);
						vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();	
						SetLearnState();
					}
					if (vSystemData.vInAutoSetup)
					{
						ReportErrorMessage("Finished Normal Learn in Auto Setup: " + dtoa(vSystemData.vWrongWidthsDuringLearn,0) + " Wrong Widths, " +
							dtoa(vSystemData.vWrongBrightnessDuringLearn,0) + " Wrong Brightness", cUserChanges,0);

						//if ((vSystemData.vWrongWidthsDuringLearn) || (vSystemData.vRejectsDuringLearn))
						{
							CNoticeDialog TempNoticeDialog;
							TempNoticeDialog.vNoticeText = "\n\nNormal Learn Complete\n" + dtoa(vSystemData.vWrongWidthsDuringLearn,0) + " Wrong Widths during learn (excluded)\n" +
								dtoa(vSystemData.vWrongBrightnessDuringLearn,0) + " Wrong Brightness during learn (excluded)\n";
							TempNoticeDialog.vType = cNoticeMessage;
							TempNoticeDialog.DoModal();
						}
					}
					else
					if (!vSystemData.vImprovingLearn)
					{
						ReportErrorMessage("Finished Normal Relearn while inspecting: " + dtoa(vSystemData.vWrongWidthsDuringLearn,0) + " Wrong Widths, " +
							dtoa(vSystemData.vRejectsDuringLearn,0) + " Rejects, " + dtoa(vSystemData.vWrongBrightnessDuringLearn,0) + " Wrong Brightness", cUserChanges,0);

					}
					vSystemData.vITIPCDig->ClearImproveLearn(false);
					vSystemData.vImproveLearnTotalContainers = 0;
				}
				else
				{ //delete accumulated average and structure images and restore backups
					if (vSystemData.vITIPCDig->vStructureImage != NULL)
					{
						delete vSystemData.vITIPCDig->vStructureImage;
						vSystemData.vITIPCDig->vStructureImage = NULL;
					}
					if (vSystemData.vITIPCDig->vContaminant2StructureImage != NULL)
					{
						delete vSystemData.vITIPCDig->vContaminant2StructureImage;
						vSystemData.vITIPCDig->vContaminant2StructureImage = NULL;
					}
					if (vSystemData.vITIPCDig->vVoidStructureImage != NULL)
					{
						delete vSystemData.vITIPCDig->vVoidStructureImage;
						vSystemData.vITIPCDig->vVoidStructureImage = NULL;
					}
					if (vSystemData.vITIPCDig->vAverageImage != NULL)
					{
						free(vSystemData.vITIPCDig->vAverageImage);
						vSystemData.vITIPCDig->vAverageImage = NULL;
					}
					vSystemData.vITIPCDig->RestoreLearnFilesFromBackups(vGlobalCurrentProduct);
					if (vSystemData.vInAutoSetup)
						ReportErrorMessage("Finished Relearn in Auto Setup", cUserChanges,0);
					else
						ReportErrorMessage("Finished Relearn while inspecting, but did not use", cUserChanges,0);
				}
				if (!vSystemData.vInAutoSetup)
					vSystemData.vITIPCDig->DeleteBackupLearnFiles();
				if (vSystemData.vITIPCDig->vStructureImage != NULL)
				{
					delete vSystemData.vITIPCDig->vStructureImage;
					vSystemData.vITIPCDig->vStructureImage = NULL;
				}
				if (vSystemData.vITIPCDig->vLearnedProductAverageImage)
				{
					delete vSystemData.vITIPCDig->vLearnedProductAverageImage;
					vSystemData.vITIPCDig->vLearnedProductAverageImage = NULL;
				}
			}
		}
		vOldStructureEnabled = vSystemData.vITIPCDig->vStructureEnabled;
		SetInterlockStatus();
		UpdateRejectReasonOnScreen(); //should clear the learn count on screen after learn done
	}
}

void CScanTracDlg::OneSecondDisplayUpdate() 
{
	//if ((vSystemData.vCurrentBrightnessAdjustment > 60.0) || (vSystemData.vCurrentBrightnessAdjustment < -60.0))
	//if (vSystemData.vSystemRunMode == cRunningSystemMode)
	//if (vGlobalCurrentProduct)
	//if (!vGlobalCurrentProduct->vNeedToRelearn)
	//if (vConfigurationData->vAutoImproveEnabled)
	//if (!CurrentProductIsInspxProduct())
	//if ((!vSystemData.vTakingQuickLearnImages) && (!vSystemData.vITIPCDig->vAverageEnabled) && //if not learning now
	//	(!vSystemData.vITIPCDig->vStructureEnabled) && (!vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled) && 
	//	(!vOldAverageEnabled) && (!vOldStructureEnabled))
	//if (!vGlobalProcessQuickLearnImagesThread)
	//if ((vSystemData.vITIPCDig->vDriftCompensationLocked) || (!vGlobalCurrentProduct->vSetupHistoryStructureCount))
	//{
	//	vGlobalCurrentProduct->vNeedToRelearn = 1;
	//	QuickSetupStartAutoReLearnIfNeeded();
	//}
	//test
	/*
	if ((vMaximum10MilliSecondSpan != vOldMaximum10MilliSecondSpan) || (vLast10MilliSecondSpan != vOldLast10MilliSecondSpan))
	{
		vOldMaximum10MilliSecondSpan = vMaximum10MilliSecondSpan;
		vOldLast10MilliSecondSpan = vLast10MilliSecondSpan;
		SetDlgItemText(IDC_TriggerIndicator, dtoa(vOldLast10MilliSecondSpan,0) + ", " + dtoa(vOldMaximum10MilliSecondSpan,0));
	}
	*/
	

	bool TempProcessingQuickLearn = false;
	if (vGlobalProcessQuickLearnImagesThread)
		TempProcessingQuickLearn = true;

	if (TempProcessingQuickLearn != vOldProcessingQuickLearn)
	{
		vOldProcessingQuickLearn = TempProcessingQuickLearn;
		if (vSystemData.vEvaluateAndOrQuickLearn == cEvaluateAndQuickLearn)
		{
			ReportErrorMessage("Process Quick Learn Finshed, Start Process Evaluate Thread", cWriteToLog,0);
			vSystemData.vEvaluateAndOrQuickLearn = cQuickLearnOnly;
			CreateProcessEvaluateImagesThread();
		}
	}

	if (vGlobalEvenSecond)
		vGlobalEvenSecond = false;
	else
	{
		vGlobalEvenSecond = true;
		if (vEveryFourthSecond)
			vEveryFourthSecond = false;
		else
		{
			vEveryFourthSecond = true;
			if (vSystemData.vEncoderFaultyCount)
				vSystemData.vEncoderFaultyCount--; //every fourth second clear one faulty encoder error count if have one.
		}
	}
	if (!vDisplayingVersion)
	{
		//CString TempForeGroundWindowName = "-";
		//CWnd *TempForeGroundWindow = GetForegroundWindow();  //gives name of application window that does have the focus
		//if (TempForeGroundWindow)
		//{
		//	TempForeGroundWindow->GetWindowText(TempForeGroundWindowName);
		//	if (TempForeGroundWindowName.GetLength() == 0)
		//		TempForeGroundWindowName = "Start Menu";
		//	//ReportErrorMessage(dtoa(vScanTracIsNotTheActiveWindow,0) + ".  Application With ForeGround: " + TempForeGroundWindowName, cAction, 0);
		//	if (vPreviousActiveWindowName != TempForeGroundWindowName)
		//	{
		//		CString TempWindowBefore = vPreviousActiveWindowName;
		//		vPreviousActiveWindowName = TempForeGroundWindowName;
		//		int TempPositionB = TempWindowBefore.Find("Inspx-");
		//		int TempPosition = TempForeGroundWindowName.Find("Inspx-");
		//		if ((TempPosition == -1) || (TempPositionB == -1))
		//			ReportErrorMessage("Window Changed: " + vPreviousActiveWindowName, cAction, 0);
		//		else
		//			ReportErrorMessage("Menu Changed: " + vPreviousActiveWindowName, cAction, 0);
		//	}
		//	int TempPosition = TempForeGroundWindowName.Find("Inspx-");
		//	if ((TempPosition == -1) && (TempForeGroundWindowName != "ScanTrac-Loading"))
		//	{
		//		this->vScanTracIsNotTheActiveWindow++;
		//		ReportErrorMessage("ScanTrac NOT FOREGROUND: " + TempForeGroundWindowName + "---" + dtoa(vScanTracIsNotTheActiveWindow, 0), cWriteToLog, 0);

		//		int TempIsTeamViewer = TempForeGroundWindowName.Find("TeamViewer", 0);
		//		if ((vScanTracIsNotTheActiveWindow > 600) || ((vScanTracIsNotTheActiveWindow == 20) && ((TempForeGroundWindowName == "Program Manager") || (TempForeGroundWindowName == "Start Menu") || (TempIsTeamViewer != -1))))
		//		if (vMostRecentActiveWindow)
		//		{
		//			BOOL TempResult = vMostRecentActiveWindow->SetForegroundWindow();
		//			//vMostRecentActiveWindow->BringWindowToTop();
		//			//vMostRecentActiveWindow->SetActiveWindow();
		//			//vMostRecentActiveWindow->SetFocus();

		//			if (TempResult)
		//				ReportErrorMessage("Grab Keypad Input ScanTrac Window: " + vMostRecentActiveWindowName, cAction, 0);
		//			else
		//			{
		//				ReportErrorMessage("Grab Keypad Input ScanTrac Window: " + vMostRecentActiveWindowName + " FAILED", cAction, 0);
		//			}
		//			vScanTracIsNotTheActiveWindow = 0;
		//		}
		//	}
		//	else
		//	{
		//		vScanTracIsNotTheActiveWindow = 0;
		//		if (TempForeGroundWindowName != "ScanTrac-Loading")//remember what ScanTrac window was most recently active, except the Loading window
		//		{
		//			vMostRecentActiveWindow = TempForeGroundWindow;
		//			vMostRecentActiveWindowName = TempForeGroundWindowName;
		//		}
		//	}
		//}
		//else
		//	ReportErrorMessage("**" + dtoa(vScanTracIsNotTheActiveWindow,0) + ".  No ForeGround Window", cAction, 0);

		//CString TempActiveWindowName = "-";
		//CWnd *TempActiveWindow = GetActiveWindow();  //gets name of active ScanTrac window if one has the focus, otherwise it is null
		//if (TempActiveWindow)
		//{
		//	TempActiveWindow->GetWindowText(TempActiveWindowName);
		//	ReportErrorMessage("Active Window in ScanTrac: " + TempActiveWindowName, cAction, 0);
		//}
		//else
		//	ReportErrorMessage("No Active Window", cAction, 0);
	}

	if ((vShowingPipeEmpty) || (vShowingAirInPipe))
		m_TriggerIndicator.Invalidate();

	if (vGlobalPCRunningWindowsXP >= cWindowsXP)
	{
		vSystemData.vCpuUsage = FindCPUUsage();
		// write message here on over value ??
		vSystemData.vCPUTemperaturesReadOK = GetCoreTempInfoAlternative();	//kjh 5/7/12
	}

	if (vTrackingCheckWeighMinuteData)
	{
		vSystemData.vCheckWeighRunDuration++;

		if (vSystemData.vCheckWeighRunDuration % 60 == 0) //if even minute, save minute data
				SaveCheckWeighTrendPoint();
	}

	if (vSystemData.vEjectTooLateMessageGivenThisRun != vSystemData.vOldSetupPasswordRequiredToRun)
	{
		vSystemData.vOldSetupPasswordRequiredToRun = vSystemData.vEjectTooLateMessageGivenThisRun;
		SetInterlockStatus();
		UpdateClearYellowMessageButton();
	}

	if (vGlobalBackupHardDriveThread)
	{
		/*
		vGlobalBackupHardDriveThread->vCount++;

		if (PasswordOK(cTemporaryInspxPassword,false))
		{
			if ((vGlobalBackupHardDriveThread->vFilesDeleted != vOldFilesDeleted) ||
				(vGlobalBackupHardDriveThread->vFilesCopied != vOldFilesCopied) ||
				(vGlobalBackupHardDriveThread->vFoldersChecked != vOldFoldersChecked))
			{
				vOldFoldersChecked = vGlobalBackupHardDriveThread->vFoldersChecked;
				vOldFilesCopied = vGlobalBackupHardDriveThread->vFilesCopied;
				vOldFilesDeleted = vGlobalBackupHardDriveThread->vFilesDeleted;
				SetDlgItemText(IDC_TriggerIndicator,"BHD:" + dtoa(vOldFoldersChecked,0) + ", " + 
					dtoa(vOldFilesDeleted,0) + ", " + dtoa(vOldFilesCopied,0));
			}
		}
		else
			SetDlgItemText(IDC_TriggerIndicator,"Backup HD: " + dtoa(vGlobalBackupHardDriveThread->vCount,0));
		*/

		if (!vSystemData.vACPowerOn)
			vGlobalBackupHardDriveThread->vEndThreadNow = true;
	}

	if (vSystemData.vAdjustingBrightnessBeforeLearning != vOldAdjustingBrightnessBeforeLearning)
	{
		if (vOldAdjustingBrightnessBeforeLearning)
		{
			vOldAdjustingBrightnessBeforeLearning = vSystemData.vAdjustingBrightnessBeforeLearning; //must have both so only do once
			StartLearning();
		}
		else
			vOldAdjustingBrightnessBeforeLearning = vSystemData.vAdjustingBrightnessBeforeLearning;
	}

	if ((vSystemData.vSystemRunMode != cAutoSetupRunningSystem) &&
		(vSystemData.vSystemRunMode != cRunningSystemMode))
	{
		vSystemData.vCPMDataIndexNotRunning++;  //start collecting counts in next memory location
		if (vSystemData.vCPMDataIndexNotRunning >= vConfigurationData->vCPMTimePeriod)
		{  //if beyond last memory location go to beginning and flag have all counts
			vSystemData.vCPMDataIndexNotRunning = 0;
		}
		vSystemData.vCPMDataNotRunning[vSystemData.vCPMDataIndexNotRunning] = 0;

		if ((vCPMNotRunning) || (vTriggerIndicatorCount > 1))
		{
			//add up data for CPM not running, but exclude sample currently collecting
			DWORD TempSum = 0;
			for (WORD TempLoop = 0; TempLoop < vConfigurationData->vCPMTimePeriod; TempLoop++)
			if (TempLoop != vSystemData.vCPMDataIndexNotRunning)
				TempSum = TempSum + vSystemData.vCPMDataNotRunning[TempLoop];
			if (vConfigurationData->vCPMTimePeriod < 1)
				ReportErrorMessage("Error-vCPMTimePeriod < 1, would cause crash", cEMailInspx, 32000);
			else
				vCPMNotRunning = (WORD)(TempSum * 60 / (vConfigurationData->vCPMTimePeriod - 1));
		}
	}

	if (vOldCPMNotRunning != vCPMNotRunning)
	{
		vOldCPMNotRunning = vCPMNotRunning;
		ShowCPM();
	}
	
	if (vOldTriggerIndicatorCount != vTriggerIndicatorCount)
//		(vOldCPMNotRunning != vCPMNotRunning))
	{
		vOldTriggerIndicatorCount = vTriggerIndicatorCount;
		//vOldCPMNotRunning = vCPMNotRunning;
		if (vTriggerIndicatorCount > 1)
		{
			//CString TempString("");
			//TempString = "";
			//TempString = ", " + dtoa(vCPMNotRunning,0) + "CPM";

			SetDlgItemText(IDC_TriggerIndicator,dtoa(vTriggerIndicatorCount,0));
			m_TriggerIndicator.ShowWindow(SW_SHOW);
		}
		else
			m_TriggerIndicator.ShowWindow(SW_HIDE);
	}

	//if (vGlobalHideRemoteControlIndicator)
	//	vGlobalHideRemoteControlIndicator--;

	//if (vGlobalUnderRemoteControl)
	//{
	//	vGlobalUnderRemoteControl--;
	//	//if (!vGlobalUnderRemoteControl)
	//	//	vGlobalRemoteControlIndicatorEnabled = false;
	//}

	if (vGlobalPasswordTimeOut)  //if password times out, clear password
	{
		vGlobalPasswordTimeOut--;
		if (!vGlobalPasswordTimeOut)
		{
			if (vGlobalCurrentUser != " No User")
				ReportErrorMessage(vGlobalCurrentUser + " timed out. Product: " + vSystemData.vCurrentProductName, cUserChanges, 0);
			//PasswordOK(cNoPassword, false);
			vGlobalPasswordLevel = cNoPassword;
			vGlobalCurrentUser = "No User";
			vGlobalDialogTitleColor = cDarkBlue;
			SetCursorPos(vGlobalDisplaySizeH,vGlobalDisplaySizeV);
		}
	}

	//if ((vOldUnderRemoteControl) && (!vGlobalUnderRemoteControl))
	//{
	//	SetDlgItemText(IDC_DialogTitleStaticText1,vDialogTitleString);
	//}
	//else
	//if (vGlobalUnderRemoteControl)
	//{
	//	if (vGlobalEvenSecond)
	//	{
	//		CString TempText = " ";
	//		TempText.LoadString(IDS_UnderRemoteControl);
	//		SetDlgItemText(IDC_DialogTitleStaticText1,TempText);
	//	}
	//	else
	//		SetDlgItemText(IDC_DialogTitleStaticText1,vDialogTitleString);
	//}
	//vOldUnderRemoteControl = vGlobalUnderRemoteControl;

	if (vGlobalShiftKeyDown)
	{
		vGlobalShiftKeyDown--;
		if (!vGlobalShiftKeyDown)
			PostThreadMessage(vGlobalCallingThreadID,cUpdateTitleBarMessage, 0, 0);
	}

	if (vSystemData.vSystemRunMode == cConditionXRayTubeMode)
	{
	//brh merge 6/18/2018
		if ((vSystemData.vXRayTubeConditionCurrentStep > 16) || 
			((vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep] == 0) && (vSystemData.vXRayTubeConditionCurrentTable[vSystemData.vXRayTubeConditionCurrentStep]	== 0)))
		{
			vSystemData.vXRayTubeConditionStepTimeLeft++;

			if (vSystemData.vXRayTubeConditionStepTimeLeft < 60)
				SetDlgItemText(IDC_ContainersPerMinute, "Burn: " + dtoa(vSystemData.vXRayTubeConditionStepTimeLeft,0) + "s");
			else
			if (vSystemData.vXRayTubeConditionStepTimeLeft < 3600)
				SetDlgItemText(IDC_ContainersPerMinute, "Burn: " + 
					dtoa(vSystemData.vXRayTubeConditionStepTimeLeft / 60.0,1) + "m");
			else
				SetDlgItemText(IDC_ContainersPerMinute, "Burn: " + 
					dtoa(vSystemData.vXRayTubeConditionStepTimeLeft / 3600.0,2) + "h");
		}
		else
		{
			vSystemData.vXRayTubeConditionStepTimeLeft--;

			if (vSystemData.vXRayTubeConditionStepTimeLeft < 1000)
				SetDlgItemText(IDC_ContainersPerMinute, "Step Time To Go: " + 
					dtoa(vSystemData.vXRayTubeConditionStepTimeLeft,0));
			else
				SetDlgItemText(IDC_ContainersPerMinute, "Time To Go: " + 
					dtoa(vSystemData.vXRayTubeConditionStepTimeLeft,0));
			if (vSystemData.vXRayTubeConditionStepTimeLeft == 0)
				NextTubeConditionStep();
		}
	}
	
	if ((vOldCalibrateBodyTriggerReferenceEnabled != vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled) && (!vOldCalibrateBodyTriggerReferenceEnabled))
		vOldCalibrateBodyTriggerReferenceEnabled = vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled;
	if (vEMailMessage != "")
	{
		//comment out tempoary as e-mail does not work SendEMail(vEMailMessage,vEMailType);
		vEMailMessage = "";
	}
	vSystemData.vLogFile.LogFileObjectBackground();

	//if have initialized and running
	if (!vDisplayingVersion)
	{  //was 3 second timeout for comm.
		if ((vGlobalFirstMicroControllerCommCheck != cFinishedSearchForNextSerialPort) && (vGlobalFirstMicroControllerCommCheck != cDoneSearchForNextSerialPort) && (vGlobalFirstMicroControllerCommCheck != cNoCommPortSettings))
		{
			if ((!vConfigurationData->vSimulateLightControlBoard) &&  (!vConfigurationData->vDemoMode) &&
				((vSystemData.vCommunicationsTimeOutCounter > 6) || ((vGlobaluCSerialPort) && (vGlobaluCSerialPort->vTryNextSerialPort > 100))))
			{
				if ((!vSystemData.vNoCommunicationsWithUController) || ((vGlobaluCSerialPort) && (vGlobaluCSerialPort->vTryNextSerialPort > 100)))
				{
					vSystemData.vNoCommunicationsWithUController = true;
					CString TempString;
					TempString.Format(_T("No Reply Comm %d, Try Next Comm Serial Port"), vGlobaluCSerialPort->vComPortNumber);
					ReportErrorMessage(TempString, cWriteToLog,0);
					if (vGlobaluCSerialPort)
					{
						vGlobaluCSerialPort->ClosePort();
						vGlobaluCSerialPort->vTryNextSerialPort = 0;
					}
				// here kjh 8/5/2014 add check if ever had comm with this serial port, if not look for correct serial port
					if (TryNextSerialPort() == true)		// modify vGlobaluCSerialPort->vComPortNumber to next serial port
					{
						vGlobaluCSerialPort->vComPortNumber = vGlobalSerialPortNumberMicroController;
						vGlobaluCSerialPort->OpenPort(vGlobaluCSerialPort->vComPortNumber);
						vSystemData.vNoCommunicationsWithUController = false;
						vSystemData.vCommunicationsTimeOutCounter = 0;
					}
					else
					{	// 
						vGlobalFirstMicroControllerCommCheck = cDoneSearchForNextSerialPort;

						vGlobaluCSerialPort->ClosePort();
						int iSerialDefault;
						iSerialDefault = SetSerialPortToDefault();
						
						if (iSerialDefault == cSetToDefault)
						{
							vSystemData.vNoCommunicationsWithUController = false;
							vSystemData.vCommunicationsTimeOutCounter = 0;
							vGlobalFirstMicroControllerCommCheck = cFinishedSearchForNextSerialPort; // out of choices, set to default
							vGlobaluCSerialPort->OpenPort(vGlobalSerialPortNumberMicroController);
						}
						else if (iSerialDefault == cDefaultNotCurrentlyAvailable)
						{
							vSystemData.vNoCommunicationsWithUController = true;
							vSystemData.vCommunicationsTimeOutCounter = 0;
						}
						else //if (iSerialDefault == cDefaultNeverAvailable)
						{
							vGlobalFirstMicroControllerCommCheck = cNoCommPortSettings; // no port available at com1, uC default port
							vSystemData.vCommunicationsTimeOutCounter = 0;
						}
					}
				}
			}
			else
			{
				vSystemData.vNoCommunicationsWithUController = false;
			}
		}
		else if (vGlobalFirstMicroControllerCommCheck == cDoneSearchForNextSerialPort)
		{
			if ((!vConfigurationData->vSimulateLightControlBoard) &&  (!vConfigurationData->vDemoMode) &&
				((vSystemData.vCommunicationsTimeOutCounter > 6) || ((vGlobaluCSerialPort) && (vGlobaluCSerialPort->vTryNextSerialPort > 100))))
			{
				vGlobaluCSerialPort->ClosePort();
				int iSerialDefault;
				iSerialDefault = SetSerialPortToDefault();

				if (iSerialDefault == cSetToDefault)
				{
					vSystemData.vNoCommunicationsWithUController = false;
					vSystemData.vCommunicationsTimeOutCounter = 0;
					vGlobalFirstMicroControllerCommCheck = cFinishedSearchForNextSerialPort; // out of choices, set to default
					vGlobaluCSerialPort->OpenPort(vGlobalSerialPortNumberMicroController);
				}
				else if (iSerialDefault == cDefaultNotCurrentlyAvailable)
				{
					vSystemData.vNoCommunicationsWithUController = true;
					vSystemData.vCommunicationsTimeOutCounter = 0;
				}
				else //if (iSerialDefault == cDefaultNeverAvailable)
				{
					vGlobalFirstMicroControllerCommCheck = cNoCommPortSettings; // out of choices, no port available
					vSystemData.vCommunicationsTimeOutCounter = 0;
				}
			}
		}
		else if ((vGlobalFirstMicroControllerCommCheck == cFinishedSearchForNextSerialPort) || (vGlobalFirstMicroControllerCommCheck == cNoCommPortSettings))
		{
			if ((!vConfigurationData->vSimulateLightControlBoard) && (vSystemData.vCommunicationsTimeOutCounter > 6) && (!vConfigurationData->vDemoMode))
			{
				if (!vSystemData.vNoCommunicationsWithUController)
				{
					vSystemData.vNoCommunicationsWithUController = true;
				}
			}
			else
			{
				vSystemData.vNoCommunicationsWithUController = false;
			}
		}
		if ((!vConfigurationData->vSimulateLightControlBoard) && (!vConfigurationData->vDemoMode) && (vGlobaluCSerialPort->vWaitingForReply))
		if (vSystemData.vCommunicationsTimeOutCounter < 253)
			vSystemData.vCommunicationsTimeOutCounter++;

		if ((vGlobalACPowerMoniter) && (vGlobalACPowerMoniter->vPortOpen == true) && (vGlobalACPowerMoniter->vTestACPowerMoniterExists != cNoCommPortFound))
		{
			if ((vGlobalACPowerMoniter->vHasReceivedCommunication == true) && (vGlobalACPowerMoniter->vTestACPowerMoniterExists == cYesCommSeen))
			{
				if (vGlobalACPowerMoniter->vCommunicationsACPowerMonitorDataCount <= 0)
				{
					switch (vACPowerMonitorTroubleCount)
					{
						case 0: case 1:
							vACPowerMonitorTroubleCount++;
						break;
						case 2: 
							// LOST A/C Power
							vACPowerMonitorTroubleCount++;
//							TempSavevShowuControllerStatusInRed = vShowuControllerStatusInRed;
//							GetDlgItemText(IDC_uControllerStatus,TempSaveIDC_uControllerStatusText);
							SetInterlockStatus();
							ReportErrorMessage("Info Only - Power Turned Off", cEMailInspx,32000);
							if (vSystemData.vSystemRunMode == cRunningSystemMode)
							{
								ReportErrorMessage("Power Turned Off While Inspecting", cError, 0);
								ReportErrorMessage("Power Turned Off While Inspecting", cEMailInspx, 0);
							}
							else
								ReportErrorMessage("Power Turned Off", cEMailMaintenance, 0);
						break;
						case 3: case 4: case 5: case 6: case 7: case 8: case 9:
							vACPowerMonitorTroubleCount++;
						break;
						case 10:
							vACPowerMonitorTroubleCount++;
							if (vSystemData.vACPowerOn)  //report only once
							if (vSystemData.vSystemRunMode == cRunningSystemMode)
							{
								::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
								ReportErrorMessage("Power Turned Off > 10 seconds.\nInspection Stopped",cCritical,0);

								vSystemData.vACPowerOn = false;
								GenerateProductionReport(cSelectProductProductionReport);
								SendProductionReport(cSelectProductProductionReport);
								SetInterlockStatus();
#ifdef CompileInHTTPClientOperationsGuardian
								if (vConfigurationData->vEnableOperationsGuardian)
								{
									vGlobalOGErrorCode = 800;
									vGlobalOGLocationString = "power";
									::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessagePowerFault, cOGSevereMessagePowerFault);
								}
#endif
							}
							break;
						case 11:
							vACPowerMonitorTroubleCount++;
						break;
						case 12:
							vACPowerMonitorTroubleCount++;
						break;
						default: 
							if (vACPowerMonitorTroubleCount < 16384)
								vACPowerMonitorTroubleCount++;
						break;
					}
				}
				else
				{
					if ((vSystemData.vACPowerOn == false) || (vACPowerMonitorTroubleCount >= 2) /*&& (vGlobalXrayNoCommMessageRcvdEver == cYesCommSeen)*/)  // system is in shutdown mode, restart
					{
						ReportErrorMessage(_T("Power Restored: Lost for " + dtoa(vACPowerMonitorTroubleCount) + " seconds"), cEMailInspx,32000);
						ClearYellowWarningButton();
						vACPowerMonitorTroubleCount = 0;
						vSystemData.vACPowerOn = true;
						vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
						::PostThreadMessage(vGlobalCallingThreadID,cKillCheckACBeforeYellowMessage,0,0);
						SetInterlockStatus();
					}
					vACPowerMonitorTroubleCount = 0;
					vGlobalACPowerMoniter->vCommunicationsACPowerMonitorDataCount = 0;	
				}
			}
			else // port exists, if uC has found a port loop twice and no AC power monitor port, look for new power monitor port
			{
				if (((vGlobaluCSerialPort->SyncFromMicroControllerSeen > 2) || (vGlobalFirstMicroControllerCommCheck == cFinishedSearchForNextSerialPort) || (vGlobalFirstMicroControllerCommCheck == cNoCommPortSettings)) &&
					((vGlobalACPowerMoniter) && (vGlobalACPowerMoniter->vTestACPowerMoniterExists == cNoCommSeenEver)))/*(SyncFromACPowerMonitorSeen == 0))*/	// uC found port, not found AC Monitor port
				{
					switch (vACPowerMoniterPortCommCheckState)
					{
						case 0:		
							if (vGlobalACPowerMoniter->SyncFromACPowerMonitorSeen == 0)
								vACPowerMoniterPortCommCheckState++;
							else
								vACPowerMoniterPortCommCheckState = 5;
							vACPowerMonitorTroubleCount = 0;		//keep clear until port is determined
							break;
						case 1:
							if (vGlobalACPowerMoniter->SyncFromACPowerMonitorSeen == 0)
								vACPowerMoniterPortCommCheckState++;
							else
								vACPowerMoniterPortCommCheckState = 5;
							vACPowerMonitorTroubleCount = 0;		//keep clear until port is determined
							break;
						case 2:
							if (vGlobalACPowerMoniter->SyncFromACPowerMonitorSeen == 0)
							{
								// if port does not exist stop looking for
								// close current AC Monitor port
								vGlobalACPowerMoniter->ClosePort();
								// look for correct serial port
								vACPowerMonitorDoesNotExistsCount++;		// if no comm for 10 seconds on power on,  then stop testing for this condition
								if (GetNextACPowerMonitorPort(vGlobalSerialPortNumberACPowerMonitor + 1) == true)
								{
									vGlobalACPowerMoniter->vComPortNumber = vGlobalSerialPortNumberACPowerMonitor; //done here
									vGlobalACPowerMoniter->OpenPort(vGlobalACPowerMoniter->vComPortNumber);
									vGlobalACPowerMoniter->SyncFromACPowerMonitorSeen = 0;
									if (vGlobalACPowerMoniter->vPortOpen)
									{
										vGlobalACPowerMoniter->InitializeACPowerMoniter();			
									}
									else
									{
										ReportErrorMessage(" Re Init AC Power Monitor Port Fail", cEMailInspx,32000);
									}
									vACPowerMoniterPortCommCheckState = 0;
								}
								else
								{
									vGlobalACPowerMoniter->vTestACPowerMoniterExists = cNoCommPortFound;	
									ReportErrorMessage(" Re Init AC Power Monitor Next Port Fail", cEMailInspx,32000);
								}
								
							}
							else
								vACPowerMoniterPortCommCheckState = 5;
							vACPowerMonitorTroubleCount = 0;		//keep clear until port is determined
						break;
						case 3:
						case 4:
							vACPowerMoniterPortCommCheckState++;
							vACPowerMonitorTroubleCount = 0;		//keep clear until port is determined
						break;
						case 5:
							vACPowerMonitorDoesNotExistsCount++;
							vACPowerMonitorTroubleCount = 0;		//keep clear until port is determined
						break;
						default:
							vGlobalACPowerMoniter->vTestACPowerMoniterExists = cNoCommPortFound;
							vGlobalACPowerMoniter->ClosePort();
							vACPowerMonitorTroubleCount = 0;		//keep clear until port is determined
						break;
					}
					if (vACPowerMonitorDoesNotExistsCount > cTimesToTryPorts)
					{
						vGlobalACPowerMoniter->ClosePort();
						int iReturnValue = SetACMonitorPortToDefault();
						if (iReturnValue == cSetToDefault)
						{
							vGlobalACPowerMoniter->vTestACPowerMoniterExists = cYesCommSeen;
							vGlobalACPowerMoniter->OpenPort(vGlobalSerialPortNumberACPowerMonitor);
							vACPowerMoniterPortCommCheckState++;
						}
						if (iReturnValue == cDefaultNeverAvailable)
						{
							vGlobalACPowerMoniter->vTestACPowerMoniterExists = cNoCommPortFound;
							vACPowerMoniterPortCommCheckState++;
						}
						if (iReturnValue == cDefaultNotCurrentlyAvailable)
							vGlobalACPowerMoniter->vTestACPowerMoniterExists = cNoCommPortFound;
					}
				}
			}
		}
		else if ((vGlobalACPowerMoniter) && (vGlobalACPowerMoniter->vPortOpen != true) && (vGlobalACPowerMoniter->vTestACPowerMoniterExists == cNoCommSeenEver) && (vACPowerMonitorDoesNotExistsCount > cTimesToTryPorts))
		{
			int iReturnValue = SetACMonitorPortToDefault();
			if (iReturnValue == cSetToDefault)
			{
				vGlobalACPowerMoniter->vTestACPowerMoniterExists = cYesCommSeen;
				vGlobalACPowerMoniter->OpenPort(vGlobalSerialPortNumberACPowerMonitor);
			}
			if (iReturnValue == cDefaultNeverAvailable)
			{
				vGlobalACPowerMoniter->vTestACPowerMoniterExists = cNoCommPortFound;
			}
			if (iReturnValue == cDefaultNotCurrentlyAvailable)
			{
				vGlobalACPowerMoniter->vTestACPowerMoniterExists = cNoCommPortFound;
			}
		}

		if (vGlobalDXMXRayPort) 	//if port valid 
		{
			if ((!vConfigurationData->vSimulateLightControlBoard) && (vGlobalDXMXRayPort->vCommunicationsTimeOutCounter < 253)) //must comment out to test monoblock in the office
			if ((vGlobalDXMXRayPort->vCommunicationsTimeOutCounter < 253))
			{
				vGlobalDXMXRayPort->vCommunicationsTimeOutCounter++;
			}
		}
		else
		if (vGlobalMonoBlockXRayPort)
		{
			if (vGlobalMonoBlockXRayPort->vWaitingForReply)
			if ((!vConfigurationData->vSimulateLightControlBoard) && (vGlobalMonoBlockXRayPort->vCommunicationsTimeOutCounter < 253))
				vGlobalMonoBlockXRayPort->vCommunicationsTimeOutCounter++;
		}
		// if the timeout for no comm happens and vGlobalDXMXRayPort has never seen a valid message, try new port.
		if ((vGlobalDXMXRayPort) && (vGlobalXrayNoCommMessageRcvdEver == cNoCommSeenEver))
		{
			if (vGlobalDXMXRayPort->vCommunicationsTimeOutCounter > 4)
			{
				switch(vDXMPortInitState) 
				{
				case 0:
					InitializeDXM();		// init port, maybe not initialized before
					vDXMPortInitState++;
					vGlobalDXMXRayPort->vCommunicationsTimeOutCounter = 0;
					break;
				case 1:
					vDXMPortInitState++;
					break;
				case 2:
					vDXMPortInitState++;
					break;
				case 3:
					if (vXRayPortTry > cTimesToTryPorts)
					{
						vGlobalDXMXRayPort->ClosePort();
						int iResult = SetXRayPortToDefault();
						if (iResult == cSetToDefault)
						{
							vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;
							vGlobalDXMXRayPort->OpenPort(vGlobalSerialPortNumberXRaySource);
							vDXMPortInitState++;
						}
						else if (iResult == cDefaultNeverAvailable)
						{
							vGlobalXrayNoCommMessageRcvdEver = cNoCommPortFound;	// no new port, time out for DXM
							vDXMPortInitState++;
						}
						else if (iResult == cDefaultNotCurrentlyAvailable)		//try again at this state?
							vGlobalXrayNoCommMessageRcvdEver = cNoCommPortFound;	// no new port, time out for DXM
					}
					else
					{
						//serial port close, serial port open
						vGlobalDXMXRayPort->ClosePort();
						if (GetNextXRayDXMPort(vGlobalSerialPortNumberXRaySource + 1) == true)		// try for next port
						{
							vGlobalDXMXRayPort->vComPortNumber = vGlobalSerialPortNumberXRaySource;
							vGlobalDXMXRayPort->OpenPort(vGlobalDXMXRayPort->vComPortNumber);
							InitializeDXM();
							vGlobalDXMXRayPort->vCommunicationsTimeOutCounter = 0;
							vDXMPortInitState = 1;
							vXRayPortTry++;
						}
						else
						{
							vGlobalXrayNoCommMessageRcvdEver = cNoCommPortFound;	// no new port, time out for DXM
//							vGlobalDXMXRayPort->ClosePort();	//above
							vDXMPortInitState++;
						}
					}
					break;
				default:	// should not get here, if get here, stop trying for new serial port
						vGlobalXrayNoCommMessageRcvdEver = cNoCommPortFound;	// no new port, time out for DXM
						vGlobalDXMXRayPort->ClosePort();
					break;
				}
			}
		}
		if (vGlobalDXMXRayPort) 
		{
			if (vGlobalDXMXRayPort->vCommunicationsTimeOutCounter == 7)
			if (!vGlobalDXMXRayPort->vNoCommunications)
			if ((vSystemData.vACPowerOn) && (vGlobalXrayNoCommMessageRcvdEver == cYesCommSeen))
			{
				vGlobalDXMXRayPort->vCommunicationsTimeOutCounter = 8;
				vGlobalDXMXRayPort->vWaitingForReply = 0;
				vGlobalDXMXRayPort->vLastCommandSent = 0;
				vGlobalDXMXRayPort->ClearCommandQueue();
				InitializeDXM();
				//vGlobalDXMXRayPort->EnableWatchDog(true);  //if do before system is initialized, then will time out as takes more than 10 seconds to initialize

				vGlobalDXMXRayPort->PopFirstCommandOffQueue();
				if (!vConfigurationData->vSimulateLightControlBoard) //must comment out to test monoblock in the office

				//don't report DXM comm lost if using Guard Master and the interlock is open
				if ((!((vGlobalGuardMaster) && (vGlobalGuardMaster->vDetectedValidGuardMasterDevice))) || ((vGlobalGuardMaster->vOldGuardMasterRawInterlockData & cInterlockOutputBits) != cInterlockOutputBits))
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " Error-Lost Communications 5 Seconds, Try Initialize", cEMailInspx,32000);
			}

			if ((vGlobalDXMXRayPort->vCommunicationsTimeOutCounter > 27) /*&& (vGlobalXrayNoCommMessageRcvdEver == cYesCommSeen)*/)
			if (!vGlobalDXMXRayPort->vNoCommunications)
			if ((!vConfigurationData->vSimulateLightControlBoard) || (vGlobalDXMXRayPort->vModelNumber.GetLength() > 2)) //must comment out to test monoblock in the office
			if ((vSystemData.vACPowerOn) && (vGlobalXrayNoCommMessageRcvdEver == cYesCommSeen))
			{
				vGlobalDXMXRayPort->vNoCommunications = true;
//				vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;	// no new port, time out for DXM
				if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode))
				//don't report DXM comm lost if using Guard Master and the interlock is open
				if ((!((vGlobalGuardMaster) && (vGlobalGuardMaster->vDetectedValidGuardMasterDevice))) || ((vGlobalGuardMaster->vOldGuardMasterRawInterlockData & cInterlockOutputBits) != cInterlockOutputBits))
				{
					::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
					TempText.LoadString(IDS_LostCommunicationwithDXMHVPSCallInspx);
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " " + TempText + " - Inspection Stopped",cError,0);
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " Error-Lost Communication - Inspection Stopped", cEMailInspx,32000);
#ifdef CompileInHTTPClientOperationsGuardian
					if (vConfigurationData->vEnableOperationsGuardian)
					{
						vGlobalOGErrorCode = 701;
						vGlobalOGLocationString = "xray";
						::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageXRayFault, cOGSevereMessageXRayFault);
					}
#endif
				}
				else
				//don't report DXM comm lost if using Guard Master and the interlock is open
				if ((!((vGlobalGuardMaster) && (vGlobalGuardMaster->vDetectedValidGuardMasterDevice))) || ((vGlobalGuardMaster->vOldGuardMasterRawInterlockData & cInterlockOutputBits) != cInterlockOutputBits))
				{
//					vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;	// no new port, time out for DXM
					TempText.LoadString(IDS_LostCommunicationwithDXMHVPSCallInspx);
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " " + TempText, cError, 0);
					ReportErrorMessage(vGlobalDXMXRayPort->vHVPSType + " Error-Lost Communication", cEMailInspx,32000);
				}
			}
			if (vOldNoCommunicationsWithDXM != vGlobalDXMXRayPort->vNoCommunications)
			{
				vOldNoCommunicationsWithDXM = vGlobalDXMXRayPort->vNoCommunications;
				SetInterlockStatus();
			}
		}
		else
		if (vGlobalMonoBlockXRayPort)
		if (!vConfigurationData->vSimulateLightControlBoard)
		{
			if (vGlobalMonoBlockXRayPort->vCommunicationsTimeOutCounter == 10)
			if (!vGlobalMonoBlockXRayPort->vNoCommunications)
			if ((vSystemData.vACPowerOn) /*&& (vGlobalXrayNoCommMessageRcvdEver == cYesCommSeen)*/)
			{
				vGlobalMonoBlockXRayPort->vCommunicationsTimeOutCounter = 11;
				//vGlobalMonoBlockXRayPort->vWaitingForReply = 0;
				//vGlobalMonoBlockXRayPort->ClearCommandQueue();
				//InitializeDXM();
				if (!vConfigurationData->vSimulateLightControlBoard)
					ReportErrorMessage("Error-Lost Communication with XRB210W MonoBlock HVPS 9 Seconds, Try Initialize", cEMailInspx,32000);
			}

			if (vGlobalMonoBlockXRayPort->vCommunicationsTimeOutCounter > 20)
			if (!vGlobalMonoBlockXRayPort->vNoCommunications)
			if ((!vConfigurationData->vSimulateLightControlBoard) || (vGlobalMonoBlockXRayPort->vModelNumber.GetLength() > 2))
			if (vSystemData.vACPowerOn)
			{
				vGlobalMonoBlockXRayPort->vNoCommunications = true;
				if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode))
				{
					::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
					ReportErrorMessage("ErrorA-Lost Communication with XRB210W MonoBlock - Inspection Stopped", cError, 0);
					ReportErrorMessage("ErrorA-Lost Communication with XRB210W MonoBlock - Inspection Stopped", cEMailInspx,32000);
#ifdef CompileInHTTPClientOperationsGuardian
					if (vConfigurationData->vEnableOperationsGuardian)
					{
						vGlobalOGErrorCode = 701;
						vGlobalOGLocationString = "xray";
						::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageXRayFault, cOGSevereMessageXRayFault);
					}
#endif
				}
				else
				{
					ReportErrorMessage("ErrorA-Lost Communication with XRB210W MonoBlock", cError, 0);
					ReportErrorMessage("ErrorA-Lost Communication with XRB210W MonoBlock", cEMailInspx,32000);
				}
			}
			if (vGlobalMonoBlockXRayPort->vOldNoCommunications != vGlobalMonoBlockXRayPort->vNoCommunications)
			{
				vGlobalMonoBlockXRayPort->vOldNoCommunications = vGlobalMonoBlockXRayPort->vNoCommunications;
				if (vGlobalMonoBlockXRayPort->vOldNoCommunications)
				{
					if (vGlobalMonoBlockXRayPort->vPortOpen)
					{
						vGlobalMonoBlockXRayPort->ClosePort();
						ReportErrorMessage("Lost XRB210W MonoBlock X-Ray Comm Closed Serial Port", cEMailInspx, 32000);
						vGlobalMonoBlockXRayPort->OpenPort(vGlobalMonoBlockXRayPort->vComPortNumber);
						ReportErrorMessage("Lost XRB210W MonoBlock X-Ray Comm Opened Serial Port", cEMailInspx, 32000);
					}
				}
				SetInterlockStatus();
			}
/*	for future serial port find
			if (vGlobalXrayNoCommMessageRcvdEver == cNoCommSeenEver)
			{
				if (vGlobalMonoBlockXRayPort->vCommunicationsTimeOutCounter > 4)
				{
					switch(vMonoPortInitState) 
					{
					case 0:
						//InitializeDXM();		// init port, maybe not initialized before
						vMonoPortInitState++;
						vGlobalMonoBlockXRayPort->vCommunicationsTimeOutCounter = 0;
						break;
					case 1:
						vMonoPortInitState++;
						break;
					case 2:
						vMonoPortInitState++;
						break;
					case 3:
						if (vXRayPortTry > cTimesToTryPorts)
						{
							vGlobalMonoBlockXRayPort->ClosePort();
							int iResult = SetXRayPortToDefault();
							if (iResult == cSetToDefault)
							{
								vGlobalXrayNoCommMessageRcvdEver = cYesCommSeen;
								vGlobalMonoBlockXRayPort->OpenPort(vGlobalSerialPortNumberXRaySource);
								vMonoPortInitState++;
							}
							else if (iResult == cDefaultNeverAvailable)
							{
								vGlobalXrayNoCommMessageRcvdEver = cNoCommPortFound;	// no new port, time out for DXM
								SetInterlockStatus();
								vMonoPortInitState++;
							}
	//						else if (iResult == cDefaultNotCurrentlyAvailable)		//try again at this state
//								vGlobalXrayNoCommMessageRcvdEver = cNoCommPortFound;
						}
						else
						{
							//serial port close, serial port open
							vGlobalMonoBlockXRayPort->ClosePort();
							if (GetNextXRayMonoPort(vGlobalSerialPortNumberXRaySource + 1) == true)		// try for next port
							{
								vGlobalMonoBlockXRayPort->vComPortNumber = vGlobalSerialPortNumberXRaySource;
								vGlobalMonoBlockXRayPort->OpenPort(vGlobalMonoBlockXRayPort->vComPortNumber);
								//InitializeDXM();
								vGlobalMonoBlockXRayPort->vCommunicationsTimeOutCounter = 0;
								vMonoPortInitState = 1;
								vXRayPortTry++;
							}
							else
							{
								vGlobalXrayNoCommMessageRcvdEver = cGiveUpOnCommPort;	// no new port, time out for mono
	//							vGlobalMonoBlockXRayPort->ClosePort();	//above
								vMonoPortInitState++;
							}
						}
						break;
					default:	// should not get here, if get here, stop trying for new serial port
							vGlobalXrayNoCommMessageRcvdEver = cGiveUpOnCommPort;	// no new port, time out for mono
							vGlobalMonoBlockXRayPort->ClosePort();
						break;
					}
				}
			}
		*/
		}

		if (vSystemData.vOldNoCommunicationsWithUController)
		if (vSystemData.vShowingShuttingDownIndicator)
		if ((vSystemData.vCommunicationsTimeOutCounter > 6) && (vSystemData.vCommunicationsTimeOutCounter < 240))
		if ((!vSystemData.vFPGAVersion9Point1OrHigher) && (vSystemData.vFPGAMajorVersionNumber))
		{
			vShuttingDownIndicatorValue = ((BYTE)vSystemData.vITIPCDig->vCaptureModule->InportVal(0));
			if ((vShuttingDownIndicatorValue & 6) != 6)
			{
				SetInterlockStatus();
				//TempText.LoadString(IDS_NouC);
				//SetDlgItemText(IDC_uControllerStatus,TempText);
				vSystemData.vShowingShuttingDownIndicator = false;
				
				CString TempString = " ";
				TempString.LoadString(IDS_LostCommunicationwithMicroControllerCallInspx);
				ReportErrorMessage(TempString,cError,0);

				if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
				{
					::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
					ReportErrorMessage("Lost Comm with uC, Power On - Inspection Stopped", cEMailInspx,32000);
					ReportErrorMessage("Lost Comm with uC - Inspection Stopped", cError, 0);
				}
				else
				{
					ReportErrorMessage("Lost Comm with uC, Not Shutting Down", cEMailInspx,32000);
					ReportErrorMessage("Lost Comm with uC", cError, 0);
				}
#ifdef CompileInHTTPClientOperationsGuardian
				if (vConfigurationData->vEnableOperationsGuardian)
				{
					vGlobalOGErrorCode = 700;
					vGlobalOGLocationString = "uC";
					::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageXRayFault, cOGSevereMessageXRayFault);
				}
#endif
			}
			if (vSystemData.vCommunicationsTimeOutCounter == 11)
			if (vSystemData.vShowingShuttingDownIndicator)
			{
				vSystemData.vShowingShuttingDownIndicator = false; //don't check any more if shutting down
				ReportErrorMessage("Power Off, Shutting Down ScanTrac.", cEMailInspx,32000);
				ReportErrorMessage("Power Off, Shutting Down ScanTrac.", cUserChanges,32000);
			}
		}

		//if (vSystemData.vHVPSInterlockDelay)
		//{
		//	CString TempString = " ";
		//	TempString.LoadString(IDS_HVPSInterlock);
		//	if (vSystemData.vOpenInterlock == TempString)
		//	{
		//		if (vSystemData.vHVPSInterlockDelay < 3)
		//			vSystemData.vHVPSInterlockDelay++;
		//		if (vSystemData.vHVPSInterlockDelay > 2)
		//		if ((vSystemData.vLastXRayCommandOn) || (vSystemData.vSystemRunMode != cStoppedSystemMode))
		//		{
		//			::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
		//			CString TempString1 = " ";
		//			TempString1.LoadString(IDS_XRaysShutDown);
		//			TempString.LoadString(IDS_HighVoltagePowerSupplyInterlock);
		//			ReportErrorMessage(TempString + " - " + TempString1, cError,15);
		//		}
		//	}
		//	else
		//		vSystemData.vHVPSInterlockDelay = 0;
		//}

		if (vSystemData.vMainDisplayMode != cMainDisplayBooting)
		{
			if ((vConfigurationData->vDemoMode) || (vConfigurationData->vSimulateLightControlBoard))
			if ((vGlobaluCSerialPort) && (vGlobaluCSerialPort->vNoCommunications))
			if (vSystemData.vXRayOnNotice)
			{
				if (vSystemData.vFPGASimulateEncoderRate)
				{
					vSystemData.vCurrentBeltPosition = vSystemData.vCurrentBeltPosition + vSystemData.vFPGASimulateEncoderRate;
					vSystemData.vActualEncoderRate = vSystemData.vFPGASimulateEncoderRate;
				}
				else
				if (vConfigurationData->vContinuousFeedEncoderRate)
				{
					vSystemData.vCurrentBeltPosition = vSystemData.vCurrentBeltPosition + vConfigurationData->vContinuousFeedEncoderRate;
					vSystemData.vActualEncoderRate = vConfigurationData->vContinuousFeedEncoderRate;
				}
				else
				{
					if (vSystemData.vMaximumEncoderRate < 5)
						vSystemData.vMaximumEncoderRate = CalculateMaximumEncoderRate(vGlobalCurrentProduct->vXRayIntegrationTime);

					vSystemData.vCurrentBeltPosition = vSystemData.vCurrentBeltPosition + (WORD)(vSystemData.vMaximumEncoderRate * .85);
					vSystemData.vActualEncoderRate = (WORD)(vSystemData.vMaximumEncoderRate * .85);
				}
			}
			else
				vSystemData.vActualEncoderRate = 0;

			if (vHaveRejects != HaveRejects(false))
			{
				vHaveRejects = HaveRejects(false);//false);
				CString TempText = " ";

				if (vHaveRejects)
				{
					TempText.LoadString(IDS_Rejects);
					SetDlgItemText(IDC_Function4Button,TempText);
				}
				else
				{
					TempText.LoadString(IDS_NoRejects);
					SetDlgItemText(IDC_Function4Button,TempText);
				}
			}
			if ((vSystemData.vOldNoCommunicationsWithUController != vSystemData.vNoCommunicationsWithUController) && (!vConfigurationData->vSimulateLightControlBoard))
			{
				vSystemData.vOldNoCommunicationsWithUController = vSystemData.vNoCommunicationsWithUController;
				if (vSystemData.vOldNoCommunicationsWithUController)
				{
					if ((!vSystemData.vFPGAVersion9Point1OrHigher) && (vSystemData.vFPGAMajorVersionNumber))
					{
						//ReportErrorMessage("Error-Lost Comm. with uC, may be shutting down",cEMailInspx,32000);
						//CString TempText;
						//TempText.LoadString(IDS_ShuttingDown);
						//SetDlgItemText(IDC_uControllerStatus,TempText);
						vSystemData.vShowingShuttingDownIndicator = true;
						vSystemData.vACPowerOn = false;
						SetInterlockStatus();

						ReportErrorMessage("Master Power Switch Turned Off",cUserChanges,0);

						if (vGlobaluCSerialPort)
						if (vGlobaluCSerialPort->vComPortNumber)
						{
							vGlobaluCSerialPort->ClosePort();
							ReportErrorMessage("Lost Comm Closed Serial Port", cWriteToLog,0);
							vGlobaluCSerialPort->OpenPort(vGlobaluCSerialPort->vComPortNumber);
							ReportErrorMessage("Lost Comm Opened Serial Port", cWriteToLog,0);
						}
						if (vSystemData.vSystemRunMode != cStoppedSystemMode)
						{
							int TimerResult = SetTimer(vTriggerIndicatorTimerHandle,10,NULL);
							if (!TimerResult)
								ReportErrorMessage("Error-Trigger Indicator Timer Failed",cEMailInspx,32000);
						}
					}
					else // vFPGAVersion9Point1OrHigher but less than version 10
					if (!vGlobalFPGAVersion10Point0OrHigher)
					{ //lost comm with micro controller
						if ((vSystemData.vSourceInterLocks & 0x0040) != 0x0040)
						{
							//TempText.LoadString(IDS_ShuttingDown);
							ReportErrorMessage("Master Power Switch Turned Off <9.1",cUserChanges,0);
							vSystemData.vACPowerOn = false;
						}
						else
						{
							//TempText.LoadString(IDS_NouC);
							//ReportErrorMessage("Lost Communication with Micro-Controller. Call Service.",
							//	cError,0);
							vSystemData.vACPowerOn = true;
							if (vGlobaluCSerialPort)
								vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
							KillTimer(vCheckACBeforeThisYellowMessageTimerHandle);

							ReportErrorMessage("Master Power On <10.1",cUserChanges,0);
							if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
							{
								::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
								ReportErrorMessage("Lost Comm with uC, Power On 9.1 - Inspection Stopped", cEMailInspx,32000);
								ReportErrorMessage("Lost Comm with uC, Power On 9.1 - Inspection Stopped", cError,0);
							}
							else
							{
								ReportErrorMessage("Lost Comm with uC, Not Shutting Down 9.1", cEMailInspx,32000);
								ReportErrorMessage("Lost Comm with uC, Not Shutting Down 9.1", cError,32000);
							}
#ifdef CompileInHTTPClientOperationsGuardian
							if (vConfigurationData->vEnableOperationsGuardian)
							{
								vGlobalOGErrorCode = 700;
								vGlobalOGLocationString = "uC";
								::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageXRayFault, cOGSevereMessageXRayFault);
							}
#endif
						}
						//SetDlgItemText(IDC_uControllerStatus,TempText);
						SetInterlockStatus();
						if (vGlobaluCSerialPort)
						if (vGlobaluCSerialPort->vComPortNumber)
						{
							vGlobaluCSerialPort->ClosePort();
							ReportErrorMessage("Lost Comm Closed Serial Port", cWriteToLog,0);
							vGlobaluCSerialPort->OpenPort(vGlobaluCSerialPort->vComPortNumber);
							ReportErrorMessage("Lost Comm Opened Serial Port", cWriteToLog,0);
						}
					}
					else 
					if (vGlobalFPGAVersion10Point0OrHigher)
					{ //lost comm with micro controller
						if (vSystemData.vACPowerOn)
						{
							if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
							{
								::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
								ReportErrorMessage("Lost Comm with uC - Inspection Stopped", cEMailInspx,32000);
								ReportErrorMessage("Lost Comm with uC - Inspection Stopped", cError, 0);
#ifdef CompileInHTTPClientOperationsGuardian
							if (vConfigurationData->vEnableOperationsGuardian)
							{
								vGlobalOGErrorCode = 700;
								vGlobalOGLocationString = "uC";
								::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageComFault, cOGSevereMessageComFault);
							}
#endif
						}
							else
							{
								if (vGlobalFirstMicroControllerCommCheck == cInitializeSearchForSerialPort)		// if communications have not started
									vGlobalFirstMicroControllerCommCheck = cStartSearchForSerialPort;
								else
								{
									if (vGlobalFirstMicroControllerCommCheck == cSearchingForNextSerialPort)
									{
										ReportErrorMessage("Lost Comm with uC", cEMailInspx,32000);
										ReportErrorMessage("Lost Comm with uC", cError, 0);
									}
									else if (vGlobalFirstMicroControllerCommCheck == cFinishedSearchForNextSerialPort)
									{
										ReportErrorMessage("No Comm with uC", cEMailInspx,32000);
										ReportErrorMessage("No Comm with uC", cError, 0);
									}
									else if (vGlobalFirstMicroControllerCommCheck == cNoCommPortSettings)
									{
										ReportErrorMessage("No Port with uC", cEMailInspx,32000);
										ReportErrorMessage("No Port with uC", cError, 0);
									}
								}
							}

							SetInterlockStatus();
							if (vGlobaluCSerialPort)
							if (vGlobaluCSerialPort->vComPortNumber)		// SyncFromMicroControllerSeen > 0 ,
							{
								// here kjh 8/5/2014 add check if ever had comm with this serial port, if not look for correct serial port
								// case I first time through, set up to try other ports
								// case II lost comm, flag no comm
								// case III checked all ports, flag no comm
								CString TempString;
								if ((vGlobalFirstMicroControllerCommCheck == cInitializeSearchForSerialPort) || (vGlobalFirstMicroControllerCommCheck == cStartSearchForSerialPort))		// if communications have not started
								{
									vGlobalFirstMicroControllerCommCheck = cSearchingForNextSerialPort;
									vSystemData.vNoCommunicationsWithUController = false;
									vSystemData.vCommunicationsTimeOutCounter = 0;
									TempString.Format(_T("No Reply Comm %d, Try Next Comm Serial Port"), vGlobaluCSerialPort->vComPortNumber);
								}
								else if ((vGlobalFirstMicroControllerCommCheck == cSearchingForNextSerialPort) ||
									     (vGlobalFirstMicroControllerCommCheck == cDoneSearchForNextSerialPort) ||
										 (vGlobalFirstMicroControllerCommCheck == cFinishedSearchForNextSerialPort))
								{
									//zvGlobaluCSerialPort->ClosePort();
									ReportErrorMessage("Lost Comm " /* Closed Serial Port */, cWriteToLog,0);
									// leave port free for other devices vGlobaluCSerialPort->OpenPort(vGlobaluCSerialPort->vComPortNumber);
									TempString.Format(_T("Lost Comm %d"), vGlobaluCSerialPort->vComPortNumber);
								}
								else if (vGlobalFirstMicroControllerCommCheck == cNoCommPortSettings)		// no serial port found
								{
									//ReportErrorMessage("No Serial Port to uController Board", cWriteToLog,0);
									ReportErrorMessage("No Serial Port to uController Board", cEMailInspx,32000);
									ReportErrorMessage("No Serial Port to uController Board", cError,0);
									TempString.LoadString(IDS_NouC);
									vShowuControllerStatusInRed = true;
									if (!vConfigurationData->vDemoMode)
										SetDlgItemText(IDC_uControllerStatus,TempString);
								}
								ReportErrorMessage(TempString, cWriteToLog,0);
							}
						}
					}
				}
				//else
				//{
				//	ReportErrorMessage("Micro-Controller Communications Tests Passed",cAction,0);
				//	//ReportErrorMessage("Micro-Controller Communications Tests Passed",cEMailInspx,32001);
				//	if (!vSystemData.vFPGAVersion9Point1OrHigher)
				//	{
				//		vSystemData.vACPowerOn = true;
				//		if (vGlobaluCSerialPort)
				//			vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
				//		KillTimer(vCheckACBeforeThisYellowMessageTimerHandle);

				//		ReportErrorMessage("Master Power Switch Turned On <9.1",cUserChanges,0);
				//	}
				//	if (vSystemData.vSystemRunMode != cStoppedSystemMode)
				//		KillTimer(vTriggerIndicatorTimerHandle);
				//	SetInterlockStatus();
				//	//reset uc if not running
				//	if (vSystemData.vSystemRunMode == cStoppedSystemMode)
				//	{
				//		tSerialCommand TempCommand;
				//		TempCommand[0] = 0x35;
				//		TempCommand[1] = 0x34;
				//		TempCommand[2] = 0x33;
				//		TempCommand[3] = 0x32;
				//		if (vGlobaluCSerialPort)
				//			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
				//		Sleep(400);  // Must keep this, does not work at 100
				//	}
				//}
			}
			if (vSystemData.vOldOpenInterlock != vSystemData.vOpenInterlock)
			{
				SetInterlockStatus();
			}
		}

		if (!vDisplayingVersion)
		{
			CTime TempTime;
			TempTime = CTime::GetCurrentTime();
			CString TempTimeString = " ";
			if (vConfigurationData->vShow24HourTime)
				TempTimeString = TempTime.Format("%H:%M:%S");//24 hour time format
			else
				TempTimeString = TempTime.Format("%#I:%M:%S%p");//12 hour time format with am pm

			SetDlgItemText(IDC_Clock,TempTimeString);
			int TempMinute = TempTime.GetMinute();
			if (TempMinute != vLastMinute)
			{
				vLastMinute = TempMinute;
				//socketio v12 dtoa(vLocalSystemData->v12, 0)
				//socketio v25 vSystemData.v15)


				vSystemData.vGaveQueueOverflowMessage = false;

				//SaveCheckWeighTrendPoint();

				if (!(vLastMinute % 5)) //every 5 minutes log the temperatures.
				{
					if (vGlobalFBWFEnable == 1)
					{		// kjh FBWF check
						if (MemoryUsageFBWFCheck() != NO_ERROR)
						{
							ReportErrorMessage("FBWF Memory Check Fail",cEMailInspx,32000);
						}
					}

					if (vGlobalFPGAVersion10Point0OrHigher)
					{
						if (vSystemData.vTemperatureAirOutside < 0xFFFF)
						if (vConfigurationData->vDeltaTemperatureForFilterCloggedError) //have a filter, so do not have AirConditioning
							ReportErrorMessage("Outside Air Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureAirOutside, vConfigurationData->vTemperatureAirOutsideAdjust), cWriteToLog,0);
						else
							ReportErrorMessage("A/C Output Air Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureAirOutside, vConfigurationData->vTemperatureAirOutsideAdjust), cWriteToLog,0);

						ReportErrorMessage("Inside Air Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureAirInside, vConfigurationData->vTemperatureAirInsideAdjust), cWriteToLog,0);

						if (vSystemData.vTemperatureSurface < 0xFFFF)
						ReportErrorMessage("Surface Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureSurface, vConfigurationData->vTemperatureSurfaceAdjust), cWriteToLog,0);

						if (vConfigurationData->vHVPSType == cDXMHVPS)
							ReportErrorMessage("Coolant Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureLiquid, vConfigurationData->vTemperatureLiquidAdjust), cWriteToLog,0);

						if ((vConfigurationData->vHVPSType == c100WMonoBlockHVPS) || (vConfigurationData->vHVPSType == cCheyneyMonoBlock) || (vConfigurationData->vHVPSType == c100WVJTMonoBlockHVPS))
						if (vGlobalDXMXRayPort)
						{
							double TempDegreesF = (vGlobalDXMXRayPort->vTemperature * 9 / 5) + 32;
							ReportErrorMessage("100 Watt MonoBlock Temp: " + dtoa(vGlobalDXMXRayPort->vTemperature,0) + "`C, " + dtoa(TempDegreesF,0) + "`F", cWriteToLog,0);
						}

						ReportErrorMessage("Detector Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureuC, vConfigurationData->vTemperatureuCAdjust), cWriteToLog,0);

						if (vSystemData.vCPUTemperaturesReadOK)
							ReportErrorMessage("CPU Temp: " + GetCoreTemperatureString(vSystemData.vCPUTemperature), cWriteToLog,0);
					}
					else
					{
						CString TempStringS = "Surface";
						if (vConfigurationData->vHasOutsideAirTemp)
							TempStringS = "Outside Air";

						ReportErrorMessage("Inside Air Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureAirInside, 
							vConfigurationData->vTemperatureAirInsideAdjust) + " " + TempStringS + " Temp: " + 
							ConvertToDegreesCString(vSystemData.vTemperatureSurface, vConfigurationData->vTemperatureSurfaceAdjust), cWriteToLog,0);

						ReportErrorMessage("Coolant Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureLiquid,
							vConfigurationData->vTemperatureLiquidAdjust), cWriteToLog,0);
					}
					if (vGlobalAmountOfFreeMemory < 500000000)
						ReportErrorMessage("Free Memory: " + IToAWithComma(vGlobalAmountOfFreeMemory), cWriteToLog,0);
				}

				int TempHour = TempTime.GetHour();
				if (TempHour != vLastHour)
				{
					vLastHour = TempHour;

					if (!vGlobalPasswordTimeOut)  //if password times out, clear password
					if (!PasswordOK(cSetupPassword,false))
						SetCursorPos(vGlobalDisplaySizeH,vGlobalDisplaySizeV);
					bool TempMadeProductionReport = false;

					if (TempHour == 0)
						TempHour = 24;  //24 is code for midnight in parameter setup
					if (vConfigurationData->vAutoProductionReportHour)
					{
						if ((TempHour == vConfigurationData->vAutoProductionReportHour) || 
							((vConfigurationData->vAutoProductionReportHour2) && (TempHour == vConfigurationData->vAutoProductionReportHour2)) ||
							((vConfigurationData->vAutoProductionReportHour2) && 
							(vConfigurationData->vAutoProductionReportHour3) && (TempHour == vConfigurationData->vAutoProductionReportHour3)))
						{
							TempMadeProductionReport = true;
							GenerateProductionReport(cSelectProductProductionReport);
							ResetCounters();
							SendProductionReport(cSelectProductProductionReport);
						}
					}

					WriteLifeTimeCounter();
#ifdef CompileInHTTPClientOperationsGuardian
					SendOGOneMinueData(true);
#endif
					if (!TempMadeProductionReport)
						GenerateProductionReport(cTimeUpdateProductoinReport);
				} //end of hour changed
#ifdef CompileInHTTPClientOperationsGuardian
				else
					SendOGOneMinueData(false);
#endif
			}//end of minute changed
			CString TempDateString = TempTime.Format("%B %#d, %Y");
			CString TempChar = TempDateString.GetAt(0);
			TempChar.MakeUpper();
			TempDateString.SetAt(0,TempChar.GetAt(0));

			if (vLastDateString != TempDateString)
			{
				//if (_wtoi(vLastDateString) + 1 == _wtoi(TempDateString)) //if date change to next day only
				RenameProductionReportIfNeeded(false);

				vGaveHardDriveFailedMessageToday = false;

				if (vLastDateString == "1")
					BackupSetupFiles(false); //just started ScanTrac program, so don't backup to backup hard disk for 30 minutes
				else
					BackupSetupFiles(true);
				//vHaveNotBackedUpYet = true;  //cause backup each day
				vSystemData.vErrorCountForLogFile = 0;
				SetDlgItemText(IDC_Date,TempDateString);
				vLastDateString = TempDateString;

				AutoDeleteLogFiles();
			//DeleteOldLogFiles(20,vConfigurationData->vScanTracSerialLogsDirectory);

				DisplaySupportContractStatus();
			}
		}

	if (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode)
		if (vSystemData.vWaitingForImage)
	if (vSystemData.vWaitingForImage < 50)
			vSystemData.vWaitingForImage++;
	if (vSystemData.vWaitingForImage == 8)
	{
		vSystemData.vTimesRetried++;
		if (vSystemData.vTimesRetried > 3)
		{
			::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
			if (vSystemData.vActualEncoderRate == 0)
			{
				ReportErrorMessage("No Image, Call Service, No Encoder-Inspection Stopped",cEMailInspx, 32000);
				ReportErrorMessage("No Image, Call Service, No Encoder-Inspection Stopped",cError, 0);
#ifdef CompileInHTTPClientOperationsGuardian
				if (vConfigurationData->vEnableOperationsGuardian)
				{
					vGlobalOGErrorCode = 501;
					vGlobalOGLocationString = "encoder";
					::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageImageFault, cOGSevereMessageImageFault);
				}
#endif
			}
			else
			if (vSystemData.vPercentBeltSpeed > 102)
			{
				ReportErrorMessage("No Image Received, encoder too fast for Integration Time-Rate (Hz): " + dtoa(vSystemData.vActualEncoderRate,2) + ", Limit: " + dtoa(vSystemData.vMaximumEncoderRate,2),cEMailInspx, 32000);
				ReportErrorMessage("No Image Received, encoder too fast for Integration Time-Rate (Hz): " + dtoa(vSystemData.vActualEncoderRate,2) + ", Limit: " + dtoa(vSystemData.vMaximumEncoderRate,2),cError, 0);
			}
			else
			{
				ReportErrorMessage("No Image Received, Call Service-Inspection Stopped",cEMailInspx, 32000);
				ReportErrorMessage("No Image Received, Call Service-Inspection Stopped",cError, 0);
			}
			int TimerResult = SetTimer(vFlashYellowLightTimerHandle,500,NULL);
			vSystemData.vCantInspectError = true; //flash blue + yellow
		}
		else
		{
			ReportErrorMessage("No Image Received, Trying Again",cWriteToLog,0);
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("No Image Received, Trying Again, SimulateOneContainerIn10MS", cDebugMessage);
			SimulateOneContainerIn10MS(100);
		}
	}

	if (vSystemData.vSystemRunMode == cRunningSystemMode)
	{
		if (!vSystemData.vRunDuration)
		{
			vSystemData.vTimeStarted = CTime::GetCurrentTime();
			vSystemData.vRunStartTime = vSystemData.vTimeStarted.Format("%H:%M:%S   %d-%b-%y");
		}
	}

	if (vSystemData.vCountTimeAsRunning)  //if no containers going through, then count time as stopped
	{
		vSystemData.vRunDuration++;
		if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
			SetDlgItemText(IDC_TotalContainers,FormatRunTimeCounterString(vSystemData.vRunDuration));// if a pipe show run duration for total
	}
	else
	{
		vSystemData.vStopDuration++;
		vSystemData.vTimeSinceLastStop++;
	}
		
	vSystemData.vTotalDuration++;
	if (vSystemData.vTotalDuration > 1)
		vSystemData.vShiftRateCPM = (WORD)((((double)vSystemData.vTotalContainers / (double)vSystemData.vTotalDuration) * 60.0) + .49);

	if (vSystemData.vXRayOnNotice)
	{
		vGlobalLifeTimeCounters->vXRaySourceRunDuration++;
		vGlobalLifeTimeCounters->vDetectorsRunDuration++;
		vGlobalLifeTimeCounters->vScanTracRunDuration++;
		vGlobalLifeTimeCounters->vXRaySourceWarrantyDuration++;
		vGlobalLifeTimeCounters->vDetectorsWarrantyDuration++;
	}

	if (vOldGlobalPasswordOK != vGlobalPasswordLevel)
	{
		vOldGlobalPasswordOK = vGlobalPasswordLevel;

		if (!vOldGlobalPasswordOK)
		{
			SetCursorPos(vGlobalDisplaySizeH,vGlobalDisplaySizeV);
		}

		ShowInspxButtons();
		SetProductDensityDisplay();
		CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
		if (TempWindow)
			TempWindow->Invalidate(false);
		WriteLifeTimeCounter();
	}


	//if ((vSystemData.vITIPCDig->vAverageEnabled != vOldAverageEnabled) ||
	//	((vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled) != vOldCalibrateBodyTriggerReferenceEnabled) ||
	//	(vSystemData.vITIPCDig->vStructureEnabled != vOldStructureEnabled))
	//{
	//	::PostThreadMessage(vGlobalCallingThreadID,cCheckLearningMessage,0,0);
	//}
	if ((vGlobalProcessQuickLearnImagesThread) || (vProcessCount))
		UpdateRejectReasonOnScreen();
	if (vSystemData.vTakingQuickLearnImages)
	{
		if (vOldLearnCount != vSystemData.vQuickLearnImageIndex)
		{
			vOldLearnCount = vSystemData.vQuickLearnImageIndex;
			UpdateRejectReasonOnScreen();
		}
	}
	if (vOldCalibrateBodyTriggerReferenceEnabled)
	{
		if (vOldLearnCount != vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceCount)
		{
			vOldLearnCount = vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceCount;
			UpdateRejectReasonOnScreen();
		}
	}
	if (vOldAverageEnabled)
	{
		if (vOldLearnCount != vSystemData.vITIPCDig->vAverageCount)
		{
			vOldLearnCount = vSystemData.vITIPCDig->vAverageCount;
			UpdateRejectReasonOnScreen();
		}
	}
	if (vOldStructureEnabled)
	{
		if (vOldLearnCount != vSystemData.vITIPCDig->vStructureCount)
		{
			vOldLearnCount = vSystemData.vITIPCDig->vStructureCount;
			UpdateRejectReasonOnScreen();
		}
	}

	if (vGlobalCurrentProduct)
	{
		if (!vSystemData.vMaximumEncoderRate)
			ReportErrorMessage("Error-vMaximumEncoderRate = 0, would cause crash", cEMailInspx, 32000);
		else
		if ((!vSystemData.vFPGASimulateEncoderRate) && (!vConfigurationData->vContinuousFeedEncoderRate))
			vSystemData.vPercentBeltSpeed = vSystemData.vActualEncoderRate / vSystemData.vMaximumEncoderRate * cMaximumConveyorSpeedDerating;
		else
			vSystemData.vPercentBeltSpeed = vSystemData.vActualEncoderRate / vSystemData.vMaximumEncoderRate * cMaximumConveyorSpeedDeratingWithSimulatedEncoder;

		if (vSystemData.vPercentBeltSpeed > vSystemData.vPercentBeltSpeedMaximum)
		if (vGlobaluCSerialPort)
		if ((vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode) &&
			(!vSystemData.vSimulatingFastestEncoder) && 
			(!vGlobaluCSerialPort->vOldSimulatingFastestEncoder))
		//if ((vSystemData.vSystemRunMode == cAutoSetupRunningSystem) || 
		//	((vSystemData.vSystemRunMode == cRunningSystemMode) &&
		//	(vSystemData.vSourceRampedUp)))
		//if ((!vSystemData.vShuttingDownXRays) && (vSystemData.vCheckConveyor == 2))
			vSystemData.vPercentBeltSpeedMaximum = vSystemData.vPercentBeltSpeed;

		if (vSystemData.vGaveConveyorTooFastWarning < 10)
		if ((vSystemData.vSystemRunMode == cRunningSystemMode) || (vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
		if (!vSystemData.vInExpressSetup) //don't give warning in Express Setup as it will adjust the integration time to match the conveyor speed
		if (vSystemData.vPercentBeltSpeed > 110)
		{
			vSystemData.vGaveConveyorTooFastWarning++;
			if (vSystemData.vGaveConveyorTooFastWarning == 10)
			{
				if ((vSystemData.vPercentBeltSpeed > 120) && (vSystemData.vSystemRunMode == cRunningSystemMode))
				{
					if ((vSystemData.vFPGASimulateEncoderRate) || (vConfigurationData->vContinuousFeedEncoderRate) || (vConfigurationData->vScanTracType == cFermataScanTrac))
						ReportErrorMessage("Encoder input too fast to take images.\nSlow down encoder input,\nor shorten Integration Time.  Rate (Hz): " + dtoa(vSystemData.vActualEncoderRate,2) + ", Limit: " + dtoa(vSystemData.vMaximumEncoderRate,2), cCritical, 0);
					else
						ReportErrorMessage("Conveyor too fast to take images.\nSlow down conveyor,\nor shorten Integration Time.  Rate (Hz): " + dtoa(vSystemData.vActualEncoderRate,2) + ", Limit: " + dtoa(vSystemData.vMaximumEncoderRate,2), cCritical, 0);
				}

				if ((vSystemData.vFPGASimulateEncoderRate) || (vConfigurationData->vContinuousFeedEncoderRate) || (vGlobalScanTracType == cLegatoScanTrac) || (vGlobalScanTracType == cFermataScanTrac))
					ReportErrorMessage("Encoder input too fast to inspect-Speed at " + dtoa(vSystemData.vPercentBeltSpeed,0) + "%",cError,0);
				else
					ReportErrorMessage("Conveyor too fast to inspect-Speed at " + dtoa(vSystemData.vPercentBeltSpeed,0) + "%",cError,0);
			}
		}
		else
		if ((vSystemData.vPercentBeltSpeed > 106) && (vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode))
		{
			vSystemData.vGaveConveyorTooFastWarning++;
			if (vSystemData.vGaveConveyorTooFastWarning == 10)
			{
				if ((vSystemData.vFPGASimulateEncoderRate) || (vConfigurationData->vContinuousFeedEncoderRate) || (vConfigurationData->vScanTracType == cFermataScanTrac))
					ReportErrorMessage("Slow Down Encoder input-Speed at " + dtoa(vSystemData.vPercentBeltSpeed,0) + "%", cEMailMaintenance,0);
				else
					ReportErrorMessage("Slow Down Conveyor-Speed at " + dtoa(vSystemData.vPercentBeltSpeed,0) + "%", cEMailMaintenance,0);
			}
		}
		else
		if ((vSystemData.vPercentBeltSpeed > 102) && ((vSystemData.vSystemRunMode == cRunningSystemMode) || (vSystemData.vSystemRunMode == cAutoSetupRunningSystem)))
		{
			vSystemData.vGaveConveyorTooFastWarning++;
			if (vSystemData.vGaveConveyorTooFastWarning == 10)
			{
				if ((vSystemData.vFPGASimulateEncoderRate) || (vConfigurationData->vContinuousFeedEncoderRate) || (vConfigurationData->vScanTracType == cFermataScanTrac))
					ReportErrorMessage("Slow Down Encoder input-Speed at " + dtoa(vSystemData.vPercentBeltSpeed,0) + "%", cEMailMaintenance,0);
				else
					ReportErrorMessage("Slow Down Conveyor-Speed at " + dtoa(vSystemData.vPercentBeltSpeed,0) + "%", cEMailMaintenance,0);
			}
		}
	}

	BYTE TempFactor = 1;
	if (vGlobalCurrentProduct)
		TempFactor = vGlobalCurrentProduct->vOverScanMultiplier;

	if (!TempFactor)
		ReportErrorMessage("Error-TempFactor = 0, would cause crash", cEMailInspx, 32000);
	else
	if (!vGlobalPixelsPerUnit)
		ReportErrorMessage("Error-vGlobalPixelsPerUnit = 0, would cause crash", cEMailInspx, 32000);
	else
		vSystemData.vBeltRate = (UINT)((vSystemData.vActualEncoderRate * 60.0  / vGlobalPixelsPerUnit) / TempFactor);

	if (vSystemData.vBeltRate > vSystemData.vBeltRateMaximum)
	if (vGlobaluCSerialPort)
	if ((vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode) &&
		(!vSystemData.vSimulatingFastestEncoder) && 
		(!vGlobaluCSerialPort->vOldSimulatingFastestEncoder))
		vSystemData.vBeltRateMaximum = vSystemData.vBeltRate;

		//check if body trigger optical sensor is blocked
	if ((vSystemData.vActualEncoderRate) && (!vSystemData.vFPGASimulateEncoderRate) && (!vConfigurationData->vContinuousFeedEncoderRate) &&
		 (!vConfigurationData->vContinuousFeedContainerRate) && (vConfigurationData->vShowOnlyRealImages) && 
		 (vSystemData.vSystemRunMode == cRunningSystemMode) &&// || (vSystemData.vSystemRunMode == cAutoSetupRunningSystem)) && 
		//look and see if body trigger is stuck high
		(vSystemData.vBodyTriggerLines) && (vSystemData.vSourceRampedUp) && (vConfigurationData->vBackupDetectionUsingBodyTriggerTimeOut & 0x7F))
		{
			if (vBodyTriggerActiveTimer < 700)
				vBodyTriggerActiveTimer++;
			if (vBodyTriggerActiveTimer == (vConfigurationData->vBackupDetectionUsingBodyTriggerTimeOut & 0x7F)) //default 3 seconds
			{
				if (!vGaveBodyTriggerJammedMessage)
				{
					CString TempText;
					TempText.LoadString(IDS_MaintenanceCleanandcheckopticalsensoralignment);
					if (vConfigurationData->vBackupDetectionUsingBodyTriggerTimeOut & 0x80)
					{ //stop inspecting and give yellow message
						TempText = TempText + ". Inspection Stopped";
						ReportErrorMessage(TempText, cEMailMaintenance, 0);
						ReportErrorMessage(TempText, cError, 0);
						::PostThreadMessage(vGlobalCallingThreadID, cEmergencyShutXRaysDownMessage,0,0);
#ifdef CompileInHTTPClientOperationsGuardian
						if (vConfigurationData->vEnableOperationsGuardian)
						{
							vGlobalOGErrorCode = 601;
							vGlobalOGLocationString = "container_trigger";
							::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageImageFault, cOGSevereMessageImageFault);
						}
#endif
					}
					else //just give yellow message
						ReportErrorMessage(TempText, cEMailMaintenance, 0);
					vGaveBodyTriggerJammedMessage = true;
				}
			}
		}
		else
		{
			vBodyTriggerActiveTimer = 0;
			vGaveBodyTriggerJammedMessage = false;
		}

		if (vConfigurationData->vSimulateLightControlBoard)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->CheckContainers(vSystemData.vCurrentBeltPosition);

	}
	// if problem with the temperatures, and problem is more than one sensor, send critical error message and turn off xrays
	// if problem with the temperature is a single sensor, set red box and monitor sensors.
	// (vSystemData.vGivenTemperatureSensorWarning == cTemperatureSensorWarningRedBoxSent)
	// (vSystemData.vGivenTemperatureSensorWarning == cTemperatureSensorWarningCriticalSent)
	if (vOldGlobalTrackSensors != vGlobalTrackSensors)
	{
		vOldGlobalTrackSensors = vGlobalTrackSensors;
		vTemperatureSecondTime = -10;
	}

	if (vTemperatureSecondTime != 0)
	if (!vConfigurationData->vSimulateLightControlBoard)
	{
		int TempAddResultsOfTemperatures;
		TempAddResultsOfTemperatures = 0;
		if (CompareBit(vGlobalTrackSensors,cAirOutsideTemperature) == cAirOutsideTemperature)
			TempAddResultsOfTemperatures++;
		if (CompareBit(vGlobalTrackSensors,cAirInsideTemperature) == cAirInsideTemperature)
			TempAddResultsOfTemperatures++;
		if (CompareBit(vGlobalTrackSensors,cSurfaceTemperature) == cSurfaceTemperature)
			TempAddResultsOfTemperatures++;
		if (CompareBit(vGlobalTrackSensors,cLiquidTemperature) == cLiquidTemperature)
			TempAddResultsOfTemperatures++;

		if (TempAddResultsOfTemperatures == 0) 
		{			
			if ((vSystemData.vGivenTemperatureSensorWarning != cTemperatureSensorWarningsNoneSent) && (vSystemData.vGivenTemperatureSensorWarning != cTemperatureSensorWarningCriticalSent))
			{
				vSystemData.vGivenTemperatureSensorWarning = cTemperatureSensorWarningsNoneSent;
			}
			vTemperatureSecondTime = 0;
		}
		else
		if (TempAddResultsOfTemperatures == 1) 
		{
			if ((vSystemData.vGivenTemperatureSensorWarning != cTemperatureSensorWarningRedBoxSent) && (vSystemData.vGivenTemperatureSensorWarning != cTemperatureSensorWarningCriticalSent))
			{
				//check a few seconds in a row
				if (vTemperatureSecondTime < -1)
				{	
					vTemperatureSecondTime++;
				}
				else // if (TempAddResultsOfTemperatures == 1) 
				{	// put warning in red box, if red box is empty, or not currently used
					vSystemData.vGivenTemperatureSensorWarning = cTemperatureSensorWarningRedBoxSent;
					SetInterlockStatus();
					vTemperatureSecondTime = 0;
				}
			}
			else
			{
				vTemperatureSecondTime = 0;
			}
		}
		else
		if (TempAddResultsOfTemperatures > 1) 
		{
			if ((vSystemData.vGivenTemperatureSensorWarning == cTemperatureSensorWarningsNoneSent) || (vSystemData.vGivenTemperatureSensorWarning == cTemperatureSensorWarningRedBoxSent))
			{
				//check two seconds in a row
				if (vTemperatureSecondTime < -1)
				{	
					vTemperatureSecondTime++;
				}
				else
				{	// more than one sensor on, turn on xrays critical warning
					if (vSystemData.vSystemRunMode != cStoppedSystemMode)
					{
						::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
						ReportErrorMessage("Temperature Sensors Failed, X-ray Shutdown", cCritical, 0); 
						ReportErrorMessage("Temperature Sensors Failed, X-ray Shutdown", cEMailInspx, 32000); 
						ReportErrorMessage("Temperature Sensors Failed, X-ray Shutdown", cError, 0); 
#ifdef CompileInHTTPClientOperationsGuardian
						if (vConfigurationData->vEnableOperationsGuardian)
						{
							vGlobalOGErrorCode = 308;
							vGlobalOGLocationString = "temperature_sensor";
							::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageTemperatureFault, cOGSevereMessageTemperatureFault);
						}
#endif
					}
					else
					{
						ReportErrorMessage("Temperature Sensors Failed, Check Sensors.", cCritical, 0); 
						ReportErrorMessage("Temperature Sensors Failed, Check Sensors.", cEMailInspx, 32000); 
						ReportErrorMessage("Temperature Sensors Failed, Check Sensors.", cError, 0); 
					}
					vSystemData.vGivenTemperatureSensorWarning = cTemperatureSensorWarningCriticalSent;
					vTemperatureSecondTime = 0;
				}
			}
			else
			{
				vTemperatureSecondTime = 0;
			}
		}
	}

	//check Air Conditioning is working, check A/C Unit
	if (vConfigurationData->vDeltaTemperatureForFilterCloggedError == 0) //have have AirConditioning
	{
		vAirConditioningLogSecond++;
		if (vAirConditioningLogSecond > 9)
		{
			vAirConditioningLogSecond = 0;
			BYTE TempACTemp = ConvertToDegreesC(vSystemData.vTemperatureAirOutside, vConfigurationData->vTemperatureAirOutsideAdjust);
			if (TempACTemp > 0)
			{
				//ReportErrorMessage("A/C Output Air Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureAirOutside, vConfigurationData->vTemperatureAirOutsideAdjust), cWriteToLog,0);

				vSystemData.vAirConditionerTemperatureSampleData[vSystemData.vAirConditionerTemperatureSampleIndex] = TempACTemp;
				vSystemData.vAirConditionerTemperatureSampleIndex++;

				if (vSystemData.vAirConditionerTemperatureSampleCount < cNumberOfAirConditionerTemperatureSamples)
					vSystemData.vAirConditionerTemperatureSampleCount++;

				if ((vSystemData.vAirConditionerTemperatureSampleIndex >= cNumberOfAirConditionerTemperatureSamples) || //taken 2 hours of data, so figure out if it is cycling
					((vSystemData.vAirConditionerTemperatureSampleCount == cNumberOfAirConditionerTemperatureSamples) && (vSystemData.vAirConditionerTemperatureSampleIndex == cNumberOfAirConditionerTemperatureSamples / 2)))//hour 3, 5, 7 ....
				{
					if (vSystemData.vAirConditionerTemperatureSampleIndex >= cNumberOfAirConditionerTemperatureSamples) //taken 2 hours of data, start recording at beginning again
						vSystemData.vAirConditionerTemperatureSampleIndex = 0;

					enum {cDontKnow, cGoingUp, cGoingDown};
					BYTE TempCurrentDirection = cDontKnow;
					WORD TempTemperatureTransitionCounter = 0;
					BYTE TempCurrentTemperatureAt = vSystemData.vAirConditionerTemperatureSampleData[0];

					for (WORD TempLoop = 1; TempLoop < cNumberOfAirConditionerTemperatureSamples; TempLoop++)
					{
						if (vSystemData.vAirConditionerTemperatureSampleData[TempLoop] > TempCurrentTemperatureAt + 1) //if more than 1 degree higher, must be going up in temperature
						{
							if (TempCurrentDirection == cGoingDown)
								TempTemperatureTransitionCounter++;
							TempCurrentDirection = cGoingUp;
							TempCurrentTemperatureAt = vSystemData.vAirConditionerTemperatureSampleData[TempLoop];
						}
						else
						if (vSystemData.vAirConditionerTemperatureSampleData[TempLoop] + 1 < TempCurrentTemperatureAt) //if more than 1 degree lower, must be going down in temperature
						{
							if (TempCurrentDirection == cGoingUp)
								TempTemperatureTransitionCounter++;
							TempCurrentDirection = cGoingDown;
							TempCurrentTemperatureAt = vSystemData.vAirConditionerTemperatureSampleData[TempLoop];
						}
					}
					if (TempTemperatureTransitionCounter < 4)
					{
						if (!vSystemData.vAirConditionerFailed)
						{
							//Check if average temperature is above 38'C
							double TempAverageTemperature = 0;
							for (WORD TempLoop = 0; TempLoop < cNumberOfAirConditionerTemperatureSamples; TempLoop++)
								TempAverageTemperature = TempAverageTemperature + vSystemData.vAirConditionerTemperatureSampleData[TempLoop];

							TempAverageTemperature = TempAverageTemperature / cNumberOfAirConditionerTemperatureSamples;
							//double TempCurrentAirConditionerOutputTemperatureInC = ConvertToDegreesC(vSystemData.vTemperatureAirOutside, vConfigurationData->vTemperatureAirOutsideAdjust);
							if (TempAverageTemperature >= 38) //Air Conditioner output must be over 100'F to give error
							{
								ReportErrorMessage("Air Conditioner may have failed", cError, 0);
								ReportErrorMessage("Air Conditioner may have failed. " + dtoa(TempTemperatureTransitionCounter, 0) + " transitions in 2 hours", cEMailInspx, 32000);

								vSystemData.vAirConditionerFailed = true;
								SetInterlockStatus();
								UpdateClearYellowMessageButton();
							}
							else
								ReportErrorMessage(dtoa(TempTemperatureTransitionCounter, 0) + " transitions in 2 hours. Air Conditioner Average Output Temp Below 38'C: " + dtoa(TempAverageTemperature, 0), cWriteToLog, 0);
						}
						else
							ReportErrorMessage("Air Conditioner still failing test. " + dtoa(TempTemperatureTransitionCounter, 0) + " transitions in 2 hours", cWriteToLog, 0);
					}
					else
					{
						if (vSystemData.vAirConditionerFailed)
						{
							vSystemData.vAirConditionerFailed = false;
							ReportErrorMessage("Air Conditioner passed test. " + dtoa(TempTemperatureTransitionCounter, 0) + " transitions in 2 hours", cEMailInspx, 0);
							SetInterlockStatus();
							UpdateClearYellowMessageButton();
						}
						ReportErrorMessage("Air Conditioner passed test. " + dtoa(TempTemperatureTransitionCounter, 0) + " transitions in 2 hours", cWriteToLog, 0);
					}
				}
			}
		}
	}

	if (vSystemData.vNeedToAdjustEjector == 1)
	{
		vSystemData.vNeedToAdjustEjector = 2;
		CYesNoDialog TempYesNoDialog;
		TempYesNoDialog.vNoticeText = _T("\nEjector position too short to get image!\nTemporarily Correct Now?\nYou must manually time ejectors later!");
		TempYesNoDialog.vYesButtonText = "Increase Position!";
		TempYesNoDialog.vNoButtonText = "You Will Fix Manually";
		TempYesNoDialog.vQuestionType = cConfirmQuestion;
		int TempResult = IDOK;

		if ((vGlobalInAutoSize) && (!vSystemData.vInExpressSetup))
			TempResult =TempYesNoDialog.DoModal();

		if (TempResult == IDOK)
		if (vGlobalCurrentProduct)
		{
			if (vGlobalCurrentProduct->vEjectorDelayPosition[0] < 50)
				vGlobalCurrentProduct->SetEjectorBeltPositionOffset(0, 50);
			else
				vGlobalCurrentProduct->SetEjectorBeltPositionOffset(0, vGlobalCurrentProduct->vEjectorDelayPosition[0] + 10);

			vGlobalCurrentProduct->CalculateEndOfLineTimeOut();
		}
		vSystemData.vNeedToAdjustEjector = 0;
	}

	if (vSystemData.vSystemRunMode == cRunningSystemMode)
	for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
	if (vSystemData.vEjectConfirmerActive[TempLoop])
	{
		if (vSystemData.vEjectConfirmerActive[TempLoop] < 10)
		{
			vSystemData.vEjectConfirmerActive[TempLoop]++;
			if (vSystemData.vEjectConfirmerActive[TempLoop] == 5) //if eject confirmer active more than 5 seconds that eject tray must be full as sensor is blocked
				ReportErrorMessage("Ejector: " + dtoa(TempLoop + 1, 0) + " path blocked, clear eject table", cError, 0);
		}
	}
	// one second update, is not doing a if (vGlobalDisplayDialogThread), and verify ports is not done put up a message verifying ports,
	// every 4 seconds add a dot, when done verifying ports, take message down. if vGlobalDisplayDialogThread active take down message
#ifndef _DEBUG
	if  ((!vGlobalDisplayDialogThread))
//	if ((vDisplayPortVerifyMessage < 1) &&
	if ((!vConfigurationData->vSimulateLightControlBoard) && (!vConfigurationData->vDemoMode) &&
	  (((vGlobaluCSerialPort) && (vGlobaluCSerialPort->vPortOpen) && (vGlobalFirstMicroControllerCommCheck != cFinishedSearchForNextSerialPort) && (vGlobalFirstMicroControllerCommCheck != cNoCommPortSettings)) ||
	   ((vGlobalACPowerMoniter) && (vGlobalACPowerMoniter->vPortOpen) && (vGlobalACPowerMoniter->vTestACPowerMoniterExists == cNoCommSeenEver)) ||
	   ((vGlobalDXMXRayPort) && (vGlobalDXMXRayPort->vPortOpen) && (vGlobalXrayNoCommMessageRcvdEver == cNoCommSeenEver))))
	{
		vDisplayPortVerifyMessage++;
//		CNoticeDialog TempNoticeDialog;
//		CString TempText;
//		TempText = " \n \n \n Verifying Ports ";
//		TempNoticeDialog.vNoticeText = TempText;
//		TempNoticeDialog.vAutoClose = 4000;
//		TempNoticeDialog.vType = cNoticeMessage;		//cInformationMessage //cWarningMessage
//		TempNoticeDialog.DoModal();
		vGlobalDisplayDialogThread = (CDisplayDialogThread *)AfxBeginThread(RUNTIME_CLASS(CDisplayDialogThread), THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
		if (!vGlobalDisplayDialogThread)
		{
			ReportErrorMessage("Error-Could Not Create Verify Ports Thread", cEMailInspx,32000); 
		}
		else
		{
			CString TempText = " ";
			TempText = " \n \n \n Verifying Ports ";
			vGlobalDisplayDialogThread->vMessageToDisplay = TempText;
			vGlobalDisplayDialogThread->ResumeThread();
		}
	}
	if  (vGlobalDisplayDialogThread)
	if  (vDisplayPortVerifyMessage >= 1)
	if 	(((vGlobaluCSerialPort)   && ((vGlobalFirstMicroControllerCommCheck == cFinishedSearchForNextSerialPort) || (vGlobalFirstMicroControllerCommCheck == cNoCommPortSettings))) &&
	     ((vGlobalACPowerMoniter) && ((vGlobalACPowerMoniter->vTestACPowerMoniterExists == cYesCommSeen) || (vGlobalACPowerMoniter->vTestACPowerMoniterExists == cNoCommPortFound))) &&
	     (((vGlobalDXMXRayPort)   && ((vGlobalXrayNoCommMessageRcvdEver == cYesCommSeen)       || (vGlobalXrayNoCommMessageRcvdEver == cNoCommPortFound))) ||
		 (!vGlobalDXMXRayPort)))	// add vGlobalMonoBlockXRayPort someday
	{
		vDisplayPortVerifyMessage = 0;
		Sleep(10);
		vGlobalDisplayDialogThread->ExitDisplayThread();
		vGlobalDisplayDialogThread = NULL;
		// here ports are done with their seek, if any port is at give up, if default is available, set to default.
		int PortReviewStatus = ReviewPortsForDefault();
		if ((PortReviewStatus & 1) == 1)	// changed uC Port
		{
			vSystemData.vNoCommunicationsWithUController = false;
			vSystemData.vCommunicationsTimeOutCounter = 0;
			vGlobaluCSerialPort->OpenPort(vGlobalSerialPortNumberMicroController);
		}
		if ((PortReviewStatus & 2) == 2)	// changed AC Power Monitor port
		{
			vACPowerMonitorTroubleCount = 0;
			vGlobalACPowerMoniter->vHasReceivedCommunication = false;
			vGlobalACPowerMoniter->vCommunicationsACPowerMonitorDataCount = 0;
	
			vGlobalACPowerMoniter->OpenPort(vGlobalACPowerMoniter->vComPortNumber);
			vGlobalACPowerMoniter->SyncFromACPowerMonitorSeen = 0;
			if (vGlobalACPowerMoniter->vPortOpen)
			{
				vGlobalACPowerMoniter->InitializeACPowerMoniter();			
			}
		}
		if ((PortReviewStatus & 4) == 4)	// changed XRay port
		{
			vGlobalDXMXRayPort->vCommunicationsTimeOutCounter = 0;
			if (vGlobalDXMXRayPort->OpenPort(vGlobalDXMXRayPort->vComPortNumber))
				InitializeDXM();	//call from ScanTrac Dlg
		}

	}
#endif
#ifdef CompileInHTTPClientOperationsGuardian
	DisplayOGStatus();
#endif
}

void CScanTracDlg::CheckForNewImageToDisplay() 
{
	if (vSystemData.vPostedNewMainImageReadyToDisplayMessage)
	{
		ScaleImageToMainDisplayBuffer();
		vSystemData.vPostedNewMainImageReadyToDisplayMessage = false;
	}
}

void CScanTracDlg::UpdateDisplay() 
{
	TickleWatchDogs();

	vFirstHalfSecond = !vFirstHalfSecond;
	if (!vDisplayingVersion)
	{
		//Pipe Status:  Empty, Pumping, Not Pumping
		if ((vConfigurationData->vScanTracType == cFermataScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac) || 
			(vConfigurationData->vContinuousFeedContainerRate) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || 
			(vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
		{
			if ((vSystemData.vSystemRunMode == cAutoSetupRunningSystem) || (vSystemData.vSystemRunMode == cRunningSystemMode))
			{
				if (vSystemData.vActualEncoderRate < 5)
					vSystemData.vCurrentPipeStatus = cPipePumpStopped;
				else
				if (vSystemData.vPipeIsEmpty > 3) 
					vSystemData.vCurrentPipeStatus = cPipeEmpty;
				else
					vSystemData.vCurrentPipeStatus = cPipePumping;

				if ((vOldPipeStatus != vSystemData.vCurrentPipeStatus) || (vSystemData.vOldAirBubblesInPipe != vSystemData.vAirBubblesInPipe))
				{
					vOldPipeStatus = vSystemData.vCurrentPipeStatus;
					vSystemData.vOldAirBubblesInPipe = vSystemData.vAirBubblesInPipe;

					m_TriggerIndicator.ShowWindow(SW_SHOW);
					if (vOldPipeStatus == cPipeEmpty)
					{
						vShowingPipeEmpty = true;
						if ((vConfigurationData->vScanTracType == cFermataScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac))
							SetDlgItemText(IDC_TriggerIndicator, _T("Pipe Empty"));
						else
							SetDlgItemText(IDC_TriggerIndicator, _T("Conveyor Empty"));
					}
					else
					if (vOldPipeStatus == cPipePumping)
					{
						vShowingPipeEmpty = false;
						CString TempAirBubbleText = " ";
						if (vSystemData.vOldAirBubblesInPipe)
						{
							TempAirBubbleText = " - Air";
							vShowingAirInPipe = true;
						}
						else
							vShowingAirInPipe = false;
						if ((vConfigurationData->vScanTracType == cFermataScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac))
							SetDlgItemText(IDC_TriggerIndicator,"Pumping" + TempAirBubbleText);
						else
							SetDlgItemText(IDC_TriggerIndicator, _T("Conveying"));
					}
					else
					if (vOldPipeStatus == cPipePumpStopped)
					{
						vShowingPipeEmpty = false;
						if ((vConfigurationData->vScanTracType == cFermataScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac))
							SetDlgItemText(IDC_TriggerIndicator, _T("Pump Stopped"));
						else
							SetDlgItemText(IDC_TriggerIndicator, _T("Conveyor Stopped"));
					}
					else
						SetDlgItemText(IDC_TriggerIndicator, _T("No Pump Status"));
				}
			}
			else
			if (vSystemData.vCurrentPipeStatus)
			{
				vSystemData.vCurrentPipeStatus = cNoPipeStatus;
				vOldPipeStatus = cNoPipeStatus;
				SetDlgItemText(IDC_TriggerIndicator, _T(""));
			}

			//if (vSystemData.vPipeIsEmpty > 3)
			//if (!vShowingPipeEmpty)
			//{
			//	CRuntimeClass  *TempClassPointer = NULL;
			//	CWnd *TempActiveWindow = this->GetForegroundWindow();
			//	if (TempActiveWindow)
			//		TempClassPointer = TempActiveWindow->GetRuntimeClass();
			//	if ((TempClassPointer) && (TempClassPointer->m_lpszClassName == "CScanTracDlg"))
			//		ShowPipeEmptyIndicator();
			//}
		}

	//br h test only
	  double TempStartTime = CIFCOS::GetSystimeMicrosecs();

	//br htest
	/*
		if (vSystemData.vBodyTriggerWidthSamples < cMaximumBodyTriggerWidthData)
		vSystemData.vBodyTriggerWidthSamples++;
		vSystemData.vBodyTriggerWidthData[vSystemData.vBodyTriggerWidthIndex] = 
			vSystemData.vBodyTriggerWidthIndex;
		if (vSystemData.vBodyTriggerWidthIndex + 1 >= cMaximumBodyTriggerWidthData)
			vSystemData.vBodyTriggerWidthIndex = 0;
		else
			vSystemData.vBodyTriggerWidthIndex++;
*/
		/*
		bool TempTestModesActive = ((!vSystemData.vITIPCDig->vShowOnlyRealImages) ||
			(vSystemData.vSimulating) ||
			(vSystemData.vFPGAGeneratingSimulatedData) ||
			(vConfigurationData->vSimulateLightControlBoard) ||
			((vSystemData.vFPGASimulateEncoderRate) && (!((vSystemData.vAutoCalibrate) ||
			(vSystemData.vAutoCalibrateWhileRunning)))) ||
			(vSystemData.vSimulateContainersRate) ||
			(vSystemData.vuControllerSendExtraDiagnosticMessages) ||
			(vSystemData.vuCOutputSerialDebugData) ||
			(vSystemData.vuCSimulate16Hz) ||
			(vSystemData.vTestingTrigger) ||
			(vSystemData.vRadiationDoorManualControlRegister) ||
			(!vSystemData.vEnableduC16HzInterrupt) ||
			(vSystemData.vLogFile.vLogSerialData) ||
			(!vSystemData.vLogFile.vLogSyncData) ||
			(vConfigurationData->vDemoMode) ||
			(vSystemData.vTemporarilyChangeSource) ||
			(vSystemData.vKeepExternalDetectorsEnabled));
*/
		//9/30/2009
		BYTE TempTestModesActive = TestModesAreActive();
		WORD TempSamplesToGo = 0;
		for (BYTE TempLoop = 0; TempLoop < 3; TempLoop++)
		{
			TempSamplesToGo = TempSamplesToGo + vSystemData.vSamplingNowNumberOfSamplesToTakeFromSeries[TempLoop];
			TempSamplesToGo = TempSamplesToGo + vSystemData.vSamplingNowNumberOfSamplesToTakeFromSameHead[TempLoop];
		}

		bool TempUpdateTestModesActiveDisplay = false;
		if (vOldSamplesToGo != TempSamplesToGo)
		{
			vOldSamplesToGo = TempSamplesToGo;
			if (vOldSamplesToGo > 0)
			{
				if (vOldSamplesToGo > 99)
					SetDlgItemText(IDC_TestModesActive, "Samples ToGo:" + dtoa(vOldSamplesToGo, 0));
				else
					SetDlgItemText(IDC_TestModesActive, "Samples To Go: " + dtoa(vOldSamplesToGo, 0));
				TempUpdateTestModesActiveDisplay = true;
				m_TestModesActive.ShowWindow(SW_SHOW);
			}
			else
			{
				vOldTestModesActive = 0xFE; //force Test Modes Active to update the display
				m_TestModesActive.ShowWindow(SW_HIDE);
				vOldTestModesActive = 252; //force update
				TempUpdateTestModesActiveDisplay = false;
			}
		}
		if (!TempUpdateTestModesActiveDisplay)
		if (vOldTestModesActive != TempTestModesActive)
		{
			vOldTestModesActive = TempTestModesActive;
			if (vOldTestModesActive)
			{
				CString TempText = " ";
				TempText.LoadString(IDS_TestModesActive);
				if (vSystemData.vRadiationDoorManualControlRegister)
				if (vSystemData.vRadiationDoorManualControlRegister & 2)
					TempText.LoadString(IDS_ShutterOpen);
				else
				if (vSystemData.vRadiationDoorManualControlRegister)
					TempText.LoadString(IDS_ShutterClosed);
				m_TestModesActive.ShowWindow(SW_SHOW);
				SetDlgItemText(IDC_TestModesActive,TempText);
			}
			else
				m_TestModesActive.ShowWindow(SW_HIDE);
		}
#ifndef _DEBUG
		if (TempTestModesActive)  // if a test mode is running check if want to display IDC_TestModesActive
		{
			CString TempTextA;
			GetDlgItemText(IDC_TestModesActive,TempTextA);
			if ((TempTextA != "Test Modes Active") || (vGlobalPasswordLevel) || (vConfigurationData->vSimulateLightControlBoard)) 
			{
				m_TestModesActive.ShowWindow(SW_SHOW);
			}
			else
			{
				m_TestModesActive.ShowWindow(SW_HIDE);
			}
		}
#endif
		//  Make the writing flash every second
		/*
		if (vOldTestModesActive)
		{
			CWnd *TempWindow = CWnd::GetDlgItem(IDC_TestModesActive);
			TempWindow->Invalidate(true);
		}
		*/
		CWnd *TempWindow = CWnd::GetDlgItem(IDC_TestModesActive);
		if (TempWindow)
		if (TempWindow->IsWindowVisible())
			TempWindow->Invalidate(false);
		
		TempWindow = CWnd::GetDlgItem(IDC_EjectorsDisabled);
		if (TempWindow)
		if (TempWindow->IsWindowVisible())
			TempWindow->Invalidate(false);
				
		if (vShowuControllerStatusInRed)
		{
			CWnd *TempWindow = CWnd::GetDlgItem(IDC_uControllerStatus);
			if (TempWindow)
				TempWindow->Invalidate(false);
		}

		//9/30/2009
		if (vSystemData.vOldAllSystemSettingsAreStandard != vSystemData.vAllSystemSettingsAreStandard)
		{
			vSystemData.vOldAllSystemSettingsAreStandard = vSystemData.vAllSystemSettingsAreStandard;
			if (vSystemData.vOldAllSystemSettingsAreStandard)
				m_NonStandardSystemSetting.ShowWindow(SW_HIDE);
			else
			{
				m_NonStandardSystemSetting.ShowWindow(SW_SHOW);
			}
		}

		//9/30/2009
		if (vSystemData.vOldInspxMessagesToView != vSystemData.vInspxMessagesToView)
		{
			vSystemData.vOldInspxMessagesToView = vSystemData.vInspxMessagesToView;
			if (vSystemData.vOldInspxMessagesToView)
			{
				m_InspxMessage.ShowWindow(SW_SHOW);
			}
			else
				m_InspxMessage.ShowWindow(SW_HIDE);
		}

		if ((vSystemData.vDownStreamSignalSaysConveyorOn != vOldDownStreamSignalSaysConveyorOn) && (vConfigurationData->vUseDownStreamSignalThatStopsConveyor == cUseDownStream))
		{
			vOldDownStreamSignalSaysConveyorOn = vSystemData.vDownStreamSignalSaysConveyorOn;
			SetInterlockStatus();
		}

		if (vGlobalBackupHardDriveThread)
		{
			TempWindow = CWnd::GetDlgItem(IDC_DoNotShutOffPower);
			if (TempWindow)
			if (TempWindow->IsWindowVisible())
				TempWindow->Invalidate(false);
		}

		CString vTempString = " ";
		//Conveyor Rate
		if (vGlobalEvenSecond)
		{
			//if (vSystemData.vLVDSErrorCount > 20)
			//{//had 20 LVDS errors in a row, so reset uController
				/*
				vSystemData.vLVDSErrorCount = 0;
				StopRunning(true);

				tSerialCommand TempCommand;
				TempCommand[0] = 0x35;
				TempCommand[1] = 0x34;
				TempCommand[2] = 0x33;
				TempCommand[3] = 0x32;
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->SendSerialCommand(TempCommand);
				ReportErrorMessage("Error-20 LVDS Errors, Resetting uController", cWriteToLog,21);
				*/
			//}

			/*
			if (vSystemData.vLastXRayCommandOn)
			if ((!vSystemData.vXRayOnNotice) && (!vConfigurationData->vSimulateLightControlBoard) &&
				(vConfigurationData->vAutoXRaySourceOffEnabled))
			if (vSystemData.vRampXRayStep == 0)
			if (!vSystemData.vGaveNoXRayMessage)
			if (!vSystemData.vShuttingDownXRays)
			{
				StopRunning(true);
				vSystemData.vGaveNoXRayMessage = true;

				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\nX-Rays are not on.\nX-Ray source failed.";
				TempNoticeDialog.vType = cNoticeMessage;
				TempNoticeDialog.DoModal();

			}
			*/

			if ((vGlobaluCSerialPort) && (vGlobaluCSerialPort->vNoCommunications))
			{
				if (vSystemData.vFPGASimulateEncoderRate)
				{
					if (vGlobaluCSerialPort)
						vGlobaluCSerialPort->ProcessBeltPosition(vSystemData.vFPGASimulateEncoderRate + vSystemData.vLastEncoderCountToCalculateEncoderRate,true);
				}
			}
			else
			{
				if (vSystemData.vSimulating)
				if (vSystemData.vNoCommunicationsWithUController)
				if (vSystemData.vFPGASimulateEncoderRate)
					vGlobaluCSerialPort->ProcessBeltPosition(100 + vSystemData.vLastEncoderCountToCalculateEncoderRate,true);
			}
			//if encoder rate is too high, must be wrong, so ignore
			if (vSystemData.vActualEncoderRate < 6000)
			if (!vGlobalPixelsPerUnit)
				ReportErrorMessage("Error-vGlobalPixelsPerUnit = 0, would cause crash 2", cEMailInspx, 32000);
			else
			if (vGlobalCurrentProduct)
			{
				if (!vGlobalCurrentProduct->vOverScanMultiplier)
					ReportErrorMessage("Error-vGlobalCurrentProduct->vOverScanMultiplier = 0, would cause crash", cEMailInspx, 32000);
				else
					vSystemData.vBeltRate = (UINT)((vSystemData.vActualEncoderRate * 60.0  / vGlobalPixelsPerUnit) / vGlobalCurrentProduct->vOverScanMultiplier);
			}
			else
				vSystemData.vBeltRate = (UINT)(vSystemData.vActualEncoderRate * 60.0  / vGlobalPixelsPerUnit);
			//if near zero, just set to zero to eliminate jitter in encoder when stopped
			if (vSystemData.vBeltRate < 10)
				vSystemData.vBeltRate = 0;

			if ((vSystemData.vCheckConveyor >= 1) && (vSystemData.vCheckConveyor <= 10))
			{
				vSystemData.vCheckConveyor++;
				if (vSystemData.vCheckConveyor == 11)
				if ((vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) && (vSystemData.vCalibrationImageNumber == 0) && (!vSystemData.vReceivedACalibrationImage))
				{
					TempText.LoadString(IDS_NoCalibrationImageCallInspx);
					ReportErrorMessage(TempText,cError,0);
					ReportErrorMessage(TempText,cEMailInspx, 32000);
					int TimerResult = SetTimer(vFlashYellowLightTimerHandle,500,NULL);
					vSystemData.vCantInspectError = true; //flash blue + yellow
					StopRunning(true);
				}
				else
				if (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode)
				if (vSystemData.vCalibrationImageNumber == 0)
				{
					if (vSystemData.vActualEncoderRate == 0)
					{
						CString TempString = " ";
						TempString.LoadString(IDS_NoCalibrationImageCallInspx);
						CString TempString1 = " ";
						TempString1.LoadString(IDS_NoEncoder);
						ReportErrorMessage(TempString + ", " + TempString1,cError,0);
						ReportErrorMessage("No Image, Call Service, No Encoder",cEMailInspx, 32000);

						if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
						{
							vSystemData.vNoImageCounter++;
							if (vSystemData.vNoImageCounter == 10)
							{
								::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
								ReportErrorMessage("No Image, Call Service, No Encoder-Inspection Stopped",cEMailInspx, 32000);
								ReportErrorMessage("No Image, Call Service, No Encoder-Inspection Stopped",cError, 0);
#ifdef CompileInHTTPClientOperationsGuardian
								if (vConfigurationData->vEnableOperationsGuardian)
								{
									vGlobalOGErrorCode = 501;
									vGlobalOGLocationString = "encoder";
									::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageImageFault, cOGSevereMessageImageFault);
								}
#endif
							}
						}
					}
					else
					{
						CString TempString = " ";
						TempString.LoadString(IDS_NoCalibrationImageCallInspx);
						ReportErrorMessage(TempString,cError,0);
						ReportErrorMessage("No Image, Call Service",cEMailInspx, 32000);
						if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && (!vSystemData.vRunningDiagnosticsMode)) //shut down if inspecting
						{
							vSystemData.vNoImageCounter++;
							if (vSystemData.vNoImageCounter == 10)
							{
								::PostThreadMessage(vGlobalCallingThreadID,cEmergencyShutXRaysDownMessage,0,0);
								ReportErrorMessage("No Image, Call Service-Inspection Stopped",cEMailInspx, 32000);
								ReportErrorMessage("No Image, Call Service-Inspection Stopped",cError, 0);
#ifdef CompileInHTTPClientOperationsGuardian
								if (vConfigurationData->vEnableOperationsGuardian)
								{
									vGlobalOGErrorCode = 500;
									::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageImageFault, cOGSevereMessageImageFault);
								}
#endif
							}
						}
					}

					int TimerResult = SetTimer(vFlashYellowLightTimerHandle,500,NULL);
					vSystemData.vCantInspectError = true; //flash blue + yellow
				}


				if (vConfigurationData->vStopInspectionIfConveyorStops)
				if (vSystemData.vBeltRate == 0)
				if (vSystemData.vSystemRunMode != cStoppedSystemMode)
				if (vSystemData.vXRayOnNotice)
				if (vSystemData.vRampXRayStep == 0)
				if (!vSystemData.vShuttingDownXRays)
				if (vSystemData.vITIPCDig->vShowOnlyRealImages)
				if (!vConfigurationData->vSimulateLightControlBoard)
				{
					StopRunning(true);
					ReportErrorMessage("Error-Conveyor Stopped, Inspection Stopped",cError,0);
				}
			}

			if (vSystemData.vOldBeltRate != vSystemData.vBeltRate)
			{
				//conveyor just started
				if (vSystemData.vOldBeltRate == 0)
				{  //turn on if enabled, and Conveyor just started
					ReportErrorMessage("Conveyor Started",cAction,0);
					//if conveyor just started, and calibrating detector offset, simulate a container
					//if (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode)
					//if (vSystemData.vActualEncoderRate)
					//	SimulateOneContainer();
					MarkAllContainersAsConveyorStop();

					if ((vSystemData.vSimulateContainersRate) || (vConfigurationData->vContinuousFeedContainerRate) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || 
						((vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))))
					if (vSystemData.vSystemRunMode != cStoppedSystemMode)
					if (vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode)
					if (vSystemData.vSystemRunMode != cCalibratingDetectorGainMode)
					if (vSystemData.vSystemRunMode != cCalibratingDetectorEdgesMode)
					if (vSystemData.vSystemRunMode != cTestShutterMode)
						TurnSimulatedContainersOn();

					if (vSystemData.vLogFile.vLogSerialData)
						vSystemData.vLogFile.WriteToLogFile("Conveyor Started",cAction);
				}
				else
				if (vSystemData.vBeltRate == 0)
				{  //Conveyor just stopped
					ReportErrorMessage("Conveyor Stopped",cAction,0);
					//if (vSystemData.vLogFile.vLogSerialData)
					//	vSystemData.vLogFile.WriteToLogFile("Conveyor Stopped",cAction);
					MarkAllContainersAsConveyorStop();

					//turn off if enabled and Conveyor just stopped
					if ((vSystemData.vSimulateContainersRate) || 
						(vConfigurationData->vContinuousFeedContainerRate))
					if (vSystemData.vSystemRunMode != cStoppedSystemMode)
						TurnSimulatedContainersOff();
				}
				if (((vSystemData.vLastReportedEncoderRate * 1.05) < vSystemData.vActualEncoderRate) && ((vSystemData.vLastReportedEncoderRate + 20) < vSystemData.vActualEncoderRate))
				{
					vSystemData.vLastReportedEncoderRate = vSystemData.vActualEncoderRate;
					if ((!vConfigurationData->vContinuousFeedContainerRate) && (!vConfigurationData->vBulkProductMode) && ((vGlobalCurrentProduct) && (!vGlobalCurrentProduct->vBulkProductMode))) //Not Continuous Feed, and Not a Pipeline
						ReportErrorMessage("Conveyor Speed Increased to: " + dtoa(vSystemData.vLastReportedEncoderRate,0) + "Hz", cWriteToLog,0);
				}
				if (((vSystemData.vLastReportedEncoderRate * 0.95) > vSystemData.vActualEncoderRate) && ((vSystemData.vLastReportedEncoderRate) > vSystemData.vActualEncoderRate + 20))
				{
					vSystemData.vLastReportedEncoderRate = vSystemData.vActualEncoderRate;
					if ((!vConfigurationData->vContinuousFeedContainerRate) && (!vConfigurationData->vBulkProductMode) && ((vGlobalCurrentProduct) && (!vGlobalCurrentProduct->vBulkProductMode))) //Not Continuous Feed, and Not a Pipeline
						ReportErrorMessage("Conveyor Speed Decreased to: " + dtoa(vSystemData.vLastReportedEncoderRate,0) + "Hz", cWriteToLog,0);
				}

				//if ((((vSystemData.vOldActualEncoderRate * 1.1) < vSystemData.vActualEncoderRate) && ((vSystemData.vOldActualEncoderRate + 20) < vSystemData.vActualEncoderRate)) ||
				//	((vSystemData.vOldActualEncoderRate * 0.9) > vSystemData.vActualEncoderRate))
				//{
				//	vSystemData.vOldActualEncoderRate = vSystemData.vActualEncoderRate;
				//}

				vSystemData.vOldBeltRate = vSystemData.vBeltRate;
				if (vSystemData.vOldBeltRate)
				SetDlgItemText(IDC_BeltRate,dtoa(vSystemData.vOldBeltRate / 12, 0));

				if (vSystemData.vActualEncoderRate > vSystemData.vMaximumEncoderRate + 5)
				if (vSystemData.vActualEncoderRate < 6000)
				if (vSystemData.vSystemRunMode == cRunningSystemMode)
				if (vSystemData.vSourceRampedUp)
				if ((!vConfigurationData->vContinuousFeedContainerRate) && (!vConfigurationData->vBulkProductMode) && ((vGlobalCurrentProduct) && (!vGlobalCurrentProduct->vBulkProductMode))) //Not Continuous Feed, and Not a Pipeline
				{
					if (!vReportedBeltSpeedTooFast)
					{
						CString TempText = " ";
						CString TempText1 = " ";
						TempText.LoadString(IDS_ErrorBeltSpeedTooFastForExposureTime);
						TempText = TempText + "-Rate (Hz): " + dtoa(vSystemData.vActualEncoderRate,2) + ", Limit: " + dtoa(vSystemData.vMaximumEncoderRate,2);
						//if ((vSystemData.vInAutoSetup) &&
						//	((vSystemData.vITIPCDig->vAverageEnabled) ||
						//	(vSystemData.vITIPCDig->vStructureEnabled)))
						//{
						//	//if you are in autosetup, then abort image Learn if doing it
						//	TempText1.LoadString(IDS_AbortLearn);
						//	TempText = TempText + ", " + TempText1;
						//	ReportErrorMessage(TempText, cEMailPlantOperations,10);
						//	vSystemData.vITIPCDig->vAverageEnabled = false;
						//	vSystemData.vITIPCDig->vStructureEnabled = false;
						//}
						//else
						if (vSystemData.vInAutoSetup)
							ReportErrorMessage(TempText, cWriteToLog,10);
						else
							ReportErrorMessage(TempText, cEMailPlantOperations,10);
						vReportedBeltSpeedTooFast = true;
						if (vSystemData.vLogFile.vLogSerialData)
						{
							vSystemData.vLogFile.WriteToLogFile("Encoder Rate: " + dtoa(vSystemData.vActualEncoderRate,2) + ", Max Encoder Rate: " + dtoa(vSystemData.vMaximumEncoderRate,2),cDebugMessage);
						}
					}
				}
			}
		}

		//Show container rate
		//update screen every second only, 
		//put data into array, then add up array and do math
		//every second, updates the data array with the last seconds worth of containers
		//uses only the number of array elements that accumulate for so can just add them
		//vSystemData.vTotalContainers = vSystemData.vEjectCountTotal + 
		//	vSystemData.vGoodCountTotal +
			//vSystemData.vTooLateToEjectErrorCount + 
			//vSystemData.vIncompleteDataCount +
			//vSystemData.vMissedEjectsBecauseDisabledCount;// + 
			//vSystemData.vProcessingErrorCount + vSystemData.vImageReferenceErrorCount;
		if (vFirstHalfSecond)
		{
			//CalculateContainerRate();
			//add second half second of data to first
			vSystemData.vCPMData[vSystemData.vCPMDataIndex] = (WORD)(vSystemData.vTotalContainers - vOldCPMTotalContainers);
			vOldCPMTotalContainers = vSystemData.vTotalContainers;
			// if too high, must be some kind of error
			vSystemData.vCPMDataTime[vSystemData.vCPMDataIndex] = CIFCOS::GetSystimeMicrosecs();
			if (vSystemData.vCPMData[vSystemData.vCPMDataIndex] > 700)
				vSystemData.vCPMData[vSystemData.vCPMDataIndex] = 0;

			WORD TempIndex = vSystemData.vCPMDataIndex;
			vSystemData.vCPMDataIndex++;
			//must take N + 1 samples so keep time start of first sample
			if (vSystemData.vCPMDataIndex >= vConfigurationData->vCPMTimePeriod)
			{
				vSystemData.vCPMDataIndex = 0;
				vSystemData.vHaveAllCPMData = true;
			}

			if ((vSystemData.vHaveAllCPMData) || //if you have been running, or are now, calculate
				(vSystemData.vCPMData[TempIndex]))
			{//sum up data to container rate
				//increment to next data array to place data in next time

				vSystemData.vContainerRate = 0;
				double TempEndTime = 0;
				double TempStartTime = 0;
				//if ((vSystemData.vSystemRunMode == cRunningSystemMode) ||
				//	(vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
				if ((vSystemData.vCPMDataIndex > 1) || (vSystemData.vHaveAllCPMData))
				{  //sum up one less than configured too, need time started first integral time
					TempEndTime = vSystemData.vCPMDataTime[TempIndex];
					double TempSum = 0;
					for (WORD TempLoop	= 0; TempLoop < vConfigurationData->vCPMTimePeriod - 1; TempLoop++)
					{
						if ((TempLoop < vConfigurationData->vCPMTimePeriod - 2) && ((vSystemData.vHaveAllCPMData) || (TempIndex)))
						{
							TempSum = TempSum + vSystemData.vCPMData[TempIndex];
							if (TempIndex)
								TempIndex--;
							else
							{
								if (vSystemData.vHaveAllCPMData)
									TempIndex = vConfigurationData->vCPMTimePeriod - 1;
								else
									TempLoop = vConfigurationData->vCPMTimePeriod;
							}
						}
					}
					TempStartTime = vSystemData.vCPMDataTime[TempIndex];
					if (vSystemData.vCountTimeAsRunning)
					{
						double TempTimePeriod = (TempEndTime - TempStartTime) / 1000000;

						//convert from seconds to minutes, and divide by sum duration
						if (TempTimePeriod)
						{
							vSystemData.vContainerRate = (WORD)(TempSum * 60 / TempTimePeriod);

							if (vSystemData.vContainerRate > vSystemData.vContainerRateMaximum)
								vSystemData.vContainerRateMaximum = vSystemData.vContainerRate;
						}
					}
					else
						vSystemData.vContainerRate = 0;
				}
			}
				//check if different then last second
			if (vSystemData.vContainerRate != vSystemData.vOldContainerRate)
			{
				ShowCPM();
			}
		}
		//else
		//{
			//store first half second of data in array
			//vSystemData.vCPMData[vSystemData.vCPMDataIndex] = 
			//	(WORD)(vSystemData.vTotalContainers - vSystemData.vOldTotalContainers);
		//}

		if (vOldXRayOnNotice != vSystemData.vXRayOnNotice)
		{
			vOldXRayOnNotice = vSystemData.vXRayOnNotice;
			if ((vOldXRayOnNotice) && (vSystemData.vSystemRunMode != cStoppedSystemMode))
			{
				m_XRaysOn.ShowWindow(SW_SHOW);
				//don't turn on the red light in demo mode
				//if (!vConfigurationData->vDemoMode)
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->TurnOnOffRedLamp(true);
				if ((!vSystemData.vRampXRayStep) && 
					(!((vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode) ||
					(vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) ||
					(vSystemData.vSystemRunMode == cTestShutterMode) ||
					(vSystemData.vSystemRunMode == cCalibratingDetectorGainMode) ||
					(vSystemData.vSystemRunMode == cMeasureSourceStrengthMode))))
				{
					TempText.LoadString(IDS_XRAYSStarted);
					//if (vSystemData.vSystemRunMode == cTestShutterMode)
					//	TempText = "Shutter Test";
					if (vSystemData.vSystemRunMode == cConditionXRayTubeMode)
						TempText = vSystemData.vConditionString + " Tube";
					if (vSystemData.vSystemRunMode == cCalibratingDetectorGainMode)
						TempText = "Calibrate Gain";
					if (vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode)
					{
						if (vSystemData.vApplyGainAndOffsetDuringCalibration)
							TempText = "Verify Pixels";
						else
							TempText = "Calibrate Pixels";
					}
					vSystemData.vXRayState = 24;
					::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,24,0); //5/14/2015  X-Rays were just turned on
					ReportErrorMessage("X-Rays Starting Up Step: 24", cWriteToLog, 0);
					m_Calibrating.ShowWindow(SW_SHOW);
					SetDlgItemText(IDC_Calibrating,TempText);
				}
			}
			else
			{
				m_XRaysOn.ShowWindow(SW_HIDE);
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->TurnOnOffRedLamp(false);
				if ((!vSystemData.vRampXRayStep) && 
					(!((vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode) ||
					(vSystemData.vSystemRunMode == cCalibratingDetectorGainMode) ||
					(vSystemData.vSystemRunMode == cTestShutterMode) ||
					(vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) ||
					(vSystemData.vSystemRunMode == cMeasureSourceStrengthMode))))
					m_Calibrating.ShowWindow(SW_HIDE);
				{
					vSystemData.vXRayState = 0;
					::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,0,0);  //X-Rays just turned off
					ReportErrorMessage("X-Rays Starting Up Step: 0", cWriteToLog, 0);
				}
			}
		}
		
		UpdateProductDensityCompensation();

		if (vSystemData.vTotalContainers != vSystemData.vOldTotalContainers)
		{
			vSystemData.vSecondsSinceLastContainer = 0;
			if ((vSystemData.vSystemRunMode == cRunningSystemMode) || (vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
			{
				if (!vSystemData.vCountTimeAsRunning)
				{
					vSystemData.vTimeSinceLastStop = 0;
					vSystemData.vCountTimeAsRunning = true;
						ReportErrorMessage("Production Started: " + vSystemData.vFrameCountString, cAction,0);

					if (!vTrackingCheckWeighMinuteData)
					if (vGlobalCurrentProduct->AreThereAnyWeightTrendingInspections()) //if have any weight trending inspections
						vTrackingCheckWeighMinuteData = true;
				}
			}
			{
				vSystemData.vOldTotalContainers = vSystemData.vTotalContainers;
				if ((!vConfigurationData->vContinuousFeedContainerRate) && (!vConfigurationData->vBulkProductMode) && ((vGlobalCurrentProduct) && (!vGlobalCurrentProduct->vBulkProductMode))) //Not Continuous Feed, and Not a Pipeline
					SetDlgItemText(IDC_TotalContainers,IToAWithComma(vSystemData.vOldTotalContainers));// if not a pipe show total

				if (vSystemData.vTotalContainers > 0)
				{

					vSystemData.vPercentEjected = ((double)vSystemData.vEjectCountTotal / (double)vSystemData.vTotalContainers) * 100.0;
					if (vSystemData.vPercentEjected > 100)
						vSystemData.vPercentEjected = 100;
				}
				else
					vSystemData.vPercentEjected = 0;

				if (vSystemData.vPercentEjected != vSystemData.vOldPercentEjected)
				{
					vSystemData.vOldPercentEjected = vSystemData.vPercentEjected;
					if (!((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))) //Continuous Feed, or a Pipeline
					{//Not Continuous Feed, and Not a Pipeline
						SetDlgItemText(IDC_PercentRejected, dtoa(vSystemData.vOldPercentEjected, 3));
					}
				}

				//if (vSystemData.vMissedEjectsBecauseDisabledCount)
				{  //if had any disable rejects, then show percent rejected updated
					if (vSystemData.vTotalContainers > 0)
					{

						vSystemData.vPercentRejected = ((double)vSystemData.vRejectCountTotal / (double)vSystemData.vTotalContainers) * 100.0;
						if (vSystemData.vPercentRejected > 100)
							vSystemData.vPercentRejected = 100;
					}
					else
						vSystemData.vPercentRejected = 0;
					if (vSystemData.vPercentRejected != vSystemData.vOldPercentRejected)
					{
						vSystemData.vOldPercentRejected = vSystemData.vPercentRejected;
						if (!((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))) //Continuous Feed, or a Pipeline
						{ //Not Continuous Feed, and Not a Pipeline
							SetDlgItemText(IDC_TotalRejectsPercent, dtoa(vSystemData.vOldPercentRejected, 3));
						}
					}
				}
			}
		}
		else
		{
			if (vGlobalEvenSecond)
			if ((vSystemData.vSystemRunMode == cRunningSystemMode) || (vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
			{
				if (vSystemData.vContainerCollection->GetCount() == 0)
				{
					if (vSystemData.vSecondsSinceLastContainer < 65000)
						vSystemData.vSecondsSinceLastContainer++;
				
					if (vConfigurationData->vReCalibrateAfterStopTimePeriod)
					if (vSystemData.vSecondsSinceLastContainer >= vConfigurationData->vReCalibrateAfterStopTimePeriod)
					if (!vSystemData.vReCalibrationTimerRunning)
					{
						int TimerResult = SetTimer(vReCalibrateOffsetTimerHandle,900000,NULL); //15 minutes
						if (!TimerResult)
							ReportErrorMessage("Error-Recalibrate Offset Timer Failed",cEMailInspx,32000);
						vSystemData.vReCalibrationTimerRunning = true;

						//if more than 15 minutes since last calibrated, can recalibrate
						CTime TempTime;
						TempTime = CTime::GetCurrentTime();
						if (TempTime >= vSystemData.vLastCalibrationTime + 900) // 15 min * 60 sec/min = 900 seconds
	 						ReCalibrateWhileRunning();
					}
					if (vSystemData.vCountTimeAsRunning)
					if (vSystemData.vSecondsSinceLastContainer >= 60)
					{
						vSystemData.vProductionStopsCount++;
#ifdef CompileInHTTPClientOperationsGuardian
						SendOGInfo(std::wstring(L"productionstops"), dtoa(vSystemData.vProductionStopsCount, 0), false);
#endif

						vSystemData.vTimeSinceLastStop = 0;
						vSystemData.vCountTimeAsRunning = false;
						ShowCPM();
						ReportErrorMessage("Production Stopped: " + vSystemData.vFrameCountString, cAction,0);

						if (vBackupHardDisk)
							StartCopyAllScanTracFoldersToBackupHardDrive();
					}
				}
				if (vConfigurationData->vAutoStop)
				{
					if ((vConfigurationData->vAutoStop * (DWORD)3600) < vSystemData.vTimeSinceLastStop)
					{
						StopRunning(true);
						GenerateProductionReport(cStopInspectingProductionReport);
						CString TempPlural = "s";
						if (vConfigurationData->vAutoStop == 1)
							TempPlural = "";
						ReportErrorMessage("No Containers in last " + dtoa(vConfigurationData->vAutoStop, 0) + " hour" + TempPlural + ", Inspection Stopped", cAction, 0);
					}
				}
			}
		}
		if (vSystemData.vMissedEjectsBecauseDisabledCount)
		if (vSystemData.vOldRejectCountTotal != vSystemData.vMissedEjectsBecauseDisabledCount)
			//4/12/2007
		//if (vSystemData.vOldRejectCountTotal != vSystemData.vRejectCountTotal)
		{
			if (!vSystemData.vOldRejectCountTotal)
			{
				m_TotalRejectsLabelStaticText.ShowWindow(SW_SHOW);
				m_TotalRejectsStaticText.ShowWindow(SW_SHOW);
				if ((!vConfigurationData->vContinuousFeedContainerRate) && (!vConfigurationData->vBulkProductMode) && ((vGlobalCurrentProduct) && (!vGlobalCurrentProduct->vBulkProductMode))) //not Continuous Feed, or a Pipeline
				{
					m_TotalRejectsPercent.ShowWindow(SW_SHOW);
					m_TotalRejectsPercentLabel.ShowWindow(SW_SHOW);
				}
			}
			vSystemData.vOldRejectCountTotal = vSystemData.vMissedEjectsBecauseDisabledCount;
			SetDlgItemText(IDC_TotalRejectsStaticText,IToAWithComma(vSystemData.vOldRejectCountTotal));
			if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
			{//if a pipeline put in when the last eject occured
				SetDlgItemText(IDC_PercentRejected,	vSystemData.vLastEjectTime);
			}
		}
		if (vSystemData.vOldEjectCountTotal != vSystemData.vEjectCountTotal)
		{
			vSystemData.vOldEjectCountTotal = vSystemData.vEjectCountTotal;
			SetDlgItemText(IDC_TotalEjectsStaticText,IToAWithComma(vSystemData.vOldEjectCountTotal));

			if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
			{//if a pipeline put in when the last eject occured
				SetDlgItemText(IDC_PercentRejected,	vSystemData.vLastEjectTime);
			}
		}

		if (vSystemData.vTotalUnConfirmed != vSystemData.vOldTotalUnConfirmed)
		{
			if (!vSystemData.vOldTotalUnConfirmed)
			{
				m_TotalUnConfirmLabel.ShowWindow(SW_SHOW);
				m_TotalUnConfirmed.ShowWindow(SW_SHOW);
			}
			vSystemData.vOldTotalUnConfirmed = vSystemData.vTotalUnConfirmed;
			SetDlgItemText(IDC_TotalUnConfirmed,IToAWithComma(vSystemData.vOldTotalUnConfirmed));
		}
	}

	if (vConfigurationData->vWriteRejectsToFiles)
	while (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vLogThisReject)
		WriteARejectToTheHardDrive();
}

void CScanTracDlg::ShowCPM()
{
	vSystemData.vOldContainerRate = vSystemData.vContainerRate;
	CString TempString = IToAWithComma(vSystemData.vOldContainerRate);
	CString TempText = " ";
	TempText.LoadString(IDS_CPM);
	TempString = TempString + " " + TempText;
	if (!vSystemData.vCountTimeAsRunning)
		TempString.LoadString(IDS_Stopped);
	if (vCPMNotRunning)
	if ((vSystemData.vSystemRunMode != cAutoSetupRunningSystem) &&
		(vSystemData.vSystemRunMode != cRunningSystemMode))
		TempString = dtoa(vCPMNotRunning,0) + " CPM";
	if (vOldCPMString != TempString)
	{
		vOldCPMString = TempString;
		SetDlgItemText(IDC_ContainersPerMinute,TempString);
	}
}

void CScanTracDlg::NextSourceRampUpStep() 
{
	KillTimer(vRampXRayTimerHandle);
	if (vSystemData.vRampXRayStep == 1)
		m_Calibrating.ShowWindow(SW_SHOW);
	//if (vSystemData.vRampXRayStep)
	{
		vSystemData.vRampXRayStep++;
		if (vSystemData.vRampXRayStep <= 10)
		{
			vSystemData.vRampXRayCurrentAmount = vSystemData.vRampXRayCurrentAmount + vSystemData.vRampXRayCurrentIncrement;
			vSystemData.vRampXRayVoltageAmount = vSystemData.vRampXRayVoltageAmount + vSystemData.vRampXRayVoltageIncrement;

			if (vSystemData.vRampXRayVoltageAmount > vGlobalCurrentProduct->vXRaySourceVoltage)
				vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;

			if (vSystemData.vRampXRayCurrentAmount > vGlobalCurrentProduct->vXRaySourceCurrent)
				vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;

			SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);
		}
		CString TempText = " ";
		TempText.LoadString(IDS_StartXRays);
		if (vSystemData.vSystemRunMode != cCalibratingDetectorEdgesMode) //ramp during edge calibration so don't show
		SetDlgItemText(IDC_Calibrating,TempText + " " + dtoa(vSystemData.vRampXRayStep + 13, 0));

		if ((vSystemData.vRampXRayStep > 12) && (vSystemData.vSystemRunMode != cStoppedSystemMode))//done ramping up
		{
			if (vGlobalCurrentProduct)
			{
				//if source up to voltage and current, or simulating light control board, 
				//then done ramping source so wait two seconds then run, else wait a second
				//then test again
				//only look at voltage
				if ((((vSystemData.vSourceVoltage >= vSystemData.vRampXRayVoltageAmount * 0.9) || (vSystemData.vRampXRayVoltageAmount == 0)) &&  
					((vSystemData.vSourceCurrent >= vSystemData.vRampXRayCurrentAmount * 0.9) || (vSystemData.vRampXRayCurrentAmount < .2))) ||
					(vConfigurationData->vSimulateLightControlBoard) || (vSystemData.vRampXRayStep > 60))
				{
					vSystemData.vRampXRayStep = 0;
					//will start image acquisition when x-ray source stabilized (timer)
					KillTimer(vSourceStabilizeTimerHandle);
					int TimerResult = SetTimer(vSourceStabilizeTimerHandle, cSourceStabilizeWaitTime, NULL);
					if (!TimerResult)
						ReportErrorMessage("Error-Source Stabilize Timer Failed",cEMailInspx,32000);

					if (vSystemData.vRampXRayStep > 60)
						ReportErrorMessage("Check X-Ray Voltage and Current",cEMailInspx,32000);
					if (vSystemData.vSystemRunMode == cMeasureSourceStrengthMode)
						TempText.LoadString(IDS_Measuring);
					else
					if (vSystemData.vSystemRunMode == cCalibratingDetectorGainMode)
						TempText = "Calibrate Gain";
					else
					//if (vSystemData.vSystemRunMode == cTestShutterMode)
					//	TempText = "Shutter Test";
					//else
					if (vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode)
					{
						if (vSystemData.vApplyGainAndOffsetDuringCalibration)
							TempText = "Verify Pixels";
						else
							TempText = "Calibrate Pixels";
					}
					else
					if ((vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) && 
						(!vSystemData.vAutoCalibrate) && (!vSystemData.vAutoCalibrateWhileRunning))
						TempText = "Calibrate Offset";
					else
					if (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode)
						TempText.LoadString(IDS_Wait);
					else
						TempText.LoadString(IDS_XRAYSStarted);
					//vSystemData.vXRayState = 13;
					//::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,13,0);
					vSystemData.vXRayState = 25;
					::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,25,0); //X-Rays up to correct voltage and current
					ReportErrorMessage("X-Rays Starting Up Step: 25", cWriteToLog, 0);

					if (vSystemData.vSystemRunMode == cConditionXRayTubeMode)
						TempText = vSystemData.vConditionString + " Tube";

					SetDlgItemText(IDC_Calibrating,TempText);
				}
				else
				{
					int TempTimerResult = SetTimer(vRampXRayTimerHandle, vSystemData.vRampXRayWaitTime,NULL);
					if (!TempTimerResult)
						ReportErrorMessage("Error-Source Ramp Timer Failed",cEMailInspx,32000);

					vSystemData.vXRayState = vSystemData.vRampXRayStep;
					::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage, vSystemData.vRampXRayStep,vSystemData.vRampXRayStep);
					ReportErrorMessage("X-Rays Starting Up Step: " + dtoa(vSystemData.vRampXRayStep, 0), cWriteToLog, 0);
				}
			}
		}
		else
		{
			int TempTimerResult = SetTimer(vRampXRayTimerHandle, vSystemData.vRampXRayWaitTime, NULL);
			if (!TempTimerResult)
				ReportErrorMessage("Error-Source Ramp Timer Failed",cEMailInspx,32000);

			vSystemData.vXRayState = vSystemData.vRampXRayStep;
			::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage, vSystemData.vRampXRayStep, vSystemData.vRampXRayStep);
			ReportErrorMessage("X-Rays Starting Up Step: " + dtoa(vSystemData.vRampXRayStep, 0), cWriteToLog, 0);
		}
	}
}

void CScanTracDlg::OnFunction1Button() 
{
}

void CScanTracDlg::OnFunction2Button() 
{ //setup button
	{
		if (PasswordOK(cSimpleSetupPassword,true))
		{
			BYTE TempEjectContainersNotInspected = ((vConfigurationData->vEjectContainersNotInspected) &&
				(vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vEnabled) &&
				(vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vDigitalInputLine));
				//first check password
			//Create configuration dialog box
			ReportErrorMessage("Operator pressed Setup Button", cUserAction,0);
			BYTE TempOriginalNumberOfXRayDetectors = vConfigurationData->vNumberOfXRayDetectors;
			bool TempDiverterEnabled = ((vConfigurationData->vEjectContainersNotInspected) &&
				(vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vEnabled) &&
				(vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vDigitalInputLine));
			vSystemData.vCurrentProductChanged = false;
			BYTE TempLaunguage = vConfigurationData->vLanguage;
		//BYTE TempClockDivider = vConfigurationData->vDetectorClockDivider;
			BYTE TempNumberOfXRayDetectors = vConfigurationData->vNumberOfXRayDetectors;
			WORD TempEncoderDivider = vConfigurationData->vEncoderDivider;
			BYTE TempAllowClientConnections = vConfigurationData->vAllowClientConnections;
			BYTE TempEnableModBusTCPIPInterface = vConfigurationData->vEnableModBusTCPIPInterface;
			CString TempOldScanTracCustomerName = vConfigurationData->vScanTracCustomerName;
			BYTE vOldNeedToCalibrateEncoder = vConfigurationData->vNeedToCalibrateEncoder;
			CConfigureProduct IConfigureProduct;  
			//Set dialog box data like how many products there are
			IConfigureProduct.vLocalConfigurationData = vConfigurationData;
			IConfigureProduct.vLocalProductCollection = &vProductCollection;
			IConfigureProduct.vLocalSystemData = &vSystemData;
			IConfigureProduct.vMainWindowPointer = this;

			//Pass control to dialog box and display
			int nResponse = IConfigureProduct.DoModal();
			//dialog box is now closed, if user pressed select do this
			if (TempAllowClientConnections != vConfigurationData->vAllowClientConnections)
			{
				if (vConfigurationData->vAllowClientConnections)
					InitializeTCPIPServerSocket();
				else
					CloseAllSockets();
			}

			if (TempEnableModBusTCPIPInterface != vConfigurationData->vEnableModBusTCPIPInterface)
			{
				if (vConfigurationData->vEnableModBusTCPIPInterface)
					OpenModBusTCPIPInterface();
				else
					CloseModBusTCPIPInterface();
			}
			if (TempOldScanTracCustomerName != vConfigurationData->vScanTracCustomerName)
				UpdateCustomerNameLine();

			if (vOldNeedToCalibrateEncoder != vConfigurationData->vNeedToCalibrateEncoder)
				UpdateCustomerNameLine();

			if (((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) && (vSystemData.vSystemRunMode != cConditionXRayTubeMode))
				m_ContainersPerMinuteControl.ShowWindow(SW_HIDE); //hide on pipe lines if not burning in or conditioning a tube
			else
			m_ContainersPerMinuteControl.ShowWindow(SW_SHOW);

			BYTE TempNewEjectContainersNotInspected = ((vConfigurationData->vEjectContainersNotInspected) &&
				(vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vEnabled) &&
				(vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vDigitalInputLine));
			if (TempEjectContainersNotInspected != TempNewEjectContainersNotInspected)
			{
				if (vConfigurationData->vEjectContainersNotInspected)
				{
					m_SubFunction2Button.ShowWindow(SW_HIDE);
					this->InvalidateRect(&m_SubFunction2Button.GetRectToInvalidateArrow());
					if (!vConfigurationData->vEnableEjectors)
					{
						vConfigurationData->vEnableEjectors = true;
						m_EjectorsDisabled.ShowWindow(SW_HIDE);
						if (vGlobaluCSerialPort)
							vGlobaluCSerialPort->EnableDisableEjectors(vConfigurationData->vEnableEjectors);
						UpdateDisableEjectorsButton();
					}
				}
				else
				{
					m_SubFunction2Button.ShowWindow(SW_SHOW);
				}
			}

			CString TempText = " ";
			//if (vConfigurationData->vUseMetric)
			//	TempText.LoadString(IDS_ConveyorRateMMin);
			//else
				TempText.LoadString(IDS_ConveyorRateFtMin);
			SetDlgItemText(IDC_BeltRateLabel,TempText + ":");

			if (vGlobalCurrentProduct == NULL)
			if (vSystemData.vPreviousProduct != "")
			{
				vSystemData.vCurrentProductName = vSystemData.vPreviousProduct;
				vGlobalCurrentProduct = GetProductByName(vSystemData.vPreviousProduct);
				vSystemData.vCurrentProductChanged = true;
			}
			UpdateCurrentProductNameDisplay();
			SetExternalDetectorDecisionOffset();
			SetProductDensityDisplay();
			if (vSystemData.vCurrentProductChanged)
			{
				ReportErrorMessage("Changed Setup for Product: " + vSystemData.vCurrentProductName, cAction,0);
				CProduct *TempProductPointer = GetProductByName(vSystemData.vCurrentProductName);
				if (CheckSystemFullyConfigured(vConfigurationData))
					CheckProductFullyConfigured(TempProductPointer);
				if (TempProductPointer)
				if (vSystemData.vSystemRunMode == cStoppedSystemMode)
				{
					SetupProduct(TempProductPointer, false);
					MakeProductionReportIfNeeded();
					ResetCounters();
					vSystemData.vInspectionNameChanged = false;
					vSystemData.vInspectionNameMoved = false;
					if (vSystemData.vSetupANewProduct)
						EditShift(true);
					vSystemData.vSetupANewProduct = false;
				}
				else
				{
					if (vSystemData.vInspectionNameChanged)
					{
						vSystemData.vInspectionNameChanged = false;
						if (vSystemData.vInspectionNameMoved)
						{
							vSystemData.vInspectionNameMoved = false;
							ResetCounters();
						}
					}
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\nYou have changed settings that effect the product.\nYou should stop running, reload the product,\nand start running again when possible.";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
			}
			else
			{	//may have changed system parameters that need only some setup done
				if (TempOriginalNumberOfXRayDetectors != vConfigurationData->vNumberOfXRayDetectors)
				if (vGlobalCurrentProduct != NULL)
				if (vSystemData.vSystemRunMode == cStoppedSystemMode)
					//SetupProduct(vGlobalCurrentProduct, false);
					SetupFrameGrabber();
			if (//(vConfigurationData->vDetectorClockDivider != TempClockDivider) ||
					(vConfigurationData->vNumberOfXRayDetectors != TempNumberOfXRayDetectors) ||
					(vConfigurationData->vEncoderDivider != TempEncoderDivider))
				if (vSystemData.vSystemRunMode == cStoppedSystemMode)
				{
					SendInitializationToUController(false);
				}
				else
					SendResolutionSettingsTouCHardware();

				if (TempLaunguage != vConfigurationData->vLanguage)
					SetupLanguage();
			}
			if (vSystemData.vInspectionNameChanged)
			{
				vSystemData.vInspectionNameChanged = false;
				if (vSystemData.vInspectionNameMoved)
				{
					vSystemData.vInspectionNameMoved = false;
					if (vSystemData.vSystemRunMode == cRunningSystemMode)
					{
						if (vSystemData.vTotalContainers > 0)
						{
							GenerateProductionReport(cSelectProductProductionReport);
							SendProductionReport(cSelectProductProductionReport);
						}
					}
					ResetCounters();
				}
			}
			if (vGlobalCurrentProduct == NULL)
			{
				if (vProductCollection.GetSize() > 0)
				{
					vGlobalCurrentProduct = vProductCollection.GetAt(0);
					SetupProduct(vGlobalCurrentProduct, false);
					ResetCounters();
					vSystemData.vInspectionNameChanged = false;
				}
			}
			//CWnd *TempWindow = CWnd::GetDlgItem(IDC_uControllerStatus);
			//TempWindow->Invalidate(false);
			//TempWindow = CWnd::GetDlgItem(IDC_TestModesActive);
			//TempWindow->Invalidate(false);

			WriteConfigurationDataToFile(false); //write to main config file
			WriteLifeTimeCounter();

			if (vSystemData.vCurrentProductChanged)
			{
				BackupSetupFiles(false);
			}
			ReportErrorMessage("Return from Setup Button", cWriteToLog,0);
			UpdateRunButton();
			UpdateSubFunction8Button();
			SetInterlockStatus();
			if (vSystemData.vSystemRunMode == cRunningSystemMode)
				CheckInspectionNamesForOldInspections(true);
		}
		CWnd * TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
		if (TempWindow)
			TempWindow->Invalidate(false);
		//9/30/2009
		CheckSystemSettingsAreStandard();
		CalculateSensitivity();
		vLastLearnState = 255;
		SetLearnState();

		if (vSystemData.vStartRunningAfterLoadProduct)
		{
			vSystemData.vStartRunningAfterLoadProduct = false;
			//OnSubFunction4Button();
			vSystemData.vModeToRunAfterCalibrateOffset = cRunningSystemMode;
			vSystemData.vCalibrateErrorCount = 0;
			vSystemData.vHadErrorTryRestart = 0;
			vSystemData.vCalibrateADCAfterDAC = true;
			vSystemData.vAutoCalibrate = true;
			vSystemData.vAutoCalibrateWhileRunning = false;
			vSystemData.vFullDetectorCalibration = false;
			if (vConfigurationData->vUseDACAndADCinDensityCompensation)
				CalibrateDACDetectorOffset();
			else
				CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
		}
	}
	CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
	if (TempWindow)
		TempWindow->Invalidate(false);

	vSystemData.vSetupANewProduct = false;
}

void CScanTracDlg::OnFunction3Button() 
{
	//Diagnostic button
	if (PasswordOK(cOperatorPassword,true))
	{
		ReportErrorMessage("Operator pressed Diagnostic Button", cUserAction,0);
		bool TempNotCommissioned = vSystemData.vNotCommissioned;

		DoDiagnostics();
		WriteConfigurationDataToFile(false); //write to main config file
		WriteLifeTimeCounter();
		if (TempNotCommissioned != vSystemData.vNotCommissioned)
			UpdateCustomerNameLine();

		ReportErrorMessage("Return from Diagnostic Button", cUserAction,0);
		UpdateRunButton();
		SetInterlockStatus();

	if (((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) && (vSystemData.vSystemRunMode != cConditionXRayTubeMode))
		m_ContainersPerMinuteControl.ShowWindow(SW_HIDE); //hide on pipe lines if not burning in or conditioning a tube
	else
		m_ContainersPerMinuteControl.ShowWindow(SW_SHOW);
	}

	CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
	if (TempWindow)
		TempWindow->Invalidate(false);
	vSystemData.vInAutoSetup = false;
}


void CScanTracDlg::OnFunction4Button() 
{
	//Rejects Button Pressed
	vSystemData.vCurrentProductChanged = false;
	if (PasswordOK(cOperatorPassword,true))
	{
		if ((vSystemData.vITIPCDig->vAquisitionBuffer == NULL) ||
			(vGlobalCurrentProduct == NULL))
		{
			CString TempText = " ";
			TempText.LoadString(IDS_Youmustselectaproducttoseeimages);  //need 3 blank lines first

			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = TempText;
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
		else
		{
			ReportErrorMessage("Operator pressed Rejects Menu Button", cUserAction,0);
			//Create diagnostic dialog box
			CNewImageDisplayDialog IImageDisplayDialog;  
			//Set dialog box data like how many products there are
			//IImageDisplayDialog.vLocalProductCollection = &vProductCollection;
			IImageDisplayDialog.vLocalSystemData = &vSystemData;
			IImageDisplayDialog.vLocalConfigurationData = vConfigurationData;
			IImageDisplayDialog.vMainWindowPointer = this;
			IImageDisplayDialog.vLocalProductCollection = &vProductCollection;
			//Pass control to dialog box and display
			int nResponse = IImageDisplayDialog.DoModal();

			//if changes were made, save data to file
			if (nResponse == IDOK)
			{
				WriteConfigurationDataToFile(false); //write to main config file
				WriteLifeTimeCounter();
			}
			if (vSystemData.vInspectionNameChanged)
			{
				vSystemData.vInspectionNameChanged = false;
				if (vSystemData.vInspectionNameMoved)
				{
					vSystemData.vInspectionNameMoved = false;
					MakeProductionReportIfNeeded();
					ResetCounters();
				}
			}
			ReportErrorMessage("Return from Rejects Menu Button", cWriteToLog,0);
			UpdateSubFunction8Button();
			SetInterlockStatus();
		}
	}
	CalculateSensitivity();

	CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
	if (TempWindow)
		TempWindow->Invalidate(false);
	vSystemData.vInAutoSetup = false;
}

void CScanTracDlg::OnFunction5Button() 
{
}

void CScanTracDlg::OnSubFunction1Button() 
{
	// Pressed Stop Button
	//vGlobalMouseMoveCounter = 0;
	vSystemData.vVerifyDACValues = 0; //cancel any verify operation
	vSystemData.vGenerateDACVerifyReport = false;
	vRunButtonPressedLastNotStop = false;
	if (vSystemData.vSystemRunMode == cConditionXRayTubeMode)
	{
		ReportErrorMessage("Abort X-Ray Tube " + vSystemData.vConditionString, cUserAction,0);
		SetDlgItemText(IDC_ContainersPerMinute, _T("Stopped"));
	}

	ReportErrorMessage("Operator pressed Stop Button", cUserChanges,0);

	if (((vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) || (vSystemData.vSystemRunMode == cCalibratingDetectorGainMode) || (vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode) ||
		(vSystemData.vSystemRunMode == cMeasureSourceStrengthMode) || (vSystemData.vSystemRunMode == cTestShutterMode)) && (!vAbortCalibration))
	{
		vAbortCalibration = true;
		SetDlgItemText(IDC_SubFunction1Button, _T("Wait"));
	}
	else
	{
		StopRunning(true);
		GenerateProductionReport(cStopInspectingProductionReport);

		CheckIfShouldMeasureSourceStrength();

		if (vBackupHardDisk)  //if you needed to backup yesterday, but constantly running, backup in 30 minutes if not running.
		{
			int TimerResult = 0;
	#ifdef _DEBUG
			TimerResult = SetTimer(vBackupToBackupHardDriveTimer,9000,NULL); //30 minutes
	#else
			TimerResult = SetTimer(vBackupToBackupHardDriveTimer,1800000,NULL); //30 minutes
	#endif
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx, 32000);
		}
	}
}

void CScanTracDlg::OnSubFunction2Button() 
{
	//toggle Ejector enable disable
	//vGlobalMouseMoveCounter = 0;
	if (!vConfigurationData->vEjectContainersNotInspected)
	{
		//if not enabled, or password OK
		if ((!vConfigurationData->vEnableEjectors) || (PasswordOK(cResetPassword,true)))
		{
			vSystemData.vHaveAutoDisabledEjectors = false;
			for (WORD TempLoop = 0; TempLoop < 2; TempLoop++)
				vSystemData.vGaveTooManyRejectsAlarm[TempLoop] = false;

			vConfigurationData->vEnableEjectors = !vConfigurationData->vEnableEjectors;
			CSocketMessage TempMessage;
			TempMessage.vMessageFormat = 3;
			TempMessage.vMessageCommand = cSocketChangedStatusMessage;
			if (vConfigurationData->vEnableEjectors)
			{
				ReportErrorMessage("Ejectors Enabled by operator", cUserChanges,0);
				TempMessage.vMessageDWordArray[0] = 3;
				TempMessage.vMessageText = "Ejectors Enabled";
#ifdef CompileInHTTPClientOperationsGuardian
				SendOGInfo(std::wstring(L"ejectorstatus"), "Enabled", false);
#endif

				//Kill yellow light if system is inspecting properly 
				if (!vSystemData.vCantInspectError)
				{
					KillTimer(vFlashYellowLightTimerHandle);

					if (vSystemData.vYellowMessageButtonYellow)
						vGlobaluCSerialPort->TurnOnOffYellowLamp(true);
					else
						vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
				}
			}
			else
			{
				ReportErrorMessage("Ejectors Disabled by operator", cUserChanges,0);
				TempMessage.vMessageDWordArray[0] = 4;
				TempMessage.vMessageText = "Ejectors Disabled";
#ifdef CompileInHTTPClientOperationsGuardian
				SendOGInfo(std::wstring(L"ejectorstatus"), "Disabled", false);
#endif
				//Flash yellow light 
				int TimerResult = SetTimer(vFlashYellowLightTimerHandle,500,NULL);
			}
			SendSocketAMessageFromServerToClients(&TempMessage);
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->EnableDisableEjectors(vConfigurationData->vEnableEjectors);
			UpdateDisableEjectorsButton();
			WriteConfigurationDataToFile(false); //write to main config file
		}
	}
	CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
	if (TempWindow)
		TempWindow->Invalidate(false);
}

void CScanTracDlg::OnSubFunction3Button() 
{
	//Select Product button
	if (m_SubFunction3Button.IsWindowVisible())
	{
		ReportErrorMessage("Operator pressed Select Product Button", cUserChanges,0);
		if (PasswordOK(cOperatorPassword,true))
		{
			if (vGlobalProcessQuickLearnImagesThread)
			{
				CNoticeDialog TempNoticeDialog;
				CString TempText = " ";
				TempText.LoadString(IDS_ProcessingQuickLearnwaituntilfinished);
				TempNoticeDialog.vNoticeText = "Processing Quick Learn, wait until finished";
				TempNoticeDialog.vType = cErrorMessage;
				TempNoticeDialog.DoModal();
			}
			else
			{
				ReportErrorMessage("Operator pressed Select Product Button", cUserChanges,0);
				SelectCurrentProduct();
			}
		}
		SetInterlockStatus();
	}
}

void CScanTracDlg::OnSubFunction4Button() 
{ // run button
 	if (vSystemData.vSystemRunMode == cStoppedSystemMode)
	if (m_SubFunction4Button.IsWindowVisible())
	{
		if (!vGlobalCurrentProduct)
		{
			CString TempText = " ";
			TempText.LoadString(IDS_YoumustselectaCurrentProducttoRun);

			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = TempText;
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
		else
		if (vGlobalImageAquisitionThread)
		{
			if (PasswordOK(cOperatorPassword,true))
			if (IfTubeHasBeenOffLongEnough())
			{
				vSystemData.vRunningDiagnosticsMode = false;
				vSystemData.vFullDetectorCalibration = false;
				vGlobalErrorCount = 0;
				ReportErrorMessage("Operator pressed Run Button", cUserChanges,0);
				if (vConfigurationData->vDemoMode)
					StartRunning(true, true);
				else
				//if ((vSystemData.vEjectTooLateMessageGivenThisRun) && (!(PasswordOK(cSetupPassword,true))))
				//{
				//	CNoticeDialog TempNoticeDialog;
				//	TempNoticeDialog.vNoticeText = "\nRecent Eject Decision was Too Late\nYou must correct the setup by Shotening the Image,\nor Reducing the Processing Time to continue inspecting";
				//	TempNoticeDialog.vType = cErrorMessage;
				//	TempNoticeDialog.DoModal();
				//}
				//else
				if (PowerWiringOK())
				if (InterlocksOK())
				if (!vSystemData.vMemoryOK)
				{
					ReportErrorMessage("Error-Not Enough Memory to Run", cEMailInspx,32000);
				}
				else
				//if ((!vSystemData.vUControllerReady) && (!vConfigurationData->vDemoMode) && (!vConfigurationData->vSimulateLightControlBoard))
				//{
				//	ReportErrorMessage("Error-uController initializing - clear message to abort, or wait", cEMailInspx,32000);
				//	vSystemData.vWaitingForUControllerReady = true;
				//}
				//else
				if (vConfigurationData->vNeedToCalibrateEncoder)
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\nInspx must Calibrate the Encoder\nin System Setup, Conveyor Setup";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
				else
				if ((vGlobalMonoBlockXRayPort) && (vGlobalMonoBlockXRayPort->vNoCommunications) && (!vConfigurationData->vSimulateLightControlBoard))
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\nNo Communication with XRB210W MonoBlock HVPS\nCall Service";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
				else
				if ((vGlobalDXMXRayPort) && (vGlobalDXMXRayPort->vNoCommunications) && (!vConfigurationData->vSimulateLightControlBoard))
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\nNo Communication with " + vGlobalDXMXRayPort->vHVPSType + "\nCall Service";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
				else
				if ((vSystemData.vNoCommunicationsWithUController) && (!vConfigurationData->vSimulateLightControlBoard))
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\nNo Communication with Micro Controller\nCall Service";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
				else
				if (!ConditionTubeIfNeeded())//if don't need to condition MonoBlock, then start running
				{
					vRunButtonPressedLastNotStop = true;
					vSystemData.vModeToRunAfterCalibrateOffset = cRunningSystemMode;
					vSystemData.vCalibrateErrorCount = 0;
					vSystemData.vHadErrorTryRestart = 0;
					//CalibrateADCDetectorOffset(true, false);
					vSystemData.vCalibrateADCAfterDAC = true;
					vSystemData.vAutoCalibrate = true;
					vSystemData.vAutoCalibrateWhileRunning = false;
					vSystemData.vFullDetectorCalibration = false;
					if (vConfigurationData->vUseDACAndADCinDensityCompensation)
						CalibrateDACDetectorOffset();
					else
						CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
#ifdef CompileInHTTPClientOperationsGuardian
			SendOGTimeZoneData();
#endif

					if (vSystemData.vCheckWeighOffsetCalibrationNeeded)
					{
						//	CNoticeDialog TempNoticeDialog;
						//	TempNoticeDialog.vNoticeText = "\nCalibration of Check Weighing Offset Recommended.\n\nTo Calibrate press Show Production Summary,\nWeight Trending, Show Recent, Weight Offset.";
						//	TempNoticeDialog.vType = cInformationMessage;
						//	TempNoticeDialog.DoModal();
						CSelectItemDialog ISelectItemDialog;
						ISelectItemDialog.vTitleString = "Calibration of Check Weighing Offset Recommended";
						ISelectItemDialog.vNumberOfItems = 3;
						ISelectItemDialog.vBackgroundColor = cGreen;

						ISelectItemDialog.vItems[0] = "Go to Calibrate Menu";
						ISelectItemDialog.vItems[1] = "Remind me to do soon";
						ISelectItemDialog.vItems[2] = "Don't calibrate offset thus run";
						ISelectItemDialog.m_DialogTitleStaticText2 = "Weights may not be accurate without calibrating";
						ISelectItemDialog.vGreenItem = 0;
						ISelectItemDialog.m_DialogTitleStaticText3 = "";
						//Pass control to dialog box and display
						int nResponse = ISelectItemDialog.DoModal();
						//dialog box is now closed, if user pressed select do this
						//if user pressed cancel, do nothing
						if (nResponse == IDOK)
						{
							if (ISelectItemDialog.vItemNumberSelected == 1)
							{
								StartCheckWeighingMenu(true);
							}
							else
							if (ISelectItemDialog.vItemNumberSelected == 2)
								vSystemData.vCheckWeighOffsetCalibrationNeeded = true;
							else
								vSystemData.vCheckWeighOffsetCalibrationNeeded = false;
						}
						else
							vSystemData.vCheckWeighOffsetCalibrationNeeded = false;

						InterlocksOK();
					}
				}
			}
		}
		//reset variables on run
		vGlobalCountErrorMsgPossibleDirectoryNotAvailableSent = 0;

		for (int i=0; i < cSlipArraySize; i++)
			vGlobalProductSlipArray[i] = 0;

		vGlobalProductSlipErrorSent = 0;
		vSystemData.vGivenTemperatureSensorWarning = cTemperatureSensorWarningsNoneSent; //vSystemData.vGivenTemperatureSensorWarning = cTemperatureSensorWarningsNoneSent;
		vGlobalTrackSensors = 0;
	}
}

void CScanTracDlg::OnSubFunction5Button() 
{
  //Change display to Production Summary
	ReportErrorMessage("Operator pressed Production Summary Button", cUserAction,0);
	
	CProductionSummaryDialog IProductionSummaryDialog;  
	//Set dialog box data like how many products there are
	IProductionSummaryDialog.vLocalProductCollection = &vProductCollection;
	IProductionSummaryDialog.vLocalSystemData = &vSystemData;
	IProductionSummaryDialog.vLocalConfigurationData = vConfigurationData;
	IProductionSummaryDialog.vMainWindowPointer = this;

	vNumberOfWeighInspections = 0;
	if (vGlobalCurrentProduct)
	for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
	if (vGlobalCurrentProduct->vInspection[TempLoop])
	{
		if ((vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection) || (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection) ||
			(vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection))
		if (!vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionNameForWeightTrendingPointer) //if wieght trending inspection, use other inspections settings
			vNumberOfWeighInspections++;
	}

	//Pass control to dialog box and display
	int nResponse = IProductionSummaryDialog.DoModal();
}

void CScanTracDlg::OnSubFunction6Button() 
{
	if (PasswordOK(cOperatorPassword,true))
	{
		ClearYellowWarningButton();
	}
}

void CScanTracDlg::OnSubFunction7Button() 
{
	if (!vGlobalCurrentProduct)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "/n/n/nYou must select a product to sample";
		TempNoticeDialog.vType = cErrorMessage;
		TempNoticeDialog.DoModal();
	}
	else
	if ((vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]) || (vConfigurationData->vNumberOfHeadsToMonitor[cSeamerSamplingType]))
	{
		//Create dialog box
		ReportErrorMessage("Operator pressed Filler-Seamer-Sampling Button", cUserAction,0);
		CFillerSeamerSamplingDialog IFillerSeamerSamplingDialog;  
		//Set dialog box data like how pointers to system data
		//IFillerSeamerSamplingDialog.vLocalProductCollection = &vProductCollection;
		IFillerSeamerSamplingDialog.vLocalSystemData = &vSystemData;
		IFillerSeamerSamplingDialog.vLocalConfigurationData = vConfigurationData;
		IFillerSeamerSamplingDialog.vMainWindowPointer = this;

		//Pass control to dialog box and display
		int nResponse = IFillerSeamerSamplingDialog.DoModal();
		ReportErrorMessage("Operator returned from Filler-Seamer-Sampling Menu", cUserAction,0);
	}
	else
	if (vConfigurationData->vNumberOfHeadsToMonitor[cRandomSamplingType] == 1)
	{ //random sampling
		ReportErrorMessage("Operator pressed Random Sampling Button", cUserAction,0);
		CSamplingDialog ISamplingDialog;  
		//Set dialog box data like how pointers to system data
		//IFillerSeamerSamplingDialog.vLocalProductCollection = &vProductCollection;
		ISamplingDialog.vLocalSystemData = &vSystemData;
		ISamplingDialog.vLocalConfigurationData = vConfigurationData;
		ISamplingDialog.vMainWindowPointer = this;

		//Pass control to dialog box and display
		int nResponse = ISamplingDialog.DoModal();
		ReportErrorMessage("Operator returned from Random Sampling Menu", cUserAction,0);
	}
	else
	if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
		ShowMultiLaneCounts();
}

void CScanTracDlg::OnSubFunction8Button() 
{
	// Toggle Display only Rejects
	if (PasswordOK(cOperatorPassword,true))
	{
		vSystemData.vITIPCDig->vImageDisplayOnlyRejects = !vSystemData.vITIPCDig->vImageDisplayOnlyRejects;
		if (vSystemData.vITIPCDig->vImageDisplayOnlyRejects)
			ReportErrorMessage("Operator pressed Show Only Rejects Button", cUserAction,0);
		else
			ReportErrorMessage("Operator pressed Show All Button", cUserAction,0);
		UpdateSubFunction8Button();
		WriteConfigurationDataToFile(false); //write to main config file
	}
}

bool CScanTracDlg::InterlocksOK()
{  //shows Red Status Indicator
	if (((vSystemData.vSourceInterLocks & 0x1F71) == 0x1F71) ||
	//bill does not have x-ray power supply AC on implemented
	//if (((vSystemData.vSourceInterLocks & 0x1F1B) == 0x1F1B) ||
		(vConfigurationData->vDemoMode)) 
	{
		vSystemData.vOpenInterlock = "";
		/*
		if ((!(vSystemData.vSourceInterLocks & 0x2000)))
		{
			ReportErrorMessage("Error-Ejector Air Pressure Low", cEMailMaintenance,0);
			ReportErrorMessage("Error-Ejector Air Pressure Low", cEMailInspx, 32000);
			vSystemData.vOpenInterlock = "Ejector Air";
		}
		else
		*/
		if (vSystemData.vDisplayingAnEncoderError)
		{
			CString TempString = "Encoder Faulty";
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if (vSystemData.vEjectTooLateMessageGivenThisRun)
		{
			CString TempString;
			TempString.LoadString(IDS_LateEject);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if (vSystemData.vPosteduCVoltageProblemMessage)
		{
			CString TempString = " ";
			TempString.LoadString(IDS_PowerSupplyProblem);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if (vSystemData.vAirConditionerFailed)
		{
			CString TempString = " ";
			TempString.LoadString(IDS_ACFailed);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if (vSystemData.vWeightTrendingAlarm)
		{
			CString TempString = " ";
			TempString.LoadString(IDS_WeightTrend);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if ((vSystemData.vCheckWeighOffsetCalibrationNeeded) && (vSystemData.vSystemRunMode == cRunningSystemMode))
		{
			CString TempString = " ";
			TempString.LoadString(IDS_CalibrateWeight);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if (vSystemData.vMissingRAM)
		{
			CString TempString = " ";
			TempString.LoadString(IDS_MissingRAM);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if (vSystemData.vShutterFailedLastTest)
		{
			CString TempString = " ";
			TempString.LoadString(IDS_ShutterFailed);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if ((vConfigurationData->vEnableOperationsGuardian) && (vSystemData.vOperationsGuardianError))
		{
			CString TempString = " ";
			TempString.LoadString(IDS_GuardianServer);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		//have a backup hard drive, but no primary hard drive in the system
		if ((!vSystemData.vPrimaryDrive.GetLength()) && (vSystemData.vBackupDrive.GetLength()))
		{
			CString TempString = " ";
			TempString.LoadString(IDS_NoPrimaryDrive);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if ((vSystemData.vPrimaryDrive.GetLength()) && (!vSystemData.vBackupDrive.GetLength()))
		{
			CString TempString = " ";
			TempString.LoadString(IDS_NoBackupDrive);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if (vSystemData.vProductHasAPoorLearn)
		{
			CString TempString = " ";
			TempString.LoadString(IDS_PoorLearn);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		if (vSystemData.vProductHasAnOldInspection)
		{
			CString TempString = " ";
			TempString.LoadString(IDS_OldInspection);
			vSystemData.vOpenInterlock = TempString;
		}
		else
		//if (vSystemData.vHadABrownOut)
		//{
		//	CString TempString = " ";
		//	TempString.LoadString(IDS_BrownOut);
		//	vSystemData.vOpenInterlock = TempString;
		//}
		//else
		//if (vSystemData.vHadAnACPowerDropOut)
		//{
		//	CString TempString = " ";
		//	TempString.LoadString(IDS_ACDropOut);
		//	vSystemData.vOpenInterlock = TempString;
		//}
		//else
		//if (vSystemData.vDetectorCalibrationNeeded)
		//{
		//	CString TempString = " ";
		//	TempString.LoadString(IDS_DetectorCalibrationNeeded);
		//	vSystemData.vOpenInterlock = TempString;
		//}
		//else
		if (vSystemData.vYellowLampBrokenCounter > 9)
		{
			vSystemData.vOpenInterlock.LoadString(IDS_YellowLight);
			//socketio Yellow Light Broken
		}
		else
		if (vSystemData.vBlueLampBrokenCounter > 9)
		{
			vSystemData.vOpenInterlock.LoadString(IDS_BlueLight);
			//socketio Blue Light Broken
		}
		else
		if ((!vSystemData.vDownStreamSignalSaysConveyorOn) && (vConfigurationData->vUseDownStreamSignalThatStopsConveyor == cUseDownStream))
		{
			CString TempString = " ";
			TempString.LoadString(IDS_DownStream);
			vSystemData.vOpenInterlock = TempString;
		}
		else 				
		if  (vSystemData.vGivenTemperatureSensorWarning == cTemperatureSensorWarningRedBoxSent)
		{
			vSystemData.vOpenInterlock = "Temp Sensor";
		}
		else
		if (vSystemData.vOperationsGuardianError)
		{
			vSystemData.vOpenInterlock.LoadString(IDS_GuardianServer);
		}
		else //faulty encoder
		if (vSystemData.vDisplayingAnEncoderError)
		{
			vSystemData.vOpenInterlock = "Encoder Faulty";
		}

		return true;  //if the interlocks are OK, then start up
	}
	else
	{
		CString TempText = " ";
		if ((!vGlobalFPGAVersion10Point0OrHigher) && (vSystemData.vFPGAVersion9Point1OrHigher))
		{
			if (!(vSystemData.vSourceInterLocks & 0x0040))  //power is off
			{
				if (vSystemData.vSystemRunMode == cRunningSystemMode)
					ReportErrorMessage("A/C Power Turned Off", cError,0);
				else
					ReportErrorMessage("A/C Power Turned Off", cEMailMaintenance,0);
				if (vSystemData.vACPowerOn)  //if was on before
				{
					vSystemData.vACPowerOn = false;
					ReportErrorMessage("Master Power Switch Turned Off <10.0",cUserChanges,0);
					//vSystemData.vOpenInterlock = TempText;
					SetInterlockStatus();
				}
			}
			else //power is on
			if (!vSystemData.vACPowerOn)  //if was off before
			{
				vSystemData.vACPowerOn = true;
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
				KillTimer(vCheckACBeforeThisYellowMessageTimerHandle);

				ReportErrorMessage("AC Power Turned On <10.1", cUserChanges,0);
				SetInterlockStatus();
			}
		}
		else
		if (!(vSystemData.vSourceInterLocks & 0x0040))  //power is off
				ReportErrorMessage("A/C Power Turned Off", cError,0);

		if (!(vSystemData.vSourceInterLocks & 0x0010))
		{
			if (vConfigurationData->vHVPSType == cXLFHVPS)
			{
				TempText.LoadString(IDS_XRayFault);
				vSystemData.vOpenInterlock = TempText;
				TempText.LoadString(IDS_ErrorXRayFaultCheckSpellmanPowerSupply);
			}
			else //DXM or MonoBlock
			{
				TempText.LoadString(IDS_NoXRayComm);
				vSystemData.vOpenInterlock = TempText;
				//TempText.LoadString(IDS_ErrorXRayFaultCheckSpellmanPowerSupply);
				TempText = "No Communication with X-Ray Device";
			}
			ReportErrorMessage(TempText, cError,9);
			ReportErrorMessage(TempText, cEMailInspx,9);
		}
		else
		//if (!(vSystemData.vSourceInterLocks & 0x0008))
		//{
		//	ReportErrorMessage("Error-X-Ray Supply", cError,9);
		//	vSystemData.vOpenInterlock = "X-Ray Supply";
		//}
		//else
		if ((!(vSystemData.vSourceInterLocks & 0x0400)) && (!vDisplayingVersion))
		{
			CString TempString = "";
			if (vConfigurationData->vUseExternalInterlock)
			{
				TempText.LoadString(IDS_ExternalInterlock);
				CString TempString2 = "";
				TempString2.LoadString(IDS_Open);
				TempText = TempText + " " + TempString2;
			}
			else
				TempText.LoadString(IDS_CoolantFlow);

			vSystemData.vOpenInterlock = TempText;
			if (vSystemData.vLogFile.vLogSerialData)
			{
				if (vConfigurationData->vUseExternalInterlock)
					vSystemData.vLogFile.WriteToLogFile("Main Menu External Interlock Open",cDebugMessage);
				else
					vSystemData.vLogFile.WriteToLogFile("Main Menu Coolant Flow Fault",cDebugMessage);
			}
				vSystemData.vLogFile.WriteToLogFile("Main Menu Coolant Flow Fault",cDebugMessage);
			//socketio coolant needs to be addedno 

			TempText.LoadString(IDS_ErrorXRayCoolantFlowProblem);
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->TurnOnOffYellowLamp(true);
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile(TempText,cDebugMessage);

			if (vConfigurationData->vUseExternalInterlock)
			{
				ReportErrorMessage(TempText, cEMailMaintenance,8);
				//ReportErrorMessage(TempText, cEMailInspx,8);
			}
			else
			if (vSystemData.vACPowerOn)
			if ((vConfigurationData->vUseExternalInterlock) || (vGlobalScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vGlobalScanTracType == cFermataScanTrac) || 
				(vConfigurationData->vScanTracType == cUpSideDownSoloScanTrac))
			{
				if (!vSystemData.vCheckACBeforeThisYellowMessage.GetLength())
				{
					vSystemData.vCheckACBeforeThisYellowMessage = TempText;
					vSystemData.vCheckACBeforeThisYellowMessageTempLevel = cError;
					vSystemData.vCheckACBeforeThisYellowMessageTempErrorCode = 8;
					int TimerResult = SetTimer(vCheckACBeforeThisYellowMessageTimerHandle,3000,NULL);
				}
				//ReportErrorMessage(TempText, cEMailMaintenance,8);
				//ReportErrorMessage(TempText, cEMailInspx,8);
			}
		}
		else
		if (!(vSystemData.vSourceInterLocks & 0x0800))
		{
			if ((vConfigurationData->vScanTracType == cAtempoScanTrac) || (vConfigurationData->vScanTracType == cForteScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || 
				(vConfigurationData->vScanTracType == cCaseInspectorScanTrac))
			{
				if ((vGlobalGuardMaster) && (vGlobalGuardMaster->vDetectedValidGuardMasterDevice))
				{
					if ((vGlobalGuardMaster->vGuardMasterRawInterlockData & cLeftConveyorCoversMaskBits) == cLeftConveyorCoversMaskBits)
						TempText.LoadString(IDS_LeftConveyorDoor);
					else
					if ((vGlobalGuardMaster->vGuardMasterRawInterlockData & cRightConveyorCoversMaskBits) == cRightConveyorCoversMaskBits)
						TempText.LoadString(IDS_RightConveyorDoor);
					else
					if ((vGlobalGuardMaster->vGuardMasterRawInterlockData & cBackDoorMaskBits) == cBackDoorMaskBits)
						TempText.LoadString(IDS_CenterConveyorDoor);
				}
				else
					TempText.LoadString(IDS_LowerDoor);
			}
			else
			if (vConfigurationData->vScanTracType == cBriosoScanTrac)
				TempText.LoadString(IDS_TunnelDoor);
			else
				TempText.LoadString(IDS_SideDoor);
			vSystemData.vOpenInterlock = TempText;
		}
		else
		if (!((vSystemData.vSourceInterLocks & 0x1000) || (vSystemData.vSystemRunMode == cAlignTubeMode)))
		{
			if ((vConfigurationData->vScanTracType == cAtempoScanTrac) || (vConfigurationData->vScanTracType == cForteScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || (vConfigurationData->vScanTracType == cCaseInspectorScanTrac))
			{
				if ((vGlobalGuardMaster) && (vGlobalGuardMaster->vDetectedValidGuardMasterDevice))
				{
					if ((vGlobalGuardMaster->vGuardMasterRawInterlockData & cFrontDoorMaskBits) == cFrontDoorMaskBits)
						TempText.LoadString(IDS_CabinetDoor);
					else
					if ((vGlobalGuardMaster->vGuardMasterRawInterlockData & cTubeCoverMaskBits) == cTubeCoverMaskBits)
						TempText.LoadString(IDS_DetectorDoor);
				}
				else
					TempText.LoadString(IDS_TopDoorOpen);
			}
			else
				TempText.LoadString(IDS_FrontorRearDoorOpen);
			ReportErrorMessage(TempText, cEMailMaintenance,14);
		}
		else
		if (vSystemData.vRedLampBrokenCounter > 9)
		{
			vSystemData.vOpenInterlock.LoadString(IDS_RedLight);
			TempText.LoadString(IDS_RedLightFilamentBroken);
			ReportErrorMessage(TempText, cEMailMaintenance,1);
		}
		else
		if ((!(vSystemData.vSourceInterLocks & 0x0001)))
		{
			vSystemData.vOpenInterlock.LoadString(IDS_RedLight);
			TempText.LoadString(IDS_RedLightFilamentBroken);
			ReportErrorMessage(TempText, cEMailMaintenance,1);
		}
		else
		if ((!(vSystemData.vSourceInterLocks & 0x0200)))
		{
			TempText.LoadString(IDS_EStop);
			vSystemData.vOpenInterlock = TempText;
			TempText.LoadString(IDS_EStopSwitchNotOn);
			ReportErrorMessage(TempText, cEMailMaintenance,16);//E-Stop Switch Not On
		}
		else
		if ((!(vSystemData.vSourceInterLocks & 0x0100)))
		{
			TempText.LoadString(IDS_KeySwitch);
			vSystemData.vOpenInterlock = TempText;
			TempText.LoadString(IDS_KeySwitchNotOn);
			ReportErrorMessage(TempText, cEMailMaintenance,15);//X-Ray Key Switch Not On
		}
		else
		if ((!(vSystemData.vSourceInterLocks & 0x0020)))
		{
			TempText.LoadString(IDS_HVPSInterlock);
			vSystemData.vOpenInterlock = TempText;
			TempText.LoadString(IDS_HighVoltagePowerSupplyInterlockNotOn);
			ReportErrorMessage(TempText, cEMailMaintenance,15);
			//ReportErrorMessage(TempText, cEMailInspx,15);
		}
		else //downstream
		if ((!vSystemData.vDownStreamSignalSaysConveyorOn) && (vConfigurationData->vUseDownStreamSignalThatStopsConveyor == cUseDownStream))
		{
			CString TempString = " ";
			TempText.LoadString(IDS_DownStream);
			vShowuControllerStatusInRed = true;
		}
		else
			ReportErrorMessage("Open Interlock.  Code: " + WordToHex(vSystemData.vSourceInterLocks), cCritical, 0);
		return false;  //if the interlocks are not OK, then don't start up
	}
}

void CScanTracDlg::StartRunning(bool TempTurnOnSource, bool TempNormalRunning) //only used from Diagnostics, Run button
{
	ClearValveMonitoringFIFO();
	ResetValveMonitoringData();
	vSystemData.vDisplayingAnEncoderError = false;
	vSystemData.vGaveEncoderErrorThisRun = false;
  if (vGlobalCurrentProduct == NULL)
	{
		CString TempText = " ";
		TempText.LoadString(IDS_Youmustselectaproductbeforeyoucanrunthesystem);  

		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = TempText;
		TempNoticeDialog.vType = cErrorMessage;
		TempNoticeDialog.DoModal();
	}
	else
	if (PowerWiringOK())
	if (vSystemData.vSystemRunMode == cStoppedSystemMode)
	if (vGlobalImageAquisitionThread)
	{
		//for TD
		vSystemData.vSecondsMeasuringRealConveyorEncoder = 0;
		vSystemData.vRealConveyorEncoderPulsesCount = 0;
		if (!vConfigurationData->vUseRealEncoder)
		if ((!vSystemData.vFPGASimulateEncoderRate) && (!vConfigurationData->vContinuousFeedEncoderRate))
			vSystemData.vRealConveyorEncoderPulsesCount = 1;
		//if (vGlobalMonoBlockXRayPort)
		//	vGlobalMonoBlockXRayPort->TurnOnXRayWatchDog();

		if ((PrepareToRun()) || (!TempTurnOnSource))
		if ((vSystemData.vXRayOnNotice) || (IfTubeHasBeenOffLongEnough()) || (!TempTurnOnSource))
		{
			{
				if (TempTurnOnSource)
				{
					ResetFPGAABFrameCounters();
				}
				if (vSystemData.vInAutoSetup)
					vSystemData.vSystemRunMode = cAutoSetupRunningSystem;
				else
					vSystemData.vSystemRunMode = cRunningSystemMode;

				//turn x-rays on unless already on from autosetup just changing parameters
				if (TempTurnOnSource)
				{
					TempText.LoadString(IDS_XRAY);
					vSystemData.vXRayState = 25;
					::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,25,0); //turn X-Rays On
					ReportErrorMessage("X-Rays Starting Up Step: 25a", cWriteToLog, 0);
					m_Calibrating.ShowWindow(SW_SHOW);
					if (InterlocksOK())
						SendXRayPowerOnOffToUController(1);
				}
				else  //if source already on, enable body triggers.
				{
					StartImageAcquisition();
					if (vSystemData.vLastXRayCommandOn)
					{
						vSystemData.vXRayState = 26;
						::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,26,0); //activate triggers
						ReportErrorMessage("X-Rays Starting Up Step: 26a", cWriteToLog, 0);
					}
				}

				//set time since last container past trigger so will only
				//generate a production stop if get a container to zero it
				//then don't get a container for the time period
				vSystemData.vSecondsSinceLastContainer = vSystemData.vWorkStopTimePeriod + 1;
				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Exit StartRunning ScanTracDlg",cDebugMessage);

				if (vConfigurationData->vReCalibrateAfterStopTimePeriod)
				{
					int TimerResult = SetTimer(vReCalibrateOffsetTimerHandle,900000,NULL); //15 minutes
					if (!TimerResult)
						ReportErrorMessage("Error-Recalibrate Offset Timer Failed",cEMailInspx,32000);
					vSystemData.vReCalibrationTimerRunning = true;
				}
				SetDlgItemText(IDC_DensityCompensation, _T("Corr: 0"));
				SetDlgItemText(IDC_ThresholdIncrease, _T("Delta Bright: 0"));
				//SetDlgItemText(IDC_ThresholdReduction, "Delta Thresh: 0");
				ShowOrHideProductDensityCompensation();

				CSocketMessage TempMessage;
				TempMessage.vMessageFormat = 3;
				TempMessage.vMessageCommand = cSocketChangedStatusMessage;
				TempMessage.vMessageDWordArray[0] = 0;
				TempMessage.vMessageText = "Start Inspecting";
				SendSocketAMessageFromServerToClients(&TempMessage);
#ifdef CompileInHTTPClientOperationsGuardian
		if (vConfigurationData->vEnableEjectors)
			SendOGInfo(std::wstring(L"ejectorstatus"), "Enabled", false);
		else
			SendOGInfo(std::wstring(L"ejectorstatus"), "Disabled", false);
#endif
			}
		}
	}
	SetInterlockStatus();
	UpdateClearYellowMessageButton();
	UpdateRunButton();
}

void CScanTracDlg::SetupExternalDetectors() 
{
	vSystemData.vSampleEjectNextContainerBitMap = 0;
	vSystemData.vLastExternalDetectorUsed = 0;

	vSystemData.vCurrentExternalDetectorMask = 0;
	vSystemData.vCurrentAlwaysOnExternalDetectorMask = 0;
	vSystemData.vCurrentExternalDetectorActiveLowMask = 0;
	vSystemData.vDoingBackupDetection = false;

	vSystemData.vNumberOfAuxiliaryDetectorsConfigured = 0;
	for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
	{
		if (vConfigurationData->vExternalDetector[TempLoop].vEnabled)
		if (vConfigurationData->vExternalDetector[TempLoop].vLineBitMask > 0)
			vSystemData.vNumberOfAuxiliaryDetectorsConfigured++;
	}
	vSystemData.vNumberOfContainerTriggersConfigured = 0;
	for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
	{
		if (vConfigurationData->vBodyTrigger[TempLoop].vEnabled)
		if (vConfigurationData->vBodyTrigger[TempLoop].vLineBitMask > 0)
			vSystemData.vNumberOfContainerTriggersConfigured++;
	}

	if (vGlobalCurrentProduct)
	{
		vGlobalCurrentProduct->CalculateEndOfLineTimeOut();

		for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
		{
			if (vConfigurationData->vExternalDetector[TempLoop].vEnabled)
			{
				if (vGlobalCurrentProduct->vExternalDetectorEnable[TempLoop])
				if (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] > cExternalDetectorDisabledMode)
				{
					if (vConfigurationData->vExternalDetector[TempLoop].vLineBitMask > 0)
					{
						if (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cBackupDetectorMode)
							vSystemData.vDoingBackupDetection = true;
						else
							vSystemData.vLastExternalDetectorUsed = TempLoop + 1;

						vSystemData.vCurrentExternalDetectorMask = vSystemData.vCurrentExternalDetectorMask | vConfigurationData->vExternalDetector[TempLoop].vLineBitMask;

						//do not need to enable mask bit if Auxiliary detector mode 1 to 4.
						if ((vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cBackupDetectorMode) || (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cValveMonitorIndexPulseInput) || 
							(vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cSeamerIndexPulseInput) || (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cSeamerObjectPulseInput) || 
							(vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cSeamerPocketPulseInput) || (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cSampleEjectNextContainerMode))
							vSystemData.vCurrentAlwaysOnExternalDetectorMask = vSystemData.vCurrentAlwaysOnExternalDetectorMask | vConfigurationData->vExternalDetector[TempLoop].vLineBitMask;

						if (!vConfigurationData->vExternalDetector[TempLoop].vActiveHigh)
							vSystemData.vCurrentExternalDetectorActiveLowMask = vSystemData.vCurrentExternalDetectorActiveLowMask | vConfigurationData->vExternalDetector[TempLoop].vLineBitMask;
						if (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cSampleEjectNextContainerMode)
						{
							vSystemData.vSampleEjectNextContainerBitMap = vConfigurationData->vExternalDetector[TempLoop].vLineBitMask;

							if (vConfigurationData->vNumberOfHeadsToMonitor[cRandomSamplingType] == 0) //if don't have random sampling configured, then set staggered sampling to false
								vConfigurationData->vStaggerSampling = false;

							vSystemData.vSamplingAuxiliaryDetector[cRandomSamplingType] = TempLoop;  //save which auxiliary detector is used for Random Sampling
						}
					}
				}
			}
		}

		//figure out which eject confirmers mask bits to set
		vSystemData.vEjectConfirmerUsed = false;
		for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
		{
			vGlobalEjectorConfirmMask[TempLoop] = 0;
			vSystemData.vEjectConfirmerActive[TempLoop] = 0; //if eject confirmer active more than 5 seconds that eject tray must be full as sensor is blocked
			// remove so same eject confirmer sensor can be used for multiple ejectors if (vSystemData.vEjectorUsed & (1 << TempLoop))
			if (vConfigurationData->vEjector[TempLoop].vConfirmEnabled)
			{
				vSystemData.vEjectConfirmerUsed = true;
				vSystemData.vCurrentExternalDetectorMask = vSystemData.vCurrentExternalDetectorMask | vConfigurationData->vEjector[TempLoop].vConfirmLineBitMask;

				vSystemData.vCurrentAlwaysOnExternalDetectorMask = vSystemData.vCurrentAlwaysOnExternalDetectorMask | vConfigurationData->vEjector[TempLoop].vConfirmLineBitMask;

				if (!vConfigurationData->vEjector[TempLoop].vConfirmActiveHigh)
					vSystemData.vCurrentExternalDetectorActiveLowMask = vSystemData.vCurrentExternalDetectorActiveLowMask | vConfigurationData->vEjector[TempLoop].vConfirmLineBitMask;

				vGlobalEjectorConfirmMask[TempLoop] = vConfigurationData->vEjector[TempLoop].vConfirmLineBitMask;
			}
		}
		//Send Interrupt Mask
		tSerialCommand TempCommand;
		TempCommand[0] = 0x1C;
		//Don't enable encoder interrupt
		TempCommand[1] = 0x02;  //send mask for 16 digital lines in #2
		TempCommand[2] = 0x00;
		if (vSystemData.vKeepExternalDetectorsEnabled)
			TempCommand[3] = vSystemData.vCurrentAlwaysOnExternalDetectorMask;
		else
			TempCommand[3] = vSystemData.vCurrentExternalDetectorMask;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);
	}
}

void CScanTracDlg::StopRunning(bool TempTurnOffSource) 
{
	vSystemData.vCheckWeighOffsetCalibrationNeeded = false;
	for (BYTE TempLoop = 0; TempLoop < cNumberOfFillerOffsetSpeeds; TempLoop++)
		vSystemData.vFindFillerOffset[TempLoop] = false;

	vSystemData.vRunningDiagnosticsMode = false;
	if (vSystemData.vInterlock200mSecChangeCount)
		ReportErrorMessage("Interlock Changed Less Than 200mSec this run count: " + dtoa(vSystemData.vInterlock200mSecChangeCount,0), cWriteToLog, 0);

	for (BYTE TempLoop = 0; TempLoop < 3; TempLoop++)
	{
		vSystemData.vSamplingNowWhichHeadToSample[TempLoop] = 0;
		vSystemData.vSamplingNowNumberOfSamplesToTakeFromSeries[TempLoop] = 0;
		vSystemData.vSamplingNowNumberOfSamplesToTakeFromSameHead[TempLoop] = 0;
	}

	vSystemData.vPipeIsEmpty = 0;

	vSystemData.vSmallestDifferenceBetweenAverageAndMinimum = 255;
	vSystemData.vPipeBrightnessCount = 0;
	vSystemData.vAirBubblesInPipe = 0;
	vSystemData.vOldAirBubblesInPipe = 0;
	vShowingPipeEmpty = false;
	vShowingAirInPipe = false;

	if (vSystemData.vLogFile.vLogSerialData)
	{
		if (TempTurnOffSource)
			vSystemData.vLogFile.WriteToLogFile("StopRunning ScanTracDlg, Turned Source Off",cDebugMessage);
		else
			vSystemData.vLogFile.WriteToLogFile("StopRunning ScanTracDlg, Left Source On",cDebugMessage);
	}
	if (vSystemData.vReCalibrationTimerRunning)
	if (!vSystemData.vAutoCalibrateWhileRunning)
	{
		KillTimer(vReCalibrateOffsetTimerHandle);
		vSystemData.vReCalibrationTimerRunning = false;
	}
	//	if ((!vStartingUpSource) && ((!vSystemData.vXRayOnNotice) ||
	vSystemData.vAdjustingBrightnessBeforeLearning = false;
	vOldAdjustingBrightnessBeforeLearning = false;
	vSystemData.vWaitingForImage = 0;
	vSystemData.vTimesRetried = 0;
	vSystemData.vSecondsSinceLastContainer = 60;
	vTriggerIndicatorCount = 0;
	vCPMNotRunning = 0;
	//vOldTriggerIndicatorValue = !vTriggerIndicatorValue;//force a screen update
	vSystemData.vShuttingDownXRays = true;
	vSystemData.vRampXRayStep = 0;
	m_DensityLockTooFarOff.ShowWindow(SW_HIDE);
	m_DensityNotLockedIndicator.ShowWindow(SW_HIDE);
	vSystemData.vContainerRate = 0;
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter StopRunning ScanTracDlg",cDebugMessage);
	//not in release 2/18/2005
	vSystemData.vCheckConveyor = false;
	KillTimer(vConveyorStartTimerHandle);
	KillTimer(vTurnDiverterOnTimerHandle);
	KillTimer(vTurnDiverterOffTimerHandle);
	KillTimer(vSourceStabilizeTimerHandle);
	KillTimer(vRampXRayTimerHandle);
	KillTimer(vWaitForScreenUpdateTimerHandle);
	KillTimer(vSimulateOneContainerTimer);
	vWaitForScreenUpdate = false;
	m_SubFunction1Button.ShowWindow(SW_HIDE);
	this->InvalidateRect(&m_SubFunction1Button.GetRectToInvalidateArrow());
	SetDlgItemText(IDC_DensityCompensation, _T("Corr: 0"));
	SetDlgItemText(IDC_ThresholdIncrease, _T("Delta Bright: 0"));
	//SetDlgItemText(IDC_ThresholdReduction, "Delta Thresh: 0");
	if (vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode)
	{
		m_Calibrating.ShowWindow(SW_HIDE);
		if (!vSystemData.vXRayOnNotice)
			m_XRaysOn.ShowWindow(SW_HIDE);
	}

	if (!vSystemData.vInAutoSetup)
	if ((vSystemData.vITIPCDig->vAverageEnabled) || (vSystemData.vITIPCDig->vStructureEnabled) ||
		(vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled))
	{
		vSystemData.vITIPCDig->RestoreLearnFilesFromBackups(vGlobalCurrentProduct);
		ReportErrorMessage("Abort Re-learn Container Image", cUserChanges,0);
		vSystemData.vITIPCDig->vAverageEnabled = false;
		vSystemData.vITIPCDig->vStructureEnabled = false;
		vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled = false;
	}
	if (vSystemData.vTakingQuickLearnImages)
	{
		vSystemData.vTakingQuickLearnImages = false;
		vSystemData.vQuickLearnImageIndex = 0;
		for (WORD TempLoop = 0; TempLoop < cMaximumQuickLearnImages; TempLoop++)
		{
			if (vSystemData.vQuickLearnImages[TempLoop])
			{
				free(vSystemData.vQuickLearnImages[TempLoop]);
				vSystemData.vQuickLearnImages[TempLoop] = NULL;
			}
			if (vSystemData.vQuickLearnWorkingImages[TempLoop])
			{
				free(vSystemData.vQuickLearnWorkingImages[TempLoop]);
				vSystemData.vQuickLearnWorkingImages[TempLoop] = NULL;
			}
		}
	}
	//if you were learning, delete the accumulation images
	if (vSystemData.vITIPCDig->vStructureImage != NULL)
	{
		delete vSystemData.vITIPCDig->vStructureImage;
		vSystemData.vITIPCDig->vStructureImage = NULL;
	}
	if (vSystemData.vITIPCDig->vContaminant2StructureImage != NULL)
	{
		delete vSystemData.vITIPCDig->vContaminant2StructureImage;
		vSystemData.vITIPCDig->vContaminant2StructureImage = NULL;
	}
		if (vSystemData.vITIPCDig->vAverageImage != NULL)
		{
			free(vSystemData.vITIPCDig->vAverageImage);
			vSystemData.vITIPCDig->vAverageImage = NULL;
	}

	if (vSystemData.vSystemRunMode == cMeasureSourceStrengthMode)
	{
		EndMeasureSourceStrength(true);
	}
	else
	if (vSystemData.vSystemRunMode == cTestShutterMode)
		EndTestShutter(true);
	else
	if (vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode)
		EndCalibrateDetectorEdges(true);
	else
	if (vSystemData.vSystemRunMode == cCalibratingDetectorGainMode)
		EndCalibrateDetectorGain(true);
	else
	if (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode)
	{
		vStopRunningTimerActive = true;
		int TempTimerResult = SetTimer(vStopRunningTimerHandle,1000,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-Stop Running Timer Failed",cEMailInspx,32000);

		if (vSystemData.vCalibrateUsingDAC)
			EndCalibrateDACDetectorOffset(true);
		else
			EndCalibrateADCDetectorOffset(true);
	}
	else
	{
		ReportErrorMessage("Stop Inspecting: " + vSystemData.vFrameCountString, cAction,0);
		if (vSystemData.vSystemRunMode == cConditionXRayTubeMode)
		{
			if (vGlobalDXMXRayPort)
			{
				//vGlobalDXMXRayPort->SetXRayFilamentLimit(1);//vSystemData.vDXMFilamentLimit);// 1 = full scale, or 4.6Amp limit
				//vGlobalDXMXRayPort->SetXRayFilamentPreHeat(.2);//.2 = .5 Amp Preheat


				if ((vConfigurationData->vScanTracType == cPiccoloScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac)) //MNX-piccolo is command 99, DXM is command 98
					vGlobalDXMXRayPort->SetXRayFilamentLimit(3.3 / 10);// 3.3 Amp out of 3.5 Amp limit MNX, (protocol range is to 10 Volts = 10 Amps)
				else
					vGlobalDXMXRayPort->SetXRayFilamentLimit(1); //vSystemData.vDXMFilamentLimit);// 1 = full scale, or 4.6Amp limit DXM, 

				if ((vConfigurationData->vScanTracType == cPiccoloScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac)) 
					//MNX-piccolo is command 99, DXM is command 98 on 50 watt systems
					vGlobalDXMXRayPort->SetXRayFilamentPreHeat(1.0 / 10);//MNX = 1 Amp out of 2.5 Amp Preheat (protocol range is to 10 Volts = 10 Amps)
				else
					vGlobalDXMXRayPort->SetXRayFilamentPreHeat(0.5 / 2.5);//DXM = .2 = .5 Amp Preheat out of 2.5 Amp


				//Per Warrkhoff Suggestion 4/20/2006
				//vGlobalDXMXRayPort->SetXRayFilamentPreHeat(1);//1 = 2.5 Amp Preheat
			}

			ReportErrorMessage("Stopped X-Ray Tube " + vSystemData.vConditionString +
				" Step " + dtoa(vSystemData.vXRayTubeConditionCurrentStep + 1,0) + 
				" Voltage: " + dtoa(vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep]) + 
				" Current: " + dtoa(vSystemData.vXRayTubeConditionCurrentTable[vSystemData.vXRayTubeConditionCurrentStep]), cAction,0);

			SetDlgItemText(IDC_ContainersPerMinute, _T("Stopped"));
			MakeProductionReportIfNeeded();
			ResetCounters();
			SetupProduct(vGlobalCurrentProduct, false);
		}
		TurnSimulatedContainersOff();
		StopImageAcquisition();

		if (TempTurnOffSource)
		{
			SendConveyorOnOffToUController(0);
			ReportErrorMessage("Turn off conveyor",cWriteToLog,0);
			SetFastestSimulatedEncoder(1); //run simulated conveyor to complete any images
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("High Speed simulated encoder",cDebugMessage);
		}

		vTurnOffSourceWhenStopRunning = TempTurnOffSource;
		FinishStopRunning(TempTurnOffSource);

		if (vSystemData.vSimulatingCamLinkImage)
			TurnOnOffCamLinkTestImages(false);

		if (vSystemData.vITIPCDig->vCaptureModule)
			vSystemData.vITIPCDig->vCaptureModule->ClearFrameBuffer();
	}
	if (vSystemData.vLogFile.vLogSerialData)
	{
		if (TempTurnOffSource)
			vSystemData.vLogFile.WriteToLogFile("Exit StopRunning ScanTracDlg, Turned Source Off",cDebugMessage);
		else
			vSystemData.vLogFile.WriteToLogFile("Exit StopRunning ScanTracDlg, Left Source On",cDebugMessage);
	}
	if (TempTurnOffSource)
	{
		int TimerResult = SetTimer(vTriggerIndicatorTimerHandle,10,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-Trigger Indicator Timer Failed",cEMailInspx,32000);
	}
	vRunButtonPressedLastNotStop = false;
	UpdateRunButton();

	vSystemData.vCPMDataIndexNotRunning = 0;
	vCPMNotRunning = 0;
	for (WORD TempLoop = 0; TempLoop < vConfigurationData->vCPMTimePeriod; TempLoop++)
		vSystemData.vCPMDataNotRunning[TempLoop] = 0;

	CSocketMessage TempMessage;
	TempMessage.vMessageFormat = 3;
	TempMessage.vMessageCommand = cSocketChangedStatusMessage;
	TempMessage.vMessageDWordArray[0] = 1;
	TempMessage.vMessageText = "Stop Inspecting";
	SendSocketAMessageFromServerToClients(&TempMessage);

	if (vBackupHardDisk)
		StartCopyAllScanTracFoldersToBackupHardDrive();

	if (vGlobalDXMXRayPort)
	{
		vGlobalDXMXRayPort->vFilamentCurrentMin = 9999999;
		vGlobalDXMXRayPort->vFilamentCurrentMax = 0;
	}

	//if (TempRestoreGainsAtEnd)
	//{
	//	SendADCGainsAndOffsets(false);
	//	RestoreOriginalProduct();
	//}

	//9/3/2009
	if (((!vConfigurationData->vContinuousFeedContainerRate) && (!vConfigurationData->vBulkProductMode) && ((vGlobalCurrentProduct) && (!vGlobalCurrentProduct->vBulkProductMode))) || //not Continuous Feed, or a Pipeline
		(vSystemData.vSystemRunMode == cConditionXRayTubeMode))
		m_ContainersPerMinuteControl.ShowWindow(SW_SHOW);
	else
		m_ContainersPerMinuteControl.ShowWindow(SW_HIDE); //hide on pipe lines if not burning in or conditioning a tube

	ShowOrHideProductDensityCompensation();

	double TempHardDriveSpaceFree = CheckDiskSpaceFree("C:\\"); //	double vGlobalHardDriveTotalBytes set in function call
	if (TempHardDriveSpaceFree < 1000000000) // if less than a gig free, verify auto delete enabled and set if not
	{
		if ((vConfigurationData->vAutoDeleteFileTypes & 0x013) != 0x13)
			vConfigurationData->vAutoDeleteFileTypes = vConfigurationData->vAutoDeleteFileTypes | 0x013;
		if ((vConfigurationData->vNumberOfDaysToKeepLogs < 2) || (vConfigurationData->vNumberOfDaysToKeepLogs > 100))
			vConfigurationData->vNumberOfDaysToKeepLogs = 60;
	}

	int TempTimerResult = SetTimer(vCheckHardDrivesTimerHandle,1000,NULL);
	if (!TempTimerResult)
		ReportErrorMessage("Error-Check Hard Drives Timer Failed",cEMailInspx,32000);
	SetInterlockStatus();

	//check for any diverters active as must deactivate
		//if fpga version high enough
	{
		//for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors - 1; TempLoop++)
		for (BYTE TempLoop = 0; TempLoop < 1; TempLoop++)
		if (vSystemData.vDiverterActive[TempLoop])
		{
			vSystemData.vDiverterActive[TempLoop] = false;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendEjectorOnOffCommand(TempLoop + 2, 0); 
			ReportErrorMessage("De-activate Diverter: " + dtoa(TempLoop + 2, 0) + " now because Stopped Inspecting", cAction, 0);
		}
	}
}

void CScanTracDlg::FinishStopRunning(bool TempTurnOffSource)
{
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter FinishStopRunning ScanTracDlg",cDebugMessage);
	vSystemData.vDigitalInputLine3Mask = 0x00;
	vSystemData.vCurrentBodyTriggerMask = 0;
	vSystemData.vSystemRunMode = cStoppedSystemMode;
	if (vTurnOffSourceWhenStopRunning)
		SendXRayPowerOnOffToUController(0);
	RemoveAllContainers();
	KillTimer(vGoodCountTimerHandle);
	KillTimer(vEjectCountTimerHandle);
	KillTimer(vBeltPositionTimerHandle);

	if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
	{
		vSystemData.vLastContainerImaged = NULL;
		//vSystemData.vContainerBeingImaged = NULL;
		vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();
	}

	vSystemData.vTimeSinceLastStop = 0;
	if (vSystemData.vCountTimeAsRunning)
	{
		vSystemData.vProductionStopsCount++;
		vSystemData.vCountTimeAsRunning = false;
		ShowCPM();
	}
	vSystemData.vSimulating = false;
	if (TempTurnOffSource)
	{
		if (vSystemData.vModeToRunAfterCalibrateOffset == 0)
			m_Calibrating.ShowWindow(SW_HIDE);

		vSystemData.vXRayState = 0;
		::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,0,0); //turn x-Rays off
		ReportErrorMessage("X-Rays Starting Up Step: 0a", cWriteToLog, 0);
	}
	else
	{
		CString TempText = " ";
		TempText.LoadString(IDS_XRayStart);
		SetDlgItemText(IDC_Calibrating,TempText);
		vSystemData.vXRayState = 25;
		::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,25,0); //stopped running but left X-Rays on
		ReportErrorMessage("X-Rays Starting Up Step: 25b", cWriteToLog, 0);
	}
	if (TempTurnOffSource)
	{
		//if not in middle of image turn everything off, else wait
		if ((vSystemData.vContainerCollection->GetCount() == 0) &&
			(vSystemData.vActualEncoderRate == 0))
		{
			ReportErrorMessage("Stop Conveyor, turn off simulated encoder",cWriteToLog,0);
			SendConveyorOnOffToUController(0);
			TurnSimulatedEncoderOff();
		}
		else
		{
			WORD TempTime = 2000;
			//give time for the containers on the Conveyor in the tunnel to get processed.
			//if (vSystemData.vBeltRate)
			//	TempTime = (WORD)(((double)vGlobalCurrentProduct->vEndOfLineBeltPosition * 
			//	vGlobalCurrentProduct->vOverScanMultiplier) / 
			//	((double)vSystemData.vBeltRate) * 1000.0);
			ReportErrorMessage("Wait 2 seconds to stop simulated encoder",cWriteToLog,0);

			vStopRunningTimerActive = true;
			int TempTimerResult = SetTimer(vStopRunningTimerHandle,TempTime,NULL);
			if (!TempTimerResult)
				ReportErrorMessage("Error-Stop Running Timer Failed",cEMailInspx,32000);
		}
	}

	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("End FinishStopRunning ScanTracDlg",cDebugMessage);
}

void CScanTracDlg::TurnOnOffFPGASimulatedData(bool TempOn)
{
	//Use real image data if false
	tSerialCommand TempCommand;
	TempCommand[0] = 0x37;
	if (TempOn)
	{
		TempCommand[1] = 0x01;
		vSystemData.vFPGAGeneratingSimulatedData = true;
	}
	else
	{
		TempCommand[1] = 0x02;
		vSystemData.vFPGAGeneratingSimulatedData = false;
	}
	TempCommand[2] = 0x00;
	TempCommand[3] = 0x00;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);
}


void CScanTracDlg::AskIfShouldResetCounters(bool TempChangedProduct, BYTE TempFrom)
{
	if (vSystemData.vTotalContainers > 0)
	{
		//Pressed Reset Counts Button
		CYesNoDialog TempYesNoDialog;
		//CString TempString("\n\nReset all counters?");

		CString TempText = " ";
		CString TempText1 = " ";
		TempText.LoadString(IDS_ResetAllCounters);//\n\nReset All Counters?

		if ((vSystemData.vSystemRunMode == cRunningSystemMode) ||
			(vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
		{
			//TempString = "\nSystem Running!\n\nReset all counters?";
			TempText.LoadString(IDS_SystemRunningResetAllCounters);
		}
		if (TempChangedProduct)
		{
			//TempString = "\n\nLoaded Product Setup - Reset all counters?";
			TempText.LoadString(IDS_LoadedProductSetupResetallcounters);
		}

		TempText1.LoadString(IDS_ResetCounters);
		TempYesNoDialog.vNoticeText = TempText;
		TempYesNoDialog.vQuestionType = cConfirmQuestion;
		TempYesNoDialog.vYesButtonText = TempText1;
		int TempResult = TempYesNoDialog.DoModal();
		//if user said OK, or not copying (must be editing) product
		//remove old product
		if (TempResult == IDOK)
		{
			GenerateProductionReport(TempFrom);
			ReportErrorMessage("Operator Reset Counters. Total counts: " + dtoa(vSystemData.vRejectCountTotal + vSystemData.vGoodCountTotal, 0) + " Product: " + vSystemData.vCurrentProductName, cUserChanges,0);
			ResetCounters();
			SendProductionReport(TempFrom);
		}
	}
	else
	{
		if (!vDisplayingVersion)
		if (!vWaitForScreenUpdate)
		{
			int TimerResult = SetTimer(vWaitForScreenUpdateTimerHandle,10,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Screen Timer Failed",cEMailInspx,32000);
			vWaitForScreenUpdate = true;
		}
	}
}

void CScanTracDlg::ResetCounters()
{
#ifdef CompileInHTTPClientOperationsGuardian
	vGlobalOGSendMessageexceptionCount = 0;
	vGlobalOGSendMessageErrorCount = 0;
	vGlobalOGSendMessageGoodCount = 0;
	vGlobalLastOGServerWriteStatusCode = -4;
	vOldLastOGServerWriteStatusCode = -4;
#endif
	//write rejects to Hard Disk
	for (WORD TempLoop = 0; TempLoop < cNumberOfRejectImageBuffers; TempLoop++)
	{
		vSystemData.vRejectImageBuffer[TempLoop].vLogThisReject = false;
		vSystemData.vRejectImageBuffer[TempLoop].vEjectorsDisabled = false;
		vSystemData.vRejectImageBuffer[TempLoop].vContainerEjectInspection = 255;
		vSystemData.vRejectImageBuffer[TempLoop].vTime = 0;
		vSystemData.vRejectImageBuffer[TempLoop].vGreyImage = NULL;
		
		vSystemData.vRejectImageBuffer[TempLoop].vRedBoxCornerX = 0;
		vSystemData.vRejectImageBuffer[TempLoop].vRedBoxCornerY = 0;
		vSystemData.vRejectImageBuffer[TempLoop].vRedBoxWidth = 0;
		vSystemData.vRejectImageBuffer[TempLoop].vRedBoxHeight = 0;
	}
	vSystemData.vNextRejectToWrite = 0;
	vSystemData.vNextRejectToSave = 0;

	vSystemData.vLastEjectTime = "";
	vSystemData.vRunStartTime = "--";
	if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
	{//if a pipeline put in when the last eject occured
		SetDlgItemText(IDC_PercentRejected,	vSystemData.vLastEjectTime);
	}

	for (WORD TempLoop = 0; TempLoop < cMaximumBodyTriggerWidthData; TempLoop++)
		vSystemData.vBodyTriggerWidthData[TempLoop] = 0;
	vSystemData.vLastBodyTriggerLength = 0;
	vSystemData.vBodyTriggerWidthStandardDeviation = 0;
	vSystemData.vBodyTriggerWidthAverage = 0;
	vSystemData.vBodyTriggerWidthIndex = 0;
	vSystemData.vBodyTriggerWidthSamples = 0;

	if (vSystemData.vITIPCDig->vMainImagePseudoColorDisplayBuffer)
		FillMemory(vSystemData.vITIPCDig->vMainImagePseudoColorDisplayBuffer,vSystemData.vITIPCDig->vMainDisplayImageSize, 255);

	if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu)
		vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjected = false;

	if (vSystemData.vITIPCDig->vOriginalImage)
		vSystemData.vITIPCDig->vOriginalImage->vTop = 0;

	if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu)
		vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vTop = 0;

	vGlobalGaveMemoryError = 0;
	SaveReportStartTime();

	if (vSystemData.vITIPCDig->vOriginalImage)
		vSystemData.vITIPCDig->vOriginalImage->vTop = 0;

	if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu)
		vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vTop = 0;
	
	vTriggerIndicatorCount = 0;
	vCPMNotRunning = 0;
	/*
	if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
	{
		//remove all the containers so you don't count them if cleared the image for them
		if (vSystemData.vContainerCollection->GetCount() > 0)
		{
			CContainer *TempContainer = vSystemData.vContainerCollection->GetHead();
			//Check Each Containter until get one before timeout
			while (TempContainer != NULL)
			{
				if (vSystemData.vLogFile.vLogSerialData)
				{
					CString TempString(dtoa(TempContainer->vContainerNumber, 0));

					vSystemData.vLogFile.WriteToLogFile("ScanTracDlg:StopRunning-RemoveAllContainers:" + 
						TempString,cDebugMessage);
				}
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->RemoveContainerFromCollection();
				//get next container to check
				if (vSystemData.vContainerCollection->GetCount() > 0)
					TempContainer = vSystemData.vContainerCollection->GetHead();
				else
					TempContainer = NULL;
			}  // while not done
		}  //end if have containers
		vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();
	}
	*/

	vSystemData.vITIPCDig->vHaveImage = false;
	vSystemData.vITIPCDig->vContainerWidthMaximum = 0;
	vSystemData.vITIPCDig->vContainerWidthMinimum = 0;
	vSystemData.vITIPCDig->vContainerWidthAverage = 0;
	vSystemData.vITIPCDig->vContainerWidthStandardDeviation = 0;
	vSystemData.vITIPCDig->vContainerWidthIndex = 0;
	vSystemData.vITIPCDig->vContainerWidthSamples = 0;

	vSystemData.vImageProcessingTimeMaximum = 0;
	vSystemData.vImageProcessingTimeMinimum = 0;
	vSystemData.vImageProcessingTimeAverage = 0;
	vSystemData.vImageProcessingTimeStandardDeviation = 0;
	vSystemData.vImageProcessingTimeIndex = 0;
	vSystemData.vImageProcessingTimeSamples = 0;
	for (WORD TempLoop = 0; TempLoop < cImageProcessingTimeMaximum; TempLoop++)
		vSystemData.vImageProcessingTimeData[TempLoop] = 0;

	vSystemData.vImageCounter = 0;
	vSystemData.vTriggerCounter = 0;
	vSystemData.vTriggerEndCounter = 0;
	//vSystemData.vStartImageCounter = 0;
	//vSystemData.vEndImageCounter = 0;
	vSystemData.vProcessImageCounter = 0;
	vSystemData.vFreeTimeMaximum = 0;
	vSystemData.vFreeTimeMinimum = 0;
	vSystemData.vFreeTimeAverage = 0;
	vSystemData.vFreeTimeStandardDeviation = 0;
	vSystemData.vFreeTimeIndex = 0;
	vSystemData.vFreeTimeSamples = 0;

	SetDlgItemText(IDC_RejectReason, _T(""));
	vMainImageRejectReason = 255;
	vMainImageWeight = "";
	vMainImageRejectDisable = false;
	vMainImageLane = 0;
	//vMainImageImproveLearn = false;
	vMainImageRejected = false;
	vSystemData.vMaximumExternalDetectorTime = 0;

	vSystemData.vEjectCountTotal = 0;
	vSystemData.vRejectCountTotal = 0;
	vSystemData.vOldRejectCountTotal = 0;
	vSystemData.vGoodCountTotal = 0;
	vSystemData.vGoodCountInBufferTotal = 0;
	vSystemData.vRealImageCountTotal = 0;
	for (WORD TempLoop = 0; TempLoop < cMaximumNumberOfCountsDisplayed; TempLoop++)
	{
		vSystemData.vXRayCriteriaCount[TempLoop] = 0;
		vSystemData.vXRayCriteriaCountTotal[TempLoop] = 0;
		vSystemData.vXRayCriteriaCountButDisabled[TempLoop] = 0;
		vSystemData.vOldXRayCriteriaCountButDisabled[TempLoop] = 0;
	}
	vSystemData.vProductionStopsCount = 0;
	vSystemData.vStopDuration = 0;
	vSystemData.vTimeSinceLastStop = 0;
	vSystemData.vRunDuration = 0;
	if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
		SetDlgItemText(IDC_TotalContainers, _T(""));// if a pipe show blank if total zero
	vSystemData.vCheckWeighRunDuration = 0;
	vSystemData.vTotalDuration = 0;
	vSystemData.vShiftRateCPM = 0;
	vSystemData.vTotalContainers = 0;
	vSystemData.vImproveLearnTotalContainers = 0;
	vSystemData.vTotalConfirmed = 0;
	vSystemData.vTotalUnConfirmed = 0;
	for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
	{
		vSystemData.vEjectorCount[TempLoop] = 0;
		vSystemData.vEjectorConfirmCount[TempLoop] = 0;
	}
	vSystemData.vBodyTriggersCount = 0;
	vSystemData.vBackupBodyTriggersCount = 0;
	vSystemData.vValidBodyTriggersCount = 0;
	vSystemData.vBackupBodyTriggerVerifyFlag = 0;
	for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
	{
		vSystemData.vExternalDetectorCount[TempLoop] = 0;
	}
	vSystemData.vIncompleteDataCount = 0;
	vSystemData.vImageReferenceErrorCount = 0;
	vSystemData.vProcessingErrorCount = 0;
	vSystemData.vTooLateToEjectErrorCount = 0;
	vSystemData.vMissedEjectsBecauseDisabledCount = 0;
	vSystemData.vOldMissedEjectsBecauseDisabledCount = 0;
	m_TotalRejectsLabelStaticText.ShowWindow(SW_HIDE);
	m_TotalRejectsStaticText.ShowWindow(SW_HIDE);
	m_TotalRejectsPercent.ShowWindow(SW_HIDE);
	m_TotalRejectsPercentLabel.ShowWindow(SW_HIDE);
	vMainImageRejectReason = 255;
	vMainImageWeight = "";
	vMainImageRejected = false;
	if (!vSystemData.vITIPCDig->vMainDisplayIsDefaultImage)
	{
		if (vSystemData.vSystemRunMode != cStoppedSystemMode)
			vSystemData.vITIPCDig->vMainDisplayIsDefaultImage = true;
		vSystemData.vITIPCDig->FillMainDisplayBuffer();
	}
	if ((!vDisplayingVersion) )//&& (!vShowingProductSetupWaitBox))		
	if (!vWaitForScreenUpdate)
	{
		int TimerResult = SetTimer(vWaitForScreenUpdateTimerHandle,10,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-Screen Timer Failed",cEMailInspx,32000);
		vWaitForScreenUpdate = true;
	}
	vSystemData.vITIPCDig->InitializeLastRejectsBuffer(false);
	vSystemData.vFrameCount = 0;
	vSystemData.vFrameCountString = "0";

	vSystemData.vTooManyRejectsIndex[0] = 0;
	vSystemData.vTooManyRejectsIndex[1] = 0;
	for (WORD TempLoop = 0; TempLoop < cMaximumEjectDataSize; TempLoop++)
	{
		vSystemData.vContainerEjectData[TempLoop][0] = 0;
		vSystemData.vContainerEjectData[TempLoop][1] = 0;
	}
	vMainImageRejectReason = 255;
	vMainImageWeight = "";

	//vSystemData.vITIPCDig->DisposeOriginalBuffer();  //don't need to do when just clearing counters
	//vSystemData.vITIPCDig->MakeOriginalBuffer();

	vSystemData.vITIPCDig->ClearImproveLearn(true);
	vSystemData.vImproveLearnTotalContainers = 0;

	CSocketMessage TempMessage;
	TempMessage.vMessageFormat = 3;
	TempMessage.vMessageCommand = cSocketChangedStatusMessage;
	TempMessage.vMessageDWordArray[0] = 5;
	TempMessage.vMessageText = "Counters cleared";
	SendSocketAMessageFromServerToClients(&TempMessage);

	if (vGlobalCurrentProduct)
	{
		if (vGlobalCurrentProduct->vNumberOfInspections > cMaximumNumberOfInspections)
		{
			vGlobalCurrentProduct->vNumberOfInspections = cMaximumNumberOfInspections;
		}
		for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
		{
			if (!vGlobalCurrentProduct->vInspection[TempLoop]) //if inspection does not exist
			{
				vGlobalCurrentProduct->vNumberOfInspections = TempLoop; //reduce the inspection count
				TempLoop = cMaximumNumberOfInspections;									//and exit the loop
			}
			else
			if ((vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection) || (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection) ||
				(vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection))
			{
				CInspectionCheckWeigh *TempCheckWeighInspection = (CInspectionCheckWeigh *)vGlobalCurrentProduct->vInspection[TempLoop];
				TempCheckWeighInspection->ClearDataMemory(true);
			}
		}
	}
	for (BYTE TempLaneLoop = 0; TempLaneLoop < cMaximumNumberForMultiLane; TempLaneLoop++)
	{
		vSystemData.vMultiLaneTotalCounts[TempLaneLoop] = 0;
		vSystemData.vMultiLaneTotalEjectsCounts[TempLaneLoop] = 0;
		vSystemData.vMultiLaneTotalDisabledEjectsCounts[TempLaneLoop] = 0;

		for (BYTE TempLoopInspection = 0; TempLoopInspection < cMaximumNumberOfInspections; TempLoopInspection++)
		{
			vSystemData.vMultiLaneInspectionCounts[TempLaneLoop][TempLoopInspection] = 0;
			vSystemData.vMultiLaneInspectionDisabledCounts[TempLaneLoop][TempLoopInspection] = 0;
		}
	}


	if ((vSystemData.vSystemRunMode != cRunningSystemMode) && (vSystemData.vSystemRunMode != cAutoSetupRunningSystem))  //if counters cleared when not inspecting, stop check weigh run time
		vTrackingCheckWeighMinuteData = false;
	else
	if (vSystemData.vContainerRate)
	{
		vSystemData.vTimeStarted = CTime::GetCurrentTime();
		vSystemData.vRunStartTime = vSystemData.vTimeStarted.Format("%H:%M:%S   %d-%b-%y");
	}

	vSystemData.vWeightTrendingAlarm = false;
	ResetValveMonitoringData();
	SetInterlockStatus();
}

void CScanTracDlg::TerminateImageAquisitionThread()
{
	if (vGlobalImageAquisitionThread)
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Start to terminate Image Thread ScanTracDlg",cDebugMessage);
		vGlobalImageAquisitionThread->ExitImageAquisition();
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Wait for Image Thread to Close",cDebugMessage);

		bool TempTimeOut = false;
		double TempStartTime = CIFCOS::GetSystimeMillisecs();
		double TempEndTime = 0;
		while ((!TempTimeOut) && (vGlobalImageAquisitionThread))
		{
			Sleep(1);
			TempEndTime = CIFCOS::GetSystimeMillisecs();
			if (TempEndTime - TempStartTime > 10000)
				TempTimeOut = true;
		}
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Image Thread Closed",cDebugMessage);
		if (TempTimeOut)
		{
			if (vGlobalImageAquisitionThread)
			{
				vGlobalImageAquisitionThread->KillThread();

				vGlobalImageAquisitionThread = NULL;
			}
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Error - Abnormal Terminate Image Thread ScanTracDlg",cDebugMessage);
			if (!vSystemData.vYellowMessageButtonYellow)
				ReportErrorMessage("Error - Abnormal Terminate Image Thread ScanTracDlg",cWriteToLog,32000);
		}

		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Terminated Image Thread ScanTracDlg",cDebugMessage);
	}
}

void CScanTracDlg::SetupProduct(CProduct *TempProduct, bool TempLeaveSourceOn)
{
	vSystemData.vUseSamplingFIFO = false;
	vSystemData.vTimeSinceLastStop = 0;
	vGlobalEndOfLineTimeOutMargin = 8;

	CString TempNoticeText = "-";

	if (vSystemData.vTakingQuickLearnImages)
	{
		vSystemData.vTakingQuickLearnImages = false;
		vSystemData.vQuickLearnImageIndex = 0;
		for (WORD TempLoop = 0; TempLoop < cMaximumQuickLearnImages; TempLoop++)
		{
			if (vSystemData.vQuickLearnImages[TempLoop])
			{
				free(vSystemData.vQuickLearnImages[TempLoop]);
				vSystemData.vQuickLearnImages[TempLoop] = NULL;
			}
			if (vSystemData.vQuickLearnWorkingImages[TempLoop])
			{
				free(vSystemData.vQuickLearnWorkingImages[TempLoop]);
				vSystemData.vQuickLearnWorkingImages[TempLoop] = NULL;
			}
		}
	}
	//if you were learning, delete the accumulation images
	if (vSystemData.vITIPCDig->vStructureImage != NULL)
	{
		delete vSystemData.vITIPCDig->vStructureImage;
		vSystemData.vITIPCDig->vStructureImage = NULL;
	}
	if (vSystemData.vITIPCDig->vContaminant2StructureImage != NULL)
	{
		delete vSystemData.vITIPCDig->vContaminant2StructureImage;
		vSystemData.vITIPCDig->vContaminant2StructureImage = NULL;
	}
	if (vSystemData.vITIPCDig->vAverageImage != NULL)
	{
		free(vSystemData.vITIPCDig->vAverageImage);
		vSystemData.vITIPCDig->vAverageImage = NULL;
	}

	vSystemData.vDisplayingAnEncoderError = false;
	vSystemData.vGaveEncoderErrorThisRun = false;
	vSystemData.vCheckWeighOffsetCalibrationNeeded = false;
	vSystemData.vIncludeRejectsInAverageAndStructure = false;
	vSystemData.vITIPCDig->vAutoImproveStatisticsCountTo100 = 0;
	vSystemData.vITIPCDig->vAutoImproveStatisticsCountEjectedIn100 = 0;
	vSystemData.vITIPCDig->vAutoImproveStatisticsAddedToLearnCount = 0;
	vSystemData.vITIPCDig->vAutoImproveStatisticsCount = 0;

	if (TempProduct)
		ReportErrorMessage("Loaded Current Product: " + *TempProduct->GetProductName(), cAction,0);
	if (vSystemData.vHadErrorTryRestart)
		ReportErrorMessage("Start Loading Product after Calibrate Error", cWriteToLog, 0);

		//must be set to 6 or does not work.  can not set to 4
	//if ((vGlobalDXMXRayPort) && ((vConfigurationData->vScanTracType == cPiccoloScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac)))
		//50 watt systems only have 4 detectors
	//	vConfigurationData->vNumberOfXRayDetectors = 4;
	//else
	//	vConfigurationData->vNumberOfXRayDetectors = 6;

	//if ((vGlobalDXMXRayPort) && ((vConfigurationData->vScanTracType == cPiccoloScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac)))
		//50 watt systems only have 4 detectors
	//	vGlobalMaximumHeight = 8;
	//else
	//	vGlobalMaximumHeight = 12;
	vTrackingCheckWeighMinuteData = false;

	if (vConfigurationData->vScanTracType == cCaseInspectorScanTrac)
		vConfigurationData->vNumberOfXRayDetectors = 9;
	else
	if (vConfigurationData->vScanTracType == cForteScanTrac)
		vConfigurationData->vNumberOfXRayDetectors = 12;
	else
	if (vConfigurationData->vScanTracType == cAllegroScanTrac)
	{
		vConfigurationData->vNumberOfXRayDetectors = 9;
	}
	else
	if (vConfigurationData->vScanTracType == cSoloPlusScanTrac)
	{
		vConfigurationData->vNumberOfXRayDetectors = 9;
	}
	else
		vConfigurationData->vNumberOfXRayDetectors = 6;

	for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
		vGlobalEjectorConfirmMask[TempLoop] = 0;

	//CheckIfDetectorCalibrationNeeded();

	//Reset running maximums
	vSystemData.vProductHasAPoorLearn = false;
	vSystemData.vProductHasAnOldInspection = false;
	vSystemData.vPercentBeltSpeedMaximum = 0;
	vSystemData.vContainerRateMaximum = 0;
	vSystemData.vBeltRateMaximum = 0;
	vSystemData.vActualEncoderRateMaximum = 0;

	vSystemData.vITIPCDig->vAverageEnabled = false;
	vSystemData.vHaveAutoDisabledEjectors = false;
	vSystemData.vMemoryOK = true;
	if (!vSystemData.vInAutoSetup)
	{
		if (vSystemData.vTotalContainers > 0)
		{
			GenerateProductionReport(cSelectProductProductionReport);
			SendProductionReport(cSelectProductProductionReport);
		}
	}
	ResetCounters();

	if (vGlobalCurrentProduct)
	for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
	if (!vGlobalCurrentProduct->vInspection[TempLoop]) //if inspection does not exist
	{
		vGlobalCurrentProduct->vNumberOfInspections = TempLoop; //reduce the inspection count
		TempLoop = cMaximumNumberOfInspections;									//and exit the loop
	}
	else
	{ //have an inspection
		if (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cSpotInROIContaminantInspection)
		if (vGlobalCurrentProduct->vUsingXScanPoint4mmDetectors)
		{
			if (vGlobalCurrentProduct->vInspection[TempLoop]->vFindSpotInSubROI == 10)  //double size using for Small Contaminant P if in .4mm mode
				vGlobalCurrentProduct->vInspection[TempLoop]->vFindSpotInSubROI = 20;
			if (vGlobalCurrentProduct->vInspection[TempLoop]->vFindSpotInSubROI == 15)  //double size using for Medium Contaminant Q if in .4mm mode
				vGlobalCurrentProduct->vInspection[TempLoop]->vFindSpotInSubROI = 30;
			if (vGlobalCurrentProduct->vInspection[TempLoop]->vFindSpotInSubROI == 25)  //double size using for Large Contaminant R if in .4mm mode
				vGlobalCurrentProduct->vInspection[TempLoop]->vFindSpotInSubROI = 50;
		}

		if (vGlobalCurrentProduct->vInspection[TempLoop]->vDoContaminant22Algorithm)
		{
			vGlobalCurrentProduct->vInspection[TempLoop]->InspxContaminant22FreeBuffers();
		}
	}

	vSystemData.vDriftCompensationImageBrightnessDelta = 0;
	vSystemData.vCurrentBrightnessAdjustment = 0;
	vSystemData.vDriftCompensationADCOffset = 0;
	vSystemData.vDriftCompensationDACOffset = 0;
	SetProductDensityDisplay();

	//Setup hardware offsets
	if (!TempLeaveSourceOn)
	if (vGlobaluCSerialPort)
	{
		vSystemData.vDriftCompensationADCOffset = 0;
		vSystemData.vDriftCompensationDACOffset = 0;
			vSystemData.vVerifyDACErros = 0;
		SendAllDACDetectorOffsets();
		SendAllADCOffsets();
	}

	if (!vSystemData.vInAutoSetup)
	if ((vSystemData.vITIPCDig->vAverageEnabled) || (vSystemData.vITIPCDig->vStructureEnabled) ||
		vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled)
	{
		vSystemData.vITIPCDig->RestoreLearnFilesFromBackups(vGlobalCurrentProduct);
		vSystemData.vITIPCDig->vAverageEnabled = false;
		vSystemData.vITIPCDig->vStructureEnabled = false;
		vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled = false;
	}

	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter SetupProduct ScanTracDlg",cDebugMessage);
	DisplayWaitToSetupProduct();
	Sleep(100);
	if (vGlobalImageAquisitionThread)
		TerminateImageAquisitionThread();
	if (vGlobalDisplayDialogThread)
		vGlobalDisplayDialogThread->NextStep(); //step1
	vSystemData.vITIPCDig->vMainDisplayIsDefaultImage = false;
	vGlobalCurrentProduct = TempProduct;
	CString vTempString3 = " ";
	vSystemData.vITIPCDig->DeleteLearnImages();
	if (vConfigurationData->vDriftCompensationEnabled)
	{
		vSystemData.vDriftCompensationThresholdReductionAmount = vConfigurationData->vDriftCompensationThresholdReductionMaximum;
		vSystemData.vDriftCompensationThresholdIncreaseAmount = vConfigurationData->vDriftCompensationThresholdReductionMaximum;
		if (!TempLeaveSourceOn)
			vSystemData.vITIPCDig->vDriftCompensationLocked = false;
	}
	else
	{
		vSystemData.vDriftCompensationThresholdReductionAmount = 0;
		vSystemData.vDriftCompensationThresholdIncreaseAmount = 0;
		vSystemData.vITIPCDig->vDriftCompensationLocked = true;
	}
	//vConfigurationData->SetDetectorLength(vConfigurationData->vDetectorLength);
	if ((vConfigurationData->vUseXScanDetectors) && ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vUsingXScanPoint4mmDetectors))) //set the system setting to match this product's setting
	{
		vSystemData.vCalibratingXScanPoint4mmDetectors = 1;
		vConfigurationData->SetPixelsPerDetector(128);
		ReportErrorMessage("X-Scan Load Product: " + *vGlobalCurrentProduct->GetProductName() + " in .4mm Detector Mode", cAction, 0);
		//vSystemData.vCalibratingXScanPoint4mmDetectors = 1;
	}
	else
	{
		vSystemData.vCalibratingXScanPoint4mmDetectors = 0;
		vConfigurationData->SetPixelsPerDetector(64);
		if (vGlobalCurrentProduct)
			ReportErrorMessage("Load Product: " + *vGlobalCurrentProduct->GetProductName() + " in .8mm Detector Mode", cAction, 0);
		//vSystemData.vCalibratingXScanPoint4mmDetectors = 0;
	}
	//vConfigurationData->SetDetectorLength(vConfigurationData->vDetectorLength);

	if (!TempLeaveSourceOn)
	{
		SendInitializationToUController(false);
	}
	else
		SendResolutionSettingsTouCHardware();

	if (!TempLeaveSourceOn)
		vSystemData.vTemporarilyChangeSource = false;
	if (vGlobalCurrentProduct == NULL)
	{
		vSystemData.vRampXRayCurrentAmount = 0;
		vSystemData.vRampXRayVoltageAmount = 0;
		TempText.LoadString(IDS_CurrentProduct);

	//chinese test only
	//TempText.LoadString(IDS_RenSymbol);
	//TempText.LoadString(IDS_YenSymbol);
	
		SetDlgItemText(IDC_CurrentProductLabel,TempText + ":");
		TempText.LoadString(IDS_NoCurrentProduct);
		SetDlgItemText(IDC_ProductLabel," " + TempText + " ");
	}
	else
	{
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendEncoderDividerTouC();//must do first because it sets the vGlobalPixelsPerUnit depending on if it is .4 or .8 mm pixels
		Sleep(cSendCommandSleepTime);

		vConfigurationData->SetDetectorLength(vConfigurationData->vDetectorLength);
		if (vConfigurationData->vUseXScanDetectors)
		if ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vUsingXScanPoint4mmDetectors) && (vConfigurationData->vScanTracType != cForteScanTrac) && 
			(vConfigurationData->vScanTracType != cCaseInspectorScanTrac)) //set the system setting to match this product's setting
		{
			vSystemData.vCalibratingXScanPoint4mmDetectors = 1;
			vConfigurationData->SetPixelsPerDetector(128);
			ReportErrorMessage("X-Scan Load Product: " + *vGlobalCurrentProduct->GetProductName() + " in .4mm Detector Mode", cAction, 0);
			vSystemData.vCalibratingXScanPoint4mmDetectors = 1;
		}
		else
		{
			vSystemData.vCalibratingXScanPoint4mmDetectors = 0;
			vConfigurationData->SetPixelsPerDetector(64);
			ReportErrorMessage("Load Product: " + *vGlobalCurrentProduct->GetProductName() + " in .8mm Detector Mode", cAction, 0);
			vSystemData.vCalibratingXScanPoint4mmDetectors = 0;
		}
		vConfigurationData->SetDetectorLength(vConfigurationData->vDetectorLength);

		vGlobalCurrentProduct->SetProductImageWidth(vGlobalCurrentProduct->vProductImageWidth);
		//unexplained crash in MVTools Median Filter occurs when image is 576 x 1016, so make slightly bigger.
		if ((vGlobalCurrentProduct->vImageWidthPosition == 1016) && (vGlobalCurrentProduct->vProductImageHeightTop == 18))
		{
			vGlobalCurrentProduct->SetProductImageWidth((float)(1024 / vGlobalPixelsPerUnit / vGlobalCurrentProduct->vOverScanMultiplier));
		}

		vGlobalCurrentProduct->SetEndOfLineTimeOut(vGlobalCurrentProduct->vEndOfLineTimeOut);
		vGlobalCurrentProduct->SetBottomLocationLeft((float)(vGlobalCurrentProduct->vBottomLocationLeftPixel / vGlobalPixelsPerUnit));
		vGlobalCurrentProduct->SetBottomLocationLength((float)(vGlobalCurrentProduct->vBottomLocationLengthPixel / vGlobalPixelsPerUnit));
		vGlobalCurrentProduct->SetProductLockOutWidth(vGlobalCurrentProduct->vProductLockOutWidth);
		vGlobalCurrentProduct->SetProductBodyTriggerToImageBeltPositionOffset(vGlobalCurrentProduct->vProductBodyTriggerToImageBeltPositionOffset);
		for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
			vGlobalCurrentProduct->SetEjectorBeltPositionOffset(TempLoop, vGlobalCurrentProduct->vEjectorDelayPosition[TempLoop]);
		for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
		{
			vGlobalCurrentProduct->SetExternalDetectorWindowStart(TempLoop,(float)vGlobalCurrentProduct->vExternalDetectorWindowStart[TempLoop]);
			vGlobalCurrentProduct->SetExternalDetectorWindowEnd(TempLoop,(float)vGlobalCurrentProduct->vExternalDetectorWindowEnd[TempLoop]);
		}
		vGlobalEndOfLineTimeOutMargin = 12;

		BYTE TempConfirmerUsed = 0;
		if (vSystemData.vEjectorUsed)
		for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
		if ((vConfigurationData->vEjector[TempLoop].vConfirmEnabled) &&
			(vConfigurationData->vEjector[TempLoop].vConfirmDigitalInputLine) &&
			(vConfigurationData->vEjector[TempLoop].vEnabled))
		{
			TempConfirmerUsed = TempConfirmerUsed | (1 << TempLoop);
		}
		if (vGlobalCurrentProduct->vEjectorDwellTime[0] > 100)
			vGlobalEndOfLineTimeOutMargin = vGlobalEndOfLineTimeOutMargin + 22;

		if (TempConfirmerUsed)
			vGlobalEndOfLineTimeOutMargin = vGlobalEndOfLineTimeOutMargin + 12; //need to add to end of line timeout as to give time for confirmer

		if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
			vGlobalEndOfLineTimeOutMargin = vGlobalEndOfLineTimeOutMargin + (BYTE)vGlobalCurrentProduct->vProductImageWidth; //need to add to end of line timeout as beginning of container could be last line of image

		vGlobalCurrentProduct->CalculateEndOfLineTimeOut();

		double TempMaximumCurrentAllowed = vConfigurationData->vMaximumCurrent;

		if (vGlobalCurrentProduct->vXRaySourceVoltage == 0)
			TempMaximumCurrentAllowed = 0;

		double TempMaximumCurrent = GetMaximumCurrentFromVoltage(vGlobalCurrentProduct->vXRaySourceVoltage * 6);
		if (TempMaximumCurrentAllowed > TempMaximumCurrent)
			TempMaximumCurrentAllowed = TempMaximumCurrent;

		TempMaximumCurrent = GetMaximumCurrentFromPower(vGlobalCurrentProduct->vXRaySourceVoltage *  6, vConfigurationData->vMaximumPower);
		if (TempMaximumCurrentAllowed > TempMaximumCurrent)
			TempMaximumCurrentAllowed = TempMaximumCurrent;

		if (vGlobalCurrentProduct->vXRaySourceCurrent > TempMaximumCurrentAllowed + .02)
		{
			if ((TempMaximumCurrentAllowed >= 8.56) && (TempMaximumCurrentAllowed < 8.6))
				TempMaximumCurrentAllowed = 8.55;

			//if (!CurrentProductIsInspxProduct())
			//	TempNoticeText = "\n\nProduct X-Ray Current Setting too high for current settings.\nWas: " + dtoa(vGlobalCurrentProduct->vXRaySourceCurrent, 2) + " Now: " + dtoa(TempMaximumCurrentAllowed, 2);
			vGlobalCurrentProduct->vXRaySourceCurrent = (float)TempMaximumCurrentAllowed;
		}

		SetLearnState();

		if (vGlobalCurrentProduct)
		if (vGlobalCurrentProduct->vNumberOfInspections)
		{//remove  improve learn inspection if exists
			vGlobalCurrentProduct->MatchInspectionsForWeightTrending();

			BYTE TempInspectionNumber = GetImproveLearnInspectionNumber();
			if (TempInspectionNumber)
			{
				if (vGlobalCurrentProduct->vInspection[TempInspectionNumber - 1])
					delete vGlobalCurrentProduct->vInspection[TempInspectionNumber - 1];
				vGlobalCurrentProduct->vInspection[TempInspectionNumber - 1] = NULL;
				vGlobalCurrentProduct->vNumberOfInspections--;
			}
		}
		if (vGlobalCurrentProduct->vNumberOfInspections)
		{
			for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
			if (!vGlobalCurrentProduct->vInspection[TempLoop])
				vGlobalCurrentProduct->vNumberOfInspections = TempLoop;  //if no inspection, then set number of inspections to loop value
		}

		SetupRejectReasonNames();

		//convert X-Ray Integration Time code from old style to new style if needed.
		if (vGlobalCurrentProduct->vXRayIntegrationTimeByte != 0xFF) //0xFF indicates it is not used now, use the word value
		{//convert product from old byte data type, to new word data type
			if (vGlobalCurrentProduct->vXRayIntegrationTimeByte < 98)
				vGlobalCurrentProduct->vXRayIntegrationTime = ((WORD)vGlobalCurrentProduct->vXRayIntegrationTimeByte + 3) * 250;  //convert old style code to new style code
			else
				vGlobalCurrentProduct->vXRayIntegrationTime = 750; //is .3mSec

			//vGlobalCurrentProduct->vXRayIntegrationTimeAtEdge = vGlobalCurrentProduct->vXRayIntegrationTime;
			vGlobalCurrentProduct->vXRayIntegrationTimeByte = 0xFF;  //don't use byte value anymore
		}
		//in new format, 205 is lowest used value, so was old format, so convert to new
		if (vGlobalCurrentProduct->vXRayIntegrationTime < 205)  //if not in legitamate number range, make .3 mSec
		{
			vGlobalCurrentProduct->vXRayIntegrationTime = 750;  //convert old style code to new style code

			ReportErrorMessage("Invalid Integration Time, Set to .3 mSec",cEMailInspx,32000);
		}
/*
		if (vSystemData.vFPGAVersion10Point9OrHigher)  //in new format, 205 is lowest used value
		{
			if (vGlobalCurrentProduct->vXRayIntegrationTimeAtEdge < 205) //if no edge value set
				vGlobalCurrentProduct->vXRayIntegrationTimeAtEdge = vGlobalCurrentProduct->vXRayIntegrationTime; //set edges same as center
			if (vGlobalCurrentProduct->vXRayIntegrationTimeAtEdge > vGlobalCurrentProduct->vXRayIntegrationTime) //if not legitament
				vGlobalCurrentProduct->vXRayIntegrationTimeAtEdge = vGlobalCurrentProduct->vXRayIntegrationTime; //set edges same as center
		}
*/
		if (vGlobalCurrentProduct->vEdgeLocationHeight < .09375)
			vGlobalCurrentProduct->vEdgeLocationHeight = .09375;

		vGlobalCurrentProduct->SetEdgeLocationBottom(vGlobalCurrentProduct->vEdgeLocationBottom);
		vGlobalCurrentProduct->SetEdgeLocationHeight(vGlobalCurrentProduct->vEdgeLocationHeight);
		vGlobalCurrentProduct->SetBottomLocationLeft(vGlobalCurrentProduct->vBottomLocationLeft);
		vGlobalCurrentProduct->SetBottomLocationLength(vGlobalCurrentProduct->vBottomLocationLength);

		//copy product name text into Label control on screen 
		if (vGlobalCurrentProduct)
		{
			CString TempString = *vGlobalCurrentProduct->GetProductName();
			vSystemData.vCurrentProductName = *vGlobalCurrentProduct->GetProductName();
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Setup Product: " + vSystemData.vCurrentProductName,cDebugMessage);
		}
		bool TempAllLanesHaveAWidth = true;
		if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
		{
			//double TempImageHeight = vConfigurationData->vNumberOfXRayDetectors * vConfigurationData->vDetectorLength;
			//double TempLaneWidthSuggestion = TempImageHeight / vGlobalCurrentProduct->vMultiLaneNumberOfLanes;
			//WORD TempLaneWidth = (WORD)(TempLaneWidthSuggestion * vGlobalPixelsPerUnitInHeight);

			vGlobalCurrentProduct->vProductImageHeightBottom = 0;
			vGlobalCurrentProduct->vProductImageHeightTop = (float)(vConfigurationData->vDetectorLength * vConfigurationData->vNumberOfXRayDetectors);
			vGlobalCurrentProduct->SetProductLockOutWidth(0.25);
			vGlobalCurrentProduct->SetProductBodyTriggerToImageBeltPositionOffset(4.0);

			WORD TempWidestLane = 0;
			for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vMultiLaneNumberOfLanes; TempLoop++)
			{
				if (vGlobalCurrentProduct->vMultiLaneWidthInPixels[TempLoop] == 0)
					TempAllLanesHaveAWidth = false;

				if (TempWidestLane < vGlobalCurrentProduct->vMultiLaneWidthInPixels[TempLoop])
					TempWidestLane = vGlobalCurrentProduct->vMultiLaneWidthInPixels[TempLoop];
			}

			if (vSystemData.vMultiLaneInSetupLanePositionsMenu)
				vSystemData.vITIPCDig->vOriginalBufferSizeX = (WORD)(vConfigurationData->vNumberOfXRayDetectors * vConfigurationData->vDetectorLength * vGlobalPixelsPerUnitInHeight);
			else
			if ((TempWidestLane > 4) && (TempAllLanesHaveAWidth))
				vSystemData.vITIPCDig->vOriginalBufferSizeX = TempWidestLane;
			else
			{
				vSystemData.vITIPCDig->vOriginalBufferSizeX = (WORD)((vConfigurationData->vNumberOfXRayDetectors * vConfigurationData->vDetectorLength * vGlobalPixelsPerUnitInHeight) / 
					vGlobalCurrentProduct->vMultiLaneNumberOfLanes);
				ReportErrorMessage("Notice-Multi Lane Widths not configured.  Set to Default", cError, 0);
			}
		}

		UpdateCurrentProductNameDisplay();
		SetExternalDetectorDecisionOffset();

		Sleep(10);

		if (vGlobalDisplayDialogThread)
			vGlobalDisplayDialogThread->NextStep();//step2
		SendProductSetupToUController(TempLeaveSourceOn);

		Sleep(10);

		if (vGlobalDisplayDialogThread)
			vGlobalDisplayDialogThread->NextStep();//step3
		SetupFrameGrabber();
		if (vGlobalDisplayDialogThread)
			vGlobalDisplayDialogThread->NextStep();//step4

		Sleep(10);

		if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
		if (!TempAllLanesHaveAWidth) //if don't have lane start positions and widths, then set the lane positions
		{
			double TempImageHeight = vConfigurationData->vNumberOfXRayDetectors * vConfigurationData->vDetectorLength;
			double TempLaneWidthSuggestion = TempImageHeight / vGlobalCurrentProduct->vMultiLaneNumberOfLanes;
			WORD TempLaneWidth = (WORD)(TempLaneWidthSuggestion * vGlobalPixelsPerUnitInHeight);
			if (TempLaneWidth > vSystemData.vITIPCDig->vOriginalBufferSizeX)
				TempLaneWidth = vSystemData.vITIPCDig->vOriginalBufferSizeX;


			for (BYTE TempLaneLoop = 0; TempLaneLoop < vGlobalCurrentProduct->vMultiLaneNumberOfLanes; TempLaneLoop++)
			{
				vGlobalCurrentProduct->vMultiLaneWidthInPixels[TempLaneLoop] = TempLaneWidth;
				vGlobalCurrentProduct->vMultiLaneStartPixel[TempLaneLoop] = TempLaneWidth * TempLaneLoop;
				//if lane extends beyond actual detectors, correct positions so they are valid
				if (vGlobalCurrentProduct->vMultiLaneWidthInPixels[TempLaneLoop] + vGlobalCurrentProduct->vMultiLaneStartPixel[TempLaneLoop] > vSystemData.vITIPCDig->vAquisitionSizeXUpTo12Detectors)
				{
					if ((TempLaneLoop < vGlobalCurrentProduct->vMultiLaneNumberOfLanes - 1) || 
						(vGlobalCurrentProduct->vMultiLaneWidthInPixels[TempLaneLoop] + vGlobalCurrentProduct->vMultiLaneStartPixel[TempLaneLoop] > vSystemData.vITIPCDig->vAquisitionSizeXUpTo12Detectors + 15))
					{ //give warning unless last lane and less than 15 pixels past image width
						if (TempNoticeText.GetLength() < 5)
							TempNoticeText = "\nMulti Lane Setup Error.\n\nLanes are wider than detectors.";
					}
					if (vGlobalCurrentProduct->vMultiLaneWidthInPixels[TempLaneLoop] > vSystemData.vITIPCDig->vAquisitionSizeX)
						vGlobalCurrentProduct->vMultiLaneStartPixel[TempLaneLoop] = vSystemData.vITIPCDig->vAquisitionSizeX - vGlobalCurrentProduct->vMultiLaneWidthInPixels[TempLaneLoop];
				}
			}
		}

		double TempNumberOfDetectorsToCheckD = (vGlobalCurrentProduct->vProductImageHeightTop / vConfigurationData->vDetectorLength) + (0.99); // 8/17/2016 Round Up
		vSystemData.vNumberOfXRayDetectorsUsing = (BYTE)(TempNumberOfDetectorsToCheckD);
		if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes) //if doing multi lane, then using all detectors
			vSystemData.vNumberOfXRayDetectorsUsing = vConfigurationData->vNumberOfXRayDetectors;

		//if (TempNumberOfDetectorsToCheckD > vSystemData.vNumberOfXRayDetectorsUsing)  //if truncated a fractional part of a detector, need to check one more detector
		//	vSystemData.vNumberOfXRayDetectorsUsing++;

		//4/20/2004
		if (vSystemData.vInAutoSetup)
			vSystemData.vNumberOfXRayDetectorsUsing = vConfigurationData->vNumberOfXRayDetectors;

		if (vGlobalDisplayDialogThread)
			vGlobalDisplayDialogThread->NextStep();//step5

		vSystemData.vITIPCDig->LoadProductDataImages(vGlobalCurrentProduct);
		if (vGlobalDisplayDialogThread)
			vGlobalDisplayDialogThread->NextStep();//step6

		if (!vSystemData.vITIPCDig->vProductContaminant2StructureImage) //if no structure, set learn count to zero and add to learn zero
		{
			vGlobalCurrentProduct->vSetupHistoryStructureCount = 0;
			vGlobalCurrentProduct->vAddToLearnCount = 0;
		}
		if (!vSystemData.vITIPCDig->vProductAverageImage) //if no Average, set learn count to zero
		{
			vGlobalCurrentProduct->vSetupHistoryAverageCount = 0;
			vGlobalCurrentProduct->vSetupHistoryAverageDensity = 0;
		}

		/*
		//problem in demo program with histogram but do not know what the problem is
		//gives loading ITEX DLL Problem
		if (!vConfigurationData->vDemoMode)
		{
			CString TempString1 = "=Process 3";
			TempString1 =  *vGlobalCurrentProduct->GetProductName() + TempString1;
			if (!vSystemData.vITIPCDig->vUsingLocalSetupDataFile)
				TempString1 = cSetupDataDirectory + TempString1;
			else
				TempString1 = vGlobalCurrentDirectory + TempString1;
			TempString1 = TempString1 + ".BMP";
			LPTSTR TempString = TempString1.GetBuffer(TempString1.GetLength());
			int TempHeight = 0;
			int TempWidth = 0;
			int TempBytesPerPixel = 0;
			int TempType = 0;

			CFileStatus TempFileStatus;
			if (CFile::GetStatus(TempString, TempFileStatus))
			{
				Erflag TempError = im_file_get_size(TempString, 
						IM_BMP_FILE, &TempHeight, &TempWidth, 
						&TempBytesPerPixel, &TempType);
				if (TempError == IM_OK)
				if (((TempWidth != vSystemData.vITIPCDig->vOriginalBufferSizeY) ||
					(TempHeight != vSystemData.vITIPCDig->vOriginalBufferSizeX)) &&
					(!vConfigurationData->vDemoMode))
				{
					ReportErrorMessage("Error-Process 3 Learned Image wrong size, ignored", cWriteToLog,0);
				}
				else
				if (ThereIsEnoughMemory(vSystemData.vITIPCDig->vOriginalBufferSize + sizeof(Image), "Temp Image In"))
				{
					Image *TempImageIn = NULL;
					TempImageIn = im_create(IM_BYTE, vSystemData.vITIPCDig->vOriginalBufferSizeX, 
						vSystemData.vITIPCDig->vOriginalBufferSizeY);
					if ((TempImageIn) && (TempImageIn->pix))
					{
						TempError = im_file_read(TempImageIn, TempString, IM_AUTO_FILE);
						if (TempError == IM_OK)
						{
							if (vSystemData.vITIPCDig->vProductHistogramImage != NULL)
							{
								delete vSystemData.vITIPCDig->vProductHistogramImage;
								vSystemData.vITIPCDig->vProductHistogramImage = NULL;
							}
							if (ThereIsEnoughMemory(sizeof(CImageData), "vProductHistogramImage"))
								vSystemData.vITIPCDig->vProductHistogramImage = new CImageData;
							if (vSystemData.vITIPCDig->vProductHistogramImage)
							{
								vSystemData.vITIPCDig->vProductHistogramImage->
									vImageTypeString = "Product Mask";
								vSystemData.vITIPCDig->vProductHistogramImage->vImageType = cDataImageType;
								vSystemData.vITIPCDig->vProductHistogramImage->MakeGreyImage(vSystemData.vITIPCDig->vOriginalBufferSize);
								if (vSystemData.vITIPCDig->vProductHistogramImage->vGreyImage)
								{
									CopyMemory(vSystemData.vITIPCDig->vProductHistogramImage->vGreyImage, 
										TempImageIn->pix, vSystemData.vITIPCDig->vOriginalBufferSize);
								}
							}
						}
					}
					if (TempImageIn)
						im_delete(TempImageIn);
				}
			}
		}
		*/

		CreateImageAquisionThread();
		if (!TempLeaveSourceOn)
		{
			vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;
			vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;
		}
		//vSystemData.vITIPCDig->FindJarWells(vGlobalCurrentProduct);
		SetupExternalDetectors();
	}
	SetupBulkModeAndMainMenuScreen();
	if (vGlobalCurrentProduct)
	{
		vGlobalCurrentProduct->SetAllDistances();

		if (!vSystemData.vTotalUnConfirmed)
		{
			m_TotalUnConfirmed.ShowWindow(SW_HIDE);
			m_TotalUnConfirmLabel.ShowWindow(SW_HIDE);
		}
		else
		{
			m_TotalUnConfirmed.ShowWindow(SW_SHOW);
			m_TotalUnConfirmLabel.ShowWindow(SW_SHOW);
		}

		if (!vGlobalCurrentProduct->vDriftDensityInspection)
		{
			vGlobalCurrentProduct->vDriftDensityInspection = new CInspectionDensity;

			if (vGlobalCurrentProduct->vDriftDensityInspection)
			{
				CProduct *TempDefaultProductPointer = GetProductByName("~Default");
				if (vGlobalCurrentProduct->vDriftDensityInspection)
				if ((TempDefaultProductPointer) && (TempDefaultProductPointer->vDriftDensityInspection))
				{
					vGlobalCurrentProduct->vDriftDensityInspection->SetROITop(TempDefaultProductPointer->vDriftDensityInspection->vROITop);
					vGlobalCurrentProduct->vDriftDensityInspection->SetROIBottom(TempDefaultProductPointer->vDriftDensityInspection->vROIBottom);
					vGlobalCurrentProduct->vDriftDensityInspection->SetROILeft(TempDefaultProductPointer->vDriftDensityInspection->vROILeft, vGlobalCurrentProduct->vOverScanMultiplier);
					vGlobalCurrentProduct->vDriftDensityInspection->SetROIRight(TempDefaultProductPointer->vDriftDensityInspection->vROIRight, vGlobalCurrentProduct->vOverScanMultiplier);
				}
				else
				{
					WORD TempImageMargin = (WORD)(0.40 * vGlobalPixelsPerUnit * vGlobalCurrentProduct->vOverScanMultiplier);
					if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes == 0)
					if ((vGlobalScanTracType == cAtempoScanTrac) || (vGlobalScanTracType == cForteScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || (vGlobalScanTracType == cLegatoScanTrac) || 
						(vGlobalScanTracType == cFermataScanTrac) || (vConfigurationData->vScanTracType == cCaseInspectorScanTrac))
					{
						vGlobalCurrentProduct->vDriftDensityInspection->SetDefaultROI((WORD)(vGlobalCurrentProduct->vProductImageHeightTop / 2 * vGlobalPixelsPerUnit * vGlobalCurrentProduct->vOverScanMultiplier), 
							(WORD)(vGlobalCurrentProduct->vProductImageHeightTop / 4 * vGlobalPixelsPerUnit * vGlobalCurrentProduct->vOverScanMultiplier), 
							vGlobalCurrentProduct->vImageWidthPosition / 4, vGlobalCurrentProduct->vImageWidthPosition * 3 / 4, vGlobalCurrentProduct->vOverScanMultiplier);
					}
					else
					{
						vGlobalCurrentProduct->vDriftDensityInspection->SetDefaultROI(
							(WORD)(vGlobalCurrentProduct->vProductImageHeightTop * 0.25 * vGlobalPixelsPerUnit * vGlobalCurrentProduct->vOverScanMultiplier), 
							(WORD)(vGlobalCurrentProduct->vProductImageHeightTop * 0.1 * vGlobalPixelsPerUnit * vGlobalCurrentProduct->vOverScanMultiplier), TempImageMargin, 
							vGlobalCurrentProduct->vImageWidthPosition - TempImageMargin, vGlobalCurrentProduct->vOverScanMultiplier);
					}
				}
			}
		}
		if (vGlobalCurrentProduct->vDriftDensityInspection)
		{
			if (vGlobalCurrentProduct->vDriftDensityInspection->vROITop >= (vSystemData.vITIPCDig->vOriginalBufferSizeX - 1) / vGlobalPixelsPerUnitInHeight)
				vGlobalCurrentProduct->vDriftDensityInspection->SetROITop((vSystemData.vITIPCDig->vOriginalBufferSizeX - 4) / vGlobalPixelsPerUnitInHeight);
			else
				vGlobalCurrentProduct->vDriftDensityInspection->SetROITop(vGlobalCurrentProduct->vDriftDensityInspection->vROITop);

			if (vGlobalCurrentProduct->vDriftDensityInspection->vROITop <= vGlobalCurrentProduct->vDriftDensityInspection->vROIBottom)
				vGlobalCurrentProduct->vDriftDensityInspection->SetROIBottom(4 / vGlobalPixelsPerUnitInHeight);
			else
				vGlobalCurrentProduct->vDriftDensityInspection->SetROIBottom(vGlobalCurrentProduct->vDriftDensityInspection->vROIBottom);

			vGlobalCurrentProduct->vDriftDensityInspection->SetROILeft(vGlobalCurrentProduct->vDriftDensityInspection->vROILeft,
				vGlobalCurrentProduct->vOverScanMultiplier);
			vGlobalCurrentProduct->vDriftDensityInspection->SetROIRight(vGlobalCurrentProduct->vDriftDensityInspection->vROIRight,
				vGlobalCurrentProduct->vOverScanMultiplier);

			vSystemData.vITIPCDig->CalculateAverageDriftDensity(vGlobalCurrentProduct);
			vSystemData.vIndexForDriftDensityOfLastNImages = 0;
		}

		if (!vGlobalCurrentProduct->vReferenceWidth)
		if (vGlobalCurrentProduct->vReferenceRight)
			vGlobalCurrentProduct->vReferenceWidth = vGlobalCurrentProduct->vReferenceRight - vGlobalCurrentProduct->vReferenceLeft;

		SendBodyTriggerInverterControl();
		for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
		if (vGlobalCurrentProduct->vInspection[TempLoop])
		{
			if (vGlobalCurrentProduct->vInspection[TempLoop]->vDoContaminant22Algorithm)
			{
				vGlobalCurrentProduct->vInspection[TempLoop]->InspxContaminant22CreateBuffers(
					vSystemData.vITIPCDig->vOriginalBufferSizeX, vSystemData.vITIPCDig->vOriginalBufferSizeY);

				//WORD TempThreshold = (WORD)(vGlobalCurrentProduct->vThresholdForContainerBounds - 10) << 8;  //default = 45000
				//TempThreshold = 45000;
				//vGlobalCurrentProduct->vInspection[TempLoop]->InspxContaminant22SetBackgroundThreshold(TempThreshold);

				/** Set min package image size on X axis (used for checking cropping results). Default value = 230.*/
				//vGlobalCurrentProduct->vInspection[TempLoop]->InspxContaminant22SetMinSizeX(vSystemData.vITIPCDig->vOriginalBufferSizeX / 3);

				/** Set min package image size on Y axis (used for checking cropping results). Default value = 280. */
				//vGlobalCurrentProduct->vInspection[TempLoop]->InspxContaminant22SetMinSizeY(vSystemData.vITIPCDig->vOriginalBufferSizeY / 3);

				/** Set number of rows/columns used for detection of package edges (after image cropping). Default value = 50.*/
				//vGlobalCurrentProduct->vInspection[TempLoop]->InspxContaminant22SetRowsEdge(vSystemData.vITIPCDig->vOriginalBufferSizeY / 6);

			}
		}

		//for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors - 1; TempLoop++)
		for (BYTE TempLoop = 0; TempLoop < 1; TempLoop++)
		if (vGlobalCurrentProduct->vEjectorDwellTime[TempLoop] == 0)
		//if (vEjectorNumberToTurnOff == 0)
		{
			vSystemData.vDiverterActive[TempLoop] = false;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendEjectorOnOffCommand(TempLoop + 2, 0); 
			ReportErrorMessage("De-activate Diverter: " + dtoa(TempLoop + 2, 0) + " now because Selected Product", cAction, 0);
		}
	}
	if (vGlobalDisplayDialogThread)
		vGlobalDisplayDialogThread->NextStep();//step11
	vSystemData.vITIPCDig->vMainDisplayIsDefaultImage = false;
	vSystemData.vITIPCDig->FillMainDisplayBuffer();
	if (!vWaitForScreenUpdate)
	{
		int TimerResult = SetTimer(vWaitForScreenUpdateTimerHandle,10,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-Screen Timer Failed",cEMailInspx,32000);
		vWaitForScreenUpdate = true;
	}
	UpdateDisableEjectorsButton();
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Exit SetupProduct ScanTracDlg",cDebugMessage);

	for (WORD TempLoop = 0; TempLoop < cMaximumNumberOfDemoImages; TempLoop++)
	if (vSystemData.vDemoImage[TempLoop])
	{
		im_delete(vSystemData.vDemoImage[TempLoop]);
		vSystemData.vDemoImage[TempLoop] = NULL;
	}
	//Read in demo images if there are any
	WORD TempImagesThatAreWrongSize = 0;
	vSystemData.vNumberOfDemoImages = 0;
	if (vGlobalCurrentProduct)
	if (vSystemData.vMemoryOK)
	if (!vConfigurationData->vShowOnlyRealImages)
	{
		for (BYTE TempImageNumber = 0; TempImageNumber < cMaximumNumberOfDemoImages; TempImageNumber++)
		{
			CString TempString1 = *vGlobalCurrentProduct->GetProductName();
			TempString1 = vConfigurationData->vScanTracImagesDirectory + TempString1 + "DemoImage" + dtoa(TempImageNumber,0) + ".bmp";

			LPCTSTR TempString = TempString1.GetBuffer(TempString1.GetLength());
			int TempHeight = 0;
			int TempWidth = 0;
			int TempBytesPerPixel = 0;
			int TempType = 0;

			CFileStatus TempFileStatus;
			if (CFile::GetStatus(TempString, TempFileStatus))
			{
				CW2A TempFileNameString(TempString1);
				Erflag TempError = im_file_get_size(TempFileNameString, IM_BMP_FILE, &TempHeight, &TempWidth, &TempBytesPerPixel, &TempType);
				if (TempError == IM_OK)
				{
					if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
					{
						DWORD TempBufferSize = vSystemData.vITIPCDig->vAquisitionSizeY * vSystemData.vITIPCDig->vAquisitionSizeXUpTo12Detectors;

						if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
							TempBufferSize = vSystemData.vITIPCDig->vAquisitionSizeY * vSystemData.vITIPCDig->vAquisitionSizeX;

						if (((TempWidth != vSystemData.vITIPCDig->vAquisitionSizeY) || (TempHeight != vSystemData.vITIPCDig->vAquisitionSizeX)) && (!vConfigurationData->vDemoMode))
							TempImagesThatAreWrongSize++;

						if (ThereIsEnoughMemory(TempBufferSize + sizeof(Image), "Temp Image In"))
						{
							if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
								vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages] = im_create(IM_BYTE, vSystemData.vITIPCDig->vAquisitionSizeXUpTo12Detectors, vSystemData.vITIPCDig->vAquisitionSizeY);
							else
								vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages] = im_create(IM_BYTE, vSystemData.vITIPCDig->vAquisitionSizeX, vSystemData.vITIPCDig->vAquisitionSizeY);

							if (vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages])
							if (vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages]->pix)
							{
								FillMemory(vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages]->pix, TempBufferSize, 255);
								TempError = im_file_read(vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages], TempFileNameString, IM_AUTO_FILE);
								if (TempError == IM_OK)
									vSystemData.vNumberOfDemoImages++;
							}
						}
					}
					else
					{
						if (((TempWidth != vSystemData.vITIPCDig->vOriginalBufferSizeY) || (TempHeight != vSystemData.vITIPCDig->vOriginalBufferSizeX)) && (!vConfigurationData->vDemoMode))
							TempImagesThatAreWrongSize++;

						if (ThereIsEnoughMemory(vSystemData.vITIPCDig->vOriginalBufferSize + sizeof(Image), "Temp Image In"))
						{
							vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages] = im_create(IM_BYTE, vSystemData.vITIPCDig->vOriginalBufferSizeX, vSystemData.vITIPCDig->vOriginalBufferSizeY);
							if (vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages])
							if (vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages]->pix)
							{
								FillMemory(vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages]->pix, vSystemData.vITIPCDig->vOriginalBufferSize, 255);
								TempError = im_file_read(vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages], TempFileNameString, IM_AUTO_FILE);
								if (TempError == IM_OK)
									vSystemData.vNumberOfDemoImages++;
							}
						}
					}
				}
			}
		}
		if (!vSystemData.vNumberOfDemoImages)
		for (BYTE TempImageNumber = 0; TempImageNumber < cMaximumNumberOfDemoImages; TempImageNumber++)
		{
			CString TempString1 = *vGlobalCurrentProduct->GetProductName();
			TempString1 = vGlobalCurrentDirectory + TempString1 + "DemoImage" + dtoa(TempImageNumber,0) + ".bmp";

			LPTSTR TempString = TempString1.GetBuffer(TempString1.GetLength());
			int TempHeight = 0;
			int TempWidth = 0;
			int TempBytesPerPixel = 0;
			int TempType = 0;
			WORD TempImagesThatAreWrongSize = 0;

			CFileStatus TempFileStatus;
			if (CFile::GetStatus(TempString, TempFileStatus))
			{
				CW2A TempFileNameString(TempString1);
				Erflag TempError = im_file_get_size(TempFileNameString, IM_BMP_FILE, &TempHeight, &TempWidth, &TempBytesPerPixel, &TempType);
				if (TempError == IM_OK)
				{
					if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
					{
						DWORD TempBufferSize = vSystemData.vITIPCDig->vAquisitionSizeY * vSystemData.vITIPCDig->vAquisitionSizeXUpTo12Detectors;
						if (((TempWidth != vSystemData.vITIPCDig->vAquisitionSizeY) || (TempHeight != vSystemData.vITIPCDig->vAquisitionSizeX)) && (!vConfigurationData->vDemoMode))
							TempImagesThatAreWrongSize++;

						if (ThereIsEnoughMemory(TempBufferSize + sizeof(Image), "Temp Image In"))
						{
							vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages] = im_create(IM_BYTE, vSystemData.vITIPCDig->vAquisitionSizeXUpTo12Detectors, vSystemData.vITIPCDig->vAquisitionSizeY);
							if (vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages])
							if (vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages]->pix)
							{
								FillMemory(vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages]->pix, TempBufferSize, 255);
								TempError = im_file_read(vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages], TempFileNameString, IM_AUTO_FILE);
								if (TempError == IM_OK)
									vSystemData.vNumberOfDemoImages++;
							}
						}
					}
					else
					{
						if (((TempWidth != vSystemData.vITIPCDig->vOriginalBufferSizeY) || (TempHeight != vSystemData.vITIPCDig->vOriginalBufferSizeX)) && (!vConfigurationData->vDemoMode))
							TempImagesThatAreWrongSize++;

						if (ThereIsEnoughMemory(vSystemData.vITIPCDig->vOriginalBufferSize + sizeof(Image), "Temp Image In"))
						{
							vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages] = im_create(IM_BYTE, vSystemData.vITIPCDig->vOriginalBufferSizeX, vSystemData.vITIPCDig->vOriginalBufferSizeY);
							if (vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages])
							if (vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages]->pix)
							{
								FillMemory(vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages]->pix, vSystemData.vITIPCDig->vOriginalBufferSize, 255);
								TempError = im_file_read(vSystemData.vDemoImage[vSystemData.vNumberOfDemoImages], TempFileNameString, IM_AUTO_FILE);
								if (TempError == IM_OK)
									vSystemData.vNumberOfDemoImages++;
							}
						}
					}
				}
			}
		}
	}
	double TempSourceVoltageTolerance = .1 * vGlobalCurrentProduct->vXRaySourceVoltage;
	double TempSourceCurrentTolerance = .1 * vGlobalCurrentProduct->vXRaySourceCurrent;
	if (TempSourceCurrentTolerance < .25)
		TempSourceCurrentTolerance = .25;

	vSystemData.vSourceVoltageMin = 254;
	vSystemData.vSourceVoltageMax = 0;
	vSystemData.vSourceCurrentMin = 254;
	vSystemData.vSourceCurrentMax = 0;
	if (vGlobalDXMXRayPort)
	{
		vGlobalDXMXRayPort->vFilamentCurrentMin = 9999999;
		vGlobalDXMXRayPort->vFilamentCurrentMax = 0;
	}

	vSystemData.vSourceVoltageMinRedLine = vGlobalCurrentProduct->vXRaySourceVoltage -
		TempSourceVoltageTolerance;
	vSystemData.vSourceVoltageMaxRedLine = vGlobalCurrentProduct->vXRaySourceVoltage +
		TempSourceVoltageTolerance;
	vSystemData.vSourceCurrentMinRedLine = vGlobalCurrentProduct->vXRaySourceCurrent -
		TempSourceCurrentTolerance;
	vSystemData.vSourceCurrentMaxRedLine = vGlobalCurrentProduct->vXRaySourceCurrent +
		TempSourceCurrentTolerance;
	if (vSystemData.vSourceVoltageMinRedLine < 0)
		vSystemData.vSourceVoltageMinRedLine = 0;
	if (vSystemData.vSourceCurrentMinRedLine < 0)
		vSystemData.vSourceCurrentMinRedLine = 0;
	if (vSystemData.vSourceVoltageMaxRedLine > 15)
		vSystemData.vSourceVoltageMaxRedLine = 15;
	if (vSystemData.vSourceCurrentMaxRedLine > 15)
		vSystemData.vSourceCurrentMaxRedLine = 15;

	if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Setup Product Reference P Right: " + dtoa(vGlobalCurrentProduct->vReferenceRight, 2) + ", Left: " + dtoa(vGlobalCurrentProduct->vReferenceLeft, 2) +
					", Width: " + dtoa(vGlobalCurrentProduct->vReferenceWidth, 2), cDebugMessage);

	if (vGlobalFPGAVersion15Point2OrHigher)
	{ //for largo and forte, move A/B pixel to other end so not in middle of image
		if ((vConfigurationData->vScanTracType == cCaseInspectorScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || 
		//if ((vGlobalScanTracType == cAllegroScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || 
			(vConfigurationData->vScanTracType == cForteScanTrac))
			vSystemData.vABPixelAtOtherSide = true;
		else
			vSystemData.vABPixelAtOtherSide = false;

		SetABPixelToOtherEnd(vSystemData.vABPixelAtOtherSide);
	}
	else
		vSystemData.vABPixelAtOtherSide = false;

	if (vSystemData.vPreviousProduct == "")
	if (vGlobalCurrentProduct)
		vSystemData.vPreviousProduct = *vGlobalCurrentProduct->GetProductName();
	SetProductDensityDisplay();
	UpdateSubFunction8Button();

	SendRadiationDoorParameters();  //send if product has an overscan, keep door open longer

	ResetCounters(); //must call at the end to initialize the improve learn image

	vLastLearnState = 255;  //cause action event to log auto improve state
	if (!vSystemData.vYellowMessageButtonYellow)
		SetDlgItemText(IDC_StatusLine, _T(""));
	SetLearnState();

	if ((vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x100; //set bulk mode bit
	else
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & 0xFEFF;

	CSocketMessage TempMessage;
	TempMessage.vMessageFormat = 0;
	TempMessage.vMessageCommand = cSocketChangedProductsMessage;
	SendSocketAMessageFromServerToClients(&TempMessage);

	CheckLearnQuality();
	if (vGlobalCurrentProduct)
		CalculatePipelineEncoderAndTrigger();

#ifdef CompileInHTTPClientOperationsGuardian
	SendOGInfo(std::wstring(L"currentProduct"), vSystemData.vCurrentProductName, false);
#endif

//#ifdef UseHalconLibraries
//	if (vGlobalUseHalconLibrary)
//	{
//		//Reset Halcon Data Base
//		if (H_MSG_true == reset_obj_db(vSystemData.vITIPCDig->vOriginalBufferSizeX, vSystemData.vITIPCDig->vOriginalBufferSizeY, 1))
//		{
//			//set_system_width();
//			//set_system_height();
//			// temp set_system(’clip_region’,’true’);
//		}
//		else
//			ReportErrorMessage("Halcon Library Reset Error", cEMailInspx, 32000);
//	}
//#endif

	ReportErrorMessage("Loaded Current Product: " + vSystemData.vCurrentProductName, cAction,0);


	if (TempImagesThatAreWrongSize)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\n" + dtoa(TempImagesThatAreWrongSize,0) + " Demo Images are a different size from the setup size";
		TempNoticeDialog.vType = cNoticeMessage;
		TempNoticeDialog.DoModal();
	}

	/*
	CProduct *TempCalibrateProduct = GetProductByName("~Calibrate Gain");
	if ((TempCalibrateProduct) && (vGlobalCurrentProduct))
	{
		if ((vGlobalCurrentProduct->vXRayIntegrationTime != TempCalibrateProduct->vXRayIntegrationTime) ||
			(vGlobalCurrentProduct->vXRaySourceCurrent != TempCalibrateProduct->vXRaySourceCurrent))

		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\nThis Product's Exposure settings are Non-Standard.\nConsider changing to Standard setting in Exposure Menu";
		TempNoticeDialog.vType = cNoticeMessage;
		TempNoticeDialog.DoModal();
	}
	*/

	SetFirstTraceOfOscilloscopeToContainerTrigger();

	//Turn off CamLink Simulated Images in LVDS to CamLink board as loading product may accidentally command it on due to initialization noise on outputs
	if (vGlobalFrameGrabberType == cPC2CamLinkFrameGrabber)
	if (vSystemData.vITIPCDig->vCaptureModule)
	{
		vSystemData.vSimulatingCamLinkImage = false;
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		for (BYTE TempLoop = 0; TempLoop < 5; TempLoop++)
		{
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFA, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
		}
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
	}
	CalculateSensitivity();
	CloseWaitToSetupProduct();

	AllocateValveMonitoringData();
	ResetValveMonitoringData();
	ClearValveMonitoringFIFO();
	CheckInspectionNamesForOldInspections(!vSystemData.vInAutoSetup);
	CheckSystemSettingsAreStandard();

	if (vSystemData.vHadErrorTryRestart)
	{
		vSystemData.vHadErrorTryRestart = 0;
		ReportErrorMessage("Finished Loading Product after Calibrate Error", cWriteToLog, 0);

		int TimerResult = SetTimer(vStartRunningTimerHandle, 2000, NULL);
	}

	if (vGlobalCurrentProduct)
	if (vGlobalCurrentProduct->vNumberOfInspections)
	for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
	if (vGlobalCurrentProduct->vInspection[TempLoop])
	if ((vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection) || (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection) || 
		(vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection))
		vSystemData.vCheckWeighOffsetCalibrationNeeded = true;

	SetInterlockStatus();
	UpdateClearYellowMessageButton();
	UpdateButtons();

	if (TempNoticeText.GetLength() > 5)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = TempNoticeText;
		TempNoticeDialog.vType = cNoticeMessage;
		TempNoticeDialog.DoModal();
	}
	if (vGlobalCurrentProduct)
	if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
	if (((vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))))
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText =  "\n\nThis product is configured for Multi Lane.\n\nBulk mode should NOT be enabled";
		TempNoticeDialog.vType = cWarningMessage;
		TempNoticeDialog.DoModal();
	}

}

void CScanTracDlg::CreateImageAquisionThread()
{
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("SetupProduct Create Image Thread ScanTracDlg",cDebugMessage);

//	AcqSecurityAttribute.bool = true ;
//	AcqSecurity.lpSecurityDescriptor = (CREATE_SUSPENDED|THREAD_QUERY_INFORMATION);
//	AcqSecurity.nLength = 10;
	//image inspection thread lower priority than serial, but higher than User Interface

	if (vSystemData.vMemoryOK)
	{	//kjh here working on adding THREAD_QUERY_INFORMATION to thread for usage information
		// InitializeSecurityDescriptor 
		//PSECURITY_DESCRIPTOR pSD;
//		SECURITY_ATTRIBUTES AcqSecurityAttribute;
//		SECURITY_DESCRIPTOR sd;
//		PACL pACL = NULL;
//		if ((InitializeSecurityDescriptor(&sd,SECURITY_DESCRIPTOR_REVISION/* Required constant*/)) == false)
//		{
			vGlobalImageAquisitionThread = (CImageAquisitionThread *)AfxBeginThread(RUNTIME_CLASS(CImageAquisitionThread),
				THREAD_PRIORITY_ABOVE_NORMAL, 0, CREATE_SUSPENDED);		//|THREAD_QUERY_INFORMATION //THREAD_PRIORITY_HIGHEST
//		}
//		else
//		{
//			if ((SetSecurityDescriptorDacl(&sd,true,pACL,false))== true)
//			{
//				AcqSecurityAttribute.nLength = sizeof (SECURITY_ATTRIBUTES);
//				AcqSecurityAttribute.lpSecurityDescriptor = &sd;
//				AcqSecurityAttribute.bInheritHandle = false;
//
//				vGlobalImageAquisitionThread = (CImageAquisitionThread *)AfxBeginThread(
//					RUNTIME_CLASS(CImageAquisitionThread),
//					//THREAD_PRIORITY_HIGHEST
//					THREAD_PRIORITY_ABOVE_NORMAL
//					,0,CREATE_SUSPENDED,&AcqSecurityAttribute);		//
//			}
//		}
	}
	if (!vGlobalImageAquisitionThread)
	{
		ReportErrorMessage("Error-Could Not Create Image Aquisition Thread A", cEMailInspx,32000); 
	}
	else
	{
		vGlobalImageAquisitionThread->vLocalSystemData = &vSystemData;
		vGlobalImageAquisitionThread->vLocalConfigurationData = vConfigurationData;
		vGlobalImageAquisitionThread->vMainWindowPointer = this;
		/*
		TempAfinity = (AFFINITYMASK_IMAGE_AQUISITION & vGlobalSystemAffinityMask);
		if ((TempAfinity != 0) && (vGlobalSystemAffinityMask >= 0x0F))
		{
			if (vGlobalSystemAffinityMask == 0xFF)
				DWORD TempOriginalAffinityMask = ::SetThreadAffinityMask(vGlobalImageAquisitionThread->m_hThread, 0x20);
			else
			if (::SetThreadAffinityMask(vGlobalImageAquisitionThread->m_hThread,TempAfinity))
				vReplyOK |= 0x08;
		}
		*/
		vGlobalImageAquisitionThread->ResumeThread();
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("SetupProduct Created Image Thread ScanTracDlg",cDebugMessage);
	}
}

void CScanTracDlg::SetProductDensityDisplay()
{
	if (PasswordOK(cTemporaryInspxPassword,false))
		SetLearnState();
	else
	{
		CalculateSensitivity();
		if (vSystemData.vNumberOfSensitivities)
		{
			CString TempText = _T("-");
			TempText.LoadString(IDS_Sensitivity);
			SetDlgItemText(IDC_LearnState, TempText);
		}
		else
			SetDlgItemText(IDC_LearnState, _T(" "));
	}

	ShowOrHideProductDensityCompensation();
}

void CScanTracDlg::DoDiagnostics() 
{
	//Create diagnostic dialog box
	CNewDiagnosticDialog IDiagnosticDialog;  
	//Set dialog box data like how many products there are
	IDiagnosticDialog.vLocalProductCollection = &vProductCollection;
	IDiagnosticDialog.vLocalSystemData = &vSystemData;
	IDiagnosticDialog.vLocalConfigurationData = vConfigurationData;
	IDiagnosticDialog.vMainWindowPointer = this;

	//Pass control to dialog box and display
	int nResponse = IDiagnosticDialog.DoModal();
}

void CScanTracDlg::RampingSource()
{
	//vSystemData.vSourceRampedUp
	//for TD
	vSystemData.vSecondsMeasuringRealConveyorEncoder = 0;
	vSystemData.vRealConveyorEncoderPulsesCount = 0;
	if (!vConfigurationData->vUseRealEncoder)
	if ((!vSystemData.vFPGASimulateEncoderRate) && (!vConfigurationData->vContinuousFeedEncoderRate))
		vSystemData.vRealConveyorEncoderPulsesCount = 1;

	KillTimer(vSourceStabilizeTimerHandle);
	if ((vSystemData.vSystemRunMode != cStoppedSystemMode) || (vSystemData.vInAutoSetup))
		int TimerResult = SetTimer(vSourceStabilizeTimerHandle, cSourceStabilizeWaitTime,NULL);
}

void CScanTracDlg::HandleuControllerReset(WORD TempWatchDog)
{
	Sleep(250);  //need delay in case uC is powering up needs extra time for supplies
	//vSystemData.vShuttingDownXRays = true;
	if (vSystemData.vLogFile.vLogSerialData)
	{
		if (vSystemData.vuCResetCount <= 1)
			vSystemData.vLogFile.WriteToLogFile("Program Start Up-ScanTracDlg:uCReset",cDebugMessage);
		else
			vSystemData.vLogFile.WriteToLogFile("Error-ScanTracDlg:uCReset",cDebugMessage);
	}
	RemoveAllContainers();
	Sleep(10);

	//ask for FPGA Version
	tSerialCommand TempCommand;
	TempCommand[0] = 0x39;
	TempCommand[1] = vSystemData.vuCHealthFactor;
	TempCommand[2] = 0x00;
	TempCommand[3] = 0x00;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);
		
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
		vGlobaluCSerialPort->TurnAlarmOnOff(3,false);//turn off Critical Alarm bit
	}
	vSystemData.vEnableduC16HzInterrupt = true;
	vSystemData.vuCSimulate16Hz = false;
	vSystemData.vuCOutputSerialDebugData = false;
	vSystemData.vuControllerSendExtraDiagnosticMessages = false;
	if (!vConfigurationData->vDemoMode)
		vSystemData.vUControllerReady = false;

	//Open shutter, and set mode it should be in when running to auto mode
	vSystemData.vRadiationDoorManualControlRegister = cRadiationShutterAutoControl;
	//set current status to something different, so definetly sends open command
	vSystemData.vRadiationDoorManualControlCurrentStatus = cRadiationShutterAutoControl;

	if (vSystemData.vSystemRunMode != cStoppedSystemMode)
	{
		StopRunning(true);
	}

	if (vGlobaluCSerialPort)
	{
		SendXRayPowerOnOffToUController(0);
		Sleep(cSendCommandSleepTimeSetup);
		SendConveyorOnOffToUController(0);
		Sleep(cSendCommandSleepTimeSetup);
	}

	//turn simulated encoder off
	//must do when start to select real encoder
	vSystemData.vFPGASimulateEncoderRate = 0;
	TurnSimulatedEncoderOff();
	TurnSimulatedContainersOff();
	TurnOnOffFPGASimulatedData(false);

	//send ejector enable/disable command
	if (vConfigurationData->vEjectContainersNotInspected)
		vGlobaluCSerialPort->EnableDisableEjectors(true);
	else
	{
		//flash yellow lights 
		vGlobaluCSerialPort->EnableDisableEjectors(vConfigurationData->vEnableEjectors);
		if ( vConfigurationData->vEnableEjectors == false )
		{
			int TimerResult = SetTimer(vFlashYellowLightTimerHandle,500,NULL);
		}
	}
	Sleep(cSendCommandSleepTimeSetup);

	//turn diverter off since uC just reset
	if (vConfigurationData->vDiverterEjector)
	if (vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vEnabled)
	{
		vGlobaluCSerialPort->SendEjectorOnOffCommand(vConfigurationData->vDiverterEjector,0);
		if (vSystemData.vLogFile.vLogSerialData)
			vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Turn Diverter Off",
			vSystemData.vCurrentBeltPosition);
	}
	vSystemData.vDiverterOn = false;
	Sleep(cSendCommandSleepTimeSetup);

	//send Can Stop Off command
	vGlobaluCSerialPort->TurnCanStopOnOff(1, false);
	Sleep(cSendCommandSleepTimeSetup);
	vGlobaluCSerialPort->TurnCanStopOnOff(2, false);
	Sleep(cSendCommandSleepTimeSetup);

	//send Alarms Off command
	vGlobaluCSerialPort->TurnAlarmOnOff(1,false);//clear alarm 1, 2, 3 bits
	Sleep(cSendCommandSleepTimeSetup);
	vGlobaluCSerialPort->TurnAlarmOnOff(4,false);//clear system inspection output bit
	Sleep(cSendCommandSleepTimeSetup);

	vSystemData.vCurrentLampStatus = 1;

	vGlobaluCSerialPort->TurnOnOffRedLamp(false);
	Sleep(cSendCommandSleepTimeSetup);

	Sleep(100);
		
	if ((vSystemData.vSimulateContainersRate) || (vConfigurationData->vContinuousFeedContainerRate))
		TurnSimulatedContainersOff();

	Sleep(100);

	if (vGlobalCurrentProduct)
		SetupProduct(vGlobalCurrentProduct, false);
	//else
	//	SendInitializationToUController(false);

	if (vGlobaluCSerialPort)
	if (vSystemData.vuCResetCount > 1)
	{
		vGlobaluCSerialPort->TurnOnOffYellowLamp(true);
		//vGlobaluCSerialPort->TurnAlarmOnOff(3,true);//turn on Critical Alarm bit
	}
	Sleep(1000);
	vSystemData.vFPGAGeneratingSimulatedData = false;

	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
		vGlobaluCSerialPort->TurnAlarmOnOff(3,false);//turn off Critical Alarm bit
	}
	TurnSimulatedEncoderOff();
}

void CScanTracDlg::ClearYellowWarningButton() 
{
	if (vSystemData.vYellowMessageButtonYellow)
	{
		ReportErrorMessage("Operator pressed Clear Yellow Message Button", cUserAction,0);
		if (vSystemData.vCantInspectError)
		{
			vSystemData.vCantInspectError = false;
			vGlobaluCSerialPort->TurnOnOffBlueLamp(false);
				
			if (vConfigurationData->vEnableEjectors)		//if ejectors are enabled turn off flashing, if ejectors disabled keep yellow flashing
			{
				KillTimer(vFlashYellowLightTimerHandle);
				if (vSystemData.vYellowMessageButtonYellow)
					vGlobaluCSerialPort->TurnOnOffYellowLamp(true);
				else
					vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
			}
		}
		vSystemData.vWaitingForUControllerReady = false;
		vSystemData.vYellowMessageButtonYellow = false;
		if (vGlobaluCSerialPort)
		{
			vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
			vGlobaluCSerialPort->TurnAlarmOnOff(3,false);//turn off Critical Alarm bit and alarm 1,2
		}
		UpdateClearYellowMessageButton();
		SetDlgItemText(IDC_StatusLine, _T(""));

		if (vConfigurationData->vAutoImproveEnabled)
		if ((vGlobalLearnState) && (vGlobalLearnState != 255)) //colors for Improving Learn - Do not test contaminants indicator
		{
			CString TempText = "-";
			TempText.LoadString(IDS_ImprovingLearnDonottestsmallcontaminants);
			SetDlgItemText(IDC_StatusLine, TempText);
		}

		CWnd *TempWindow = CWnd::GetDlgItem(IDC_PercentRejectLabel);
		if (TempWindow)
			TempWindow->Invalidate(false);

		TempWindow = CWnd::GetDlgItem(IDC_PercentRejected);
		if (TempWindow)
			TempWindow->Invalidate(false);

		if (vGlobalCurrentProduct)
		for (BYTE TempLoop = 0; TempLoop < 2; TempLoop++)
		if (vSystemData.vGaveTooManyRejectsAlarm[TempLoop])
		{
			vSystemData.vGaveTooManyRejectsAlarm[TempLoop] = false;
			//turn alarm output bit off
		}
	}
	else //clear yellow light even if don't think it is set
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->TurnOnOffYellowLamp(true);
		vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
		Sleep(10);
		vGlobaluCSerialPort->TurnAlarmOnOff(3,false);//turn off Critical Alarm bit and alarm 1,2
		ClearRedStatusIndicator();
		vSystemData.vCantInspectError = false;
		if (vConfigurationData->vEnableEjectors)		//if ejectors are enabled turn off flashing, if ejectors disabled keep yellow flashing
		{
			KillTimer(vFlashYellowLightTimerHandle);	//killtimer 
		}
	}
}

void CScanTracDlg::UpdateClearYellowMessageButton() 
{
	if (vSystemData.vYellowMessageButtonYellow)
	{
		m_SubFunction6Button.ShowWindow(SW_SHOW);
		CString TempText = " ";
		TempText.LoadString(IDS_ClearYellowMessage);
		SetDlgItemText(IDC_SubFunction6Button,TempText);
	}
	else
	if ((PasswordOK(cTemporaryInspxPassword,false)) &&
		(/*(vSystemData.vHadABrownOut) || (vSystemData.vHadAnACPowerDropOut) ||*/ (vSystemData.vMissingRAM) || (vSystemData.vEjectTooLateMessageGivenThisRun) ||
		(vSystemData.vAirConditionerFailed) || (vSystemData.vProductHasAPoorLearn) || (vSystemData.vProductHasAnOldInspection) || //(vSystemData.vDetectorCalibrationNeeded) ||
			((vConfigurationData->vEnableOperationsGuardian) && (vSystemData.vOperationsGuardianError)) ||
		(vSystemData.vDisplayingAnEncoderError)))
	{
		m_SubFunction6Button.ShowWindow(SW_SHOW);
		SetDlgItemText(IDC_SubFunction6Button, _T("Clear\nRed\nIndicator"));
	}
	else
	{
		m_SubFunction6Button.ShowWindow(SW_HIDE);
		this->InvalidateRect(&m_SubFunction6Button.GetRectToInvalidateArrow());
	}
}

void CScanTracDlg::UpdateDisableEjectorsButton()
{
	if (vConfigurationData->vEnableEjectors)
	{
		if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
			TempText.LoadString(IDS_DisableEjectors);
		else
			TempText.LoadString(IDS_DisableContainerEjectors);
		SetDlgItemText(IDC_SubFunction2Button,TempText);
		m_EjectorsDisabled.ShowWindow(SW_HIDE);
	}
	else
	if (!vDisplayingVersion)
	{
		if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
			TempText.LoadString(IDS_EnableEjectors);
		else
			TempText.LoadString(IDS_EnableContainerEjectors);
		SetDlgItemText(IDC_SubFunction2Button,TempText);
		TempText.LoadString(IDS_EjectorsDisabled);
		SetDlgItemText(IDC_EjectorsDisabled,TempText);
		m_EjectorsDisabled.ShowWindow(SW_SHOW);
	}
}

void CScanTracDlg::ChangeDisplays() 
{
	if (!vDisplayingVersion)
	{
		vSystemData.vMainDisplayMode = cMainDisplayImage;
		//don't change as can't find menu if someone tries to open a second copy this->SetWindowText("ScanTrac Main");

		if (!vSystemData.vLastChatWindowText.GetLength())
			m_LearnState.ShowWindow(SW_SHOW); 

		if ((vSystemData.vCurrentBrightnessAdjustment > 50.0) ||
			(vSystemData.vCurrentBrightnessAdjustment < -50.0))
		{
			if (!m_DensityLockTooFarOff.IsWindowVisible())
			{
				m_DensityLockTooFarOff.ShowWindow(SW_SHOW);
			}
		}

		if (vGlobalBackupHardDriveThread)  //backing up
			m_DoNotShutOffPower.ShowWindow(SW_SHOW);

		m_Function1Button.ShowWindow(SW_HIDE);
		this->InvalidateRect(&m_Function1Button.GetRectToInvalidateArrow());

		m_Function2Button.ShowWindow(SW_SHOW);
		m_Function2Button.ModifyStyle(NULL,SS_CENTERIMAGE,NULL);
		TempText.LoadString(IDS_Setup);
		SetDlgItemText(IDC_Function2Button,TempText);

		m_Function3Button.ShowWindow(SW_SHOW);
		m_Function3Button.ModifyStyle(NULL,SS_CENTERIMAGE,NULL);
		TempText.LoadString(IDS_Diagnostics);
		SetDlgItemText(IDC_Function3Button,TempText);

		m_Function4Button.ModifyStyle(NULL,SS_CENTERIMAGE,NULL);
		m_Function4Button.ShowWindow(SW_SHOW);
		TempText.LoadString(IDS_Rejects);
		if (!vHaveRejects)
		{
			TempText.LoadString(IDS_NoRejects);
		}
		SetDlgItemText(IDC_Function4Button,TempText);

		m_Function5Button.ShowWindow(SW_HIDE);
		this->InvalidateRect(&m_Function5Button.GetRectToInvalidateArrow());

		UpdateRunButton();

		m_SubFunction5Button.ShowWindow(SW_SHOW);
		TempText.LoadString(IDS_ShowProductionSummary);
		SetDlgItemText(IDC_SubFunction5Button,TempText);

		CString TempText = " ";
		vDialogTitleString.LoadString(IDS_MainMenu);
#ifdef _DEBUG
		vDialogTitleString = "Test Version";
#endif
		SetDlgItemText(IDC_DialogTitleStaticText1,vDialogTitleString);

		m_ContainersPerMinuteControl.ModifyStyle(SS_LEFT,SS_CENTER,NULL);
		ShowCPM();

		m_MainBackground2.ShowWindow(SW_SHOW);
		m_TotalGoodStaticText.ShowWindow(SW_HIDE);
		m_TotalGoodLabelStaticTextControl.ShowWindow(SW_HIDE);

		if (vConfigurationData->vSupportContractType != cHideSupportContractDisplay)
		{
			m_SupportContract.ShowWindow(SW_SHOW);
			m_SupportContract2.ShowWindow(SW_SHOW);
		}
		m_SupportContract.ModifyStyle(SS_CENTERIMAGE,NULL,NULL);

		m_SupportContract2.ModifyStyle(SS_CENTERIMAGE,NULL,NULL);

		m_RejectReason.ShowWindow(SW_SHOW);
		m_RejectReason.ModifyStyle(SS_CENTERIMAGE,NULL,NULL);

		CWnd *TempWindow = this;
		if (TempWindow)
			TempWindow->Invalidate(false);
		UpdateDisplay();
		UpdateButtons();
		UpdateSubFunction8Button();
	} //end of ChangeDisplays
}

void CScanTracDlg::UpdateSubFunction8Button() 
{
	CString TempText = " ";
	if (vSystemData.vITIPCDig->vImageDisplayOnlyRejects)
	{
		TempText.LoadString(IDS_DisplayAllImages);
		SetDlgItemText(IDC_SubFunction8Button,TempText);

		TempText.LoadString(IDS_ShowingRejects);

		if (vGlobalCurrentProduct)
		{
			WORD TempMask = 0xFFFF;
			TempMask = TempMask << (vGlobalCurrentProduct->vNumberOfInspections + vSystemData.vNumberOfShapeInspections + vGlobalCurrentProduct->vNumberOfAuxiliaryDetectors);

			TempMask = 
				vGlobalCurrentProduct->vTypesOfRejectsToView | TempMask;

			if (TempMask != 0xFFFF)
			{
				CString TempText1 = " ";
				TempText1.LoadString(IDS_Filtered_First_Letter);
				TempText = TempText + " (" + TempText1 + ")";
			}
		}
	}
	else
	{
		TempText.LoadString(IDS_DisplayOnlyRejects);
		SetDlgItemText(IDC_SubFunction8Button,TempText);
		TempText.LoadString(IDS_ShowingAllImages);
	}
	if (!vDisplayingVersion)
		m_ShowingRejects.ShowWindow(SW_SHOW);
	SetDlgItemText(IDC_ShowingRejects,TempText);
}

void CScanTracDlg::EditShift(bool bNewProductSelected) 
{
	if (vConfigurationData->vAskForProductionReportProductCode == 1)
	{
		//Create dialog box
		CSelectItemDialog ISelectItemDialog;   
		
		//Set dialog box data titles and number value
		int StringCount;
		int i;
		int ProductCodeStringLength;		
		int ProductCodesCount;
		CString TempTextD;
		CString NewCopyProductCodeCString;   // next string to use for ProductCodeCString
		CString TempCopyProductCodeCString;	 // current ProductCodeCString, string taken apart to create abouve NewCopyProductCodeCString

		// in previous function vSaveProductCodeTemp = vSystemData.vShiftProductCode; 
		StringCount = 0;
		ISelectItemDialog.vTitleString = "Select Product Code";
		ISelectItemDialog.m_DialogTitleStaticText2 = "Current Product: " + vSystemData.vCurrentProductName;
		if (vSaveProductCodeTemp.GetLength() > 1)
		{
			ISelectItemDialog.m_DialogTitleStaticText3 = "Previous Code used: " + vSaveProductCodeTemp;

			if (vSystemData.vPreviousProduct != *vGlobalCurrentProduct->GetProductName())
			{
				ISelectItemDialog.m_DialogTitleStaticText3 = ISelectItemDialog.m_DialogTitleStaticText3 + " on Product: " + vSystemData.vPreviousProduct;
			}
		}
		else
			ISelectItemDialog.m_DialogTitleStaticText3 = " ";

		ISelectItemDialog.vBackgroundColor = cGreen;
		ISelectItemDialog.vNumberOfItems = 0;
		
		//kjh
		ISelectItemDialog.vItems[ISelectItemDialog.vNumberOfItems++]  = _T("None");
		ISelectItemDialog.vItems[ISelectItemDialog.vNumberOfItems++]  = _T("New");	
		
		if (vGlobalCurrentProduct->vProductCodeSelectionCString.IsEmpty() != true)
		{
			TempCopyProductCodeCString = vGlobalCurrentProduct->vProductCodeSelectionCString.GetBuffer(vGlobalCurrentProduct->vProductCodeSelectionCString.GetLength());

			if (TempCopyProductCodeCString.Find('&') != -1) // if string has a '&'
			{
				ISelectItemDialog.vItems[ISelectItemDialog.vNumberOfItems++] = _T("Delete Product Code");		// if no items, can not delete an item
		
				TempTextD = "";
				NewCopyProductCodeCString = "";

				while (((ProductCodeStringLength = TempCopyProductCodeCString.GetLength()) > 0) && (StringCount <= cMaximumNumberOfSelectProductCodes))
				{
					ProductCodesCount = TempCopyProductCodeCString.Find('&');
					if (ProductCodesCount > 0)		// if '&' found
					{
						if (ProductCodesCount > (cDisplayProductCodeCount + 1))  // +1 to disclude &, for loop runs 0 to ProductCodesCount 
						{
							ReportErrorMessage("Product Code String Corrupted, Shortened", cEMailInspx, 32000);
							ProductCodesCount = cDisplayProductCodeCount;		// if string is corrupted, clear problem . . . hopefully
						}
						if (ProductCodesCount > TempCopyProductCodeCString.GetLength())
							ProductCodesCount = TempCopyProductCodeCString.GetLength() - 1;

						TempTextD = "";
						for (i = 0; i < ProductCodesCount; i++)
						{
							TempTextD += TempCopyProductCodeCString[i];
						}
						NewCopyProductCodeCString += TempTextD;
						NewCopyProductCodeCString += "&";
						ISelectItemDialog.vItems[ISelectItemDialog.vNumberOfItems++] = TempTextD;
						StringCount++;
						TempCopyProductCodeCString = TempCopyProductCodeCString.Mid(i+1);  // drop off first part of string and &
					}
				}
			}

			vGlobalCurrentProduct->vProductCodeSelectionCString = NewCopyProductCodeCString;
		}
		//Pass control to dialog box and display
		int nResponse1 = ISelectItemDialog.DoModal();
		//dialog box is now closed, if user pressed select do this
		//if user pressed cancel, do nothing
		BYTE TempProductCodeType;
		CString TempTextB = " ";
		CAlphaEntryDialog IAlphaEntryDialog;
		IAlphaEntryDialog.vLocalSystemData = &vSystemData;
		IAlphaEntryDialog.vMainWindowPointer = this;
		if (nResponse1 == IDOK)
		{
			int nResponse2;
			int nResponse4;
			//add on if not inspx above advanced contaminant so select correct item since don't have
			TempProductCodeType = ISelectItemDialog.vItemNumberSelected;
			switch (TempProductCodeType)
			{
				case 0:
				break;
				case 1: 
					vSystemData.vShiftProductCode = " ";		
					UpdateCurrentProductNameDisplay();
				break;
				case 2: 
					if (StringCount > cMaximumNumberOfSelectProductCodes)		//need to delete an entry first, send message 
					{
						if (bNewProductSelected == false)
						{
							vSystemData.vShiftProductCode = vSaveProductCodeTemp;
						}
						CNoticeDialog TempNoticeDialog;
						CString TempTextC = " ";
						CString TempText1 = " ";
						TempTextC.Format(_T("\n\nYou cannot add more Product Codes.\nMaximum Number of Product Codes"));
						TempText1.Format(_T("\nDelete a product code first."));	// StringCount 0, 1, 2, for none, new, and delete
						TempNoticeDialog.vNoticeText =  TempTextC + ": " + dtoa((cMaximumNumberOfSelectProductCodes-2),0) + " " + TempText1 + ".";
						TempNoticeDialog.vType = cErrorMessage;
						TempNoticeDialog.DoModal();
					}
					else
					{
						// add product code here
						//CAlphaEntryDialog IAlphaEntryDialog;  
						//Set dialog box data titles and number value
						IAlphaEntryDialog.vEditString = "";//vSystemData.vShiftProductCode;
						//CString TempTextB = " ";
						TempTextB.LoadString(IDS_ProductCodeLotDateCodeShiftorOperator);
						IAlphaEntryDialog.m_DialogTitleStaticText = TempTextB; //"Product Code, Lot Date Code, Shift, or Operator";
						if (vSystemData.vShiftProductCode.GetLength() > 1)
						{
							TempTextB.LoadString(IDS_OriginalValue);
							IAlphaEntryDialog.m_DialogTitleStaticText2 = TempTextB + ": " + vSystemData.vShiftProductCode;
						}
						else
							IAlphaEntryDialog.m_DialogTitleStaticText2 = " ";

						IAlphaEntryDialog.m_DialogTitleStaticText3 = "For Product: " + vSystemData.vCurrentProductName;
						IAlphaEntryDialog.vLocalSystemData = &vSystemData;
						IAlphaEntryDialog.vAllowDashes = true;
						IAlphaEntryDialog.vAllowMoreThan32Characters = false;
						IAlphaEntryDialog.vAllowSlashes = true;
						IAlphaEntryDialog.vAllowPeriod = true;
						IAlphaEntryDialog.vBlankNameOK = true;
						//Pass control to dialog box and display
						nResponse2 = IAlphaEntryDialog.DoModal();
						//dialog box is now closed, if user pressed select do this
						//if user pressed cancel, do nothing
						if (nResponse2 == IDOK)
						{
							WORD TempLength = IAlphaEntryDialog.vEditString.GetLength();
							WORD TempReturnPosition = IAlphaEntryDialog.vEditString.Find((char)13,0);
							if (TempLength > cDisplayProductCodeCount)
								TempLength = cDisplayProductCodeCount;
							if (TempReturnPosition < TempLength)
								TempLength = TempReturnPosition;		// also add the product.str string
							CString MaybeNewStringToSave = IAlphaEntryDialog.vEditString.GetBufferSetLength(TempLength);

							if (TempLength > 0)	// if there is a string returned
							{
								// does product code already exist, if so select it and continue, do not re-add it
								int StringExistsCheck;
								BOOL FoundStringMatch;
								BOOL FoundStringPosition;
								FoundStringMatch = false;
								FoundStringPosition = false;

								// find position of new string in product code and add
								TempCopyProductCodeCString = NewCopyProductCodeCString; // reload CString with copy of current product code cstring
								StringExistsCheck = 0;
								NewCopyProductCodeCString = "";		// reset/reload NewCopyProductCString

								// if a match, skip adding string, if greater than current string keep going, if less than current string, add then add current string
								while ((StringExistsCheck <= StringCount)  && (FoundStringMatch == false) && (FoundStringPosition == false))
								{
									//go through list of strings here
									if ((ProductCodesCount = TempCopyProductCodeCString.Find('&')) != -1)	// if there are strings in the product codes already
									{
										ProductCodeStringLength = TempCopyProductCodeCString.GetLength();
										if (ProductCodesCount > (cDisplayProductCodeCount + 1))  // +1 to disclude &, for loop runs 0 to ProductCodesCount 
										{
											ProductCodesCount = cDisplayProductCodeCount;		// if string is corrupted, clear problem . . . hopefully
										}
										TempTextD = "";
										for (i = 0; i < ProductCodesCount; i++)
										{
											TempTextD += TempCopyProductCodeCString[i];
										}
										TempCopyProductCodeCString = TempCopyProductCodeCString.Mid(i+1);  // drop off next part of string and &

										int TempCompareStrings;
										if ((TempCompareStrings = TempTextD.CompareNoCase(MaybeNewStringToSave)) == 0) // string had a match, do not enter it, exit
										{
											FoundStringMatch = true;
											// if string already exists, but case is different, replace case type in product string, do not add both strings
											NewCopyProductCodeCString += MaybeNewStringToSave;
											NewCopyProductCodeCString += "&";
											
											// add remainder of product string
											NewCopyProductCodeCString += TempCopyProductCodeCString;
										}
										else
										{
											if (TempCompareStrings < 0)	// keep looking for place to put in string
											{
												NewCopyProductCodeCString += TempTextD;
												NewCopyProductCodeCString += "&";
											}
											else // (TempCompareStrings > 0)  // string location is here,  last string check was greater than
											{
												FoundStringPosition = true;
												NewCopyProductCodeCString += MaybeNewStringToSave;
												NewCopyProductCodeCString += "&";
												NewCopyProductCodeCString += TempTextD;
												NewCopyProductCodeCString += "&";
												NewCopyProductCodeCString += TempCopyProductCodeCString;
											}
										}	
									}
									else // string to look at is empty, add item and exit
									{
										FoundStringPosition = true;
										NewCopyProductCodeCString += MaybeNewStringToSave;
										NewCopyProductCodeCString += "&";
									}
									StringExistsCheck++;	
								}												
								vSystemData.vShiftProductCode = MaybeNewStringToSave;
								vGlobalCurrentProduct->vProductCodeSelectionCString = NewCopyProductCodeCString;
								UpdateCurrentProductNameDisplay();
								ReportErrorMessage("Changed Product Code: " + MaybeNewStringToSave, cUserChanges,0);
							}
						}
						// end add another product code
						else if (nResponse2 == 10)
						{
							//Main Menu button pressed
							CDialog::EndDialog(10);
						}
						else
						{
							if (bNewProductSelected == false)
							{
								vSystemData.vShiftProductCode = vSaveProductCodeTemp;
							}
							UpdateCurrentProductNameDisplay();
						}
					}
				break;

				case 3:		// delete a Product Code
					StringCount = 0;
					TempCopyProductCodeCString = NewCopyProductCodeCString; // reload CString with copy of current product code cstring

					if (TempCopyProductCodeCString.Find('&') != -1) // if string has a '&'
					{		
						// Create dialog box to select item to delete
						CSelectItemDialog ASelectItemDialog;   

						ASelectItemDialog.vTitleString = "Select Product Code to Delete";
						// ISelectItemDialog.m_DialogTitleStaticText2 = "";
						// ISelectItemDialog.m_DialogTitleStaticText3 = "";
						ASelectItemDialog.vBackgroundColor = cGreen;
						ASelectItemDialog.vNumberOfItems = 0;

						TempTextD = "";
						NewCopyProductCodeCString = "";		// re check new copy product code cstring
						ASelectItemDialog.vNumberOfItems = 0;

						while (((ProductCodeStringLength = TempCopyProductCodeCString.GetLength()) > 0) && (StringCount <= cMaximumNumberOfSelectProductCodes))
						{
							ProductCodesCount = TempCopyProductCodeCString.Find('&');
							if (ProductCodesCount != -1)		// if '&' found
							{
								if (ProductCodesCount > (cDisplayProductCodeCount + 1))  // +1 to disclude &, for loop runs 0 to ProductCodesCount 
								{
									ProductCodesCount = cDisplayProductCodeCount;		// if string is corrupted, clear problem . . . hopefully
								}
								TempTextD = "";
								for (i = 0; i < ProductCodesCount; i++)
								{
									TempTextD += TempCopyProductCodeCString[i];
								}
								NewCopyProductCodeCString += TempTextD;
								NewCopyProductCodeCString += "&";
								ASelectItemDialog.vItems[ASelectItemDialog.vNumberOfItems++] = TempTextD;
								StringCount++;
								TempCopyProductCodeCString = TempCopyProductCodeCString.Mid(i+1);  // drop off first part of string and &
		
							}
						}		

						nResponse4 = ASelectItemDialog.DoModal();
						//dialog box is now closed, if user pressed select do this
						if (nResponse4 == IDOK)
						{
							int ItemToDelete = ASelectItemDialog.vItemNumberSelected;
							TempCopyProductCodeCString = NewCopyProductCodeCString; // reload CString with copy of current product code cstring
							NewCopyProductCodeCString = "";
							// if ItemtoDelete is not cancel and <= Number of Items on the list
							if ((ItemToDelete > 0) && (ItemToDelete <= StringCount))
							{
								int ProductStringLocation;
 								// delete Product Code 1 through cMaximumNumberOfSelectProductCodes, StringCount = # items
								for (ProductStringLocation = 1; ProductStringLocation <= StringCount; ProductStringLocation++)
								{
									// location of a copy of the product codes string NewCopyProductCodeCString.
									ProductCodesCount = TempCopyProductCodeCString.Find('&');
									if (ProductCodesCount != -1)
									{
										TempTextD = "";
										int ProductCodeCharLocation;
										for (ProductCodeCharLocation = 0; ProductCodeCharLocation < ProductCodesCount; ProductCodeCharLocation++)
										{
											TempTextD += TempCopyProductCodeCString[ProductCodeCharLocation];
										}
										if (ProductStringLocation != ItemToDelete)	// if not item to delete, add item to string, -1 for actual location
										{									
											// update GUI, locations start at address 0; 0 = none, 1 = new, 2 = delete
	// menu do not need to re-display						ISelectItemDialog.vItems[ProductStringLocation+2] = TempTextD;
											//update product string
											NewCopyProductCodeCString = NewCopyProductCodeCString + TempTextD + '&';
										}
										else
										{   // vSystemData.vShiftProductCode
											// if same as currently selected, put none in current selection
											if (TempTextD.CompareNoCase(vSaveProductCodeTemp) == 0)
											{
												vSaveProductCodeTemp = " ";		// clear saved Product Code, it is the one being deleted
											}
											// UpdateCurrentProductNameDisplay();	// update ate end
	// menu do not need to re-display						ISelectItemDialog.vNumberOfItems--;		// one less item on list
											// deleteing string so dont add -- NewCopyProductCodeCString += TempTextD;
										}
										TempCopyProductCodeCString = TempCopyProductCodeCString.Mid(ProductCodeCharLocation+1);  // drop off item processed in string 
									}
								}
								// update Global vProductCodeSelectionCString
								vGlobalCurrentProduct->vProductCodeSelectionCString = NewCopyProductCodeCString.GetBuffer(NewCopyProductCodeCString.GetLength());
							}
							if (bNewProductSelected == true)		// this is a new product than before, if delete, clear vShiftProductCode
							{
								vSaveProductCodeTemp = " ";			
							}
							//else if (bNewProductSelected == false)  <<<-- below
							//{
							//	vSystemData.vShiftProductCode = vSaveProductCodeTemp;
							//}
							vSystemData.vShiftProductCode = vSaveProductCodeTemp;
							UpdateCurrentProductNameDisplay();
						}
						else if (nResponse4 == 10)
						{
							//Main Menu button pressed
							CDialog::EndDialog(10);
						}
						else
						{
							if (bNewProductSelected == false)
							{
								vSystemData.vShiftProductCode = vSaveProductCodeTemp;
							}
							UpdateCurrentProductNameDisplay();
						}

					}	//end if & in string
					else
					{
						//delete fail message ??
					}
				break;

				case 4:
				case 5:
				case 6:
				case 7:
				case 8:
				default:
					// find corresponding product code and output
					TempCopyProductCodeCString = NewCopyProductCodeCString;
					int TempLocationOfProductCode = TempProductCodeType - 3; // sequential product code
					int TempFindLocationOfSelectedProductCode = 0;
					BOOL TempProductCodeFound = false;

					while ((TempFindLocationOfSelectedProductCode < TempLocationOfProductCode) && (TempProductCodeFound == false))
					{
						TempTextD = "";
						ProductCodesCount = TempCopyProductCodeCString.Find('&');
						if (ProductCodesCount != -1)
						{
							//int ProductCodeCharLocation;
							for (i = 0; i < ProductCodesCount; i++)
							{
								TempTextD += TempCopyProductCodeCString[i];
							}
							TempFindLocationOfSelectedProductCode++;

							if (TempLocationOfProductCode == TempFindLocationOfSelectedProductCode)	// if not item to delete, add item to string, -1 for actual location
							{									
								TempProductCodeFound = true;
							}
							else
							{   
								TempCopyProductCodeCString = TempCopyProductCodeCString.Mid(i+1);  // drop off first part of string and &
							}
						}
						else
						{
								TempProductCodeFound = true;		//if here use blank product code
						}
					}
					vSystemData.vShiftProductCode = TempTextD;		// 
					ReportErrorMessage("Changed Product Code: " + vSystemData.vShiftProductCode, cUserChanges,0);
					UpdateCurrentProductNameDisplay();
				break;
			}
		}
		else
		{
			if (bNewProductSelected == true)
			{
				// if initial start up menu and as for Product code and main menu or default is pressed,
				vSystemData.vShiftProductCode = " ";		
	//				UpdateCurrentProductNameDisplay();
			}
			else
			{
				if (bNewProductSelected == false)
				{
					vSystemData.vShiftProductCode = vSaveProductCodeTemp;
				}
			}
			UpdateCurrentProductNameDisplay();
		}
	}
	else
	if (vConfigurationData->vAskForProductionReportProductCode == 2)
	{
		// enter product code each time
		CAlphaEntryDialog IAlphaEntryDialog;  
		//Set dialog box data titles and number value
		IAlphaEntryDialog.vEditString = vSystemData.vShiftProductCode;
		CString TempText = " ";
		TempText.LoadString(IDS_ProductCodeLotDateCodeShiftorOperator);
		IAlphaEntryDialog.m_DialogTitleStaticText = TempText; //"Product Code, Lot Date Code, Shift, or Operator";
		if (vSystemData.vPreviousShiftProductCode.GetLength() > 1)
			IAlphaEntryDialog.m_DialogTitleStaticText2 = "Previous Product Code: " + vSystemData.vPreviousShiftProductCode;
		IAlphaEntryDialog.vLocalSystemData = &vSystemData;
		IAlphaEntryDialog.vAllowDashes = true;
		IAlphaEntryDialog.vAllowMoreThan32Characters = true;
		IAlphaEntryDialog.vAllowSlashes = true;
		IAlphaEntryDialog.vAllowPeriod = true;
		IAlphaEntryDialog.vBlankNameOK = true;
		//Pass control to dialog box and display
		int nResponse = IAlphaEntryDialog.DoModal();
		//dialog box is now closed, if user pressed select do this
		//if user pressed cancel, do nothing
		if (nResponse == IDOK)
		{
			WORD TempLength = IAlphaEntryDialog.vEditString.GetLength();
			WORD TempReturnPosition = IAlphaEntryDialog.vEditString.Find((char)13,0);
			if (TempLength > 18)
				TempLength = 18;
			if (TempReturnPosition < TempLength)
				TempLength = TempReturnPosition;
			vSystemData.vShiftProductCode = IAlphaEntryDialog.vEditString;
			CString TempString(vSystemData.vShiftProductCode);
			if (TempLength < vSystemData.vShiftProductCode.GetLength())
				TempString.Delete(TempLength,TempString.GetLength() - TempLength);
			ReportErrorMessage("Changed Product Code: " + vSystemData.vShiftProductCode, cAction,0);
			UpdateCurrentProductNameDisplay();
			vSystemData.vPreviousShiftProductCode = vSystemData.vShiftProductCode;
		}
	}
}

void CScanTracDlg::ChatWindow() 
{
	// Shift Button was pressed
	CAlphaEntryDialog IAlphaEntryDialog;  
	IAlphaEntryDialog.vMainWindowPointer = this;
	//Set dialog box data titles and number value
	IAlphaEntryDialog.vEditString = vSystemData.vLastChatWindowText;
	IAlphaEntryDialog.m_DialogTitleStaticText = "Chat Window";

	IAlphaEntryDialog.m_DialogTitleStaticText2 = "";
	IAlphaEntryDialog.vChatMode = true;
	IAlphaEntryDialog.vAllowPeriod = true;
	IAlphaEntryDialog.vAllowDashes = true;
	IAlphaEntryDialog.vLocalSystemData = &vSystemData;
	IAlphaEntryDialog.vBlankNameOK = true;
	//Pass control to dialog box and display
	int nResponse = IAlphaEntryDialog.DoModal();
	//dialog box is now closed, if user pressed select do this
	//if user pressed cancel, do nothing
	//if (nResponse == 111)
	//{
	//	vSystemData.vLastChatWindowText = IAlphaEntryDialog.vEditString;
	//}
	//else
	if ((nResponse == IDOK) && (IAlphaEntryDialog.vEditString.GetLength() > 2))
	{
		vSystemData.vLastChatWindowText = IAlphaEntryDialog.vEditString;
		m_ChatMessage.ShowWindow(SW_SHOW);
		CString TempStringToShow = vSystemData.vLastChatWindowText;
		TempStringToShow.Replace(_T("\n"), _T(" "));
		WORD TempLength = TempStringToShow.GetLength();
		if (TempLength > 70)
		{
			TempLength = 70;
			TempStringToShow = TempStringToShow.Left(TempLength);
		}
		vSystemData.vLastChatWindowText = TempStringToShow;
		SetDlgItemText(IDC_ChatMessage, "Message: " + TempStringToShow);
	}
	else
	{
		vSystemData.vLastChatWindowText = "";
		m_ChatMessage.ShowWindow(SW_HIDE);
	}
}

void CScanTracDlg::StartImageAcquisition()
{
	if (vSystemData.vTotalContainers == 0)
		SaveReportStartTime();
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter StartImageAcquisition ScanTracDlg",cDebugMessage);
	//figure out which Container Trigger mask bit to set
	vWaitForScreenUpdate = false;
	tSerialCommand TempCommand;
	vSystemData.vCurrentBodyTriggerActiveLowMask = 0;
	vSystemData.vCurrentBodyTriggerMask = vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBodyTrigger - 1].vLineBitMask;

	SendBodyTriggerInverterControl();

	if (!vSystemData.vFPGAVersion10Point7OrHigher)
	//before version 10.7 must set the Active Log Register if body trigger is active low
	if (!vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBodyTrigger - 1].vActiveHigh)
		vSystemData.vCurrentBodyTriggerActiveLowMask = vSystemData.vCurrentBodyTriggerActiveLowMask | vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBodyTrigger - 1].vLineBitMask;

	vSystemData.vBackupBodyTriggerMask = 0;
	if (vGlobalCurrentProduct->vBackupBodyTrigger)
	{
		vSystemData.vBackupBodyTriggerMask = vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBackupBodyTrigger - 1].vLineBitMask;

		if (!vSystemData.vFPGAVersion10Point7OrHigher)
		//if active low, and can't invert in FPGA, then set in ActiveLowMask Register
		if (!vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBackupBodyTrigger - 1].vActiveHigh)
			vSystemData.vCurrentBodyTriggerActiveLowMask = vSystemData.vCurrentBodyTriggerActiveLowMask | vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBackupBodyTrigger - 1].vLineBitMask;
	}
	vSystemData.vDigitalInputLine3Mask = vSystemData.vBackupBodyTriggerMask | vSystemData.vCurrentBodyTriggerMask;

	if (vSystemData.vBackupBodyTriggerMask && vSystemData.vCurrentBodyTriggerMask)
		vSystemData.vOnlyOneBodyTriggerEnabled = false;
	else
		vSystemData.vOnlyOneBodyTriggerEnabled = true;

	//Send Interrupt Mask for body trigger
	TempCommand[0] = 0x1C;
		//Don't enable encoder interrupt
	TempCommand[1] = 0x04;  //send mask so uC know which bit is body trigger
	TempCommand[2] = 0x00;
	TempCommand[3] = vSystemData.vCurrentBodyTriggerMask;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);

	TempCommand[1] = 0x03;  //send mask for 16 digital lines in #3 , body triggers
	TempCommand[2] = 0x00;
	TempCommand[3] = vSystemData.vDigitalInputLine3Mask;
	if ((vSystemData.vSystemRunMode == cMeasureSourceStrengthMode) ||
		(vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode) ||
		(vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) ||
		(vSystemData.vSystemRunMode == cTestShutterMode) ||
		(vSystemData.vSystemRunMode == cCalibratingDetectorGainMode))
		TempCommand[3] = 0x00;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);

	WORD TempDistanceBodyTriggerActive = 0;
	if (vTriggerIndicatorValue)
		TempDistanceBodyTriggerActive = vSystemData.vCurrentBeltPosition;

	if ((vSystemData.vSystemRunMode == cMeasureSourceStrengthMode) ||
		(vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode) ||
		(vSystemData.vSystemRunMode == cCalibratingDetectorGainMode) ||
		(vSystemData.vSystemRunMode == cTestShutterMode) ||
		(vSystemData.vSystemRunMode == cAlignTubeMode) ||
		(vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode))
		SetFastestSimulatedEncoder(1);
	else
	if ((vSystemData.vSystemRunMode != cConditionXRayTubeMode) && (vSystemData.vSystemRunMode != cDarkCurrentMode))
	{
		if ((vSystemData.vFPGASimulateEncoderRate) || (vConfigurationData->vContinuousFeedEncoderRate))
			TurnSimulatedEncoderOn();
		else
			SetSimulatedEncoderTo16TimesConveyor();

		SendConveyorOnOffToUController(1);

		if ((vSystemData.vSimulateContainersRate) || 
			(vConfigurationData->vContinuousFeedContainerRate) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || 
			(vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
		if (vSystemData.vActualEncoderRate)
		if (vSystemData.vSimulatedContainerTimerDelay == 0)
		{
			Sleep(500);
			TurnSimulatedContainersOn();
		}
	}
	
	if (vSystemData.vSystemRunMode == cAlignTubeMode)
		::PostThreadMessage(vGlobalCallingThreadID,cSimulateOneContainerIn10MSMessage,50,0);

	if (((vSystemData.vSystemRunMode == cRunningSystemMode) && (vConfigurationData->vEnableEjectors)) ||
		(vSystemData.vSystemRunMode == cAutoSetupRunningSystem))  //turn on while in setup so conveyor or pump runs if interlocked
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->TurnAlarmOnOff(4,true);//turn on system inspecting bit

	if (vSystemData.vXRayOnNotice)
	{
		::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage, 26, 26); //activated triggers
		ReportErrorMessage("X-Rays Starting Up Step: 26b", cWriteToLog, 0);
		vSystemData.vXRayState = 26;
	}

	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Exit StartImageAcquisition ScanTracDlg",cDebugMessage);
}

void CScanTracDlg::StopImageAcquisition()
{
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter StopImageAcquisition ScanTracDlg",cDebugMessage);
	
	vSystemData.vCurrentBodyTriggerMask = 0;

	vGlobaluCSerialPort->TurnAlarmOnOff(4,false);//turn off system inspecting bit
	KillTimer(vSourceStabilizeTimerHandle);
	KillTimer(vRampXRayTimerHandle);
	vSystemData.vRampXRayStep = 0;
	//Send Interrupt Mask
	tSerialCommand TempCommand;
	TempCommand[0] = 0x1C;
	TempCommand[1] = 0x03;  //send mask for 16 digital lines in #3
	TempCommand[2] = 0x00;
	TempCommand[3] = 0;//vSystemData.vDigitalInputLine3Mask;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);

	TempCommand[1] = 0x04;  //send mask so uC know which bit is body trigger
	TempCommand[2] = 0x00;
	TempCommand[3] = 0;//vSystemData.vCurrentBodyTriggerMask;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Exit StopImageAcquisition ScanTracDlg",cDebugMessage);
}

void CScanTracDlg::AddProduct(CProduct *TempProduct)
{
	if (vProductCollection.GetSize() > 0)
	{
		int TempIndex = 0;
		CString *NewProductName = TempProduct->GetProductName();
		CString *CompareProductName = vProductCollection.GetAt(TempIndex)->GetProductName();
		while ((*NewProductName > *CompareProductName) &&
					(TempIndex < vProductCollection.GetSize()))
		{
			TempIndex++;
			if (TempIndex <= vProductCollection.GetUpperBound())
		  CompareProductName = vProductCollection.GetAt(TempIndex)->GetProductName();
		}
	  vProductCollection.InsertAt(TempIndex, TempProduct);
	}
	else
	  vProductCollection.Add(TempProduct);
}

CProduct *CScanTracDlg::GetProductByNumber(int TempProductNumber)
{
  int TempInt = vProductCollection.GetUpperBound();
	if (TempProductNumber < 1 || TempProductNumber > vProductCollection.GetUpperBound() + 1)
		return NULL;
	return vProductCollection.GetAt(TempProductNumber - 1);
}

CProduct *CScanTracDlg::GetProductByName(CString TempProductName)
{
  int TempLoop = 0;
	CProduct *TempProductPointer;
	CString *TestProductName;
	for (; TempLoop <= vProductCollection.GetUpperBound(); TempLoop++)
	{	
		TempProductPointer = vProductCollection.GetAt(TempLoop);
		TestProductName = TempProductPointer->GetProductName();
		if (!TempProductName.CompareNoCase(*TestProductName))
			return TempProductPointer;
	}
	return NULL;
}

	//////////////////////////////////////////////////////////


BEGIN_EVENTSINK_MAP(CScanTracDlg, CDialog)
    //{{AFX_EVENTSINK_MAP(CScanTracDlg)
	//}}AFX_EVENTSINK_MAP
END_EVENTSINK_MAP()

void CScanTracDlg::SendProductSetupToUController(bool TempLeaveSourceOn)
{
	if (!TempLeaveSourceOn)
		vSystemData.vUControllerReady = false;
	if (vConfigurationData->vDemoMode)
		vSystemData.vUControllerReady = true;

	//Send Container Trigger Lockout
	SendRetriggerLockout(vGlobalCurrentProduct->vLockoutPosition);

	//Send Container Trigger to Image Delay
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendContainerTriggerToImageDelay(vGlobalCurrentProduct);
	Sleep(cSendCommandSleepTime);

	SendLinesPerFrame();
	
	//send image to image delay of zero so both images taken at same time(only used on 24 inch TD)
	if (((vConfigurationData->vScanTracType == cForteScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || 
		(vConfigurationData->vScanTracType == cCaseInspectorScanTrac)) && (vGlobaluCSerialPort))  //24 inch TD needs two 12 inch images taken at same time
	{
		tSerialCommand TempCommand;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xD4;
		TempCommand[2] = 0;
		TempCommand[3] = 0;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		if (vConfigurationData->vScanTracType == cCaseInspectorScanTrac)
		{
			vGlobaluCSerialPort->StartMiddleBeamControl();
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup); //send distance to center image is zero to center daughter board
			vGlobaluCSerialPort->EndMiddleBeamControl();
		}
	}

	//Send Integration Time
	SendProductIntegrationTime(vGlobalCurrentProduct->vXRayIntegrationTime);//, vGlobalCurrentProduct->vXRayIntegrationTimeAtEdge);

	//Send Ejector Dwell Times
	for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectorsForUser; TempLoop++)
	{
		tSerialCommand TempCommand;
		TempCommand[0] = 0x4E;
		TempCommand[1] = TempLoop + 1;
		//must multiply user entry of milliseconds by 31.25 as need to count 31.25Kilohertz
		//clock signals.
		WORD TempWord = (WORD)(vGlobalCurrentProduct->vEjectorDwellTime[TempLoop] * 31.25);
					
		if (vGlobalFPGAVersion10Point87OrHigher)
			TempWord = (WORD)(vGlobalCurrentProduct->vEjectorDwellTime[TempLoop] * 3.975); // clock 8 times slower

		//for shuttleworth diverter, use 100 millisecond pulse to open or close it
		if (vGlobalCurrentProduct->vEjectorDwellTime[TempLoop] == 0)
			TempWord = (WORD)(100 * 3.975);

		TempCommand[2] = (BYTE)(TempWord >> 8);
		TempCommand[3] = (BYTE)TempWord;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);
	}

	DWORD TempLevel = 0;
	for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
	{
		if (!vConfigurationData->vEjector[TempLoop].vActiveHigh)
			TempLevel = TempLevel + (1 << TempLoop);
	}

	//send ejector activity level to FPGA
	tSerialCommand TempCommand;
	TempCommand[0] = 0x23;
	TempCommand[1] = 0xD8; //0xD0;
	TempCommand[2] = (BYTE)(TempLevel >> 8);
	TempCommand[3] = (BYTE)TempLevel;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);

	//send ejector activity level to FPGA
	TempCommand[0] = 0x23;
	TempCommand[1] = 0xD9;
	TempCommand[2] = (BYTE)(TempLevel >> 24);
	TempCommand[3] = (BYTE)(TempLevel >> 16);
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);

	if (!TempLeaveSourceOn)
	{
		if (vGlobalCurrentProduct)
			SendSourceSettingsToUController(vGlobalCurrentProduct->vXRaySourceVoltage, vGlobalCurrentProduct->vXRaySourceCurrent);
		SendXRayPowerOnOffToUController(0);
	}
}

void CScanTracDlg::SendInitializationToUController(bool TempLeaveSourceOn)
{
	if ((vGlobaluCSerialPort) && (vSystemData.vFPGAMajorVersionNumber > 5))  //don't initialize if don't have FPGA Version yet
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("SendInitializationToUController, FPGA Version: " + dtoa(vSystemData.vFPGAMajorVersionNumber, 0), cDebugMessage);

		tSerialCommand TempCommand;
		if (vGlobalFPGAVersion16point0orAbove)
		{ //send a 1 if (X-Scan .8) or (DT .4 or .8)
			TempCommand[0] = 0x23;
			TempCommand[1] = 0x81;
			TempCommand[2] = 0x00;
			TempCommand[3] = 0x01; // all DT and X-scan .4

			if ((vConfigurationData->vUseXScanDetectors) && (vConfigurationData->vPixelsPerDetector == 64)) //if X-Scan and .8 mm detector make a zero
				TempCommand[3] = 0x00;

			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);
		}

		//Send Detector size .8 or .4 mm
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xEE;
		TempCommand[2] = 0;
		if (vConfigurationData->vPixelsPerDetector == 128) //.4mm Detectors
			TempCommand[3] = 1;
		else
		if (vConfigurationData->vDetectorLength == 4) //1.6mm Detectors
			TempCommand[3] = 2;
		else
		//if (vLocalConfigurationData->vPixelsPerDetector == 64)
			TempCommand[3] = 0; //.8mm Detectors
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		if (vGlobalImageAquisitionThread)
		{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Init uC Reset a/b frame Counters",cDebugMessage);
			vGlobalImageAquisitionThread->vAFrameCounter = 0;
			vGlobalImageAquisitionThread->vBFrameCounter = 0;
			vGlobalImageAquisitionThread->vPreviousHardwareFrameCount = -1;
		}

		Sleep(100);

		InitializeDACs();

		Sleep(100);

		InitializeADCs();

		Sleep(100);

		SendRadiationDoorParameters();
		Sleep(cSendCommandSleepTimeSetup);

		TempCommand[0] = 0x3A;
		TempCommand[1] = 0x00;
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x00;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		Sleep(30);

		//Send Container trigger back to back mode
		TempCommand[0] = 0x25;
		TempCommand[1] = 0x02;
		TempCommand[2] = 0x00;
		TempCommand[3] = 0;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);
			
		//Send X-Ray Voltage maximums for comparisons for uController shut down
		TempCommand[0] = 0x27;
		TempCommand[1] = 0xFF;
		TempCommand[2] = 0xFF;
		TempCommand[3] = 0;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);
			
		if (!vGlobalFPGAVersion15Point2OrHigher)
		{
			//Send Clock Divisor  not used on FPGA version 15 and higher
			TempCommand[0] = 0x1D;
			TempCommand[1] = vConfigurationData->vDetectorClockDivider;
			TempCommand[2] = 0;
			TempCommand[3] = 0;
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);
		}

		//Send Digital Input Line input latch clock frequency
		TempCommand[0] = 0x20;
		TempCommand[1] = 4;
		TempCommand[2] = 4;
		TempCommand[3] = 4;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendEncoderDividerTouC();
		//Send Encoder Divisor
//
		//Send Detector Enables for Serialization
		BYTE TempByte = 0;
		TempCommand[0] = 0x1E;
		
		//always indicate 6 detectors to the hardware
		//if (vConfigurationData->vNumberOfXRayDetectors == 6)
			TempByte = 3;  //code for 6 detectors
		//else
		//	TempByte = 5;  //new code for 3 detectors
		
		TempCommand[1] = TempByte;
		TempCommand[2] = 0;
		TempCommand[3] = 0;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);
		Sleep(100);

		ReportErrorMessage("Initialize ADCs, " + dtoa(vConfigurationData->vNumberOfXRayDetectors,0) + " detectors",cWriteToLog,0);

		if ((vGlobalScanTracType == cForteScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vGlobalScanTracType == cCaseInspectorScanTrac))
		{ //have daughter card, so initialize duo settings for 2 images
			ReportErrorMessage("Initialize daughter board(s) position to zero offset from uC",cWriteToLog,0);

			TempCommand[0] = 0x23;
			TempCommand[1] = 0xD2; //product flow, left to right
			TempCommand[2] = 0; 
			TempCommand[3] = 0;  
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);

			SendImageToImageDelay(0); //number of encoder pulses between images
		}
		Sleep(100);

		SendPreAmpGain(vConfigurationData->vPreAmplifierGain);

		Sleep(100);

		//Send Interrupt Mask
		TempCommand[0] = 0x1C;
		//Don't enable encoder interrupt
		vSystemData.vDigitalInputLine3Mask = 0x00;
		vSystemData.vCurrentBodyTriggerMask = 0;
		TempCommand[1] = 0x01;  //send mask x-ray interlocks
		//enable msbit for encoder error indicator for fpga 15.42 and above
		if (vGlobalFPGAVersion15point42orAbove)
			TempCommand[2] = 0xBF;
		else
			TempCommand[2] = 0x3F;

		TempCommand[3] = 0x7F;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		TempCommand[1] = 0x02;  //send mask for Auxiliary Detectors
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x00;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		TempCommand[1] = 0x03;  //send mask for 16 digital lines in #3
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x00;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		TempCommand[1] = 0x04;  //send mask so uC know which bit is body trigger
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x00;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		// send the mode for handling back to back containers
		TempCommand[0] = 0x24;
		TempCommand[1] = 0x01; //shorten the frame by split the difference
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x00;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		TempCommand[0] = 0x30;
		TempCommand[1] = 0x80; //read the interlock input port
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x00;
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		//send FF for ADC to perform 2 dummy cycles to initialize the analog status monitor chip
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xF8; //Setup status ADC chip AD7490
		TempCommand[2] = 0xFF;
		TempCommand[3] = 0xFF;
		for (BYTE TempLoop = 0; TempLoop < 2; TempLoop++)
		{
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);
		}

		//send ADC convert for each channel to get them initialized
		for (BYTE TempLoop = 0; TempLoop < 16; TempLoop++)
		{
			WORD TempWord = 0x0835 + (TempLoop << 6);
			TempWord = TempWord << 4;
			TempCommand[0] = 0x23;
			TempCommand[1] = 0xF8; //Setup status ADC chip AD7490
			TempCommand[2] = (BYTE)(TempWord >> 8);
			TempCommand[3] = (BYTE)(TempWord);
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);
		}

		SendDiagnosticLineSelect();
		Sleep(cSendCommandSleepTimeSetup);


		/*
		//b rh test
		if (vSystemData.vFPGAVersion10Point9OrHigher)
		{ //can do fixed or variable integration time
			TempCommand[0] = 0x23;
			TempCommand[1] = 0xAE;
			TempCommand[2] = 0xFF;
			TempCommand[3] = 0xFE;  //set FPGA in Fixed Integration time mode
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);

			TempCommand[2] = 3;  //send 764 about .3msec
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);
		}
		*/
		//if (vGlobalMonoBlockXRayPort)
		//	vGlobalMonoBlockXRayPort->TurnOnXRayWatchDog();
	}
}

void CScanTracDlg::SendImageToImageDelay(WORD TempDelay) //number of encoder pulses between images
{
	if ((vGlobalScanTracType == cForteScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vGlobalScanTracType == cCaseInspectorScanTrac))
	if (vGlobaluCSerialPort)
	{
		//send the first to second image delay
		tSerialCommand TempCommand;
		//send the delay to the center image
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xD4; 
		TempCommand[2] = 0;//(BYTE)(TempDelay >> 8);
		TempCommand[3] = 0;//(BYTE)(TempDelay);
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Send first to last Image number of pulses: " + dtoa(TempDelay,0),cDebugMessage);

		if ((vGlobalFPGAVersion11Point0OrHigher) && (vGlobalScanTracType == cCaseInspectorScanTrac))
		{
			//WORD TempCenterDelay = 0;
			//if (TempDelay)  //if delay is 0, make center delay zero
			//	TempCenterDelay = vGlobalCurrentProduct->vFirstToMiddleImageDistanceDelayPulses;

			vGlobaluCSerialPort->StartMiddleBeamControl();

			TempCommand[0] = 0x23;
			TempCommand[1] = 0xD4; 
			TempCommand[2] = 0;//(BYTE)(TempCenterDelay >> 8);
			TempCommand[3] = 0;//(BYTE)(TempCenterDelay);
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);

			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Send first to center Image number of pulses: 0",cDebugMessage);//dtoa(TempCenterDelay,0)

			vGlobaluCSerialPort->EndMiddleBeamControl();
		}
	}
}


void CScanTracDlg::SendManualConveyorOnOffToUController(BYTE TempOn)
{
	if (TempOn)
		//turn on and activate the start pulse signal
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x7;
	else
		//turn off and activate the stop pulse signal
		vSystemData.vCurrentConveyorOutput = (vSystemData.vCurrentConveyorOutput & 0xFFF9) | 8;

	Send0x9ACommand();

	//if (vSystemData.vFPGAVersion9Point0OrHigher)
	{
		KillTimer(vConveyorStartStopSignalOffTimerHandle);
		int TempTimerResult = SetTimer(vConveyorStartStopSignalOffTimerHandle,500,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-vConveyor Turn Signal Off Timer Failed",cEMailInspx,32000);
	}
}

void CScanTracDlg::SendConveyorOnOffToUController(BYTE TempOn)
{
	vSystemData.vConveyorIsOn = TempOn;
	if (TempOn)
	{
		//bill should be 0x07 and 0x01, but need reset a/b frame counter with values
		if (((vConfigurationData->vContinuousFeedContainerRate) ||  ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || 
			(vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) && //Continuous Feed, or a Pipeline
			(vConfigurationData->vUsePipeFlowInput)) 
			vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x03;  //on, enable encoder, start pulse
		else
		if ((!vSystemData.vFPGASimulateEncoderRate) && 
			(!vConfigurationData->vContinuousFeedEncoderRate)) //not simulating encoder
			vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x07;  //on, enable encoder, start pulse
		else
			vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x01;//enable encoder for simulated encoder
	}
	else
	{
		vSystemData.vCurrentConveyorOutput = (vSystemData.vCurrentConveyorOutput & 0xFFF8) | 0x08;  //pulse off, conveyor off, disable encoder
	}

	Send0x9ACommand();

	//if (vSystemData.vFPGAVersion9Point0OrHigher)
	{
		KillTimer(vConveyorStartStopSignalOffTimerHandle);
		int TempTimerResult = SetTimer(vConveyorStartStopSignalOffTimerHandle,500,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-vConveyor Turn Signal Off Timer Failed",cEMailInspx,32000);
	}

	KillTimer(vConveyorStartTimerHandle);
	if (TempOn)
	{
		int TempTimerResult = SetTimer(vConveyorStartTimerHandle,5000,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-vConveyorStart Timer Failed",cEMailInspx,32000);

		//if using diverter to seperate all uninspected containers, open diverter after
		//conveyor has traveled that much
		if (vConfigurationData->vEjectContainersNotInspected)
		if (vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vEnabled)
		if (vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vDigitalInputLine)
		if (vSystemData.vSystemRunMode == cRunningSystemMode)
		if (!vSystemData.vInAutoSetup)
		{
			WORD TempDiverterOnPosition = (WORD)(vSystemData.vCurrentBeltPosition + (vConfigurationData->vDiverterMargin * vGlobalPixelsPerUnit * vGlobalCurrentProduct->vOverScanMultiplier) +
				(vGlobalCurrentProduct->vEjectorDelayBeltPosition[vConfigurationData->vDiverterEjector - 1]));

			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendEjectCommand(vConfigurationData->vDiverterEjector, TempDiverterOnPosition);

			if (vSystemData.vLogFile.vLogSerialData)
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Turn Diverter On Eject, Start Running", TempDiverterOnPosition);
			vSystemData.vDiverterOn = true;
		}
	}
	else
	if (vGlobaluCSerialPort)
	{
		if (vConfigurationData->vEjectContainersNotInspected)
		if (vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vEnabled)
		if (vConfigurationData->vEjector[vConfigurationData->vDiverterEjector - 1].vDigitalInputLine)
		if (!vSystemData.vInAutoSetup)
		{//turn diverter off if stopping the conveyor
			vGlobaluCSerialPort->SendEjectorOnOffCommand(vConfigurationData->vDiverterEjector,0); 
			vSystemData.vDiverterOn = false;
			if (vSystemData.vLogFile.vLogSerialData)
				vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Turn Diverter Off",
				vSystemData.vCurrentBeltPosition);
		}
	}
	UpdateRunButton();
}

void CScanTracDlg::SendSynchronizeCommand()
{
	tSerialCommand TempCommand;
	TempCommand[0] = 0x5A;
	TempCommand[1] = 0xA5;
	TempCommand[2] = 0xA5;
	TempCommand[3] = 0xA5;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTime);

	//read conveyorencoder speed
	TempCommand[0] = 0x30;
	TempCommand[1] = 0xA8; //was 0xBC in the TD with to IO Board
	TempCommand[2] = 0x00;
	TempCommand[3] = 0x00;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
}

void CScanTracDlg::SendDiagnosticLineSelect()
{
	tSerialCommand TempCommand;
	TempCommand[0] = 0x19;
	TempCommand[1] = vConfigurationData->vDiagnosticLineSelect[0];
	TempCommand[2] = vConfigurationData->vDiagnosticLineSelect[1];
	TempCommand[3] = vConfigurationData->vDiagnosticLineSelect[2];
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTime);

	TempCommand[0] = 0x17;
	TempCommand[1] = vConfigurationData->vDiagnosticLineSelect[3];
	TempCommand[2] = vConfigurationData->vDiagnosticLineSelect[4];
	TempCommand[3] = vConfigurationData->vDiagnosticLineSelect[5];
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTime);
}

void CScanTracDlg::SetExternalDetectorDecisionOffset()
{
	if (vGlobalCurrentProduct != NULL)
	{ 
		WORD TempDetectorPositionEnd = 0;
		WORD TempDetectorPositionStart = 0;
		for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
		{
			if ((vConfigurationData->vExternalDetector[TempLoop].vEnabled) &&
				(vGlobalCurrentProduct->vExternalDetectorEnable[TempLoop]))
			{
				if (TempDetectorPositionEnd < vGlobalCurrentProduct->vExternalDetectorWindowEndPosition[TempLoop] * vGlobalCurrentProduct->vOverScanMultiplier)
					TempDetectorPositionEnd = vGlobalCurrentProduct->vExternalDetectorWindowEndPosition[TempLoop] * vGlobalCurrentProduct->vOverScanMultiplier;

				if (TempDetectorPositionStart > vGlobalCurrentProduct->vExternalDetectorWindowStartPosition[TempLoop] * vGlobalCurrentProduct->vOverScanMultiplier)
					TempDetectorPositionStart = vGlobalCurrentProduct->vExternalDetectorWindowStartPosition[TempLoop] * vGlobalCurrentProduct->vOverScanMultiplier;
			}
		}
		vSystemData.vExternalDetectorDecisionEnd = TempDetectorPositionEnd;
		vSystemData.vExternalDetectorDecisionStart = TempDetectorPositionStart;
		
		vSystemData.vEjectorUsed = 0;

		for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
		if ((vConfigurationData->vExternalDetector[TempLoop].vEnabled) && (vGlobalCurrentProduct->vExternalDetectorEnable[TempLoop]))
			vSystemData.vEjectorUsed = vSystemData.vEjectorUsed | vGlobalCurrentProduct->vExternalDetectorEjector[TempLoop];

		for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
		if (vGlobalCurrentProduct->vInspection[TempLoop])
		if (vGlobalCurrentProduct->vInspection[TempLoop]->vEnable)  //may be temorarily disabled
			vSystemData.vEjectorUsed = vSystemData.vEjectorUsed | vGlobalCurrentProduct->vInspection[TempLoop]->vEjector;
	}
}

BOOL CScanTracDlg::PreTranslateMessage(MSG* TempMessage) 
{
	// TODO: Add your specialized code here and/or call the base class
	  //br ht for debug tests 
	/*
	if (TempMessage->message != 0x113)
	if (TempMessage->message != 0x00F)
	if (TempMessage->message != 0x0A0)
	if (TempMessage->message != 0x200)
	if (TempMessage->message != 0x001)
	if (TempMessage->message != 0x104)// alt key down
	if (TempMessage->message != 257)// alt key down
	if (TempMessage->message != 49331)// alt key down
	if (TempMessage->message != 49318)// alt key down
*/
	if (TempMessage->message == 0x112)
	{  //alt F4 was pressed
		ReportErrorMessage("ScanTrac Got Alt F4 Shut Down Message, Ignored", cAction,0);
		return true;  //say we handled an Alt F4 so operating system will not close ScanTrac window
	}
	else
	if (TempMessage->message == cUpdateTitleBarMessage)
	{
		CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
		if (TempWindow)
			TempWindow->Invalidate(false);
		return true;  //true indicates it has been handled, so do not process
	}
	else
	if (TempMessage->message == cOffsetCalibrationNextStep)
	{
		//newimage newframe to display on screen
		CString TempText = " ";
		/*
		if ((PasswordOK(cTemporaryInspxPassword,false)) && (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) &&
			(vSystemData.vCalibrateUsingDAC))
			TempText = "Calibrate DAC";
		else
		if ((PasswordOK(cTemporaryInspxPassword,false)) && (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) &&
			(!vSystemData.vCalibrateUsingDAC))
			TempText = "Calibrate ADC";
		else
		*/
			TempText.LoadString(IDS_Wait);
		if (vSystemData.vCalibrateUsingDAC)
			SetDlgItemText(IDC_Calibrating,TempText + " " + dtoa(vSystemData.vCalibrationImageNumber, 0));
		else
			SetDlgItemText(IDC_Calibrating,TempText + " " + dtoa(vSystemData.vCalibrationImageNumber + 12, 0));
		return true;
	}
	else
	if (TempMessage->message == cBackupChangedMessage)
	{
		if (TempMessage->wParam)
		{
			TempText.LoadString(IDS_ConveyorBackedUp);
			SetDlgItemText(IDC_EjectorsDisabled,TempText);
			m_EjectorsDisabled.ShowWindow(SW_SHOW);
		}
		else
			UpdateDisableEjectorsButton();
		return true;  //true indicates it has been handled, so do not process
	}
	else
	if (TempMessage->message == WM_KEYDOWN)
	{
		if (!vDisplayingVersion)
		if ((vEnteringPecoPasswordMode) && (HandlePecoPasswordKeyPress(TempMessage->wParam)))
			return true;  //true indicates it has been handled, so do not process
		else
		{
			BYTE *TestCrashPointer = NULL;
			int TempKey = TempMessage->wParam;
			int TempKey1 = TempMessage->lParam;
			int TempError = 0;
			CContainer *TempContainer = NULL;
			//SetDlgItemText(IDC_TriggerIndicator,dtoa(TempKey));
			//if (vGlobalShiftKeyDown)
			//	PostThreadMessage(vGlobalCallingThreadID,cHiddenKeyPressed, 0, TempKey);
			// else
			switch (TempKey)
			{
				case 35: // End Key, Left Right on duo but new Image Key on Universal Overlays, Image Button
					OnNewImageKey();
				break;
				case 16: // Shift Key
				case 0x60:  //0 key on KeyPad
					PostThreadMessage(vGlobalCallingThreadID,cHiddenKeyPressed, 1, 0);
				break;
				case 89:  //letter Y to clear yellow message
						ClearYellowWarningButton();
				break;
				case 113: // F2:
					OnSubFunction5Button();
				break;
				case 114: // F3:
					OnSubFunction7Button();
				break;
				case 115: // F4:
					OnSubFunction6Button();
				break;
				case 116: // F5:
					OnSubFunction1Button();
				break;
				case 117: // F6 Key - Function 5:
					OnSubFunction4Button();
				break;
				case 118: // F7 Key - Sub Function 1:
					OnFunction1Button();
				break;
				case 119: // F8 Key - Sub Function 2:
					OnSubFunction8Button();
				break;
				case 120: // F9 Key - Sub Function 3:
					OnSubFunction2Button();
				break;
				case 122: // F11 Key - Sub Function 4:
					OnSubFunction3Button();
				break;
				case 111: // / Key - Sub Function 5:
					OnFunction2Button();
				break;
				case 106: // * Key - Sub Function 6:
					OnFunction4Button();
				break;
				case 109: // - Key - Sub Function 7  Decimal Point:
					OnFunction3Button();
				break;
				case 107: // + Key - Sub Function 8:
					OnFunction5Button();
				break;
#ifdef CompileInHTTPClientOperationsGuardian
				case 79: //o key
				case c5:
				//for testing
					if (vGlobaluCSerialPort)
						vGlobaluCSerialPort->TestOGMessage();
				break;
				//case c8:
				////  for testing
				//	if (PasswordOK(cSuperInspxPassword,false))
				//		TestDTOA();
				//break;

	#endif			
				//case c5: 
				//	//for testing watch dog timers			
				//	if (PasswordOK(cSuperInspxPassword,false))
				//		Sleep(15000);
				//	//test
				//	//if (PasswordOK(cSuperInspxPassword,false))
				//	//	DisableCamLinkImages();
				//break;
				//case c6:
				//	//test
				//	//if (PasswordOK(cSuperInspxPassword,false))
				//	//	EnableCamLinkImages();
				//break;
				/*
				case c9:
					if (PasswordOK(cTemporaryInspxPassword,false))
					{ //br h test crash
						TempKey = *TestCrashPointer;
					}
				break;
				case c5:
					if (PasswordOK(cSuperInspxPassword,false))
					{
						vSystemData.vTestingOnlyStopImages = !vSystemData.vTestingOnlyStopImages;
					}
				break;
				case c5:
					if (PasswordOK(cSuperInspxPassword,false))
						TestingOnlySendSourceCurrentToUController();
				break;
				case c6:
					if (PasswordOK(cSuperInspxPassword,false))
						TestingOnlySendSourceVoltageToUController();
				break;
				
				case c1:
					if (PasswordOK(cTemporaryInspxPassword,false))
						this->Invalidate(true);
				break;
				case c7:
				case 55:  //seven on the top row of number keys
					vSystemData.vOperatorPasswordOK = false;
				break;
				//test
				case 77:  //m
					if (PasswordOK(cSuperInspxPassword,false))
						for (TempLoop = 0; TempLoop < 100; TempLoop++)
						//TempReadBuffer = (BYTE *)malloc(50000);
						TempReadBuffer = (BYTE *)malloc(50000);
				break;

				case c5:
					TerminateImageAquisitionThread();
					SetupFrameGrabber();
					CreateImageAquisionThread();

				break;
				case c8:
					vMaximum10MilliSecondSpan = 0;
					vLast10MilliSecondSpan = 0;
				break;
				case c9:
					StartCopyAllScanTracFoldersToBackupHardDrive();
				break;
				*/
				//case c8:
				//	ConvertImagesTo16Bit();
				//break;
				/*
				case c9:
					if (PasswordOK(cTemporaryInspxPassword,false))
					{
						//int TempError = _execl("C:\\Windows\\System32\\calc.exe", " ", " ", NULL);
						//int TempError = _execl("C:\\Windows\\explorer.exe", "/e,C:", "/select,C:\\ScanTrac", NULL);
						//int TempError = _execl("C:\\Windows\\explorer.exe", "/root,C:", "/select,C:\\ScanTrac", NULL);
						//int TempError = _execl("C:\\Windows\\explorer.exe", "C:\\Windows\\explorer.exe", "/e,C:\\ScanTrac", NULL);
						int TempError = _spawnl(_P_NOWAIT, "C:\\Windows\\explorer.exe", "C:\\Windows\\explorer.exe", "/e,C:\\ScanTrac", NULL);

						if (errno)
							ReportErrorMessage("could not launch explorer: " + dtoa(errno,0),cEMailInspx,22);
					}
				break;
				case c8:
					if (PasswordOK(cTemporaryInspxPassword,false))
					{
						//int TempError = _execl("C:\\Windows\\System32\\calc.exe", " ", " ", NULL);
						//int TempError = _execl("C:\\Windows\\explorer.exe", "/e,C:", "/select,C:\\ScanTrac", NULL);
						//int TempError = _execl("C:\\Windows\\explorer.exe", "/root,C:", "/select,C:\\ScanTrac", NULL);
						//int TempError = _execl("C:\\Windows\\explorer.exe", "C:\\Windows\\explorer.exe", "/e,C:\\ScanTrac", NULL);
						int TempError = _spawnl(_P_NOWAIT, "c:\\Windows\\system32\\calc.exe", "c:\\Windows\\system32\\calc.exe", " ", NULL);

						if (errno)
							ReportErrorMessage("could not launch explorer: " + dtoa(errno,0),cEMailInspx,22);
					}
				break;
				*/
				
				/*
				case c2:
					SetCursorPos(0,0);
				break;
				case c3:
					SetCursorPos(vGlobalDisplaySizeH,vGlobalDisplaySizeV);
				break;
				case c4:
					SetCursorPos(vGlobalDisplaySizeH,vGlobalDisplaySizeV);
				break;
				case c5:
					SetCursorPos(0,480);
				break;
				case c6:
					SetCursorPos(660,500);
				break;
				*/
				/*
				case c2:  //br htest
					m_TriggerIndicator.ShowWindow(SW_SHOW);
					SetDlgItemText(IDC_TriggerIndicator,"BBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBB");
				break;
				*/
				//br ht
				//case c5: // + Key - Sub Function 8:
				//	if (PasswordOK(cTemporaryInspxPassword,false))
				//		ResetFPGAABFrameCounters();
				//break;
				//br//ht
				//case c3:
				//	ReportErrorMessage("Test Error Message to Inspx",cEMailInspx,22);
				//break;
				//br ht
				/*
				case c4:
					vSystemData.vGenerateTestError = 1;
				break;
				case c5:
					vSystemData.vGenerateTestError = 2;
				break;
				case c6:
					vSystemData.vGenerateTestError = 3;
				break;
				case c7:
					vSystemData.vGenerateTestError = 4;
				break;
				case c7:
					SetDlgItemText(IDC_TriggerIndicator, dtoa(sizeof(vGlobalLifeTimeCounters->vXRaySourceRunDuration),0));
				break;
*/
				//case c5:
				//	//b rh test
				//	if (vGlobalFPGAVersion15Point2OrHigher)
				//	{
				//		vSystemData.vABPixelAtOtherSide = !vSystemData.vABPixelAtOtherSide;
				//		SetABPixelToOtherEnd(vSystemData.vABPixelAtOtherSide);

				//		CNoticeDialog TempNoticeDialog;
				//		if (vSystemData.vABPixelAtOtherSide)
				//			TempNoticeDialog.vNoticeText =  "\n\n\nA/B Pixel at other end";
				//		else
				//			TempNoticeDialog.vNoticeText =  "\n\n\nA/B Pixel at default end";
				//		TempNoticeDialog.vType = cNoticeMessage;
				//		TempNoticeDialog.DoModal();
				//	}
				//break;
				case 36:  //Home key, Screen Capture
					if (PasswordOK(cOperatorPassword,true))
					{
						vGlobalShiftKeyDown = true;
						PostThreadMessage(vGlobalCallingThreadID,cHiddenKeyPressed, 0, 0x61);
					}
				break;
				case cPageDown: // Help
					if (PasswordOK(cOperatorPassword,true))
					{
						//main menu help
						PostThreadMessage(vGlobalCallingThreadID,cShowHelp, 1, 0);
					}
					{
						CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
						if (TempWindow)
							TempWindow->Invalidate(false);
					}
				break;
				case cPageUp: // Clear
				{
					CWnd * TempWindow = NULL;
					if (vGlobalPasswordLevel)
					{
						PasswordOK(cNoPassword, false);	//todo, search on PasswordOK (cNoPassword)
					}
					else
					{
						vPasswordEntryString = "";
						vEnteringPecoPasswordMode = true;
						TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
					}
					TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
					if (TempWindow)
						TempWindow->Invalidate(false);
				}
				break;
				case 27:// escape
					if (vConfigurationData->vDemoMode)
						AskIfShouldExit();
					else //open a chat window
					//	if (Pass wor dOK())
					//		AskIfShouldExit();
					::PostThreadMessage(vGlobalCallingThreadID,	cStartChatWindowMessage, 0,0);

				break;
				//case 66: case 67: //pressed b or c on keyboard to clear brownout indicator
				//	if (PasswordOK(cSuperInspxPassword,false))
				//	{
				//		ClearRedStatusIndicator();
				//		UpdateClearYellowMessageButton();
				//	}
				//break;
			}
			return true;  //true indicates it has been handled, so do not process
		}
	}
	/*
	else
	if (TempMessage->message != 0x113)
	if (TempMessage->message != 0x00F)
	if (TempMessage->message != 0x0A0)
	if (TempMessage->message != 0x200)
	if (TempMessage->message != 0x001)
	{
		if (TempMessage->message == 0x101)
		{
			int TempKey = TempMessage->wParam;
			if (TempKey == 0x10)  //1  also 0-9 key on KeyPad
			{
				PrintScreen();
				//return true;  //true indicates it has been handled, so do not process
			}
		}
		if (TempMessage->message == WM_KEYUP)
		{
			int TempKey = TempMessage->wParam;
			if (TempKey == 16) // Shift Key
			{
				PostThreadMessage(vGlobalCallingThreadID,cHiddenKeyPressed, 0, 0);
				return true;  //true indicates it has been handled, so do not process
			}
		}
	}
	*/
	return CDialog::PreTranslateMessage(TempMessage);
}

void CScanTracDlg::AskIfShouldExit()
{
	int TempResult = IDOK;
	CYesNoDialog TempYesNoDialog;
	TempYesNoDialog.vNoticeText = _T("\n\nExit ScanTrac?");
	if ((vSystemData.vSystemRunMode == cRunningSystemMode) ||
		(vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
		TempYesNoDialog.vNoticeText = _T("\nInspection System Running\nExit ScanTrac?");
	TempYesNoDialog.vQuestionType = cConfirmQuestion;
	TempYesNoDialog.vYesButtonText = "Exit";
	TempResult = TempYesNoDialog.DoModal();
	if (TempResult == IDOK)
	{
		ReportErrorMessage(vGlobalCurrentUser + " Exited Program. Product: " + vSystemData.vCurrentProductName, cUserChanges, 0);
		ReportErrorMessage("Exiting ScanTrac System", cEMailMaintenance,0);
		//ReportErrorMessage("Exiting ScanTrac System", cEMailInspx, 32000);
		SendXRayPowerOnOffToUController(0);
		//vSystemData.vShuttingDownXRays = true;
		if (vSystemData.vSystemRunMode != cStoppedSystemMode)
			StopRunning(true);
		vSystemData.vOKToCloseProgram = true;

		if (vGlobalBackupHardDriveThread)
			vGlobalBackupHardDriveThread->vEndThreadNow = true;

		int TempTimerResult = SetTimer(vExitTimerHandle,500,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-Exit Timer Failed",cEMailInspx,32000);
	}
}

void CScanTracDlg::ExitProgram()
{
#ifdef CompileInHTTPClientOperationsGuardian
	CloseOGServerSendMessageThread();
#endif
	if (vGlobalDXMXRayPort)
		vGlobalDXMXRayPort->DisableWatchDogTimer();
	KillTimer(vCopyNextFilesTimerHandle);
	KillTimer(vBackupToBackupHardDriveTimer);
	KillTimer(vSplashScreenTimerHandle);
	KillTimer(vGoodCountTimerHandle);
	KillTimer(vEjectCountTimerHandle);
	KillTimer(vBeltPositionTimerHandle);
	KillTimer(vSendSyncCommandTimerHandle);
	KillTimer(vUpdateDisplayTimerHandle);
	KillTimer(vSimulateOneContainerTimer);
	KillTimer(vRampXRayTimerHandle);
	KillTimer(vSourceStabilizeTimerHandle);
	KillTimer(vWaitForScreenUpdateTimerHandle);
	KillTimer(vShowSourceStrengthTimerHandle);
	KillTimer(vCheckLampsTimerHandle);
	KillTimer(vSetupProductTimerHandle);
	KillTimer(vStopRunningTimerHandle);
	vStopRunningTimerActive = false;
	KillTimer(vExitTimerHandle);
	KillTimer(vEndCalibrateDetectorsTimerHandle);
	KillTimer(vEndMeasureSourceStrengthTimerHandle);
	KillTimer(vBackupTimerHandle);
	KillTimer(vSetWindowActiveTimerHandle);
	KillTimer(vCheckForErrorMessagesTimerHandle);
	KillTimer(vConveyorStartTimerHandle);
	KillTimer(vTurnDiverterOnTimerHandle);
	KillTimer(vTriggerIndicatorTimerHandle);
	KillTimer(vTurnDiverterOffTimerHandle);
	KillTimer(vEnableErrorMessagesTimerHandle);
	KillTimer(vReCalibrateOffsetTimerHandle);
	KillTimer(vClearSlippedTimerHandle);
	KillTimer(vConveyorStartStopSignalOffTimerHandle);
	KillTimer(vClearRejectHiddenTimerHandle);
	KillTimer(vCheckHVPSVoltageSoonTimerHandle);
	KillTimer(v50HertzTimerHandle);
	KillTimer(vOneHourUpdatesTimerHandle);
	KillTimer(vXRayTubeHasCooledTimerHandle);
//	KillTimer(vScreenShot1TimerHandle);
//	KillTimer(vScreenShot2TimerHandle);
	KillTimer(vCheckACBeforeThisYellowMessageTimerHandle);
	KillTimer(vShowSafetyViolationMessageTimer);
	KillTimer(vDisableEjectorsTimerHandle);
	KillTimer(vOperatorPasswordTimerHandle);
	KillTimer(vCheckInterlocksIn200MSTimerHandle);
	KillTimer(vSetupDataBackupTimerHandle);
	SendConveyorOnOffToUController(0);
	TurnSimulatedEncoderOff();
	TerminateImageAquisitionThread();
	WriteLifeTimeCounter();

	GenerateProductionReport(cSelectProductProductionReport);
	SendProductionReport(cSelectProductProductionReport);

	if (vConfigurationData)
	{
		vConfigurationData->vXRayTubeHasCooled = true;	
		WriteConfigurationDataToFile(false); //write to main config file
	}

	//ReportErrorMessage("Exited ScanTrac System", cEMailInspx,32001);
	ReportErrorMessage("Exited ScanTrac System2", cAction,0);
	Sleep(500);
	Sleep(100);
	if (vGlobaluCSerialPort)
	if (vGlobaluCSerialPort->vComPortString != "")
	if (vConfigurationData)
	if (!vConfigurationData->vDemoMode)
		vGlobaluCSerialPort->ClosePort();
	//if (vGlobaluCSerialPort)
	//	vGlobaluCSerialPort->EndTheThread();
	if (vConfigurationData)
	if (vConfigurationData->vAllowClientConnections)
		CloseAllSockets();
	CloseModBusTCPIPInterface();
	Sleep(500);
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.CloseLogFile();

	WORD TempCount = 0;
	while ((vGlobalBackupHardDriveThread) && (TempCount < 100))
	{
		vGlobalBackupHardDriveThread->vEndThreadNow = true;
		Sleep(100);
		TempCount++;
	}
	if (vGlobalACPowerMoniter)
	if (vGlobalACPowerMoniter->vComPortString != "")
		vGlobalACPowerMoniter->ClosePort();
//	if (vGlobalACPowerMoniter)
//		vGlobalACPowerMoniter->~CACPowerMoniter();

	if (vGlobalDXMXRayPort)
	{
		if (vGlobalDXMXRayPort->vComPortString != "")
			vGlobalDXMXRayPort->ClosePort();
	}
	else
	if (vGlobalMonoBlockXRayPort)
	{
		if (vGlobalMonoBlockXRayPort->vComPortString != "")
		{
			vGlobalMonoBlockXRayPort->ClosePort();
			//vGlobalMonoBlockXRayPort->EndTheThread();
		}
	}
	EndDialog(true);
}

void CScanTracDlg::ShowHelp(long TempContext, long TempType)
{
	CWnd *TempWindow = NULL;
	TempWindow = FindWindow(NULL, _T("Help"));
	if (TempWindow) 
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nA Help window is currently open.\nYou must exit your current window to return to it.";
		TempNoticeDialog.vType = cNoticeMessage;
		TempNoticeDialog.DoModal();
	}
	else
	{
		CHelpDialog * IHelpDialog;
		IHelpDialog = new CHelpDialog;
		IHelpDialog->vHelpContext = TempContext;
		IHelpDialog->vMainWindowPointer = this;
		IHelpDialog->vLocalSystemData = &vSystemData;
		IHelpDialog->vHelpType = TempType;
		IHelpDialog->vWindowType = cMainHelpWindow;
		IHelpDialog->vLocalProductCollection = &vProductCollection;
		IHelpDialog->vLocalConfigurationData = vConfigurationData;
		IHelpDialog->vProductPointer = vGlobalCurrentProduct;
		int TempResult = IHelpDialog->DoModal();

		delete(IHelpDialog);
	}
}

void CScanTracDlg::ScaleImageToMainDisplayBuffer()
{
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("STD-ScaleImageToMainDisplayBuffer-Start",cDebugMessage);
	
	if ((vSystemData.vTakingQuickLearnImages) && (vSystemData.vQuickLearnImageIndex >= vConfigurationData->vNumberOfQuickLearnImagesToTake) && (vSystemData.vQuickLearnImageIndex))
	{
		vSystemData.vTakingQuickLearnImages = false;
		vSystemData.vCompletedEvaluation = true;
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("STD-Quick Learn Done",cDebugMessage);
		if (vSystemData.vQuickLearnImageIndex > vConfigurationData->vNumberOfQuickLearnImagesToTake)
			vSystemData.vQuickLearnImageIndex = vConfigurationData->vNumberOfQuickLearnImagesToTake;

		//process the learned images now
		bool TempOKToSave = true;
		if (!vSystemData.vInAutoSetup)
		if (!vSystemData.vImprovingLearn)
		{
			CString TempText = " (included)";
			if (!vSystemData.vIncludeRejectsInAverageAndStructure)
				TempText = " (excluded)";
			TempText = dtoa(vSystemData.vRejectsDuringLearn,0) + 
				" Rejects during Learn" + TempText;

			CYesNoDialog TempYesNoDialog;
			//CString TempString("\nUse new Learn Image Data?\n(This change is permanent if made.)\nCalculating Learn can take up to a minute.");
			CString TempString = "Use new Quick Learn Image Data?\n(This change is permanent if made.)\n" + dtoa(vSystemData.vWrongWidthsDuringLearn,0) + 
				" Wrong Widths during Learn (excluded)\n" + dtoa(vSystemData.vWrongBrightnessDuringLearn,0) + " Wrong Brightness during Learn (excluded)\n" + TempText;
			TempYesNoDialog.vNoticeText = TempString;
			TempYesNoDialog.vQuestionType = cConfirmSave;
			int TempResult = TempYesNoDialog.DoModal();
			//if user said OK
			if (TempResult != IDOK)
				TempOKToSave = false;
		}

		if (TempOKToSave)
		{
			if ((vSystemData.vEvaluateAndOrQuickLearn == cQuickLearnOnly) || (vSystemData.vEvaluateAndOrQuickLearn == cEvaluateAndQuickLearn))
			{ //create learned images from images saved
				CreateProcessQuickLearnImagesThread();

				if (vConfigurationData->vDriftCompensationEnabled)
					vSystemData.vKeepDensityFeedbackLoopLocked = true;
				Sleep(30);
			}
			else
			{  //evaluate the images saved
				CreateProcessEvaluateImagesThread();
			}
		}
	}
	//else
	
	//if (vSystemData.vPostedNewMainImageReadyToDisplayMessage)
	{

		CWnd *TempActiveWindow = this->GetForegroundWindow();
		if (vSystemData.vSystemRunMode == cCalibratingDetectorGainMode)
		{
			ProcessCalibrateDetectorGain();
		}

		//measure source strenght and calibrate edges images show on main screen
		if ((vSystemData.vSystemRunMode == cMeasureSourceStrengthMode) &&
			(vSystemData.vRampXRayStep == 0)) //not ramping up source
		{
			ProcessMeasureSourceStrengthFrame();
		}
		if (vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode)
		{
			if ((vSystemData.vITIPCDig->vOriginalImage) && (vSystemData.vITIPCDig->vOriginalImage->vGreyImage))
			if ((vSystemData.vITIPCDig->vNextImageToDisplay) && (vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage))
			if (vSystemData.vITIPCDig->vNextImageToDisplayLock.Lock())
			{
				vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->CopyImage(vSystemData.vITIPCDig->vNextImageToDisplay, vSystemData.vITIPCDig->vOriginalBufferSize);

				ProcessCalibrateDetectorEdgeFrame();
				vSystemData.vITIPCDig->vNextImageToDisplayLock.Unlock();
			}
			else
				ReportErrorMessage("Error-Lock Failed STD Next Image 3",cEMailInspx,32000);
		}

		if (vSystemData.vSystemRunMode == cTestShutterMode)
		{
			if ((vSystemData.vITIPCDig->vOriginalImage) && (vSystemData.vITIPCDig->vOriginalImage->vGreyImage))
			if ((vSystemData.vITIPCDig->vNextImageToDisplay) && (vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage))
			if (vSystemData.vITIPCDig->vNextImageToDisplayLock.Lock())
			{
				CopyMemory(vSystemData.vITIPCDig->vOriginalImage->vGreyImage,
							vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage,
							vSystemData.vITIPCDig->vOriginalBufferSize);

				vSystemData.vITIPCDig->vNextImageToDisplayLock.Unlock();

				ProcessTestShutter();
			}
			else
				ReportErrorMessage("Error-Lock Failed STD Next Image 4",cEMailInspx,32000);
		}
		else
		if (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode)
		{
		}
		else
		if (vSystemData.vSystemRunMode == cCalibrateEncoderMode)
		{
			if (vSystemData.vITIPCDig->vNextImageToDisplayLock.Lock())
			{
				vSystemData.vITIPCDig->CopyImageData(
					vSystemData.vITIPCDig->vNextImageToDisplay,
					vSystemData.vITIPCDig->vOriginalImage, 
					vSystemData.vITIPCDig->vOriginalBufferSize);

				vSystemData.vITIPCDig->vNextImageToDisplayLock.Unlock();
			}
			vSystemData.vImageNumberToDisplay++;

			//if (vSystemData.vLogFile.vLogSerialData)
			//	vSystemData.vLogFile.WriteToLogFile("SCD Post New Image B, Frame: " + dtoa(vSystemData.vImageNumberToDisplay, 0),cDebugMessage);

			PostThreadMessage(vGlobalCallingThreadID, cNewImageReadyToDisplay, vSystemData.vSeqNum, vSystemData.vFrameCount);
		}
		else
		if (vSystemData.vSystemRunMode == cAlignTubeMode)
		{
			//do souce density average for each detector
			//if (vSystemData.vLogFile.vLogSerialData)
			//	vSystemData.vLogFile.WriteToLogFile("40STD-Pre vNextImageToDisplayLock.Lock",cDebugMessage);
			if ((vSystemData.vITIPCDig->vOriginalImage) && (vSystemData.vITIPCDig->vOriginalImage->vGreyImage))
			if ((vSystemData.vITIPCDig->vNextImageToDisplay) && (vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage))
			if (vSystemData.vITIPCDig->vNextImageToDisplayLock.Lock())
			{
				CopyMemory(vSystemData.vITIPCDig->vOriginalImage->vGreyImage, vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage, vSystemData.vITIPCDig->vOriginalBufferSize);

				vSystemData.vITIPCDig->vNextImageToDisplayLock.Unlock();

				for (WORD TempLoopDetector = 0; TempLoopDetector < vConfigurationData->vNumberOfXRayDetectors; TempLoopDetector++)
				{
					//add up all the pixels in all the lines except the first 4 and last 4 pixels 
					//in each line
					double TempSum = 0;
					BYTE *TempPointer = NULL;
					DWORD TempCount = 0;
					for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vOriginalBufferSizeY; TempLoopY++)
					{
						TempPointer = vSystemData.vITIPCDig->vOriginalImage->vGreyImage + 4 + (TempLoopDetector * vConfigurationData->vPixelsPerDetector) + (TempLoopY * vSystemData.vITIPCDig->vOriginalBufferSizeX);
						for (WORD TempLoopX = 4; TempLoopX < vConfigurationData->vPixelsPerDetector - 8; TempLoopX++)
						{
							TempSum = TempSum + *TempPointer++;
							TempCount++;
						}
					}
					if (TempCount)
						vSystemData.vCurrentDetectorAverage[TempLoopDetector] = (BYTE)(TempSum / TempCount);
					else
						vSystemData.vCurrentDetectorAverage[TempLoopDetector] = 0;

					if (vSystemData.vCurrentDetectorAverage[TempLoopDetector] > vSystemData.vMaximumDetectorAverage[TempLoopDetector])
					{
						vSystemData.vMaximumDetectorAverage[TempLoopDetector] = vSystemData.vCurrentDetectorAverage[TempLoopDetector];
						vSystemData.vHaveAlignmentDataToSave = true;
					}
				}
				vSystemData.vFrameCount++;
			}
			else
				ReportErrorMessage("Error-Lock Failed STD Next Image 6",cEMailInspx,32000);
			PostThreadMessage(vGlobalCallingThreadID,cSimulateOneContainerIn10MSMessage,0,0);

			//if (vSystemData.vLogFile.vLogSerialData)
			//	vSystemData.vLogFile.WriteToLogFile("SCD Post New Image A, Frame: " + dtoa(vSystemData.vImageNumberToDisplay, 0),cDebugMessage);

			PostThreadMessage(vGlobalCallingThreadID, cNewImageReadyToDisplay, vSystemData.vSeqNum, vSystemData.vFrameCount);
		}
		else
		if (vSystemData.vSystemRunMode == cConditionXRayTubeMode)
		{
		}
		else
		if (TempActiveWindow)
		if (vSystemData.vITIPCDig->vNextImageToDisplay)
		if ((!vWaitForScreenUpdate) || (vSystemData.vITIPCDig->vNextImageToDisplay->vImageType == cLoadedFromFileImageType))
		if ((vSystemData.vSystemRunMode != cStoppedSystemMode) || (vSystemData.vITIPCDig->vNextImageToDisplay->vImageType == cLoadedFromFileImageType))
		{
			//if (vSystemData.vLogFile.vLogSerialData)
			//	vSystemData.vLogFile.WriteToLogFile("STD-SITMDB-Scale Image",cDebugMessage);
			CRuntimeClass  *TempClassPointer = TempActiveWindow->GetRuntimeClass();
			//if main window is open, copy image data so other windows can display, else let them copy
			//it if they want
			if (vSystemData.vITIPCDig->vOriginalImage)
			if (TempClassPointer->m_lpszClassName == "CScanTracDlg")
			{  //if displaying main window
				//if ((vSystemData.vSystemRunMode == cAutoSetupRunningSystem) || (vSystemData.vSystemRunMode == cRunningSystemMode))
				if (vSystemData.vITIPCDig->vNextImageToDisplayLock.Lock())
				{
					vSystemData.vITIPCDig->CopyImageData(
						vSystemData.vITIPCDig->vNextImageToDisplay,
						vSystemData.vITIPCDig->vImageToDisplayOnMainMenu, 
						vSystemData.vITIPCDig->vOriginalBufferSize);

					vSystemData.vITIPCDig->vNextImageToDisplayLock.Unlock();
					//	vSystemData.vLogFile.WriteToLogFile("45aSTD-Post vNextImageToDisplayLock.Lock",cDebugMessage);

					vSystemData.vITIPCDig->CopyImageData(
						vSystemData.vITIPCDig->vImageToDisplayOnMainMenu,
						vSystemData.vITIPCDig->vOriginalImage, 
						vSystemData.vITIPCDig->vOriginalBufferSize);
				}
				else
					ReportErrorMessage("Error-Lock Failed STD Next Image 1",cEMailInspx,32000);
			}
			else
			if (((vSystemData.vSystemRunMode != cStoppedSystemMode) || (vSystemData.vITIPCDig->vNextImageToDisplay->vImageType == cLoadedFromFileImageType)) && (vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode))
			{  //if not displaying main window
				if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu)
				if (vSystemData.vITIPCDig->vNextImageToDisplayLock.Lock())
				{
					vSystemData.vITIPCDig->CopyImageData(
						vSystemData.vITIPCDig->vNextImageToDisplay,
						vSystemData.vITIPCDig->vImageToDisplayOnMainMenu, 
						vSystemData.vITIPCDig->vOriginalBufferSize);

					vSystemData.vITIPCDig->vNextImageToDisplayLock.Unlock();
				}
				else
					ReportErrorMessage("Error-Lock Failed STD Next Image 2",cEMailInspx,32000);


				if (vSystemData.vITIPCDig->vNextImageToDisplay->vImageType == cLoadedFromFileImageType)
				{  //if loaded file, put on other window also
					if (vSystemData.vITIPCDig->vOriginalImage)
					if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu)
					{
						vSystemData.vITIPCDig->CopyImageData(
							vSystemData.vITIPCDig->vImageToDisplayOnMainMenu,
							vSystemData.vITIPCDig->vOriginalImage, 
							vSystemData.vITIPCDig->vOriginalBufferSize);
					}
				}
				vSystemData.vImageNumberToDisplay++;

			//if (vSystemData.vLogFile.vLogSerialData)
			//	vSystemData.vLogFile.WriteToLogFile("SCD Post New Image, Frame: " + dtoa(vSystemData.vImageNumberToDisplay, 0),cDebugMessage);

				PostThreadMessage(vGlobalCallingThreadID, cNewImageReadyToDisplay, vSystemData.vSeqNum, vSystemData.vFrameCount);
			}

			//11/5/2009
			CalculateIfRunningOutOfTime();

			if ((vSystemData.vSystemRunMode != cStoppedSystemMode) || (vSystemData.vITIPCDig->vNextImageToDisplay->vImageType == cLoadedFromFileImageType))
				vSystemData.vITIPCDig->vMainDisplayIsDefaultImage = false;

			//if (((TempClassPointer->m_lpszClassName == "CScanTracDlg") && 
			//	(vSystemData.vSystemRunMode != cStoppedSystemMode)) ||
			//	(vSystemData.vITIPCDig->vNextImageToDisplay->vImageType == cLoadedFromFileImageType))
			if ((vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode) ||
				(vSystemData.vModeToRunAfterCalibrateOffset == cStoppedSystemMode))
			if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu)
			if (vSystemData.vITIPCDig->vMainImageDisplayBuffer)
			{
				//copy image data to main display buffer
				//scale from original buffer to desired size
				double TempScaleX = (double)vSystemData.vITIPCDig->vAquisitionSizeY / (double)vSystemData.vITIPCDig->vMainDisplayImageSizeX;
				double TempScaleY = (double)(vSystemData.vITIPCDig->vOriginalBufferSizeX - 2) / (double)vSystemData.vITIPCDig->vMainDisplayImageSizeY;

				BYTE *TempDisplayBuffer = vSystemData.vITIPCDig->vMainImageDisplayBuffer;
				BYTE *TempPseudoColorDisplayBuffer = vSystemData.vITIPCDig->vMainImagePseudoColorDisplayBuffer;
				BYTE *TempNewImageBuffer;
				BYTE *TempRedImageBuffer;
				DWORD TempDelta = 0;

				double TempReferenceDelta = 
					(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vLeftReferenceAdjust * vSystemData.vITIPCDig->vOriginalBufferSizeX);

				if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu)
				if ((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjected) || (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason < 255))
				{
					//if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason <= 
					//	vGlobalCurrentProduct->vNumberOfInspections)
					//if (vGlobalCurrentProduct->vInspection[vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason - 1])
					//if (vGlobalCurrentProduct->vInspection[vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason - 1]->vReferenceToTop)
					//	TempReferenceDelta = TempReferenceDelta + vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vTopReferenceAdjust;

					if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjected)
						vMainImageRejected = true;
					else
						vMainImageRejected = false;

					vMainImageRejectReason = vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason;

					if ((vMainImageRejectReason <= vGlobalCurrentProduct->vNumberOfInspections) &&
						(vGlobalCurrentProduct->vInspection[vMainImageRejectReason - 1]->vInspectionType == cUnderfillByWeightInspection))
						vMainImageWeight = " " + dtoa(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vFillLevel, 1) + " " + vGlobalCurrentProduct->vInspection[vMainImageRejectReason - 1]->vCheckWeighUnits;
					else
						vMainImageWeight = "";

					vMainImageRejectDisable = vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRejectDisabled;
				}
				else
				{
					vMainImageRejectReason = 255;
					vMainImageRejected = false;
					vMainImageWeight = "";
				}
				vMainImageLane = vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vMultiLaneLaneNumber;

				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("STD-SITMDB-Scale Image to Display on Main",cDebugMessage);

				bool TempCanShowInspectionInRed = ((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu) &&
					(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectThreshold));

				if (TempCanShowInspectionInRed)
				if (vGlobalCurrentProduct)
				{
					BYTE TempInspectionNumber = vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectInspection;
					if (TempInspectionNumber >= vGlobalCurrentProduct->vNumberOfInspections)
						TempCanShowInspectionInRed = false;
					else
					if (vGlobalCurrentProduct->vInspection[TempInspectionNumber])
					if ((vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cDensityInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cCheckWeighInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cMissingLidInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cUnderfillByWeightInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cOverfillByWeightInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cUnderfillInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cOverfillInspection) ||
						(vGlobalCurrentProduct->vInspection[TempInspectionNumber]->vInspectionType == cStandardDeviationInspection))
						TempCanShowInspectionInRed = false;
				}

				//don't have an image so may show gray patter with red inspx logo on top
				if ((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu) && (!vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vHeight))
					TempCanShowInspectionInRed = true;

				if ((vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectInRedBox) || (vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectsInRedBoxes)) //if not showing red on all images, then don't show on this one as not correct image
					TempCanShowInspectionInRed = true;

				if ((vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectsInRed) && (TempCanShowInspectionInRed))
				{  //draw gray image with red contaminant indicator pixels
					if (TempDisplayBuffer)
					if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedImage)
					if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vGreyImage)
					for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vMainDisplayImageSizeY; TempLoopY++)
					{
						for (WORD TempLoopX = 0; TempLoopX < vSystemData.vITIPCDig->vMainDisplayImageSizeX; TempLoopX++)
						{
							TempDelta = 1 + ((DWORD)(((double)TempScaleY * (double)(vSystemData.vITIPCDig->vMainDisplayImageSizeY - 1 - TempLoopY))) + //number of pixels up this line
								(vSystemData.vITIPCDig->vOriginalBufferSizeX * (DWORD)(((double)( TempLoopX) * (double)TempScaleX)))); //number of lines up the frame

							if (TempDelta >= vSystemData.vITIPCDig->vOriginalBufferSize)
								TempDelta = vSystemData.vITIPCDig->vOriginalBufferSize - 1;

							TempNewImageBuffer = TempDelta + vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vGreyImage;

							if (((vSystemData.vSystemRunMode == cRunningSystemMode) || (vSystemData.vITIPCDig->vNextImageToDisplay->vImageType == cLoadedFromFileImageType)) && 
								((TempReferenceDelta < TempDelta) && (TempDelta - TempReferenceDelta >= 0) && (TempDelta - (DWORD)TempReferenceDelta < vSystemData.vITIPCDig->vOriginalBufferSize)))
								TempRedImageBuffer = vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedImage + TempDelta - (DWORD)TempReferenceDelta;
							else
								TempRedImageBuffer = NULL;

							if ((TempRedImageBuffer) && 
								(*TempRedImageBuffer < vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectThreshold))
							{
								*TempDisplayBuffer = 0;  //make pixel red if red buffer pixel is zero
							}
							else
							{
								*TempDisplayBuffer = *TempNewImageBuffer;  //copy scaled image data
								if (*TempDisplayBuffer == 0) //if data point was 0, make pixel 1 so not show red
									*TempDisplayBuffer = 1;
							}
							TempDisplayBuffer++; 
						}
					}
				}
				else
				//enum {cDefectsInNoColor, cDefectsInPseudoColor, cDefectsInRed, cDefectInRedBox, cDefectsInRedBoxes};
				if ((vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectsInPseudoColor) && (TempCanShowInspectionInRed) &&
					(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu) && (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vTop))
				{
					FillMemory(vSystemData.vITIPCDig->vMainImagePseudoColorDisplayBuffer,vSystemData.vITIPCDig->vMainDisplayImageSize, 255);

					if (vSystemData.vITIPCDig->vMainImagePseudoColorDisplayBuffer)
					if (TempDisplayBuffer)
					if (TempPseudoColorDisplayBuffer)
					if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedImage)
					if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vGreyImage)
					for(WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vMainDisplayImageSizeY; TempLoopY++)
					{
						for(WORD TempLoopX = 0; TempLoopX < vSystemData.vITIPCDig->vMainDisplayImageSizeX; TempLoopX++)
						{
							TempDelta = 1 + ((DWORD)(((double)TempScaleY * (double)(vSystemData.vITIPCDig->vMainDisplayImageSizeY - 1 - TempLoopY))) + //number of pixels up this line
								(vSystemData.vITIPCDig->vOriginalBufferSizeX * (DWORD)(((double)( TempLoopX) * (double)TempScaleX)))); //number of lines up the frame

							if (TempDelta >= vSystemData.vITIPCDig->vOriginalBufferSize)
								TempDelta = vSystemData.vITIPCDig->vOriginalBufferSize - 1;

							TempNewImageBuffer = TempDelta + vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vGreyImage;

							if ((vSystemData.vSystemRunMode == cRunningSystemMode) && ((TempReferenceDelta < TempDelta) && (TempDelta - TempReferenceDelta >= 0) && 
								(TempDelta - (DWORD)TempReferenceDelta < vSystemData.vITIPCDig->vOriginalBufferSize)))
								TempRedImageBuffer = vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedImage + TempDelta - (DWORD)TempReferenceDelta;
							else
								TempRedImageBuffer = NULL;

							if ((TempRedImageBuffer) && (*TempRedImageBuffer < 255))
							{
								*TempPseudoColorDisplayBuffer = *TempRedImageBuffer;  //make pixel pseudo color if red buffer pixel is below 255
							}
							else
							{
								*TempDisplayBuffer = *TempNewImageBuffer;  //copy scaled image data
								if (*TempDisplayBuffer == 0) //if data point was 0, make pixel 1 so not show red
									*TempDisplayBuffer = 1;
							}
							TempDisplayBuffer++; 
							TempPseudoColorDisplayBuffer++;
						}
					}
				}
				else
				{ //just draw gray image
					if (TempDisplayBuffer)
					if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vGreyImage)
					for(WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vMainDisplayImageSizeY; TempLoopY++)
					{
						for(WORD TempLoopX = 0; TempLoopX < vSystemData.vITIPCDig->vMainDisplayImageSizeX; TempLoopX++)
						{
							TempDelta = 1 + ((DWORD)(((double)TempScaleY * (double)(vSystemData.vITIPCDig->vMainDisplayImageSizeY - 1 - TempLoopY))) + //number of pixels up this line
								(vSystemData.vITIPCDig->vOriginalBufferSizeX * (DWORD)(((double)( TempLoopX) * (double)TempScaleX)))); //number of lines up the frame

							if (TempDelta >= vSystemData.vITIPCDig->vOriginalBufferSize)
								TempDelta = vSystemData.vITIPCDig->vOriginalBufferSize - 1;

							TempNewImageBuffer = TempDelta + vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vGreyImage;

							*TempDisplayBuffer = *TempNewImageBuffer;  //copy scaled image data
							if (*TempDisplayBuffer == 0) //if data point was 0, make pixel 1 so not show red
								*TempDisplayBuffer = 1;

							TempDisplayBuffer++; 
						}
					}
				}

				//draw red box on screen if reject
				//enum {cDefectsInNoColor, cDefectsInPseudoColor, cDefectsInRed, cDefectInRedBox, cDefectsInRedBoxes};

				//draw 1 red box on screen 
				if (TempCanShowInspectionInRed)
				if (vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectInRedBox)
				if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason <= vGlobalCurrentProduct->vNumberOfInspections)
				if ((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxWidth[0]) && 
					(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxHeight[0]))
				{
					if (!vSystemData.vITIPCDig->vAquisitionSizeY)
						ReportErrorMessage("Error-vSystemData.vITIPCDig->vAquisitionSizeY = 0, would cause crash", cEMailInspx, 32000);
					else
						TempScaleX = (double)vSystemData.vITIPCDig->vMainDisplayImageSizeX / (double)vSystemData.vITIPCDig->vAquisitionSizeY;

					if (!vSystemData.vITIPCDig->vOriginalBufferSizeX)
						ReportErrorMessage("Error-vSystemData.vITIPCDig->vOriginalBufferSizeX = 0, would cause crash", cEMailInspx, 32000);
					else
					TempScaleY = (double)vSystemData.vITIPCDig->vMainDisplayImageSizeY / (double)vSystemData.vITIPCDig->vOriginalBufferSizeX;

					int TempCornerX = (int)((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxCornerY[0] + vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vLeftReferenceAdjust) * TempScaleX);
					if (TempCornerX < 0)
						TempCornerX = 0;

					int TempCornerY = (int)(vSystemData.vITIPCDig->vMainDisplayImageSizeY - (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxCornerX[0] * TempScaleY));

					//if ((vGlobalCurrentProduct->vInspection[vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason - 1]->vReferenceToBottom) ||
					//	(vGlobalCurrentProduct->vInspection[vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason - 1]->vReferenceToTop))
					//	TempCornerY = (int)(vSystemData.vITIPCDig->vMainDisplayImageSizeY - (((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxCornerX[0] - 6) +
					//	vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vTopReferenceAdjust) * TempScaleY));

					if (TempCornerY < 0)
						TempCornerY = 0;

					if (TempCornerY >= vSystemData.vITIPCDig->vMainDisplayImageSizeY)
						TempCornerY = vSystemData.vITIPCDig->vMainDisplayImageSizeY - 1;

					int TempHeight = (int)(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxHeight[0] * TempScaleY);
					int TempWidth = (int)(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxWidth[0] * TempScaleX);

					if (TempHeight >= vSystemData.vITIPCDig->vMainDisplayImageSizeY)
						TempHeight = vSystemData.vITIPCDig->vMainDisplayImageSizeY - 1;

					if (TempWidth + TempCornerX + 2 > vSystemData.vITIPCDig->vMainDisplayImageSizeX)
						TempWidth = vSystemData.vITIPCDig->vMainDisplayImageSizeX - TempCornerX - 2;

					BYTE *TempDestinationPointer = vSystemData.vITIPCDig->vMainImageDisplayBuffer + TempCornerX +
						(TempCornerY * vSystemData.vITIPCDig->vMainDisplayImageSizeX);

					BYTE *TempMaxDestinationPointer = vSystemData.vITIPCDig->vMainImageDisplayBuffer +
						(vSystemData.vITIPCDig->vMainDisplayImageSizeX * vSystemData.vITIPCDig->vMainDisplayImageSizeY);

					//draw bottom horizontal line
					BYTE *TempPointer = TempDestinationPointer;
					for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
						*TempPointer++ = 0; //set left pixel red

					TempPointer = TempDestinationPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
						*TempPointer++ = 0; //set left pixel red

					//draw Top horizontal line
					TempPointer = TempDestinationPointer - (vSystemData.vITIPCDig->vMainDisplayImageSizeX * TempHeight);

					while (TempPointer < vSystemData.vITIPCDig->vMainImageDisplayBuffer + vSystemData.vITIPCDig->vMainDisplayImageSizeX)
						TempPointer = TempPointer + vSystemData.vITIPCDig->vMainDisplayImageSizeX;

					for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
						*TempPointer++ = 0; //set left pixel red

					TempPointer = TempDestinationPointer - (vSystemData.vITIPCDig->vMainDisplayImageSizeX * (TempHeight - 1));

					while (TempPointer < vSystemData.vITIPCDig->vMainImageDisplayBuffer)
						TempPointer = TempPointer + vSystemData.vITIPCDig->vMainDisplayImageSizeX;

					for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
						*TempPointer++ = 0; //set left pixel red

					//draw left vertical line
					TempPointer = TempDestinationPointer;
					for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
					{
						if (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer)
							*TempPointer = 0; //set left pixel red
						TempPointer = TempPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					}

					TempPointer = TempDestinationPointer + 1;
					for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
					{
						if (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer)
							*TempPointer = 0; //set left pixel red
						TempPointer = TempPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					}

					//draw Right vertical line
					TempPointer = TempDestinationPointer + TempWidth;
					for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
					{
						if (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer)
							*TempPointer = 0; //set left pixel red
						TempPointer = TempPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					}

					TempPointer = TempDestinationPointer + TempWidth + 1;
					for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
					{
						*TempPointer = 0; //set left pixel red
						TempPointer = TempPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					}
				}

				//draw up to 10 red boxes on screen
				if (TempCanShowInspectionInRed)
				if (vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectsInRedBoxes)
				if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason <= vGlobalCurrentProduct->vNumberOfInspections)
				for (BYTE TempBoxLoop = 0; TempBoxLoop < cMaximumRedBoxes; TempBoxLoop++)
				if ((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxWidth[TempBoxLoop]) && 
					(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxHeight[TempBoxLoop]))
				{
					if (!vSystemData.vITIPCDig->vAquisitionSizeY)
						ReportErrorMessage("Error-vSystemData.vITIPCDig->vAquisitionSizeY = 0, would cause crash", cEMailInspx, 32000);
					else
					TempScaleX = (double)vSystemData.vITIPCDig->vMainDisplayImageSizeX / (double)vSystemData.vITIPCDig->vAquisitionSizeY;

					if (!vSystemData.vITIPCDig->vOriginalBufferSizeX)
						ReportErrorMessage("Error-vSystemData.vITIPCDig->vOriginalBufferSizeX = 0, would cause crash", cEMailInspx, 32000);
					else
					TempScaleY = (double)vSystemData.vITIPCDig->vMainDisplayImageSizeY / (double)vSystemData.vITIPCDig->vOriginalBufferSizeX;

					int TempCornerX = (int)((vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxCornerY[TempBoxLoop] +
						vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vLeftReferenceAdjust) * TempScaleX);
					if (TempCornerX < 0)
						TempCornerX = 0;

					int TempCornerY = (int)(vSystemData.vITIPCDig->vMainDisplayImageSizeY - (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxCornerX[TempBoxLoop] * TempScaleY));

					if (vGlobalCurrentProduct->vInspection[vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason - 1])
					if ((vGlobalCurrentProduct->vInspection[vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason - 1]->vReferenceToBottom) ||
						(vGlobalCurrentProduct->vInspection[vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vContainerEjectReason - 1]->vReferenceToTop))
						TempCornerY = (int)(TempCornerY - (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vTopReferenceAdjust * TempScaleY));

					if (TempCornerY < 0)
						TempCornerY = 0;

					if (TempCornerY >= vSystemData.vITIPCDig->vMainDisplayImageSizeY)
						TempCornerY = vSystemData.vITIPCDig->vMainDisplayImageSizeY - 1;

					int TempHeight = (int)(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxHeight[TempBoxLoop] * TempScaleY);
					int TempWidth = (int)(vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRedBoxWidth[TempBoxLoop] * TempScaleX);

					if (TempHeight >= vSystemData.vITIPCDig->vMainDisplayImageSizeY)
						TempHeight = vSystemData.vITIPCDig->vMainDisplayImageSizeY - 1;

					if (TempWidth + TempCornerX + 2 > vSystemData.vITIPCDig->vMainDisplayImageSizeX)
						TempWidth = vSystemData.vITIPCDig->vMainDisplayImageSizeX - TempCornerX - 2;

					BYTE *TempDestinationPointer = vSystemData.vITIPCDig->vMainImageDisplayBuffer + TempCornerX +
						(TempCornerY * vSystemData.vITIPCDig->vMainDisplayImageSizeX);

					BYTE *TempMaxDestinationPointer = vSystemData.vITIPCDig->vMainImageDisplayBuffer + (vSystemData.vITIPCDig->vMainDisplayImageSizeX * vSystemData.vITIPCDig->vMainDisplayImageSizeY);

					if (TempDestinationPointer > TempMaxDestinationPointer)
						TempDestinationPointer = TempMaxDestinationPointer;

					//draw bottom horizontal line
					BYTE *TempPointer = TempDestinationPointer;
					for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
						*TempPointer++ = 0; //set left pixel red

					TempPointer = TempDestinationPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
						*TempPointer++ = 0; //set left pixel red

					//draw Top horizontal line
					TempPointer = TempDestinationPointer - (vSystemData.vITIPCDig->vMainDisplayImageSizeX * TempHeight);

					while (TempPointer < vSystemData.vITIPCDig->vMainImageDisplayBuffer + vSystemData.vITIPCDig->vMainDisplayImageSizeX)
						TempPointer = TempPointer + vSystemData.vITIPCDig->vMainDisplayImageSizeX;

					for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
						*TempPointer++ = 0; //set left pixel red

					TempPointer = TempDestinationPointer - (vSystemData.vITIPCDig->vMainDisplayImageSizeX * (TempHeight - 1));

					while (TempPointer < vSystemData.vITIPCDig->vMainImageDisplayBuffer)
						TempPointer = TempPointer + vSystemData.vITIPCDig->vMainDisplayImageSizeX;

					for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
						*TempPointer++ = 0; //set left pixel red

					//draw left vertical line
					TempPointer = TempDestinationPointer;
					for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
					{
						*TempPointer = 0; //set left pixel red
						TempPointer = TempPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					}

					TempPointer = TempDestinationPointer + 1;
					for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
					{
						if (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer)
							*TempPointer = 0; //set left pixel red
						TempPointer = TempPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					}

					//draw Right vertical line
					TempPointer = TempDestinationPointer + TempWidth;
					for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
					{
						*TempPointer = 0; //set left pixel red
						TempPointer = TempPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					}

					TempPointer = TempDestinationPointer + TempWidth + 1;
					for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
					if ((TempPointer < TempMaxDestinationPointer) && (TempPointer >= vSystemData.vITIPCDig->vMainImageDisplayBuffer))
					{
						*TempPointer = 0; //set left pixel red
						TempPointer = TempPointer - vSystemData.vITIPCDig->vMainDisplayImageSizeX;
					}
				}
			}

			int TimerResult = SetTimer(vWaitForScreenUpdateTimerHandle,1000,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Screen Update Timer Failed",cEMailInspx,32000);
			vWaitForScreenUpdate = true;
		}
	}
}

//11/23/2009
void CScanTracDlg::ReportErrorMessage(CString TempErrorMessage, BYTE TempLevel, WORD TempErrorCode)
{
	//if (vSystemData.vLogFile.vLogSerialData)
	//	vSystemData.vLogFile.WriteToLogFile("50STD-vErrorStringCollectionLock.Lock",cDebugMessage);
	if (vSystemData.vErrorStringCollectionLock.Lock())
	{
		WORD TempUseThisPlace = vErrorMessageHeadUIT;
		WORD TempNextPlace = vErrorMessageHeadUIT + 1;
		if (TempNextPlace >= cMaximumNumberOfErrorMessages)
			TempNextPlace = 0;
		if (TempNextPlace == vErrorMessageTailUIT)
		{
			vSystemData.vMissedErrorMessages = true;
		}
		else
		{
			vTheErrorMessageTypeUIT[TempUseThisPlace] = TempLevel;
			vTheErrorMessageCodeUIT[TempUseThisPlace] = TempErrorCode;
			vTheErrorMessageStringUIT[TempUseThisPlace] = TempErrorMessage;
			vErrorMessageHeadUIT = TempNextPlace;
		}
		vSystemData.vErrorStringCollectionLock.Unlock();
		//if (vSystemData.vLogFile.vLogSerialData)
		//	vSystemData.vLogFile.WriteToLogFile("51STD-vErrorStringCollectionLock.Unlock",cDebugMessage);
	}
}

void CScanTracDlg::HandleErrorMessage(CString TempErrorMessage, BYTE TempLevel, WORD TempErrorCode)
{
	CTime TempTime;
	TempTime = CTime::GetCurrentTime();
	CString TempTimeString = TempTime.Format("%m/%d %H:%M:%S");
	CString TempErrorString = dtoa(vSystemData.vErrorCount + 1,0) + "  " + TempTimeString + "  " + TempErrorMessage;
	vSystemData.vErrorCountForLogFile++;
	CString TempErrorStringForFile = dtoa(TempLevel) + ">" + dtoa(vSystemData.vErrorCountForLogFile,0) + "  " + TempTimeString + " " + TempErrorMessage;
	CString TempErrorStringForInspx = " ";
	//socketio alert monitoring
	if ((TempLevel == cError) || (TempLevel == cCritical) || (TempLevel == cEMailPlantOperations) || (TempLevel == cEMailMaintenance) || (TempLevel == cUserChanges))
	{
	}
	if (TempLevel == cEMailInspx)
	{
		CString TempTimeString1 = TempTime.Format("%m/%d/%Y %H:%M:%S");
		//vConfigurationData->vInspxMessageCount++;
		TempErrorStringForInspx = //dtoa(vConfigurationData->vInspxMessageCount,0) + "  " + 
			TempTimeString1 + " " + TempErrorMessage;
	}
	//if ((!vConfigurationData->vSuppressWarningMessages) || (TempLevel == cAction) || 
	//	(TempLevel == cWrongSizeNotice) || (TempLevel == cReject))
	{
		bool TempOldButton2Yellow = vSystemData.vYellowMessageButtonYellow;
		if (TempLevel == cCritical)
		{
			CNoticeDialog TempNoticeDialog;
			CString TempString = "\n\n\n" + TempErrorMessage;
			TempNoticeDialog.vNoticeText = TempString;
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
		if ((TempLevel == cError) || (TempLevel == cCritical) || (TempLevel == cEMailPlantOperations) || (TempLevel == cEMailInspx) || (TempLevel == cEMailMaintenance))
		{
			if ((TempLevel != cEMailInspx) || (PasswordOK(cTemporaryInspxPassword,false)))
			if (!vConfigurationData->vSuppressWarningMessages)
			if ((TempErrorCode != 32001) && (TempErrorCode != 32002) && (TempErrorCode != 32003))
				//32000 is a standard Inspx Message
				//32001 is reserved for Inspx messages not to show up in yellow message or Inspx notice, are red in Inspx Log
				//32002 will not force log to write config file as it will generate an event and
				//			start an infinite loop, and make it green
				//32003 is a reset counters or service log event, will not cause yellow, 
				//			Inspx notice but will write in service log
			{
				vSystemData.vYellowMessageButtonYellow = true;
				if (vGlobaluCSerialPort)
				{
					vGlobaluCSerialPort->TurnOnOffYellowLamp(true);
					if (TempLevel == cError)
						vGlobaluCSerialPort->TurnAlarmOnOff(3,true);//turn on Critical Alarm bit
				}
				SetDlgItemText(IDC_StatusLine,TempErrorMessage); 
			}
			if (vConfigurationData)
			{
				/*
				//this e-mail works on 9/10/2012 in my office on my development PC.
				if ((TempLevel == cEMailInspx) && (TempErrorCode == 32000))
				{
					LPTSTR TempEMailProgramName = "C:\\Temp\\EMail\\SendEMail";
					LPTSTR TempArg1 = "-t Brian.Higgins@Inspx.Com";
					CString TempStringTitle = "-u E-Mail Message From ScanTrac: " + vConfigurationData->vScanTracCustomerName;
					LPTSTR TempArg2 = TempStringTitle.GetBuffer(TempStringTitle.GetLength());
					CString TempStringMessage = "-m " + TempErrorString;
					LPTSTR TempArg3 = TempStringMessage.GetBuffer(TempStringMessage.GetLength());;
					LPTSTR TempArg4 = "-f Brian.Higgins@Inspx.Com";
					LPTSTR TempArg5 = "-s Inspx.Com";
					int TempError = _spawnl(_P_NOWAIT, TempEMailProgramName, TempEMailProgramName, TempArg1, TempArg2, TempArg3, TempArg4, TempArg5, NULL);
					ReportErrorMessage("E-Mail Send code: " + dtoa(TempError, 0), cEMailInspx, 32002);

					if (TempError == -1)
					{
						if (errno == E2BIG)
							ReportErrorMessage("E-Mail Send error: Argument list exceeds 1024 bytes.", cEMailInspx, 32002);
						if (errno == EINVAL)
							ReportErrorMessage("E-Mail Send error: mode argument is invalid.", cEMailInspx, 32002);
						if (errno == ENOENT)
							ReportErrorMessage("E-Mail Send error: File or path is not found.", cEMailInspx, 32002);
						if (errno == ENOEXEC)
							ReportErrorMessage("E-Mail Send error: Specified file is not executable or has invalid executable-file format.", cEMailInspx, 32002);
						if (errno == ENOMEM)
							ReportErrorMessage("E-Mail Send error: Not enough memory is available to execute the new process.", cEMailInspx, 32002);
					}
				}
				
				*/
				//if (((TempLevel == cEMailPlantOperations) && (vConfigurationData->vEMailEnable[0])) || 
				//	((TempLevel == cEMailInspx) && (vConfigurationData->vEMailEnable[1])) || 
				//	((TempLevel == cEMailMaintenance) && (vConfigurationData->vEMailEnable[2])))
				//{
				//	CTime TempTime;
				//	TempTime = CTime::GetCurrentTime();
				//	CTimeSpan TempDeltaTime;
				//	TempDeltaTime = TempTime - vSystemData.vLastEMailErrorMessageTime;
				//	LONGLONG TempSeconds = TempDeltaTime.GetTotalSeconds();
				//	if (TempSeconds > 120)
				//	{
				//		vEMailMessage = TempErrorMessage;
				//		vEMailType = TempLevel;
				//		vSystemData.vLastEMailErrorMessageTime = CTime::GetCurrentTime();
				//	}
				//}
				//send error message to all clients out TCPIP Socket
				if (vConfigurationData->vAllowClientConnections)
				{
					if ((TempLevel == cEMailPlantOperations) || (TempLevel == cEMailInspx) || (TempLevel == cCritical) || (TempLevel == cEMailMaintenance) || (TempLevel == cError))
					{
						CString TempSocketMessage = vConfigurationData->vScanTracID;
						CSocketMessage TempMessage;
						TempMessage.vMessageFormat = 3;
						TempMessage.vMessageDWordArray[0] = TempErrorCode;
						TempMessage.vMessageCommand = cSocketErrorMessage;
						TempMessage.vMessageText = TempSocketMessage + ":" + TempErrorString;
						SendSocketAMessageFromServerToClients(&TempMessage);
					}
				}
			}
		}
		if (vSystemData.vErrorLog.GetCount() > 1000)
		{
			CStringBufferObject *TempTail = NULL;
			for (BYTE TempLoop = 0; TempLoop < 2; TempLoop++)
			{
				TempTail = vSystemData.vErrorLog.GetTail();
				vSystemData.vErrorLog.RemoveTail();
				delete TempTail;
			}
		}
		if (TempLevel == 0)
			TempLevel = 1;

		if (TempLevel != cWriteToLog)
		{
			CStringBufferObject *TempErrorObject = NULL;
			TempErrorObject = new CStringBufferObject;
			if (TempErrorObject)
			{
				TempErrorObject->vTheString = TempErrorString;
				TempErrorObject->vTheType = TempLevel;
				vSystemData.vErrorLog.AddHead(TempErrorObject);
				vSystemData.vErrorCount++;
			}
		}
		if (TempLevel == cEMailInspx)
		{
			if (vSystemData.vInspxLog.GetCount() > 1000)
			{
				CStringBufferObject *TempTail = NULL;
				for (BYTE TempLoop = 0; TempLoop < 2; TempLoop++)
				{
					TempTail = vSystemData.vInspxLog.GetTail();
					vSystemData.vInspxLog.RemoveTail();
					delete TempTail;
					TempTail = NULL;
				}
			}
			CStringBufferObject *TempErrorObject = NULL;
			TempErrorObject = new CStringBufferObject;
			if (TempErrorObject)
			{
				if (TempErrorCode == 32002)
					TempErrorStringForInspx = "--" + TempErrorStringForInspx;

				if (TempErrorCode == 32003)
				{
					vGlobalLifeTimeCounters->vServiceRecordLog = TempErrorStringForInspx + "\n\n" + vGlobalLifeTimeCounters->vServiceRecordLog;
					WriteLifeTimeCounter();
				}

				TempErrorObject->vTheString = TempErrorStringForInspx;
				TempErrorObject->vTheType = TempLevel;
				vSystemData.vInspxLog.AddHead(TempErrorObject);

				//br htest
				//if (TempErrorCode != 32002)
				//	WriteConfigurationDataToFile(false);//save new Inspx log entry number in setup file
			}
			CString TempDirectoryString = cLogDirectory;
			TempTimeString = TempDirectoryString + "ScanTracCriticalLog.txt";
			LPCTSTR TempFileName = TempTimeString;
			CFileException TempFileException;
			if (TempErrorCode != 32322) //don't write 32322 code to the log
			if (ThereIsEnoughMemory(sizeof(CFile), "Critical Log File"))
			{
				CFile *TempCriticalLogFile = new CFile;
				if (TempCriticalLogFile)
				{
					if (TempCriticalLogFile->Open(TempFileName, (CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException))
					{
						if ((TempCriticalLogFile->m_hFile) && (TempCriticalLogFile->m_hFile != INVALID_HANDLE_VALUE ))
						{
							char TempBuffer[50000];
							DWORD TempBytesRead = TempCriticalLogFile->Read(TempBuffer, 50000);

							USES_CONVERSION;
							LPCTSTR TempStringJustRead = A2W(TempBuffer);

							CString TempCurrentFile = TempStringJustRead;
							TempCurrentFile.GetBufferSetLength(TempBytesRead);
							DWORD TempFileSize = TempCurrentFile.GetLength();
							if (TempBytesRead)
							if (TempBytesRead > 49700)
							{
								DWORD TempPosition = TempCurrentFile.Find((char)0x0A, TempBytesRead - 200);
								if (TempPosition < 40001)
									TempCurrentFile.Delete(TempPosition, TempBytesRead - TempPosition);
								else
									TempCurrentFile.Delete(TempBytesRead - 120, 120);
							}
							TRY
							{
								TempCriticalLogFile->SeekToBegin();
							}
							CATCH_ALL(TempFileException)
							{
								ReportErrorMessage("Failed SeekToBegin of Inspx Log", cEMailInspx, 32000);
							}
							END_CATCH_ALL

							CString TempCriticalStringForFile = TempErrorStringForInspx + (char)0x0D + (char)0x0A + TempCurrentFile;
							WORD TempLength = TempCriticalStringForFile.GetLength();
							if (TempLength)
							{
								CW2A TempStringToWrite(TempCriticalStringForFile);
								TempCriticalLogFile->Write(TempStringToWrite, TempLength);
							}
							TempCriticalLogFile->Close();
						}
						else
							ReportErrorMessage("Failed to Write Inspx Log File to Disk",cEMailInspx, 32322);
					}
					else
						ReportErrorMessage("Failed to Write Inspx Log File to Disk",cEMailInspx, 32322);
					delete TempCriticalLogFile;
				}
			}
		}

		if ((TempLevel == cError) || (TempLevel == cCritical) || (TempLevel == cEMailPlantOperations) || (TempLevel == cEMailMaintenance) || ((TempLevel == cEMailInspx) && (PasswordOK(cTemporaryInspxPassword,false))))
			vSystemData.vLastErrorMessage = TempErrorMessage; //2012 11 29
		else
		if (TempLevel == cEMailInspx)
		if ((TempErrorCode != 32001) && (TempErrorCode != 32002) && (TempErrorCode != 32003))
		//9/30/2009
			vSystemData.vInspxMessagesToView = true;

		if (!TempOldButton2Yellow)
		if ((TempLevel == cError) || (TempLevel == cCritical) || (TempLevel == cEMailPlantOperations) || (TempLevel == cEMailMaintenance) || ((TempLevel == cEMailInspx) && (PasswordOK(cTemporaryInspxPassword,false))))
			UpdateClearYellowMessageButton();
	}
	if (vConfigurationData)
	if (vConfigurationData->vAllowClientConnections)
	if ((TempLevel == cAction) || (TempLevel == cWrongSizeNotice) || (TempLevel == cReject))
	{
		CString TempSocketMessage = vConfigurationData->vScanTracID;
		CSocketMessage TempMessage;
		TempMessage.vMessageFormat = 2;
		TempMessage.vMessageCommand = cSocketEventMessage;
		if (TempLevel == cReject)
			TempMessage.vMessageCommand = cSocketRejectMessage;
		if (TempLevel == cWrongSizeNotice)
			TempMessage.vMessageCommand = cSocketRejectMessage;
		
		TempMessage.vMessageText = TempSocketMessage + ";" + TempErrorString;
		SendSocketAMessageFromServerToClients(&TempMessage);
	}

	vSystemData.vLogFile.WriteToLogFile(TempErrorStringForFile,cDebugMessage);

	CFileException TempFileException;

	//if (vConfigurationData->vWriteErrorLogOnDisk)
	CString TempFileDirectoryString = " ";
	CString TempFileNameShadowString = " ";
	LPCTSTR TempFileNameShadowStringPtr;

	if (vConfigurationData)
		TempFileDirectoryString = vConfigurationData->vScanTracEventLogDirectory;
	else
		TempFileDirectoryString = cScanTracEventLogDirectory;

	CString TempDateString = "";
	CString TempFilePathString = ""; 
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;

	TempFileDirectoryString.Delete(TempFileDirectoryString.GetLength() -1, 1);
	LPCTSTR TempFileNameString = TempFileDirectoryString.GetBuffer(TempFileDirectoryString.GetLength()); //+ "\\ScanTracEventLog2008-07-14_12-34-08.txt";
	CFileStatus TempFileStatus;
	if (TempErrorCode != 32322) //don't write 32322 code to the log
	{
		if (CFile::GetStatus(TempFileNameString, TempFileStatus))
		{
			ULONGLONG x = TempFileStatus.m_size;

							//Write Event to log if configured
			TempDateString = TempTime.Format("%Y-%m-%d");
			TempTimeString = TempTime.Format("%H-%M-%S");

			//look for old event log under 2Mb
			TempFileDirectoryString = TempFileDirectoryString + "\\";
			TempFilePathString = TempFileDirectoryString + "ScanTracEventLog" + TempDateString + "*" + ".txt";

			LPTSTR TempDirectoryFiles = TempFilePathString.GetBuffer(TempFilePathString.GetLength());
		
			hFind = FindFirstFile(TempDirectoryFiles, &FindFileData);
		
			if (hFind == INVALID_HANDLE_VALUE) // no files in directory
			{

				//if no old files found, make new file
				TempFilePathString = TempFileDirectoryString + "ScanTracEventLog" + TempDateString 
					+ "_" + TempTimeString + ".txt";
				TempFileNameString = TempFilePathString.GetBuffer(TempFilePathString.GetLength());
				TempFileNameShadowString = cScanTracEventLogDirectory;
				TempFileNameShadowString = TempFileNameShadowString + "ScanTracEventLog" + TempDateString + "_" + TempTimeString + ".txt";	
			} 
			else	//else scan through files to see one less than 2MB
			{
				do
				{
					TempFilePathString = FindFileData.cFileName; 
					TempFileNameShadowString = cScanTracEventLogDirectory;
					TempFileNameShadowString += TempFilePathString;
					TempFilePathString = TempFileDirectoryString + TempFilePathString;
					TempFileNameString = TempFilePathString.GetBuffer(TempFilePathString.GetLength());
					if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
					{
						if (CFile::GetStatus(TempFileNameString, TempFileStatus))
						{
							if (TempFileStatus.m_size > 2000000)
								TempFileNameString = _T("");
							else	
								break;
						}
					}
				} 
				while (FindNextFile(hFind,&FindFileData));
			
				if (TempFileNameString == _T(""))
				{
					TempFilePathString = TempFileDirectoryString + "ScanTracEventLog" + TempDateString + "_" + TempTimeString + ".txt";
					TempFileNameShadowString = cScanTracEventLogDirectory;
					TempFileNameShadowString += "ScanTracEventLog" + TempDateString + "_" + TempTimeString + ".txt";
					TempFileNameString = TempFilePathString.GetBuffer(TempFilePathString.GetLength());
				}
			}
			FindClose(hFind);

			if (TempFileNameString != _T(""))
			{
				CFileException *TempException = NULL;
				TRY
				{
					if (ThereIsEnoughMemory(sizeof(CFile), "Event Log File"))
					{
						CFile *TempErrorLogFile = new CFile;
						if (TempErrorLogFile)
						{
							//11/23/2009
							int TempOpenedFileOK = TempErrorLogFile->Open(TempFileNameString, (CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException);

							if (TempOpenedFileOK)
							{
								ULONGLONG TempFileLength = TempErrorLogFile->SeekToEnd();

								if ((TempErrorLogFile->m_hFile) && (TempErrorLogFile->m_hFile != INVALID_HANDLE_VALUE))
								{
									TempErrorStringForFile = TempErrorStringForFile + "\n";
									WORD TempLength = TempErrorStringForFile.GetLength();

									if (TempLength)
									{
										CW2A TempStringToWrite(TempErrorStringForFile);
										TempErrorLogFile->Write(TempStringToWrite, TempLength);
									}
								}
								TempErrorLogFile->Close();

								// have shadow directory? and valid TempFileNameShadowString name
								if ((CompareBit(vGlobalShadowImages, cShadowEventLogBit) == cShadowEventLogBit) && (TempFileNameShadowString != ""))
								{
									TempFileNameShadowStringPtr = TempFileNameShadowString.GetBuffer(TempFileNameShadowString.GetLength());
									if (ThereIsEnoughMemory(sizeof(CFile), "Event Log File"))
									{
										CFile *TempErrorLogFile2 = new CFile;
										if (TempErrorLogFile2)
										{
											int TempOpenedFileOK2 = TempErrorLogFile2->Open(TempFileNameShadowStringPtr,
												(CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException);

											if (TempOpenedFileOK2)
											{
												ULONGLONG TempFileLength = TempErrorLogFile2->SeekToEnd();

												if ((TempErrorLogFile2->m_hFile) && (TempErrorLogFile2->m_hFile != INVALID_HANDLE_VALUE))
												{
													TempErrorStringForFile = TempErrorStringForFile + "\n";
													WORD TempLength = TempErrorStringForFile.GetLength();
													if (TempLength)
													{
														CW2A TempStringToWrite(TempErrorStringForFile);
														TempErrorLogFile2->Write(TempStringToWrite, TempLength);
													}
												}
												TempErrorLogFile2->Close();
											}
										}
										delete TempErrorLogFile2;
									}
								}
							}
							else
								ReportErrorMessage("Failed to Write Event Log File to Disk 1 ", cEMailInspx, 32322); //6/28/2011

							delete TempErrorLogFile;
						}
					}
					else
						ReportErrorMessage("Failed to Write Event Log File to Disk 2 ",cEMailInspx, 32322); //6/28/2011
				}
				CATCH_ALL(TempException)
				{
					ReportErrorMessage("System could not write to Event Log 3",cEMailInspx,32322); //6/28/2011
				}
				END_CATCH_ALL
			}
			else
				ReportErrorMessage("Failed to Write Event Log File to Disk 4",cEMailInspx, 32322); //6/28/2011
		}	//end if	//file problem with server, if have a shadow directory, write to it
		else if (CompareBit(vGlobalShadowImages,cShadowEventLogBit) == cShadowEventLogBit)
		{
			CString TempFileShadowDirectoryString = cScanTracEventLogDirectory;	
			TempFileShadowDirectoryString.Delete(TempFileShadowDirectoryString.GetLength() -1, 1);

			LPCTSTR TempFileShadowDirectoryStringPtr = TempFileShadowDirectoryString.GetBuffer(TempFileShadowDirectoryString.GetLength()); //+ "\\ScanTracEventLog2008-07-14_12-34-08.txt";
			CFileStatus TempFileShadowStatus;

			if (CFile::GetStatus(TempFileShadowDirectoryStringPtr,TempFileShadowStatus))
			{
				ULONGLONG x = TempFileShadowStatus.m_size;
					//ULONGLONG x = TempFileStatus.m_size;

							//Write Event to log if configured
				TempDateString = TempTime.Format("%Y-%m-%d");
				TempTimeString = TempTime.Format("%H-%M-%S");

				//look for old event log under 2Mb
				TempFileNameShadowString = cScanTracEventLogDirectory;
				TempFileNameShadowString = TempFileNameShadowString + "\\" + "ScanTracEventLog" + TempDateString + "*" + ".txt";

				TempFileNameShadowStringPtr = TempFileNameShadowString.GetBuffer(TempFileNameShadowString.GetLength());
		
				hFind = FindFirstFile(TempFileNameShadowStringPtr, &FindFileData);
		
				if (hFind == INVALID_HANDLE_VALUE) // no files in directory
				{

					//if no old files found, make new file
					//TempFilePathString = TempFileDirectoryString + "ScanTracEventLog" + TempDateString 
					//	+ "_" + TempTimeString + ".txt";
					//TempFileNameString = TempFilePathString.GetBuffer(TempFilePathString.GetLength());
					TempFileNameShadowString = cScanTracEventLogDirectory;
					TempFileNameShadowString = TempFileNameShadowString + "ScanTracEventLog" + TempDateString + "_" + TempTimeString + ".txt";
					TempFileNameShadowStringPtr = TempFileNameShadowString.GetBuffer(TempFileNameShadowString.GetLength());
				} 
				else	//else scan through files to see one less than 2MB
				{
					do
					{
						TempFileNameShadowString = FindFileData.cFileName; 
						TempFileNameShadowString = cScanTracEventLogDirectory + TempFileNameShadowString;
						TempFileNameShadowStringPtr = TempFileNameShadowString.GetBuffer(TempFileNameShadowString.GetLength());
						if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
						{
							if (CFile::GetStatus(TempFileNameShadowStringPtr, TempFileShadowStatus))
							{
								if (TempFileShadowStatus.m_size > 2000000)
									TempFileNameShadowStringPtr = _T("");
								else	
									break;
							}
						}
					} 
					while (FindNextFile(hFind,&FindFileData));
			
					if (TempFileNameShadowStringPtr == _T(""))
					{
						TempFileNameShadowString = cScanTracEventLogDirectory;
						TempFileNameShadowString = TempFileNameShadowString + "ScanTracEventLog" + TempDateString + "_" + TempTimeString + ".txt";
						TempFileNameShadowStringPtr = TempFileNameShadowString.GetBuffer(TempFileNameShadowString.GetLength());
					}

				}

				FindClose(hFind);

				if (TempFileNameShadowStringPtr != _T(""))
				{
					CFileException *TempException = NULL;
					TRY
					{
						if (ThereIsEnoughMemory(sizeof(CFile), "Event Log File"))
						{
							CFile *TempErrorLogFile = new CFile;
							if (TempErrorLogFile)
							{
								//11/23/2009
								int TempOpenedFileOK = TempErrorLogFile->Open(TempFileNameShadowStringPtr,
									(CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException);

								if (TempOpenedFileOK)
								{
									ULONGLONG TempFileLength = TempErrorLogFile->SeekToEnd();

									if ((TempErrorLogFile->m_hFile) && (TempErrorLogFile->m_hFile != INVALID_HANDLE_VALUE))
									{
										TempErrorStringForFile = TempErrorStringForFile + "\n";
										WORD TempLength = TempErrorStringForFile.GetLength();
										if (TempLength)
										{
											CW2A TempStringToWrite(TempErrorStringForFile);
											TempErrorLogFile->Write(TempStringToWrite, TempLength);
										}
									}
									TempErrorLogFile->Close();
								}
								else
									ReportErrorMessage("Failed to Write Event Log File to Disk 1 ", cEMailInspx, 32322); //6/28/2011

								delete TempErrorLogFile;
							}
						}
						else
							ReportErrorMessage("Failed to Write Event Log File to Disk 2 ",cEMailInspx, 32322); //6/28/2011
					}
					CATCH_ALL(TempException)
					{
						ReportErrorMessage("System could not write to Event Log 3",cEMailInspx,32322); //6/28/2011
					}
					END_CATCH_ALL
				}
				else
					ReportErrorMessage("Failed to Write Event Log File to Disk 4",cEMailInspx, 32322); //6/28/2011
			}
		}
	}	// end if dont record message in log
}

void CScanTracDlg::AutoDeleteLogFiles()
{
	bool TempDeletedOldFiles = false;
	bool TempSearchDirectory = false;
	bool TempSearchDirectory2 = false;
	CTime TempTodaysDate, TempFileDate;
	TempTodaysDate = CTime::GetCurrentTime();
	CFileStatus TempFileStatus;

	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;

	WORD TempMoreThanXDaysOld = vConfigurationData->vNumberOfDaysToKeepLogs;
	vConfigurationData->vAutoDeleteFileTypes; 
	CString TempDirectory = "";
	CString TempDirectory2 = "";

	for (int i = 0; i < 5; i++)
	{
		switch (i)
		{
		case 0:
			if (vConfigurationData->vAutoDeleteFileTypes & 0x001)	// 0x1 = ACPower Monitor
			{
				TempDirectory = cACPowerMoniterLogDirectory;
				TempSearchDirectory = true;
				break;
			}
			i++;
		case 1:
			if (vConfigurationData->vAutoDeleteFileTypes & 0x002)	// 0x2 = Event Logs
			{
				TempDirectory = vConfigurationData->vScanTracEventLogDirectory;
				TempSearchDirectory = true;
				if (CompareBit(vGlobalShadowImages,cShadowEventLogBit) == cShadowEventLogBit)
				{
					TempDirectory2 = cScanTracEventLogDirectory;
					TempSearchDirectory2 = true;
				}
				break;
			}
			i++;
		case 2:
			if (vConfigurationData->vAutoDeleteFileTypes & 0x004)	// 0x4 = Images
			{
				TempDirectory = vConfigurationData->vScanTracImagesDirectory;
				TempSearchDirectory = true;
				break;
			}
			i++;
		case 3:
			if (vConfigurationData->vAutoDeleteFileTypes & 0x008)	// 0x8 = Screen Shots
			{
				TempDirectory = vConfigurationData->vScanTracScreenShotDirectory;
				TempSearchDirectory = true;
				if (CompareBit(vGlobalShadowImages,cShadowScreenShotsBit) == cShadowScreenShotsBit)
				{
					TempDirectory2 = cScanTracScreenShotDirectory;
					TempSearchDirectory2 = true;
				}
				break;
			}
			i++;
		case 4:
			if (vConfigurationData->vAutoDeleteFileTypes & 0x010)	// 0x10 = Serial logs
			{
				TempDirectory = vConfigurationData->vScanTracSerialLogsDirectory;
				TempSearchDirectory = true;
				break;
			}
			i++;
		default:
			break;
		}
		
		if (TempSearchDirectory)
		{
			CString TempString = TempDirectory + "*.*";
			LPTSTR TempDirectoryName = TempString.GetBuffer(TempString.GetLength());

			hFind = FindFirstFile(TempDirectoryName, &FindFileData);

			if (hFind != INVALID_HANDLE_VALUE) //have some files in the directory
			{
				CString TempString = " ";
				while (FindNextFile(hFind,&FindFileData))
				{
					TempString = TempDirectory + FindFileData.cFileName;
					if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
					{
						if (CFile::GetStatus(TempString,TempFileStatus))
						{ 						
							TempFileDate = TempFileStatus.m_ctime;

							CTimeSpan TempTimeSpan = CTimeSpan(TempTodaysDate - TempFileDate);

							if (TempTimeSpan.GetDays() > TempMoreThanXDaysOld)
							{
								if (!DeleteFile(TempString))
									ReportErrorMessage("Failed to Delete File: " + TempString, cEMailInspx, 32000);
								TempDeletedOldFiles = true;
							}
						}
					}
					Sleep(1);
				}
			}
			FindClose(hFind);

			TempSearchDirectory = false;
		}

		if (TempDeletedOldFiles)
			vSystemData.vLogFile.WriteToLogFile("Deleted old log files from " + TempDirectory,cDebugMessage);
		else
			vSystemData.vLogFile.WriteToLogFile("No old log files to delete" + TempDirectory,cDebugMessage);

		TempDeletedOldFiles = false;

		if (TempSearchDirectory2)
		{
			CString TempString = TempDirectory2 + "*.*";
			LPTSTR TempDirectoryName = TempString.GetBuffer(TempString.GetLength());

			hFind = FindFirstFile(TempDirectoryName, &FindFileData);

			if (hFind != INVALID_HANDLE_VALUE) //have some files in the directory
			{
				CString TempString = " ";
				while (FindNextFile(hFind,&FindFileData))
				{
					TempString = TempDirectory2 + FindFileData.cFileName;
					if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
					{
						if (CFile::GetStatus(TempString,TempFileStatus))
						{ 						
							TempFileDate = TempFileStatus.m_ctime;

							CTimeSpan TempTimeSpan = CTimeSpan(TempTodaysDate - TempFileDate);

							if (TempTimeSpan.GetDays() > TempMoreThanXDaysOld)
							{
								if (!DeleteFile(TempString))
									ReportErrorMessage("Failed to Delete File: " + TempString, cEMailInspx, 32000);
								TempDeletedOldFiles = true;
							}
						}
					}
					Sleep(1);
				}
			}
			FindClose(hFind);

			TempSearchDirectory2 = false;
		}

		if (TempDeletedOldFiles)
			vSystemData.vLogFile.WriteToLogFile("Deleted old log files from " + TempDirectory2,cDebugMessage);
		else
			vSystemData.vLogFile.WriteToLogFile("No old log files to delete" + TempDirectory2,cDebugMessage);

		TempDeletedOldFiles = false;


	}
/*	WORD TempMoreThanXDaysOld = vConfigurationData->vNumberOfDaysToKeepLogs;
	CString TempDirectory = cACPowerMoniterLogDirectory;
	// vScanTracProductionReportDirectory;
	// ;
	// ;
	// ;
	// vScanTracCalibrationImagesDirectory;
	// ;
	if (!TempMoreThanXDaysOld)
		TempMoreThanXDaysOld = 20;

		*/
}
/*
void CScanTracDlg::DeleteOldLogFiles(BYTE TempMoreThanXDaysOld, CString TempDirectory)
{
	if (!TempMoreThanXDaysOld)
		TempMoreThanXDaysOld = 20;
	bool TempDeletedOldFiles = false;
	BYTE TempNumberOfDaysToDelete = 31 - TempMoreThanXDaysOld;
	CTime TempTime;
	TempTime = CTime::GetCurrentTime();
	CString TempDayString = TempTime.Format("%d");  //give day of month
	CString TempMonthString = TempTime.Format("%m");  //gives month
	CString TempYearString = TempTime.Format("%Y");  //gives year
	BYTE TempCurrentDay = _wtoi(TempDayString);
	BYTE TempCurrentMonth = _wtoi(TempMonthString);
	WORD TempCurrentYear = _wtoi(TempYearString);

	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;

	if (TempDirectory == vConfigurationData->vScanTracEventLogDirectory)
	{
		CString TempString(vConfigurationData->vScanTracEventLogDirectory);
		TempString = TempString + "*.*";
		LPTSTR TempDirectoryName = TempString.GetBuffer(TempString.GetLength());

		hFind = FindFirstFile(TempDirectoryName, &FindFileData);

		if (hFind != INVALID_HANDLE_VALUE) //have some files in the directory
		{
			CString TempString;
			CString TempDirectory(vConfigurationData->vScanTracEventLogDirectory);
			while (FindNextFile(hFind,&FindFileData))
			{
				TempString = TempDirectory + FindFileData.cFileName;
				if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					WORD TempPositionOfEventLog = TempString.Find("ScanTracEventLog",0);
					if (TempPositionOfEventLog < 200)
					{
						BYTE TempPosition = TempString.Find("-",0);
						if (TempPosition < 200)
						{
							CString TempFileMonthString = TempString.Mid(TempPosition - 2, 2);
							CString TempFileDayString = TempString.Mid(TempPosition + 1, 2);
							CString TempFileYearString = TempString.Mid(TempPosition + 4, 4);
							BYTE TempFileMonth = _wtoi(TempFileMonthString);
							BYTE TempFileDay = _wtoi(TempFileDayString);
							WORD TempFileYear = _wtoi(TempFileYearString);
							
							bool TempNeedToDelete = (TempFileYear + 1 < TempCurrentYear);

							if ((TempFileYear < TempCurrentYear) &&
								(TempFileMonth < TempCurrentMonth))
								TempNeedToDelete = true;

							if ((TempFileYear < TempCurrentYear) &&
								(TempFileMonth == TempCurrentMonth) &&
								(TempFileDay <= TempCurrentDay))
								TempNeedToDelete = true;
						
							if (TempNeedToDelete)
							{
								if (!DeleteFile(TempString))
									ReportErrorMessage("Failed to Delete File: " + TempString, cEMailInspx, 32000);
								TempDeletedOldFiles = true;
							}
						}
					}
				}
				Sleep(1);
			}
		}
		FindClose(hFind);
	}


	if (TempDirectory == vConfigurationData->vScanTracProductionReportDirectory)
	{
		CString TempString(vConfigurationData->vScanTracProductionReportDirectory);
		TempString = TempString + "*.*";
		LPTSTR TempDirectoryName = TempString.GetBuffer(TempString.GetLength());

		hFind = FindFirstFile(TempDirectoryName, &FindFileData);

		if (hFind != INVALID_HANDLE_VALUE) //have some files in the directory
		{
			CString TempString;
			CString TempDirectory(vConfigurationData->vScanTracProductionReportDirectory);
			//TempString = TempDirectory + FindFileData.cFileName;
			while (FindNextFile(hFind,&FindFileData))
			{
				TempString = TempDirectory + FindFileData.cFileName;
				if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{
					WORD TempPositionofPReport = TempString.Find("ScanTracProductionReport",0);
					if (TempPositionofPReport < 200)
					{
						BYTE TempPosition = TempString.Find("-",0);
						if (TempPosition < 200)
						{
							CString TempFileMonthString = TempString.Mid(TempPosition - 2, 2);
							CString TempFileDayString = TempString.Mid(TempPosition + 1, 2);
							CString TempFileYearString = TempString.Mid(TempPosition + 4, 4);
							BYTE TempFileMonth = _wtoi(TempFileMonthString);
							BYTE TempFileDay = _wtoi(TempFileDayString);
							WORD TempFileYear = _wtoi(TempFileYearString);
							
							bool TempNeedToDelete = (TempFileYear + 1 < TempCurrentYear);

							if ((TempFileYear < TempCurrentYear) &&
								(TempFileMonth < TempCurrentMonth))
								TempNeedToDelete = true;

							if ((TempFileYear < TempCurrentYear) &&
								(TempFileMonth == TempCurrentMonth) &&
								(TempFileDay <= TempCurrentDay))
								TempNeedToDelete = true;
						
							if (TempPositionofPReport < 200)
							{
								WORD TempFile = (TempFileMonth * 30) + TempFileDay;
								WORD TempCurrent = (TempCurrentMonth * 30) + TempCurrentDay;
								if ((TempFile + 15) < TempCurrent)
									TempNeedToDelete = true;
							}
							if (TempNeedToDelete)
							{
								if (!DeleteFile(TempString))
									ReportErrorMessage("Failed to Delete File: " + TempString, cEMailInspx, 32000);
								TempDeletedOldFiles = true;
							}
						}
					}
				}
				Sleep(1);
			}
		}
		FindClose(hFind);
	}

	if (TempDirectory == vConfigurationData->vScanTracSerialLogsDirectory)
	{
		CString TempDirectoryString = vConfigurationData->vScanTracSerialLogsDirectory;
		//delete old serial log files
		TempDayString = TempTime.Format("%d");
		for (BYTE TempLoop = 0; TempLoop < TempNumberOfDaysToDelete; TempLoop++)
		{
			BYTE TempDayNumber = _wtoi(TempDayString);
			TempDayNumber++;
			if (TempDayNumber > 31)
				TempDayNumber = 1;
			TempDayString = dtoa(TempDayNumber,0);
			if (TempDayString.GetLength() == 1)
				TempDayString = "0" + TempDayString;
			CString TempFileNameString = TempDirectoryString + "ScanTracSerialData" + 
				TempDayString + "*.txt";

			LPTSTR TempFileToDeleteName = TempFileNameString.GetBuffer(TempFileNameString.GetLength());

			CFile TempFile;
			CFileStatus TempFileStatus;
			
			if (TempFile.GetStatus(TempFileToDeleteName, TempFileStatus))
			{
				WIN32_FIND_DATA FindFileData;
				HANDLE hFind;
				hFind = FindFirstFile(TempFileToDeleteName, &FindFileData);

				if (hFind == INVALID_HANDLE_VALUE) 
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n\nNo files in image directory to delete";
					TempNoticeDialog.vType = cInformationMessage;
					//TempNoticeDialog.vAutoClose = 15000;
					TempNoticeDialog.DoModal();
				} 
				else 
				{
					CString TempString;
					CString TempDirectory(vConfigurationData->vScanTracSerialLogsDirectory);
					TempString = TempDirectory + FindFileData.cFileName;
					if (TempString.GetAt(TempString.GetLength() - 1) != '.')
					{
						if (!DeleteFile(TempString))
							ReportErrorMessage("Failed to Delete File: " + TempString, cEMailInspx, 32000);
						TempDeletedOldFiles = true;
					}
					while (FindNextFile(hFind,&FindFileData))
					{
						TempString = TempDirectory + FindFileData.cFileName;
						if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
						if (!DeleteFile(TempString))
							ReportErrorMessage("Failed to Delete File: " + TempString, cEMailInspx, 32000);
						Sleep(1);
					}
					FindClose(hFind);
				}
			}
		}
	}

	if (vSystemData.vLogFile.vLogSerialData)
	if (TempDeletedOldFiles)
		vSystemData.vLogFile.WriteToLogFile("Deleted old log files",cDebugMessage);
	else
		vSystemData.vLogFile.WriteToLogFile("No old log files to delete",cDebugMessage);
}
		*/

void CScanTracDlg::SetupFrameGrabber()
{
	bool TempOK = true;
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter SetupFrameGrabber ScanTracDlg",cDebugMessage);

	//WORD TempImageHeight = 384; //vConfigurationData->vPixelsPerDetector * vConfigurationData->vNumberOfXRayDetectors;

	vSystemData.vITIPCDig->vAquisitionROIBottom = (WORD)(vGlobalCurrentProduct->vProductImageHeightBottom * vGlobalPixelsPerUnitInHeight);
									
	//if (vConfigurationData->vScanTracType == cAllegroScanTrac)
	//	vSystemData.vITIPCDig->vAquisitionROIBottom = vSystemData.vITIPCDig->vAquisitionROIBottom + (3 * 2); //front 3 detectors of 2 inches each are not there

	vSystemData.vITIPCDig->vAquisitionROITop = (WORD)(vGlobalCurrentProduct->vProductImageHeightTop * vGlobalPixelsPerUnitInHeight);

	if (vSystemData.vITIPCDig->vAquisitionROIBottom >= vSystemData.vITIPCDig->vAquisitionROITop)
		vSystemData.vITIPCDig->vAquisitionROIBottom = 0;

	WORD TempImageHeight = vSystemData.vITIPCDig->vAquisitionROITop - vSystemData.vITIPCDig->vAquisitionROIBottom;
	vSystemData.vITIPCDig->vMaximumImageOverlap = (WORD)(vGlobalCurrentProduct->vMaximumImageOverlap * vGlobalPixelsPerUnit * vGlobalCurrentProduct->vOverScanMultiplier);

	if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes) //in Multi Lane, figured out display height in SetupProduct
		TempImageHeight = vSystemData.vITIPCDig->vOriginalBufferSizeX;

	Sleep(10);

  BYTE TempNumberOfImageBuffersToGiveFrameGrabber = cFramesInAquisitionBuffer;
	if ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vUsingXScanPoint4mmDetectors))
	if ((vConfigurationData->vScanTracType == cAllegroScanTrac) || (vConfigurationData->vScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cForteScanTrac))
		TempNumberOfImageBuffersToGiveFrameGrabber = 2;

	if (TempOK)
		TempOK = vSystemData.vITIPCDig->SetupAquisitionBuffer(vGlobalCurrentProduct->vImageWidthPosition, TempNumberOfImageBuffersToGiveFrameGrabber, TempImageHeight, vConfigurationData->vPixelsPerDetector);
	Sleep(10);

	if (TempOK)
		vSystemData.vITIPCDig->InitializeCamera(vConfigurationData->vPixelsPerDetector);
/*
	if ((vGlobalCurrentProduct->vImageWidthPosition > 0) && (vGlobalCurrentProduct->vProductImageHeightTop > vGlobalCurrentProduct->vProductImageHeightBottom))
	{
		if (TempImageHeight + 2 < vSystemData.vITIPCDig->vAquisitionROITop)
		{
			vSystemData.vITIPCDig->vAquisitionROITop = TempImageHeight;
		}
	}
	*/
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Exit SetupFrameGrabber ScanTracDlg",cDebugMessage);
	if (!TempOK)
		vSystemData.vMemoryOK = false;
}

HBRUSH CScanTracDlg::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
  // Call the base class implementation first! Otherwise, it may
  // undo what we're trying to accomplish here.
	HBRUSH hbr = CDialog::OnCtlColor(pDC, pWnd, nCtlColor);
	int TempControlID = pWnd->GetDlgCtrlID();
	HWND TempDialogHwnd = this->m_hWnd;
	int TextSize;
	pDC->SetAttribDC(pDC->m_hDC);
 
	if (TempControlID == IDC_Clock) 
	{	TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_Clock, 5);
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cBlack);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID == IDC_Date)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_Date, 5);
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cBlack);
		return vSystemData.vLightBlueBrush;
	}

	if (TempControlID ==IDC_TotalGoodStaticText) 
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalGoodStaticText, 5);
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cDarkBlue);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID == IDC_RejectReason)
	{
		TextSize = SetTextSizeMultilineDisplay(TempDialogHwnd, pWnd, pDC, &m_RejectReason, 5);	
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cDarkBlue);
		return vSystemData.vLightBlueBrush;
	}
	 if (TempControlID ==IDC_TotalRejectsStaticText)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalRejectsStaticText, 5); 
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cRed);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID ==IDC_TotalRejectsPercent)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalRejectsPercent, 5); 
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cRed);
		return vSystemData.vLightBlueBrush;
	}

  if (TempControlID == IDC_TriggerIndicator)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TriggerIndicator, 5);  //5 is medium large
		if (vCPMNotRunning)
		{
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vYellowBrush;
		}
		if ((vShowingPipeEmpty) || (vShowingAirInPipe))
		if (vGlobalEvenSecond)
		{
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vYellowBrush;
		}
	}

	if (TempControlID == IDC_SupportContract)
	{
			TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_SupportContract, 5);  //5 is medium large
			pDC->SetBkMode(TRANSPARENT);
			pDC->SetAttribDC(pDC->m_hDC);
			if (vConfigurationData->vSupportContractType == cSupportContract24_7)
				pDC->SetTextColor(cMediumDarkGreen);
			else
			if (vConfigurationData->vSupportContractType == cSupportContract16_5)
				pDC->SetTextColor(cBlack);
			else
				pDC->SetTextColor(cBlue);
			return vSystemData.vLightBlueBrush;
	}

	if (TempControlID == IDC_SupportContract2)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_SupportContract2, 5);  //5 is medium large
			pDC->SetBkMode(TRANSPARENT);
			pDC->SetAttribDC(pDC->m_hDC);
			if ((vSupportContractStatus == cExpired) || (vSupportContractStatus == cNone))
				pDC->SetTextColor(cDarkRed); //for  expired
			else
			if (vSupportContractStatus == cContractLastMonth)
				pDC->SetTextColor(cYellow); //for 1 month until expires
			else
				pDC->SetTextColor(cBlue); //for not expired

			return vSystemData.vLightBlueBrush;
	}

	if (TempControlID == IDC_TotalUnConfirmed)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalUnConfirmed, 5);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		if (vSystemData.vOldTotalUnConfirmed)
			pDC->SetTextColor(cRed);
		else
			pDC->SetTextColor(cDarkBlue);
		return vSystemData.vLightBlueBrush;
	}
	
  if ((TempControlID == IDC_TestModesActive) && (vOldSamplesToGo))
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_EjectorsDisabled, 5);  //5 is medium large
		pDC->SetTextColor(cButtonTextColor);
		pDC->SetBkMode(TRANSPARENT);
		return vSystemData.vLightGreenBrush;
	}

	if (TempControlID == IDC_EjectorsDisabled)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_EjectorsDisabled, 5);  //5 is medium large
		if (!vDisplayingVersion)
		{
			pDC->SetTextColor(cButtonTextColor);
			if (vGlobalEvenSecond)
				pDC->SetTextColor(cDarkBlue);
			else
				pDC->SetTextColor(cYellow);
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vYellowBrush;
		}
	}

	if (TempControlID == IDC_TestModesActive)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TestModesActive, 5);  //5 is medium large
			
		if (!vDisplayingVersion)
		{
			pDC->SetTextColor(cButtonTextColor);
			if (vGlobalEvenSecond)
				pDC->SetTextColor(cDarkBlue);
			else
				pDC->SetTextColor(cYellow);
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vYellowBrush;
		}
		else 
		{
			pDC->SetTextColor(cButtonTextColor);
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vLightGreenBrush;
		}
	}
	if (TempControlID == IDC_DoNotShutOffPower)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_DoNotShutOffPower, 5);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		if (vGlobalEvenSecond)
			pDC->SetTextColor(cDarkBlue);
		else
			pDC->SetTextColor(cYellow);
		return vSystemData.vYellowBrush;
	}

	if (TempControlID == IDC_uControllerStatus) 	
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_uControllerStatus, 5);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		if (vGlobalEvenSecond)
			pDC->SetTextColor(cDarkBlue);
		else
			pDC->SetTextColor(cRed);
		if (vShowuControllerStatusInRed)
			return vSystemData.vRedBrush;
	}

	if (TempControlID == IDC_StatusLine)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_StatusLine, 5);  //5 is medium large
		if ((vSystemData.vYellowMessageButtonYellow) && (!vDisplayingVersion))
		{
			pDC->SetTextColor(cDarkBlue);
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vYellowBrush;
		}
		else
		if ((vGlobalLearnState) && (vGlobalLearnState != 255)) //colors for Improving Learn - Do not test contaminants indicator
		{
			pDC->SetTextColor(cWhite);
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vDarkBlueBrush;
		}
		else
		{
			pDC->SetTextColor(cBlack);
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vLightBlueBrush;
		}
			return vSystemData.vLightBlueBrush;
	}

	if (TempControlID == IDC_ShowingRejects)
	{
		pDC->SetTextColor(cButtonTextColor);
		pDC->SetBkMode(TRANSPARENT);
		TextSize = SetTextSizeMultilineDisplay(TempDialogHwnd, pWnd, pDC, &m_ShowingRejects, 5);  //5 is medium large
		if (vSystemData.vITIPCDig->vImageDisplayOnlyRejects)
		//	return vSystemData.vLightBlueBrush;
		//else
			return vSystemData.vGreenBrush;
	}
	
	if (TempControlID == IDD_ScanTracDlg)
	{
		//pDC->SetBkMode(TRANSPARENT);
		//pDC->SetTextColor(cButtonTextColor);
		//pDC->SetBkColor(cGreen);
		return vSystemData.vBlueBrush;
	}

	if (TempControlID == IDC_Function2Button)
	{
		TextSize = SetTextSizeFunctionButton(TempDialogHwnd, pWnd, pDC, &m_Function2Button, 5);
		pDC->SetTextColor(cSupervisorTextColor);
		pDC->SetBkMode(TRANSPARENT);
		return vGlobalButtonColorBrush;
	}
	
	if (TempControlID == IDC_SubFunction1Button)
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_SubFunction1Button, 6);
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		return vSystemData.vRedBrush;
	}

	if (TempControlID == IDC_Function1Button)
	{
		TextSize = SetTextSizeFunctionButton(TempDialogHwnd, pWnd, pDC, &m_Function1Button, 5);
	
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		return vGlobalButtonColorBrush;
	}
	if (TempControlID == IDC_Function2Button)
	{
		TextSize = SetTextSizeFunctionButton(TempDialogHwnd, pWnd, pDC, &m_Function2Button, 5);
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		return vGlobalButtonColorBrush;
	}
	if (TempControlID == IDC_Function3Button)
	{
		TextSize = SetTextSizeFunctionButton(TempDialogHwnd, pWnd, pDC, &m_Function3Button, 5);
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		return vGlobalButtonColorBrush;
	}
	if (TempControlID == IDC_Function4Button)
	{
		TextSize = SetTextSizeFunctionButton(TempDialogHwnd, pWnd, pDC, &m_Function4Button, 5);
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		return vGlobalButtonColorBrush;
	}
	if (TempControlID == IDC_Function5Button)
	{
		TextSize = SetTextSizeFunctionButton(TempDialogHwnd, pWnd, pDC, &m_Function5Button, 5);
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		return vGlobalButtonColorBrush;
	}
	if (TempControlID == IDC_SubFunction2Button) 
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_SubFunction2Button, 6);
		pDC->SetTextColor(cButtonTextColor);
		pDC->SetBkMode(TRANSPARENT);
		if (!vConfigurationData->vEnableEjectors)
			return vSystemData.vGreenBrush;
		else
			return vSystemData.vYellowBrush;
		return vGlobalButtonColorBrush;
	}
	if (TempControlID == IDC_SubFunction3Button)
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_SubFunction3Button, 6);
		if (!vGlobalCurrentProduct)
		{
			pDC->SetTextColor(cButtonTextColor);
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vGreenBrush;
		}
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		return vGlobalButtonColorBrush;
	}
 
	if (TempControlID == IDC_SubFunction4Button)
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_SubFunction4Button, 8);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);

		if (vSubFunction4ButtonEnable == true)
			pDC->SetTextColor(cButtonTextColor);
		else
			pDC->SetTextColor(cGray);
		return vSystemData.vGreenBrush;
	}

	if (TempControlID == IDC_SubFunction5Button)
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_SubFunction5Button, 5);  //5 is medium large
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		return vGlobalButtonColorBrush;
	}

	if (TempControlID == IDC_SubFunction6Button)
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_SubFunction6Button, 5);  //5 is medium large
		pDC->SetTextColor(cButtonTextColor);
		pDC->SetBkMode(TRANSPARENT);
		if (vSystemData.vYellowMessageButtonYellow)
			return vSystemData.vYellowBrush;
		else
			return vGlobalButtonColorBrush;
	}

	if (TempControlID == IDC_SubFunction7Button)
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_SubFunction7Button, 6);
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
			return vGlobalButtonColorBrush;
	}

	if (TempControlID == IDC_SubFunction8Button)
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_SubFunction8Button, 6);
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
	}
	if (TempControlID == IDC_SubFunction8Button)
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_SubFunction8Button, 5);
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		if (vSystemData.vITIPCDig->vImageDisplayOnlyRejects)
			return vSystemData.vGreenBrush;
		else
		return vGlobalButtonColorBrush;
	}
 
	if (TempControlID == IDC_ChatMessage) 
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_ChatMessage, 4);  //5 is medium large
		if (vSystemData.vLastChatWindowText.GetLength() > 2)
		{
			pDC->SetTextColor(cRed); //cButtonTextColor);
			pDC->SetBkMode(TRANSPARENT);
			return vSystemData.vLightGreenBrush;
		}
		else
		{
			pDC->SetTextColor(cButtonTextColor);
			pDC->SetBkMode(TRANSPARENT);
		}
	}

	if (TempControlID == IDC_Shift) 
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_ShiftControl, 4);  //5 is medium large
		pDC->SetTextColor(cButtonTextColor);
		pDC->SetBkMode(TRANSPARENT);
	}

	if ((TempControlID == IDC_MainBackground) ||
		(TempControlID == IDC_MainBackground2) )
	{
		//pDC->SetBkMode(TRANSPARENT);
		return vSystemData.vLightBlueBrush;
	}

	if (TempControlID ==IDC_TotalGoodLabelStaticText)
	{
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cWhite);
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalGoodLabelStaticTextControl, 5);  //5 is medium large
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID ==IDC_TotalRejectsPercentLabel)
	{
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cWhite);
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalRejectsPercentLabel, 4);  //5 is medium large
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID ==IDC_CurrentProductLabel)
	{
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cWhite);
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_CurrentProductLabel, 4);  //5 is medium large
		return vSystemData.vLightBlueBrush;
	}

	if (TempControlID == IDC_ProductLabel)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_ProductLabelControl, 4);  //5 is medium large
		pDC->SetTextColor(cDarkBlue);
		if (!vGlobalCurrentProduct)
		{
			pDC->SetBkColor(cYellow);
			return vSystemData.vLightBlueBrush;
		}
		else
		{
			return vSystemData.vLightBlueBrush;
		}
	}
	if (TempControlID == IDC_BackGroundStatic)
	{
		pDC->SetBkMode(TRANSPARENT);
		return vSystemData.vLightGreenBrush;
	}

	if (TempControlID == IDC_ContainersPerMinute)
	{
			TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_ContainersPerMinuteControl, 5);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cBlack);
		if ((vSystemData.vSystemRunMode == cConditionXRayTubeMode) && (vSystemData.vConditionString == "Burn-in"))
		{
			if (vSystemData.vXRayTubeConditionStepTimeLeft < 3600 * 48) //if less than 24 hours of burn in
				return vSystemData.vYellowBrush;
			else
				return vSystemData.vGreenBrush;
		}
		else
		if ((vCPMNotRunning) && (vSystemData.vSystemRunMode != cAutoSetupRunningSystem) && (vSystemData.vSystemRunMode != cRunningSystemMode))
			return vSystemData.vYellowBrush;
		else
			return vSystemData.vLightBlueBrush;

	}
	if (TempControlID == IDC_TotalContainersLabel)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalContainersLabelControl, 4);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cWhite);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID == IDC_TotalUnConfirmLabel)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalUnConfirmLabel, 4);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cWhite);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID ==IDC_TotalRejectsLabelStaticText)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalRejectsLabelStaticText, 4);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cWhite);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID == IDC_PercentRejectLabel)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_PercentRejectedLabelControl, 4);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cWhite);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID == IDC_TotalEjectsLabelStaticText)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalEjectsLabelStaticTextControl, 4);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cWhite);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID == IDC_BeltRateLabel)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_BeltRateLabel, 4);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cWhite);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID == IDC_TotalContainers)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalContainersControl, 4);  //5 is medium large
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cDarkBlue);
		return vSystemData.vLightBlueBrush;
	}

	if (TempControlID == IDC_BeltRate)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_BeltRate, 4);  //5 is medium large
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cDarkBlue);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID == IDC_PercentRejected)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_PercentRejectedControl, 4);  //5 is medium large
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cDarkBlue);
		return vSystemData.vLightBlueBrush;
	}
	if (TempControlID == IDC_TotalEjectsStaticText)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_TotalEjectsStaticText, 4);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cDarkBlue);
		return vSystemData.vLightBlueBrush;
	}
	
	if (TempControlID == IDC_DialogTitleStaticText1)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_DialogTitleStaticText1, 8);  //5 is medium large
		//if ((vGlobalUnderRemoteControl) && (vGlobalEvenSecond))
		//	pDC->SetTextColor(cRed);
		//else
		if (vGlobalShiftKeyDown)
			pDC->SetTextColor(cBlack);
		else
		if (vEnteringPecoPasswordMode)
			pDC->SetTextColor(cPurple);
		else
			pDC->SetTextColor(vGlobalDialogTitleColor);


		pDC->SetBkMode(TRANSPARENT);
	}

	if (TempControlID == IDC_XRaysOn)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_XRaysOn, 8);  //5 is medium large
		pDC->SetAttribDC(pDC->m_hDC);
		pDC->SetTextColor(cYellow);
			pDC->SetBkMode(TRANSPARENT);
		//pDC->SetBkColor(cRed);
		return vSystemData.vRedBrush;
	}

	
	if (TempControlID == IDC_Calibrating)
	{
		pDC->SetAttribDC(pDC->m_hDC);
		pDC->SetTextColor(cYellow);
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_Calibrating, 7);  //5 is medium large
		pDC->SetBkMode(TRANSPARENT);
		//pDC->SetBkColor(cRed);
		return vSystemData.vRedBrush;
	}
	
	if (TempControlID == IDC_DemoHelpButton)
	{
		TextSize = SetTextSizeSubFunctionButton(TempDialogHwnd, pWnd, pDC, &m_DemoHelpButton, 6);
		
		pDC->SetBkMode(TRANSPARENT);
		pDC->SetTextColor(cButtonTextColor);
		return vGlobalButtonColorBrush;
	}
	if (TempControlID == IDC_uControllerStatus)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_uControllerStatus, 5);
		pDC->SetBkMode(TRANSPARENT);
	}
	if (TempControlID == IDC_LearnState)
	{
		TextSize = SetTextSizeSingleLineDisplay(TempDialogHwnd, pWnd, pDC, &m_LearnState, 5);
		pDC->SetTextColor(cBlack);
		pDC->SetBkMode(TRANSPARENT);
	}
	if (TempControlID == IDC_DensityCompensation)
		TextSize = SetTextSizeFunctionButton(TempDialogHwnd, pWnd, pDC, &m_DensityCompensation, 5);
	if (TempControlID == IDC_ThresholdIncrease)
		TextSize = SetTextSizeFunctionButton(TempDialogHwnd, pWnd, pDC, &m_ThresholdIncrease, 5);
	return hbr;
}

void CScanTracDlg::WriteConfigurationDataToFile(bool TempWriteToBackup) 
{
	//save product data in a file
	vConfigurationData->vXRaySourceRunDuration = vGlobalLifeTimeCounters->vXRaySourceRunDuration;  //set the value in Products.Str
	vConfigurationData->vDetectorsRunDuration = vGlobalLifeTimeCounters->vDetectorsRunDuration;
	vConfigurationData->vScanTracRunDuration = vGlobalLifeTimeCounters->vScanTracRunDuration;
	
	if (vSystemData.vXRayOnNotice)
		vConfigurationData->vTimeXRaysWereOnLast = CTime::GetCurrentTime();

	if (vGlobalCurrentProduct) //&& (vConfigurationData->vLoadLastProduct))
		vConfigurationData->vLastProduct = *vGlobalCurrentProduct->GetProductName();
	else
		vConfigurationData->vLastProduct = "No Product";


		vConfigurationData->vLogSerialData = vSystemData.vLogFile.vLogSerialData;
		vConfigurationData->vLogSyncData = vSystemData.vLogFile.vLogSyncData;

	CFileException TempFileException;

	bool TempOKToWriteFile = true;
	bool TempGiveRebootNotice = false;
	CString TempBootMessageText = "Products.STR Write Error, Rebooting"; 

	TRY
	{
		if (TempWriteToBackup)
		{
			CString TempStreamFileNameString = cSetupDataDirectory;
			if (vSystemData.vITIPCDig->vUsingLocalSetupDataFile)
				TempStreamFileNameString = vGlobalCurrentDirectory;

			TempStreamFileNameString = TempStreamFileNameString + "Products.STR";

			LPTSTR TempStreamFileName = TempStreamFileNameString.GetBuffer(TempStreamFileNameString.GetLength());

			CFileStatus TempFileStatus;
			if (CFile::GetStatus(TempStreamFileName, TempFileStatus))
			{
				ULONGLONG TempFileSize = TempFileStatus.m_size;
				if (TempFileSize == 0)
				{
					TempOKToWriteFile = false;
					ReportErrorMessage("Products.STR Empty when writing backup, Rebooting now",cEMailInspx,32000);
					TempGiveRebootNotice = true;
					TempBootMessageText = "Products.STR Empty when writing backup, Rebooting now";
				}
				else
				{
					int TempNumberOfProducts = vProductCollection.GetSize();
					double TempExpectedSize = 15000 + (TempNumberOfProducts * 1700);
					if (TempFileSize < TempExpectedSize)//if primary file too small
					{
						CString TempStreamFileNameStringB = cSetupDataDirectory;
						if (vSystemData.vITIPCDig->vUsingLocalSetupDataFile)
							TempStreamFileNameStringB = vGlobalCurrentDirectory;

						TempStreamFileNameStringB = TempStreamFileNameStringB + "ProductsB.STR";

						LPTSTR TempStreamNameStringB = TempStreamFileNameStringB.GetBuffer(TempStreamFileNameStringB.GetLength());

						CFileStatus TempFileStatusB;
						if (CFile::GetStatus(TempStreamNameStringB, TempFileStatusB))
						{
							ULONGLONG TempFileSizeB = TempFileStatusB.m_size;
							if (TempFileSizeB < TempExpectedSize)  //if backup file correct size
							{
								TempOKToWriteFile = false;
								ReportErrorMessage("Products.STR too small when writing backup, Rebooting now",cEMailInspx,32000);
								TempGiveRebootNotice = true;
								TempBootMessageText = "Products.STR too small when writing backup, Rebooting now";
							}
						}
					}
				}
			}
			else
			{
				TempOKToWriteFile = false;
				ReportErrorMessage("Products.STR Missing when writing backup, Rebooting now",cEMailInspx,32000);
				TempGiveRebootNotice = true;
				TempBootMessageText = "Products.STR Missing when writing backup, Rebooting now";
			}
		}

		if (TempOKToWriteFile)
		{
			CString TempProductFileNameString = cSetupDataDirectory;
			if (vSystemData.vITIPCDig->vUsingLocalSetupDataFile)
				TempProductFileNameString = vGlobalCurrentDirectory;

			if (TempWriteToBackup == false)
				TempProductFileNameString = TempProductFileNameString + "Products.STR";
			else
				TempProductFileNameString = TempProductFileNameString + "ProductsB.STR";

			LPTSTR TempProductFileName = TempProductFileNameString.GetBuffer(TempProductFileNameString.GetLength());
			CFile TempProductFile(TempProductFileName,CFile::modeCreate | CFile::modeWrite);
			CFile *PTempProductFile = &TempProductFile;
				if (PTempProductFile)
			if (ThereIsEnoughMemory(sizeof(CArchive), "Archive"))
			{
				CArchive *PProductArchive = new CArchive(PTempProductFile,CArchive::store);
				if (PProductArchive)
				if (ThereIsEnoughMemory(sizeof(CProduct), "New Product for Write Config"))
				{
					CObject *TempObjectPointer = new CProduct;
					CFile *TempArchiveFilePointer = PProductArchive->GetFile();
					if ((TempObjectPointer) && (TempArchiveFilePointer))
					{
						int TempSize = sizeof(CProduct);

						//Write the configuration data to the file
						CObject *TempObjectDataPointer = vConfigurationData;
						PProductArchive->WriteObject(TempObjectDataPointer);

						//Write the PCDig data to the file
						//TempObjectDataPointer = vSystemData.vITIPCDig;
						//PProductArchive->WriteObject(TempObjectDataPointer);

						//Write the serial object data to the file
						//TempObjectDataPointer = vSystemData.vOlduCSerialPort;
						//PProductArchive->WriteObject(TempObjectDataPointer);

						//write the product object type to the file
						CRuntimeClass *TempProductRunTimeClass = TempObjectPointer->GetRuntimeClass();
						PProductArchive->WriteClass(TempProductRunTimeClass);

						//write all the products to the file
						CProduct *TempProductPointer;
						CString *TempName;
						int TempLoop = 1;
						int TempNumberOfProducts = vProductCollection.GetSize();
						//need to loop until end of file
						for (TempLoop=1; TempLoop <= TempNumberOfProducts ; TempLoop++)
						{
							TempProductPointer = GetProductByNumber(TempLoop);
							PProductArchive->WriteObject(TempProductPointer);
							//throw( CFileException, CArchiveException);
							TempName = TempProductPointer->GetProductName();
						}
						}
						if (TempObjectPointer)
							delete TempObjectPointer;
					}
					if (PProductArchive)
					{
						PProductArchive->Close(); 
						delete PProductArchive;
					}
				}
				if (PTempProductFile)
					PTempProductFile->Close();
			}
	}
	CATCH(CFileException, TempFileException)
	{
		ReportErrorMessage("System could not write configuration data to file",cEMailInspx,32000);
		TempGiveRebootNotice = true;
		TempBootMessageText = "Products.STR write error, Rebooting now";
		//CNoticeDialog TempNoticeDialog;
		//TempNoticeDialog.vNoticeText = "\n\n\nSystem could not write configuration data to file";
		//TempNoticeDialog.vType = cErrorMessage;
		//TempNoticeDialog.DoModal();
		//#ifdef _DEBUG
		//	afxDump << "Configuraton file could not be opened " << TempFileException->m_cause << "\n";
		//#endif
	}
	END_CATCH
	//if (!WriteConfigurationDataToINIFile())
	//	ReportErrorMessage("Error - Could not write INI file", cEMailInspx,32000);

	//int TempNumberOfFilesFlushed;
	//TempNumberOfFilesFlushed = _flushall();
	if (TempGiveRebootNotice)
	{
#ifdef _DEBUG
		CYesNoDialog TempYesNoDialog;
		TempBootMessageText = TempBootMessageText + "\nRelease Version would Reboot now,\nThis is a development version,\nDo you want to Reboot Now?";
		TempYesNoDialog.vNoticeText = TempBootMessageText;
		TempYesNoDialog.vYesButtonText = "Reboot Now!";
		TempYesNoDialog.vNoButtonText = "Reboot Later";
		TempYesNoDialog.vQuestionType = cConfirmQuestion;
		int TempResult = TempYesNoDialog.DoModal();
		if (TempResult == IDOK)
			SystemShutDown(cReboot);
#else
		CNoticeDialog TempNoticeDialog;
		TempBootMessageText = TempBootMessageText + "\n\n\n";
		TempNoticeDialog.vNoticeText = TempBootMessageText;
		TempNoticeDialog.vType = cInformationMessage;
		TempNoticeDialog.vAutoClose = 30000;
		TempNoticeDialog.DoModal();
		SystemShutDown(cReboot);
#endif
	}
	CheckDiskSpaceFree("C:\\");
	if (vSystemData.vLogFile.vLogSerialData)
	{
		if (TempWriteToBackup)
			vSystemData.vLogFile.WriteToLogFile("Save Backup Setup Data",cDebugMessage);
		else
			vSystemData.vLogFile.WriteToLogFile("Save Primary Setup Data",cDebugMessage);
	}

	if (!TempWriteToBackup)
	{
		KillTimer(vSetupDataBackupTimerHandle);
		int TimerResult = SetTimer(vSetupDataBackupTimerHandle,30000,NULL);	
	}
}

void CScanTracDlg::TurnSimulatedContainersOff() 
{
	if (vSystemData.vFPGAVersion9Point0OrHigher)
	{
		tSerialCommand TempCommand;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xFC;
		TempCommand[2] = 0;
		TempCommand[3] = 0;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime);

		ReportErrorMessage("Turn Simulated Containers OFF", cAction,0);
	}
	else
	{
		KillTimer(vSystemData.vSimulatedContainerTimerHandle);
		vSystemData.vSimulatedContainerTimerDelay = 0;
	}
}

void CScanTracDlg::TurnSimulatedContainersOn() 
{
	if (vSystemData.vFPGAVersion9Point0OrHigher)
	{
		WORD TempRate = 0;
		if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
		{
			if (vSystemData.vSystemRunMode != cStoppedSystemMode)
				TempRate = (WORD)(vSystemData.vITIPCDig->vOriginalBufferSizeY);  //NO Overlap so can construct images of each item without duplicates

			ReportErrorMessage("Multi Image: set how many lines to take next image", cAction,0);
		}
		else
		if ((vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
		{
			if (vSystemData.vSystemRunMode != cStoppedSystemMode)
			if (vSystemData.vITIPCDig->vOriginalBufferSize > vGlobalPixelsPerUnit)  //if more than an inch wide image
				TempRate = (WORD)(vSystemData.vITIPCDig->vOriginalBufferSizeY - (vGlobalPixelsPerUnit / 2));  //half inch of overlap
			else
			if (vSystemData.vITIPCDig->vOriginalBufferSize > (vGlobalPixelsPerUnit / 2)) //if more than half inch wide image
				TempRate = (WORD)(vSystemData.vITIPCDig->vOriginalBufferSizeY - (vGlobalPixelsPerUnit / 4)); //quarter inch overlap
			else
				TempRate = (WORD)(vSystemData.vITIPCDig->vOriginalBufferSizeY); //no overlap

			ReportErrorMessage("Bulk Mode: set how many lines to take next image", cAction,0);
		}
		else
		{
			if (vSystemData.vActualEncoderRate > 0) //if conveyor is moving
			if (vSystemData.vSystemRunMode != cStoppedSystemMode)
			if (vSystemData.vSimulateContainersRate)
			{
				TempRate = vSystemData.vSimulateContainersRate;
				ReportErrorMessage("Turn Simulated Containers on: " + dtoa(TempRate, 0), cAction,0);
			}
			else
			if (vConfigurationData->vContinuousFeedContainerRate)
			{
				TempRate = vConfigurationData->vContinuousFeedContainerRate;
				ReportErrorMessage("Turn Continuous Feed Containers on: " + dtoa(TempRate, 0), cAction,0);
			}
			//convert CPM to 4khz clock divider
			if (TempRate)
			{
				TempRate = (WORD)(4000.0 * 60.0/ (double)TempRate) - 1;
			}
		}

		tSerialCommand TempCommand;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xFC;
		TempCommand[2] = TempRate >> 8;
		TempCommand[3] = (BYTE)TempRate;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		//vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterOpen);
		Sleep(cSendCommandSleepTime);
	}
	else  //FPGA version before 9.0
	{
		KillTimer(vSystemData.vSimulatedContainerTimerHandle);
		vSystemData.vSimulatedContainerTimerDelay = 0;
		if (vSystemData.vActualEncoderRate > 0) //if conveyor is moving
		if (vSystemData.vSystemRunMode != cStoppedSystemMode)
		if (vSystemData.vSimulateContainersRate)
		{
			//convert CPM to Milli-sec delay
			WORD TempDelay = 60 * 1000 / vSystemData.vSimulateContainersRate; 
			int TimerResult = SetTimer(vSystemData.vSimulatedContainerTimerHandle,
				TempDelay,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Container Timer Failed",cEMailInspx,32000);
			vSystemData.vSimulatedContainerTimerDelay = TempDelay;
		}
		else
		if (vConfigurationData->vContinuousFeedContainerRate)
		{
			//convert CPM to Milli-sec delay
			WORD TempDelay = 60 * 1000 / vConfigurationData->vContinuousFeedContainerRate; 
			int TimerResult = SetTimer(vSystemData.vSimulatedContainerTimerHandle,
				TempDelay,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Container Timer Failed",cEMailInspx,32000);
			vSystemData.vSimulatedContainerTimerDelay = TempDelay;
		}
		if (vSystemData.vSystemRunMode != cStoppedSystemMode)
		{
			//if ((vSystemData.vSimulateContainersRate) ||
			//	vConfigurationData->vContinuousFeedContainerRate)
			//{ //don't enable body trigger if simulating body trigger
				//tSerialCommand TempCommand;
				//TempCommand[0] = 0x1C;
				//TempCommand[1] = 0x03;  //send mask for 16 digital lines in #3 , body triggers
				//TempCommand[2] = 0x00;
				//TempCommand[3] = 0x00;
				//if (vGlobaluCSerialPort)
				//	vGlobaluCSerialPort->SendSerialCommand(TempCommand);
				//vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterOpen);
			//	Sleep(cSendCommandSleepTime);
			//}
			//else
			{
				//vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterAutoControl);
				//figure out which Container Trigger mask bit to set
				tSerialCommand TempCommand;
				vSystemData.vCurrentBodyTriggerActiveLowMask = 0;
				
				vSystemData.vCurrentBodyTriggerMask = vConfigurationData-> vBodyTrigger[vGlobalCurrentProduct->vBodyTrigger - 1].vLineBitMask;
				if ((!vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBodyTrigger - 1].vActiveHigh) && (!vSystemData.vFPGAVersion10Point7OrHigher)) //always active high in FPGA 10.7 and above
					vSystemData.vCurrentBodyTriggerActiveLowMask = vSystemData.vCurrentBodyTriggerActiveLowMask | vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBodyTrigger - 1].vLineBitMask;

				if (vGlobalCurrentProduct->vBackupBodyTrigger)
				{
					vSystemData.vBackupBodyTriggerMask = vConfigurationData-> vBodyTrigger[vGlobalCurrentProduct->vBackupBodyTrigger - 1].vLineBitMask;
					if ((!vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBackupBodyTrigger - 1].vActiveHigh) && (!vSystemData.vFPGAVersion10Point7OrHigher)) //always active high in FPGA 10.7 and above
						vSystemData.vCurrentBodyTriggerActiveLowMask = vSystemData.vCurrentBodyTriggerActiveLowMask | vConfigurationData-> vBodyTrigger[vGlobalCurrentProduct->vBackupBodyTrigger - 1].vLineBitMask;
				}
				vSystemData.vDigitalInputLine3Mask = vSystemData.vBackupBodyTriggerMask | vSystemData.vCurrentBodyTriggerMask;
				if (vSystemData.vBackupBodyTriggerMask &&
					vSystemData.vCurrentBodyTriggerMask)
					vSystemData.vOnlyOneBodyTriggerEnabled = false;
				else
					vSystemData.vOnlyOneBodyTriggerEnabled = true;


				//Send Interrupt Mask for body trigger
				TempCommand[0] = 0x1C;
				TempCommand[1] = 0x03;  //send mask for 16 digital lines in #3 , body triggers
				TempCommand[2] = 0x00;
				TempCommand[3] = vSystemData.vDigitalInputLine3Mask;
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->SendSerialCommand(TempCommand);
				Sleep(cSendCommandSleepTime);

				//if just turned off simulate containers, and running, set shutter in auto mode
				//if (!vSystemData.vSimulateContainersRate)
				//if (vSystemData.vSystemRunMode == cRunningSystemMode)
				//if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
				//	vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterAutoControl);
			}
		}
	}
}

//Global functions

WORD BPAdd(WORD TempWord1, WORD TempWord2)
{
	WORD TempResult =  TempWord1 + TempWord2;
	return TempResult;
}

WORD BPSubtract(WORD TempWord1, WORD TempWord2)
{
		WORD TempResult =  TempWord1 - TempWord2;
	return TempResult;
}

void Wait100MicroSecondsForCommandSend()
{
	double TempEndTime = 0; 
	double TempStartTime = CIFCOS::GetSystimeMicrosecs();
	TempEndTime = CIFCOS::GetSystimeMicrosecs();
	while ((TempEndTime - TempStartTime < 100))
		TempEndTime = CIFCOS::GetSystimeMicrosecs();
}

CString uCConvertToDegreesCString(WORD TempReading, double TempAdjust)
{
	CString TempString("--");
	if (vGlobalFPGAVersion10Point0OrHigher)
	{
		if (TempReading)
		{
			double TempVolts = ((TempReading) * 3.3) / 255.0;
			double TempDegreesC = (4.1831 * TempVolts * TempVolts) - (41.603 * TempVolts) + 101.53;
			TempDegreesC = (int)(TempDegreesC + TempAdjust);
			double TempDegreesF = ((TempDegreesC * 9) / 5) + 32;
			TempString = dtoa(TempDegreesC,0);
			TempString = TempString + "`C, " + dtoa(TempDegreesF,0) + "`F";
		}
		//else
		//	TempString.LoadString(IDS_NoReading);
	}
	else
	{
		if (TempReading)
		{
			double TempVolts = ((TempReading) * 3.3) / 255.0;
			double TempDegreesC = (4.1831 * TempVolts * TempVolts) - (41.603 * TempVolts) + 101.53;
			TempDegreesC = TempDegreesC + TempAdjust;
			double TempDegreesF = ((TempDegreesC * 9) / 5) + 32;
			TempString = dtoa(TempDegreesC,0);
			//TempString = TempString + "`C, " + dtoa(TempDegreesF,0) + "`F, " +
			//	ByteToHex(TempReading + TempAdjust);
			TempString = TempString + "`C, " + dtoa(TempDegreesF,0) + "`F";
		}
		//else
		//	TempString.LoadString(IDS_NoReading);
	}
	return TempString;
}

int uCConvertToDegreesC(WORD TempReading, double TempAdjust)
{
	double TempDegreesC = 0;
	if (vGlobalFPGAVersion10Point0OrHigher)
	{
		if (TempReading)
		{
			double TempVolts = ((TempReading) * 3.3) / 4095.0;
			TempDegreesC = (4.1831 * TempVolts * TempVolts) - (41.603 * TempVolts) + 101.53;
			TempDegreesC = TempDegreesC + TempAdjust;
		}
	}
	else
	{
		if (TempReading)
		{
			double TempVolts = ((TempReading) * 3.3) / 255.0;
			TempDegreesC = (2.742 * TempVolts * TempVolts) - (32.635 * TempVolts) + 88.909;
			TempDegreesC = TempDegreesC + TempAdjust;
		}
	}
	return (int)TempDegreesC;
}
/*
CString ConvertToDegreesCString(WORD TempReading, double TempAdjust)
{
	CString TempString("");
	TempString = "";
	if (TempReading)
	{
		double TempVolts = ((TempReading) * 3.3) / 255.0;
		double TempDegreesC = (2.742 * TempVolts * TempVolts) - (32.635 * TempVolts) + 88.909;
		TempDegreesC = TempDegreesC + TempAdjust;
		double TempDegreesF = ((TempDegreesC * 9) / 5) + 32;
		TempString = dtoa(TempDegreesC,0);
		TempString = TempString + "`C, " + dtoa(TempDegreesF,0) + "`F";
	}
	else
		TempString.LoadString(IDS_NoReading);
	return TempString;
}

int ConvertToDegreesC(WORD TempReading, double TempAdjust)
{
	double TempDegreesC = 0;
	if (TempReading)
	{
		double TempVolts = ((TempReading) * 3.3) / 255.0;
		TempDegreesC = (2.742 * TempVolts * TempVolts) - (32.635 * TempVolts) + 88.909;
		TempDegreesC = TempDegreesC + TempAdjust;
	}
	return (int)TempDegreesC;
}
*/
CString ConvertToDegreesCString(WORD TempReading, double TempAdjust)
{
	CString TempString("--");
	if (vGlobalFPGAVersion10Point0OrHigher)
	{
		if (!((TempReading == 0) || (TempReading == 0xFFFF)))
		{
			double TempVolts = ((TempReading) * 5) / 4095.0;
			double TempDegreesC = (2.742 * TempVolts * TempVolts) - (32.635 * TempVolts) + 88.909;
			TempDegreesC = TempDegreesC + TempAdjust;
			double TempDegreesF = ((TempDegreesC * 9) / 5) + 32;
			TempString = dtoa(TempDegreesC,0);
			if (TempDegreesC <= 0)
				TempString = "No Sensor";
			else
				TempString = TempString + "`C, " + dtoa(TempDegreesF,0) + "`F";
		}
	}
	else
	{
		if (!((TempReading == 0) || (TempReading == 0xFFFF)))
		{
			double TempVolts = ((TempReading) * 3.3) / 255.0;
			double TempDegreesC = (2.742 * TempVolts * TempVolts) - (32.635 * TempVolts) + 88.909;
			TempDegreesC = (TempDegreesC + TempAdjust);
			double TempDegreesF = ((TempDegreesC * 9) / 5) + 32;
			TempString = dtoa(TempDegreesC,0);
			if (TempDegreesC <= 0)
				TempString = "No Sensor";
			else
				TempString = TempString + "`C, " + dtoa(TempDegreesF,0) + "`F";
		}
	}
	return TempString;
}

int ConvertToDegreesC(WORD TempReading, double TempAdjust)
{
	double TempDegreesC = 0;
	if (vGlobalFPGAVersion10Point0OrHigher)
	{
		if ((TempReading) && (TempReading < 0xFFFF))
		{
			double TempVolts = ((TempReading) * 5) / 4095.0;
			TempDegreesC = (2.742 * TempVolts * TempVolts) - (32.635 * TempVolts) + 88.909;
			TempDegreesC = TempDegreesC + TempAdjust + .5; //.5 to round off instead of truncate.
		}
	}
	else
	{
		if (TempReading)
		{
			double TempVolts = ((TempReading) * 3.3) / 255.0;
			TempDegreesC = (2.742 * TempVolts * TempVolts) - (32.635 * TempVolts) + 88.909;
			TempDegreesC = TempDegreesC + TempAdjust;
		}
	}

	if (TempDegreesC < 0)
		TempDegreesC = 0;
	return (int)TempDegreesC;
}
/*
int ConvertToPressurePSI(WORD TempReading, double TempAdjust)
{
	double TempPressurePSI = 0;
	if (TempReading)
	{
		//1 volt = 0 PSI, 4.91 volts = 80 PSI
		//a/d converter 12 bits, maximum 0xFFF = __ volts, code 0x000 = 0 volts
		//subtract value for 1 volt offset, multiply by full scale PSI, divide by maximum code value
		TempPressurePSI = ((TempReading - 834) * 80.0) / 3261;
		TempPressurePSI = TempPressurePSI + TempAdjust;
	}
	return (int)TempPressurePSI;
}

CString ConvertToPressurePSIString(WORD TempReading, double TempAdjust)
{
	double TempPressurePSI = 0;
	CString TempString("--");
	if (!((TempReading == 0) || (TempReading == 0xFFFF)))
	//{
		//if (PasswordOK(cTemporaryInspxPassword,false))
		//	TempString = dtoa(TempReading,0);
		//else
		//	TempString.LoadString(IDS_NoReading);
	//}
	//else
	{
		//1 volt = 0 PSI, 4.91 volts = 80 PSI
		//a/d converter 12 bits, maximum 0xFFF = __ volts, code 0x000 = 0 volts
		//subtract value for 1 volt offset, multiply by full scale PSI, divide by maximum code value
		TempPressurePSI = ((TempReading - 834) * 80.0) / 3261;
		TempPressurePSI = TempPressurePSI + TempAdjust;
		TempString = dtoa(TempPressurePSI,0) + " PSI";
		//if (PasswordOK(cTemporaryInspxPassword,false))
		//	TempString = TempString + ", " + dtoa(TempReading,0);
	}
	return TempString;
}
*/
CString ByteToHex(BYTE TempData)
{
	char TempChars[6] = "";

	BYTE TempByte = (TempData >> 4);

	if (TempByte < 10)
		TempChars[0] = (CHAR)(0x30 +TempByte);
	else
		TempChars[0] =(CHAR)(65 + TempByte - 10);

	TempByte = (TempData & 0x0F);

	if (TempByte < 10)
		TempChars[1] =(CHAR)(0x30 +TempByte);
	else
		TempChars[1] =(CHAR)(65 + TempByte - 10);

	return TempChars;
}

CString WordToHex(WORD TempData)
{
	char TempChars[6] = "";

	BYTE TempByte = (BYTE)(TempData >> 12);

	if (TempByte < 10)
		TempChars[0] = (CHAR)(0x30 +TempByte);
	else
		TempChars[0] =(CHAR)(65 + TempByte - 10);

	TempByte = (BYTE)((TempData & 0x0F00) >> 8);

	if (TempByte < 10)
		TempChars[1] = (CHAR)(0x30 +TempByte);
	else
		TempChars[1] =(CHAR)(65 + TempByte - 10);

	TempByte = (BYTE)((TempData & 0x00F0) >> 4);

	if (TempByte < 10)
		TempChars[2] = (CHAR)(0x30 +TempByte);
	else
		TempChars[2] =(CHAR)(65 + TempByte - 10);

	TempByte = (BYTE)(TempData & 0x000F);

	if (TempByte < 10)
		TempChars[3] =(CHAR)(0x30 +TempByte);
	else
		TempChars[3] =(CHAR)(65 + TempByte - 10);

	return TempChars;
}

double GetMaximumCurrentFromVoltage(double TempVoltage) 
{
	double TempMaximumCurrent = 10;
	if ((!vGlobalDXMXRayPort) && (!vGlobalMonoBlockXRayPort))
	{//when using XLF power supply, derate current at certain voltages.
		TempMaximumCurrent = - (TempVoltage * TempVoltage * 0.0029) +
			(TempVoltage * 0.3453) - .2449;
		if (TempVoltage >= 50)
		{
			TempMaximumCurrent = (TempVoltage * TempVoltage * 0.0025) -
				(TempVoltage * 0.435) + 25.1;
		}
	}

	/* old algrithm
	double TempMaximumCurrent = (TempVoltage * TempVoltage * 0.0089296) -
		(TempVoltage * TempVoltage * TempVoltage * 0.000125) +
		(TempVoltage * 0.0032143) + 2.68;
	*/
	if (TempMaximumCurrent > 10)
		TempMaximumCurrent = 10;

	return TempMaximumCurrent;
}

double GetMaximumCurrentFromPower(double TempVoltage, double TempMaximunPower) 
{
	double TempMaximumCurrent = 0;
	if (TempVoltage)
		TempMaximumCurrent = TempMaximunPower / TempVoltage;

	if (TempMaximumCurrent > 10)
		TempMaximumCurrent = 10;
				
	return TempMaximumCurrent;
}

WORD HexToWord(CString TempString)
{
	CString TempString1 = TempString;
	TempString1.MakeUpper();
	wchar_t TempChars[6] = _T("");
	wchar_t TempChar = ' ';
	WORD TempReturn = 0;

	while (TempString1.GetLength())
	{
		TempChar = TempString1.GetAt(0);
		if ((TempChar >= 'A') && (TempChar <= 'F'))
			TempReturn = (TempReturn * 16) + ((BYTE)(TempChar)) - 65 + 10;
		else
		if ((TempChar >= '0') && (TempChar <= '9'))
			TempReturn = (TempReturn * 16) + ((BYTE)(TempChar)) - 0x30;
		TempString1.Delete(0,1);
	}
	return TempReturn;
}

BYTE HexToByte(CString TempString)
{
	CString TempString1 = TempString;
	TempString1.MakeUpper();
	wchar_t TempChars[6] = _T("");
	wchar_t TempChar = ' ';
	WORD TempReturn = 0;

	while (TempString1.GetLength())
	{
		TempChar = TempString1.GetAt(0);
		if ((TempChar >= 'A') && (TempChar <= 'F'))
			TempReturn = (TempReturn * 16) + ((BYTE)(TempChar)) - 65 + 10;
		else
		if ((TempChar >= '0') && (TempChar <= '9'))
			TempReturn = (TempReturn * 16) + ((BYTE)(TempChar)) - 0x30;
		TempString1.Delete(0,1);
	}
	return (BYTE)TempReturn;
}


CString Pad(CString TempString, BYTE TempLengthLeft, BYTE TempLengthRight)
{
	WORD TempLength = TempString.GetLength();
	WORD TempDecimalPlace = TempString.Find('.',0);
	if (TempDecimalPlace == 65535)
	{
		for (WORD TempLoop = TempLength; TempLoop < TempLengthLeft; TempLoop++)
			TempString = " " + TempString;
	}
	else
	if (TempDecimalPlace < TempLengthLeft)
	for (WORD TempLoop = TempDecimalPlace; TempLoop < TempLengthLeft; TempLoop++)
		TempString = " " + TempString;

	if (TempLengthRight)
	{
		TempLength = TempString.GetLength();
		TempDecimalPlace = TempString.Find('.',0);
		if (TempDecimalPlace == 65535)
		{
			//TempString = TempString + ".";
			TempDecimalPlace = TempLengthLeft;
			for (WORD TempLoop = 0; TempLoop < TempLengthRight; TempLoop++)
				TempString = TempString + " ";
		}
		else
		for (WORD TempLoop = TempLength - TempDecimalPlace; TempLoop <= TempLengthRight; TempLoop++)
			TempString = TempString + " ";
	}
	return TempString;
}

BYTE FindMedianValue(BYTE *TempLineData, WORD TempHeight)
{
	BYTE TempMedianValue = 0;
	if (TempLineData)
	{
		WORD TempMiddleIndex = TempHeight / 2;
		BYTE *TempDataPointer = (BYTE *)malloc(TempHeight);
		if (TempDataPointer)
		{
			CopyMemory(TempDataPointer, TempLineData, TempHeight);
			QuickSort(TempDataPointer, 0, TempHeight);
			TempMedianValue = TempDataPointer[TempMiddleIndex];
			free(TempDataPointer);
		}
	}
	return TempMedianValue;
}

void QuickSort(BYTE *arr, WORD low, WORD high)
{
	if (low < high)
	{
		for (WORD TempLoop = low; TempLoop < high; TempLoop++)
		{
			bool TempSwapped = false;
			for (WORD TempPixelLoop = low; TempPixelLoop < high - 1; TempPixelLoop++)
			{
				if (arr[TempPixelLoop] > arr[TempPixelLoop + 1])
				{
					BYTE TempByte = arr[TempPixelLoop];
					arr[TempPixelLoop] = arr[TempPixelLoop + 1];
					arr[TempPixelLoop + 1] = TempByte;
					TempSwapped = true;
				}
			}
			if (!TempSwapped)
			{
				TempLoop = high;
				for (WORD TempPixelLoop = low; TempPixelLoop < high - 1; TempPixelLoop++)
				{
						BYTE TempByte = arr[TempPixelLoop];
				}
			}
		}
	}
}

double ATOF(CString TempString)
{
	if (vGlobalLanguage == cSpanish)
	if (!vGlobalUseCommaForDecimalPoint)
		TempString.Replace(_T("."), _T(","));

	double TempResult = _wtof(TempString);
	return TempResult;
}

CString dtoa(double TempData)
{
	char TempChars[40] = "";
	int TempInt = (int)TempData;
	_itoa_s(TempInt,TempChars, 20, 10);
	CString TempString = TempChars;
	if (vGlobalUseCommaForDecimalPoint)
		TempString = TempString + ",";
	else
		TempString = TempString + ".";

	BYTE TempLoop = 0;
	double TempDouble = TempData - TempInt;
	if (TempDouble != 0)
	for (; TempLoop < 4; TempLoop++)
	{
		TempInt = (BYTE)(TempDouble * 10);
		TempString = TempString + (char)(TempInt + 48);
		TempDouble = (TempDouble * 10) - TempInt;
	}
	while (	TempString.GetAt(TempString.GetLength()-1) == 48)
		TempString.Delete(TempString.GetLength()-1,1);

	wchar_t TempChar = TempString.GetAt(TempString.GetLength() - 1);
	if ((TempChar == '.') || ((vGlobalUseCommaForDecimalPoint) && (TempChar == ',')))
		TempString.Delete(TempString.GetLength() - 1, 1);

	return TempString;
}

void ReportErrorMessage(CString TempErrorMessage, BYTE TempLevel, WORD TempCode)
{
	vDialogPointer->ReportErrorMessage(TempErrorMessage, TempLevel, TempCode);
}

CString IToAWithComma(DWORD TempData)
{
	//Clip Length is number of digits after decimal point
	CString TempString = dtoa(TempData, 0);

	if (vGlobalUseCommaForDecimalPoint)
	{
		if (TempString.GetLength() > 3)
			TempString.Insert(TempString.GetLength() - 3, _T("."));
		if (TempString.GetLength() > 7)
			TempString.Insert(TempString.GetLength() - 7, _T("."));
		if (TempString.GetLength() > 11)
			TempString.Insert(TempString.GetLength() - 11, _T("."));
	}
	else
	{
		if (TempString.GetLength() > 3)
			TempString.Insert(TempString.GetLength() - 3, _T(","));
		if (TempString.GetLength() > 7)
			TempString.Insert(TempString.GetLength() - 7, _T(","));
		if (TempString.GetLength() > 11)
			TempString.Insert(TempString.GetLength() - 11, _T(","));
	}

	return TempString;
}

//#ifdef UseHalconLibraries
//HByteImage MakeHalconImage(Image *TempInputImage)
//{
//			HByteImage TempHalconImageIn = HByteImage::GenImage1("byte", TempInputImage->dx, TempInputImage->dy, (long)(TempInputImage->pix));
//			return TempHalconImageIn;
//}
//
//void CopyFromHalconImage(HByteImage TempHalconImage, Image *TempOutputImage)
//{
//			char     TempImageType[128] = "byte";
//			long     TempWidth = 0;
//			long     TempHeight = 0;
//			BYTE *TempHalconPointer = (BYTE *)(TempHalconImage.GetImagePointer1((HTuple *)(TempImageType), (HTuple *)TempWidth, (HTuple *)TempHeight));
//
//			CopyMemory(TempOutputImage->pix, TempHalconPointer, TempOutputImage->dx * TempOutputImage->dy);
//}
//
//void CopyFromHalconTuple(HTuple TempHalconTuple, Image *TempOutputImage)
//{
//			//char     TempImageType[128] = "byte";
//			//long     TempWidth = 0;
//			//long     TempHeight = 0;
//			//BYTE *TempHalconPointer = (BYTE *)(TempHalconImage.GetImagePointer1((HTuple *)(TempImageType), (HTuple *)TempWidth, (HTuple *)TempHeight));
//
//			//CopyMemory(TempOutputImage->pix, (BYTE *)TempHalconTuple[0], TempOutputImage->dx * TempOutputImage->dy);
//}
//
//void CopyFromHalconRegion(HRegion TempHalconRegion, Image *TempOutputImage)
//{
//			char     TempImageType[128] = "byte";
//			long     TempWidth = 0;
//			long     TempHeight = 0;
//
//
//			//BYTE *TempHalconPointer = (BYTE *)(TempHalconRegion.GetImagePointer1((HTuple *)(TempImageType), (HTuple *)TempWidth, (HTuple *)TempHeight));
//
//			//CopyMemory(TempOutputImage->pix, TempHalconPointer, TempInputImage->dx * TempInputImage->dy);
//}
//
//void ConvertHalconRegionToImage(HRegion TempHalconRegion, Image *TempOutputImage)
//{
//	// temp shape_trans(TempHalconRegion : RegionTrans : Type : )
//}
//#endif

void RotateImage90Degrees(Image *TempInputImage, int TempSteps)
{
	if ((TempInputImage) && (TempInputImage->pix))
	{
//#ifdef UseHalconLibraries
//		if (vGlobalUseHalconLibrary)
//		{//using HALCON
//			HByteImage TempHalconImageIn = MakeHalconImage(TempInputImage);
//			
//			int TempDegrees = 90;
//			if (TempSteps == -1)
//				TempDegrees = 270;
//			HByteImage TempRotatedImage = TempHalconImageIn.RotateImage(TempDegrees, "constant");
//			CopyFromHalconImage(TempRotatedImage, TempInputImage);
//		}
//		else
//#endif
		{ //MVTools
#ifdef UseIFCDLLs
				mvt_rotate90(TempInputImage, TempSteps);
#endif
		}
	}
}

void DoMedianSmooth(Image *TempInputImage, BYTE TempSmoothAmountX, BYTE TempSmoothAmountY)
{
	if ((TempInputImage) && (TempInputImage->pix))
	{
//#ifdef UseHalconLibraries
//		if (vGlobalUseHalconLibrary)
//		{//using HALCON
//			HByteImage TempHalconImageIn = MakeHalconImage(TempInputImage);
//			
//			HByteImage TempSmoothResultImage = TempHalconImageIn.MedianImage("square",  TempSmoothAmountX, 0);
//			CopyFromHalconImage(TempSmoothResultImage, TempInputImage);
//		}
//		else
//#endif
		{ //MVTools
#ifdef UseIFCDLLs
			mvt_median_rect(TempInputImage, TempSmoothAmountX, TempSmoothAmountY);
#endif
		}
	}
}

//void DilateImage(Image *TempInputImage)
//{
//	if ((TempInputImage) && (TempInputImage->pix))
//	{
//#ifdef UseHalconLibraries
//		if (vGlobalUseHalconLibrary)
//		{//using HALCON
//			HByteImage TempHalconImageIn = MakeHalconImage(TempInputImage);
//			
//			HByteImage TempResultImage = TempHalconImageIn.GrayOpeningRect(3, 3);
//			CopyFromHalconImage(TempResultImage, TempInputImage);
//		}
//		else
//#endif
//		{ //MVTools
//#ifdef UseIFCDLLs
//			Erflag TempResultError = mvt_dilate_rect(TempInputImage, 3, 3, NULL);
//			if (TempResultError != IM_OK)
//				ReportErrorMessage("Error, MVT Dilate Failed", cEMailInspx,32000);
//#endif
//		}
//	}
//}
//
//void DilateImage(Image *TempInputImage, Image *TempScratchImage)
//{
//	if ((TempInputImage) && (TempInputImage->pix))
//	if ((TempScratchImage) && (TempScratchImage->pix))
//	{
//		Erflag TempResultError = mvt_dilate(TempInputImage, TempScratchImage);
//		if (TempResultError != IM_OK)
//			ReportErrorMessage("Error, MVT Dilate Failed", cEMailInspx,32000);
//		else
//			CopyMemory(TempInputImage->pix, TempScratchImage->pix, TempInputImage->dx * TempInputImage->dy);
//	}
//}
//
//void ErodeImage(Image *TempInputImage)
//{
//	if ((TempInputImage) && (TempInputImage->pix))
//	{
//#ifdef UseHalconLibraries
//		if (vGlobalUseHalconLibrary)
//		{//using HALCON
//			HByteImage TempHalconImageIn = MakeHalconImage(TempInputImage);
//			
//			HByteImage TempResultImage = TempHalconImageIn.GrayClosingRect(3, 3);
//			CopyFromHalconImage(TempResultImage, TempInputImage);
//		}
//		else
//#endif
//		{ //MVTools
//#ifdef UseIFCDLLs
//			Erflag TempResultError = mvt_erode_rect(TempInputImage, 3, 3, NULL);
//			if (TempResultError != IM_OK)
//				ReportErrorMessage("Error, MVT Erode Failed", cEMailInspx,32000);
//#endif
//		}
//	}
//}
//
//void ErodeImage(Image *TempInputImage, Image *TempScratchImage)
//{
//	if ((TempInputImage) && (TempInputImage->pix))
//	if ((TempScratchImage) && (TempScratchImage->pix))
//	{
//#ifdef UseHalconLibraries
//		if (vGlobalUseHalconLibrary)
//		{//using HALCON
//			HByteImage TempHalconImageIn = MakeHalconImage(TempInputImage);
//			
//			HByteImage TempResultImage = TempHalconImageIn.GrayClosingRect(3, 3);
//			CopyFromHalconImage(TempResultImage, TempInputImage);
//		}
//		else
//#endif
//		{ //MVTools
//			//ZeroMemory(TempScratchImage->pix, TempInputImage->dx * TempInputImage->dy);
//			//Erflag TempResultError = mvt_erode(TempInputImage, TempScratchImage);
//#ifdef UseIFCDLLs
//			Erflag TempResultError = mvt_erode_rect(TempInputImage, 3, 3, EDGE_IGNORE);
//			if (TempResultError != IM_OK)
//				ReportErrorMessage("Error, MVT Erode Failed", cEMailInspx,32000);
//#endif			//else
//			//	CopyMemory(TempInputImage->pix, TempScratchImage->pix, TempInputImage->dx * TempInputImage->dy);
//		}
//	}
//}
//
void SubtractImage(Image *TempImageIn, Image *TempImageOut)
{
	if ((TempImageIn) && (TempImageIn->pix))
	if ((TempImageOut) && (TempImageOut->pix))
	{
//#ifdef UseHalconLibraries
//		if (vGlobalUseHalconLibrary)
//		{//using HALCON
//			HByteImage TempHalconImageIn = MakeHalconImage(TempImageIn);
//			HByteImage TempHalconImageIn1 = MakeHalconImage(TempImageOut);
//			
//			HByteImage TempHalconImageOut = TempHalconImageIn - TempHalconImageIn1;
//			CopyFromHalconImage(TempHalconImageOut, TempImageOut);
//		}
//		else
//#endif
		{ //MVTools
#ifdef UseIFCDLLs
			mvt_sub(TempImageIn, TempImageOut, TempImageOut, OL_CLIP);
#endif
		}
	}
}

void ThresholdImage(Image *TempImageIn, BYTE TempThreshold)
{
	if ((TempImageIn) && (TempImageIn->pix))
	{
		//if (vGlobalUseHalconLibrary)
		//{//using HALCON
		//	BYTE *TempPointer = TempImageIn->pix;
		//	DWORD TempSize = TempImageIn->dx * TempImageIn->dy;
		//	for (DWORD TempLoop = 0; TempLoop < TempSize; TempLoop++)
		//	{
		//		if (*TempPointer < TempThreshold)
		//			*TempPointer = 0;
		//		else
		//			*TempPointer = 255;
		//		TempPointer++;
		//	}
		//}
		//else
		{
				int TempError = mvt_threshold(TempImageIn, TempThreshold, 0, 255);
				if (TempError != IM_OK) 
				{
					ReportErrorMessage("MVT_Threshold Error",cEMailInspx,32000);
					ReportErrorMessage("Error-No MVTools License code: " + dtoa(TempError,0), cEMailInspx,32000);
				}
		}
	}
}

void ThresholdImageDown(Image *TempImageIn, BYTE TempThreshold)
{
	if ((TempImageIn) && (TempImageIn->pix))
	{
		//if (vGlobalUseHalconLibrary)
		//{//using HALCON
		//	BYTE *TempPointer = TempImageIn->pix;
		//	DWORD TempSize = TempImageIn->dx * TempImageIn->dy;
		//	for (DWORD TempLoop = 0; TempLoop < TempSize; TempLoop++)
		//	{
		//		if (*TempPointer < TempThreshold)
		//			*TempPointer = 0;
		//		TempPointer++;
		//	}
		//}
		//else
		{
				int TempError = mvt_threshold_down(TempImageIn, TempThreshold, 0);
				if (TempError != IM_OK) 
				{
					ReportErrorMessage("MVT_Threshold Error",cEMailInspx,32000);
					ReportErrorMessage("Error-No MVTools License code: " + dtoa(TempError,0), cEMailInspx,32000);
				}
		}
	}
}

BYTE MaximumValueInImage(Image *TempImageIn)
{
	BYTE TempResult = 0;
	if ((TempImageIn) && (TempImageIn->pix))
	{
		//if (vGlobalUseHalconLibrary)
		//{//using HALCON
		//	BYTE *TempPointer = TempImageIn->pix;
		//	DWORD TempSize = TempImageIn->dx * TempImageIn->dy;
		//	for (DWORD TempLoop = 0; TempLoop < TempSize; TempLoop++)
		//	{
		//		if (*TempPointer > TempResult)
		//			TempResult = *TempPointer;
		//		TempPointer++;
		//	}
		//}
		//else
		{
#ifdef UseIFCDLLs
			TempResult = mvt_max(TempImageIn, &TempImageIn->dx, &TempImageIn->dy);
#endif
		}
	}
	return TempResult;
}

BYTE MinimumValueInImage(Image *TempImageIn)
{
	BYTE TempResult = 255;
	if ((TempImageIn) && (TempImageIn->pix))
	{
		//if (vGlobalUseHalconLibrary)
		//{//using HALCON
		//	BYTE *TempPointer = TempImageIn->pix;
		//	DWORD TempSize = TempImageIn->dx * TempImageIn->dy;
		//	for (DWORD TempLoop = 0; TempLoop < TempSize; TempLoop++)
		//	{
		//		if (*TempPointer < TempResult)
		//			TempResult = *TempPointer;
		//		TempPointer++;
		//	}
		//}
		//else
		{
#ifdef UseIFCDLLs
			TempResult = mvt_min(TempImageIn, &TempImageIn->dx, &TempImageIn->dy);
#endif
		}
	}
	return TempResult;
}

CString GetCoreTemperatureString(WORD TemperatureIn)
{
	CString TempString;
	double TempDegreesF;
	double TempDegreesC;

	//if (vSystemData.vF_TemperatureType == true)
	//{
	//	TempDegreesF = (double)TemperatureIn;
	//	TempDegreesC = (TempDegreesF - 32);
	//	if (TempDegreesC != 0)
	//		TempDegreesC = ((TempDegreesC * 5) / 9);
	//	else
	//		TempDegreesC = 0;
	//	TempString = dtoa(TempDegreesC,0);
	//	TempString = TempString + "`C, " + dtoa(TempDegreesF,0) + "`F";
	//}
	//else
	{
		TempDegreesC = (double)TemperatureIn;
		if (TempDegreesC != 0)
			TempDegreesF = ((TempDegreesC * 9) / 5) + 32;
		else
			TempDegreesF = 32;
		TempString = dtoa(TempDegreesC,0);
		TempString = TempString + "`C, " + dtoa(TempDegreesF,0) + "`F";
	}
	return(TempString);
}


CString dtoa(double TempData, BYTE TempClipLength)
{
		//Clip Length is number of digits after decimal point
	CString TempString = _T("");
	TempString = _T("");
	if (vGlobalUseCommaForDecimalPoint)
	{
		if ((!(TempData > -.0000001)) && (TempData < 0))
		{
			TempData = - TempData;
			TempString = _T("-");
		}
		if (TempClipLength == 0)
			TempData = TempData + .5;
		else
		if (TempClipLength == 1)
			TempData = TempData + .05;
		else
		if (TempClipLength == 2)
			TempData = TempData + .005;
		else
		if (TempClipLength == 3)
			TempData = TempData + .0005;
		else
		if (TempClipLength >= 4)
			TempData = TempData + .00005;
		wchar_t TempChars[20] = _T("");

		__int64 TempInt = (__int64)TempData;
		_i64tow_s(TempInt,TempChars, 18, 10);
		TempString = TempString + TempChars;

		if (TempClipLength > 0)
			TempString = TempString + _T(",");
		
		double TempDouble = TempData - TempInt;
		if (TempDouble != 0)
		{
			for (BYTE TempLoop = 0; TempLoop < TempClipLength; TempLoop++)
			{
				TempInt = (BYTE)(TempDouble * 10);
				TempString = TempString + (char)(TempInt + 48);
				TempDouble = (TempDouble * 10) - TempInt;
			}
			if (TempClipLength > 0)
			while ((TempString.GetLength() > 1) &&
				(TempString.GetAt(TempString.GetLength()-1) == 48))
				TempString.Delete(TempString.GetLength()-1,1);
		}
		if (TempString == _T("-0,")) 
			TempString = _T("0,");
		if (TempString == _T("-0"))
			TempString = _T("0");

		wchar_t TempChar = TempString.GetAt(TempString.GetLength() - 1);
		if (TempChar == ',')
			TempString.Delete(TempString.GetLength() - 1,1);
	}
	else
	{ //english
				//Clip Length is number of digits after decimal point
		if ((!(TempData > -.0000001)) && (TempData < 0))
		{
			TempData = - TempData;
			TempString = _T("-");
		}
		if (TempClipLength == 0)
			TempData = TempData + .5;
		else
		if (TempClipLength == 1)
			TempData = TempData + .05;
		else
		if (TempClipLength == 2)
			TempData = TempData + .005;
		else
		if (TempClipLength == 3)
			TempData = TempData + .0005;
		else
		if (TempClipLength == 4)
			TempData = TempData + .00005;
		wchar_t TempChars[20] = _T("");

		__int64 TempInt = (__int64)TempData;
		_i64tow_s(TempInt,TempChars, 18, 10);
		TempString = TempString + TempChars;

		if (TempClipLength > 0)
			TempString = TempString + _T(".");
		
		double TempDouble = TempData - TempInt;
		if (TempDouble != 0)
		{
			for (BYTE TempLoop = 0; TempLoop < TempClipLength; TempLoop++)
			{
				TempInt = (BYTE)(TempDouble * 10);
				TempString = TempString + (char)(TempInt + 48);
				TempDouble = (TempDouble * 10) - TempInt;
			}
			if (TempClipLength > 0)
			while ((TempString.GetLength() > 1) &&
				(TempString.GetAt(TempString.GetLength()-1) == 48))
				TempString.Delete(TempString.GetLength()-1,1);
		}
		if (TempString == _T("-0.")) 
			TempString = _T("0.");
		if (TempString == _T("-0"))
			TempString = _T("0");

		wchar_t TempChar = TempString.GetAt(TempString.GetLength() - 1);
		if ((TempChar == '.') || ((vGlobalUseCommaForDecimalPoint) && (TempChar == ',')))
			TempString.Delete(TempString.GetLength() - 1,1);
	}
	return TempString;
}

CString dtoa(double TempData, BYTE TempClipLength, BYTE TempNumberOfSignificantDigits)
{
	CString TempString = _T("");
	TempString = _T("");
	BYTE TempNumberOfInsignificantDecimalPlaces = 0;
	double i = 1000000000000;
	for (; i > 0; i = i / 10)	//find first significant digit
	{
		if ((int)(TempData/i) != 0)
			break;
		if (i < 1)
			TempNumberOfInsignificantDecimalPlaces++;
	}
	
	for (int j = 1; j<TempNumberOfSignificantDigits; j++)
		i = i/10;

	TempData = (int)(TempData/i);		//divide by i and truncate to get rid of all digits below i
	TempData = TempData*i;		//multiply by i to get back to origional value
	TempString = dtoa(TempData,TempClipLength);

	return TempString;
}

CString dtoaWithCommas(double TempData, BYTE TempClipLength)
{
	//Clip Length is number of digits after decimal point
	CString TempString = _T("");
	TempString = _T("");
	if ((!(TempData > -.0000001)) && (TempData < 0))
	{
		TempData = - TempData;
		TempString = _T("-");
		if (TempClipLength == 0)
			TempData = TempData - .5;
		else
		if (TempClipLength == 1)
			TempData = TempData - .05;
		else
		if (TempClipLength == 2)
			TempData = TempData - .005;
		else
		if (TempClipLength == 3)
			TempData = TempData - .0005;
		else
		if (TempClipLength == 4)
			TempData = TempData - .00005;
	}
	else
	{
		if (TempClipLength == 0)
			TempData = TempData + .5;
		else
		if (TempClipLength == 1)
			TempData = TempData + .05;
		else
		if (TempClipLength == 2)
			TempData = TempData + .005;
		else
		if (TempClipLength == 3)
			TempData = TempData + .0005;
		else
		if (TempClipLength == 4)
			TempData = TempData + .00005;
	}
	wchar_t TempChars[40] = _T("");

	__int64 TempInt = (__int64)TempData;
	_i64tow_s(TempInt, TempChars, 38, 10);
	TempString = TempString + TempChars;

	if (TempString.GetLength() > 3)
		TempString.Insert(TempString.GetLength() - 3, _T(","));
	if (TempString.GetLength() > 7)
		TempString.Insert(TempString.GetLength() - 7, _T(","));
	if (TempString.GetLength() > 11)
		TempString.Insert(TempString.GetLength() - 11, _T(","));

	if (TempClipLength > 0)
	{
		if (vGlobalUseCommaForDecimalPoint)
			TempString = TempString + _T(",");
		else
			TempString = TempString + _T(".");
	}
	
	double TempDouble = TempData - TempInt;
	if (TempDouble != 0)
	{
		for (BYTE TempLoop = 0; TempLoop < TempClipLength; TempLoop++)
		{
			TempInt = (BYTE)(TempDouble * 10);
			TempString = TempString + (char)(TempInt + 48);
			TempDouble = (TempDouble * 10) - TempInt;
		}
		if (TempClipLength > 0)
		while ((TempString.GetLength() > 1) &&
			(TempString.GetAt(TempString.GetLength()-1) == 48))
			TempString.Delete(TempString.GetLength()-1,1);
	}
	if (TempString == _T("-0.")) 
		TempString = _T("0.");
	if (TempString == _T("-0"))
		TempString = _T("0");

	wchar_t TempChar = TempString.GetAt(TempString.GetLength() - 1);
	if ((TempChar == '.') || ((vGlobalUseCommaForDecimalPoint) && (TempChar == ',')))
		TempString.Delete(TempString.GetLength() - 1, 1);

	return TempString;
}

bool CScanTracDlg::CheckProductFullyConfigured(CProduct *TempProduct)
{
	bool TempOK = true;
	CString TempText = "";
	if (TempProduct)
	{
		if (TempProduct->vOverScanMultiplier > 1)
		{
			if (vConfigurationData->vEncoderDivider % 2 != 0)// % is mod function  //if not divisible by 2, then can't do
			{
				TempProduct->SetOverScanFactor(0); //turn overscan off
				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\nYou cannot use Overscan because the\nEncoder Divider factor is not divisible by two.\nYou must re-calibrate the encoder with the divider divisible by 2. Turned Overscan Off on this product";
				TempNoticeDialog.vType = cErrorMessage;
				TempNoticeDialog.DoModal();
				TempOK = false;
			}
		}

		CString *TempNameString = TempProduct->GetProductName();
		wchar_t TempFirstChar = TempNameString->GetAt(0);
		if (TempFirstChar != 0x7E)
		{
			DWORD TempEjectorUsed = 0;
			if (TempOK)
			{
				float TempMaximumHeight = (float)(vConfigurationData->vNumberOfXRayDetectors * vConfigurationData->vDetectorLength);
				//if (vConfigurationData->vUseMetric)
				//	TempMaximumHeight = (float)(TempMaximumHeight * 25.4);
				if (TempProduct->vProductImageHeightTop > TempMaximumHeight)
				{
					CNoticeDialog TempNoticeDialog;
					TempText.LoadString(IDS_ProductHeightIsTallerThanDetectors);
					TempNoticeDialog.vNoticeText = TempText;
					TempNoticeDialog.vType = cWarningMessage;
					TempNoticeDialog.DoModal();
					TempOK = false;
					TempProduct->vProductImageHeightTop = TempMaximumHeight;
				}
			}
			if (TempProduct->vMaximumImageOverlap > TempProduct->vProductImageWidth / 2)
			{
				TempProduct->vMaximumImageOverlap = TempProduct->vProductImageWidth / 2;
				//CNoticeDialog TempNoticeDialog;
				//TempText.LoadString(IDS_ImageOverlapIsWiderThanHalfTheImage);
				//TempNoticeDialog.vNoticeText = TempText;
				//TempNoticeDialog.vType = cWarningMessage;
				//TempNoticeDialog.DoModal();
				//TempOK = false;
			}
			if (TempProduct->vEdgeLocationHeight + TempProduct->vEdgeLocationBottom > TempProduct->vProductImageHeightTop -	TempProduct->vProductImageHeightBottom)
			{
				TempProduct->SetEdgeLocationHeight((float)(TempProduct->vProductImageHeightTop - TempProduct->vProductImageHeightBottom - .5 - TempProduct->vEdgeLocationBottom));
				if (TempProduct->vEdgeLocationHeight < 0)
					TempProduct->SetEdgeLocationHeight(0);
				TempText.LoadString(IDS_ProductEdgeLocationHeightIsTallerThanProduct);
				ReportErrorMessage(TempText, cWriteToLog, 0);
				//CNoticeDialog TempNoticeDialog;
				//TempText.LoadString(IDS_ProductEdgeLocationHeightIsTallerThanProduct);
				//TempNoticeDialog.vNoticeText = TempText;
				//TempNoticeDialog.vType = cWarningMessage;
				//TempNoticeDialog.DoModal();
				//TempOK = false;
			}
			if (TempProduct->vEdgeLocationBottom > TempProduct->vProductImageHeightTop - TempProduct->vProductImageHeightBottom)
			{
				TempProduct->SetEdgeLocationBottom(.25);
				TempText.LoadString(IDS_ProductEdgeLocationBottomIsTallerThanProduct);
				ReportErrorMessage(TempText, cWriteToLog, 0);
				//CNoticeDialog TempNoticeDialog;
				//TempText.LoadString(IDS_ProductEdgeLocationBottomIsTallerThanProduct);
				//TempNoticeDialog.vNoticeText = TempText;
				//TempNoticeDialog.vType = cWarningMessage;
				//TempNoticeDialog.DoModal();
				//TempOK = false;
			}
			if (TempProduct->vReferenceWidth)
			{
				if (TempProduct->vBottomLocationLeftPixel + TempProduct->vBottomLocationLengthPixel >= TempProduct->vReferenceWidth)
				{
					if (TempProduct->vBottomLocationLength + .5 < TempProduct->vReferenceWidth / vGlobalPixelsPerUnit)
					{
						TempProduct->SetBottomLocationLeft(.25);
					}
					else
					{
						TempProduct->SetBottomLocationLeft(0);
						TempProduct->SetBottomLocationLength((float)(TempProduct->vReferenceWidth / vGlobalPixelsPerUnit));
					}
					ReportErrorMessage("Bottom Location Finder Left + Length too large, set to Reference Width", cWriteToLog, 0);
					//CNoticeDialog TempNoticeDialog;
					//TempText.LoadString(IDS_ProductEdgeLocationBottomIsTallerThanProduct);
					//TempNoticeDialog.vNoticeText = TempText;
					//TempNoticeDialog.vType = cWarningMessage;
					//TempNoticeDialog.DoModal();
					//TempOK = false;
				}
			}
			else
			{
				if (TempProduct->vBottomLocationLeftPixel + TempProduct->vBottomLocationLengthPixel >= vSystemData.vITIPCDig->vOriginalBufferSizeY)
				{
					TempProduct->SetBottomLocationLeft(0);
					TempProduct->SetBottomLocationLength((float)((vSystemData.vITIPCDig->vOriginalBufferSizeY - 4) / vGlobalPixelsPerUnit));
					ReportErrorMessage("Bottom Location Finder Left + Length too large, set to Image Width", cWriteToLog, 0);
					//CNoticeDialog TempNoticeDialog;
					//TempText.LoadString(IDS_ProductEdgeLocationBottomIsTallerThanProduct);
					//TempNoticeDialog.vNoticeText = TempText;
					//TempNoticeDialog.vType = cWarningMessage;
					//TempNoticeDialog.DoModal();
					//TempOK = false;
				}
			}

			if (TempOK)
			if (TempProduct->vProductImageWidth == 0)
			{
				CNoticeDialog TempNoticeDialog;
				TempText.LoadString(IDS_ProductWidthIsZero);
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cWarningMessage;
				TempNoticeDialog.DoModal();
				TempOK = false;
			}
			if (TempOK)
			if (!((vConfigurationData->vContinuousFeedContainerRate) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || 
				(vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))))		// not bulk mode
			if (TempProduct->vBodyTrigger == 0)
			{
				CNoticeDialog TempNoticeDialog;
				TempText.LoadString(IDS_NoContainerTriggerAssigned);
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cWarningMessage;
				TempNoticeDialog.DoModal();
				TempOK = false;
			}
			if (TempOK)
			if (!((vConfigurationData->vContinuousFeedContainerRate) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)) || 
				(vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))))		// not bulk mode
			if (!vConfigurationData->vBodyTrigger[TempProduct->vBodyTrigger - 1].vEnabled)
			{
				CNoticeDialog TempNoticeDialog;
				TempText.LoadString(IDS_ContainerTriggerUsedNotEnabled);
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cWarningMessage;
				TempNoticeDialog.DoModal();
				TempOK = false;
			}
			if (TempOK)
			if (TempProduct->vProductBodyTriggerToImageBeltPositionOffset == 0)
			{
				CNoticeDialog TempNoticeDialog;
				TempText.LoadString(IDS_ContainerTriggerToDetectorDistanceIsZero);
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cWarningMessage;
				TempNoticeDialog.DoModal();
				TempOK = false;
			}
			if (TempOK)
			if (TempProduct->vEndOfLineTimeOut == 0)
			{
				CNoticeDialog TempNoticeDialog;
				TempText.LoadString(IDS_EndOfLineBeltPositionIsZero);
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cWarningMessage;
				TempNoticeDialog.DoModal();
				TempOK = false;
			}
			if (TempOK)
			if (TempProduct->vXRaySourceVoltage == 0)
			{
				CNoticeDialog TempNoticeDialog;
				TempText.LoadString(IDS_XRaySourceVoltageIsZero);
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cWarningMessage;
				TempNoticeDialog.DoModal();
				TempOK = false;
			}
			if (TempOK)
			if (TempProduct->vXRaySourceCurrent == 0)
			{
				CNoticeDialog TempNoticeDialog;
				TempText.LoadString(IDS_XRaySourceCurrentIsZero);
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cWarningMessage;
				TempNoticeDialog.DoModal();
				TempOK = false;
			}

			//don't check anyother settings if it is a setup product
			CString *TempProductName = TempProduct->GetProductName();
			if (TempProductName->GetAt(0) == '~')
				TempOK = false;
			if (TempOK)
			{
				bool TempHaveContaminantOrVoidInspections = false;
				BYTE TempAtLeastOneEnabled = false;
				for (BYTE TempLoop = 0; TempLoop < TempProduct->vNumberOfInspections; TempLoop++)
				{
					if (!TempProduct->vInspection[TempLoop])
					{
						TempProduct->vNumberOfInspections--;
						ReportErrorMessage("Error, Inspection pointer lost: " + *TempProduct->GetProductName(), cEMailInspx,32000);
					}
					else
					{
						if (TempProduct->vInspection[TempLoop]->vEnable)
							TempAtLeastOneEnabled = true;

						if (!TempProduct->vInspection[TempLoop]->vShowRejects) //must be set unless Weight Trending inspection
						if (TempProduct->vInspection[TempLoop]->vInspectionType != cCheckWeighInspection)
							TempProduct->vInspection[TempLoop]->vShowRejects = true;

						if ((TempProduct->vInspection[TempLoop]->vInspectionType == cContaminantInspection) ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cWireContaminantInspection) ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cSpotInROIContaminantInspection) ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cContaminantBonesInspection) ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cContaminant22Inspection) ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cGlass13mmContaminantInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cThresholdContaminantInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cBadHeartInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cDripBySpoutInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cDripInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cFloodedInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cTopContaminantInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cBottomContaminantInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cJarBottomContaminantInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cIPContaminantInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cVoidInspection) ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cKernelInspection) ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cContaminant2Inspection) ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cAdvancedContaminant2Inspection))
								TempHaveContaminantOrVoidInspections = true;

							if (((TempProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection) || (TempProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection) || 
								(TempProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection)) && 
								((TempProduct->vInspection[TempLoop]->vSetupHistoryMinimumGoodCount < 4) || (TempProduct->vInspection[TempLoop]->vSetupHistoryMaximumBadCount < 4)))
							if (!TempProduct->vInspection[TempLoop]->vInspectionNameForWeightTrendingPointer) //if not using another inspection for calibrations
							{
								CNoticeDialog TempNoticeDialog;
								TempText = "\n\n" + TempProduct->vInspection[TempLoop]->vName + " Inspection does not have\nits weight calibrations complete.\nIt will not inspect properly.";
								TempNoticeDialog.vNoticeText = TempText;
								TempNoticeDialog.vType = cWarningMessage;
								TempNoticeDialog.DoModal();
							}
					}
				}
				/*
				if (TempHaveContaminantOrVoidInspections)
				{
					if (!TempProduct->ProductHasImageFiles(vGlobalCurrentDirectory))
					{
						CNoticeDialog TempNoticeDialog;
						TempNoticeDialog.vNoticeText = "\n\nAuto Learn has not been completed.\nProduct will not run correctly until Auto Learn is completed.";
						TempNoticeDialog.vType = cWarningMessage;
						TempNoticeDialog.DoModal();
						TempOK = false;
					}
				}
				*/
				if (!TempAtLeastOneEnabled)
				{
					CNoticeDialog TempNoticeDialog;
					TempText.LoadString(IDS_NoXRayImageCriteriaEnabled);
					TempNoticeDialog.vNoticeText = TempText;
					TempNoticeDialog.vType = cWarningMessage;
					TempNoticeDialog.DoModal();
					TempOK = false;
				}
			}
			if (TempOK)
			{
				bool TempHaveContaminantTOrFM = false;
				//CString TempText;
				//TempText.LoadString(IDS_ImproveLearn);
				for (BYTE TempLoop = 0; TempLoop < TempProduct->vNumberOfInspections; TempLoop++)
				if (TempProduct->vInspection[TempLoop])
				if (TempProduct->vInspection[TempLoop]->vEnable)
				if (TempProduct->vInspection[TempLoop]->vShowRejects)
				//if (TempProduct->vInspection[TempLoop]->vName != TempText)
				if (TempOK)
				{
					if ((TempProduct->vInspection[TempLoop]->vInspectionType == cThresholdContaminantInspection) || (TempProduct->vInspection[TempLoop]->vInspectionType == cBadHeartInspection)  ||
							(TempProduct->vInspection[TempLoop]->vInspectionType == cDripInspection)  ||(TempProduct->vInspection[TempLoop]->vAddStructure))
						TempHaveContaminantTOrFM = true;

					TempEjectorUsed = TempEjectorUsed | TempProduct->vInspection[TempLoop]->vEjector;
					if (!TempProduct->vInspection[TempLoop]->vEjector)
					{
						TempOK = false;
						CNoticeDialog TempNoticeDialog;
						TempText.LoadString(IDS_NoContaminantEjectorConfigured);
						TempNoticeDialog.vNoticeText = TempText;
						TempNoticeDialog.vType = cWarningMessage;
						TempNoticeDialog.DoModal();
					}
					else
					for (BYTE TempLoopE = 0; TempLoopE < cNumberOfEjectors; TempLoopE++)
					if (TempOK)
					if (TempProduct->vInspection[TempLoop]->vEjector & (1 << TempLoopE))
					if (!vConfigurationData->vEjector[TempLoopE].vEnabled)
					{
						TempOK = false;
						CNoticeDialog TempNoticeDialog;
						//TempText.LoadString(IDS_ContaminantEjectorDisabled);
						//TempNoticeDialog.vNoticeText = TempText;
						TempNoticeDialog.vNoticeText = "\n\n\nInspection: " + 
							TempProduct->vInspection[TempLoop]->vName + ", Ejector Disabled";
						TempNoticeDialog.vType = cWarningMessage;
						TempNoticeDialog.DoModal();
					}
					if (TempOK)
					if ((TempProduct->vInspection[TempLoop]->vInspectionType == cContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cWireContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cSpotInROIContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cContaminantBonesInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cContaminant22Inspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cGlass13mmContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cThresholdContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cBadHeartInspection)  ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cDripBySpoutInspection)  ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cDripInspection)  ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cFloodedInspection)  ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cTopContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cBottomContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cJarBottomContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cIPContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cKernelInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cVoidInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cContaminant2Inspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cAdvancedContaminant2Inspection))
					if (TempProduct->vInspection[TempLoop]->vThreshold == 255)
					{
						TempOK = false;
						CNoticeDialog TempNoticeDialog;
						TempText.LoadString(IDS_ContaminantThresholdNotSet);
						TempNoticeDialog.vNoticeText = TempText;
						TempNoticeDialog.vType = cWarningMessage;
						TempNoticeDialog.DoModal();
					}
					else
					if (!TempProduct->vInspection[TempLoop]->vName.GetLength())
					{
						TempOK = false;
						CNoticeDialog TempNoticeDialog;
						TempText.LoadString(IDS_InspectionNameBlank);
						TempNoticeDialog.vNoticeText = TempText;
						TempNoticeDialog.vType = cWarningMessage;
						TempNoticeDialog.DoModal();
					}
					else
					if (!TempProduct->vInspection[TempLoop]->vSize)
					if ((TempProduct->vInspection[TempLoop]->vInspectionType == cContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cWireContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cSpotInROIContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cContaminantBonesInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cContaminant22Inspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cGlass13mmContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cThresholdContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cBadHeartInspection)  ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cDripBySpoutInspection)  ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cDripInspection)  ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cFloodedInspection)  ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cTopContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cBottomContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cJarBottomContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cIPContaminantInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cKernelInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cVoidInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cContaminant2Inspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cAdvancedContaminant2Inspection))
					{
						TempOK = false;
						CNoticeDialog TempNoticeDialog;
						if (TempProduct->vInspection[TempLoop]->vInspectionType == cKernelInspection)
							TempText.LoadString(IDS_KernelSizeNotSet);
						else
							TempText.LoadString(IDS_ContaminantSizeNotSet);
						TempNoticeDialog.vNoticeText = TempText;
						TempNoticeDialog.vType = cWarningMessage;
						TempNoticeDialog.DoModal();
					}
					if (TempOK)
					if (!TempProduct->vInspection[TempLoop]->vDensityThresholdUpper)
					if (!TempProduct->vInspection[TempLoop]->vDensityThresholdLower)
					if ((TempProduct->vInspection[TempLoop]->vInspectionType == cDensityInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cMissingLidInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cUnderfillInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cOverfillInspection) ||
						(TempProduct->vInspection[TempLoop]->vInspectionType == cStandardDeviationInspection))
					{
						TempOK = false;
						CNoticeDialog TempNoticeDialog;
						if (TempProduct->vInspection[TempLoop]->vInspectionType == cDensityInspection)
							TempNoticeDialog.vNoticeText = "\n\nInspection: " + TempProduct->vInspection[TempLoop]->vName + "\nBoth thresholds are zero.\nInspection disabled.";
						else
							TempNoticeDialog.vNoticeText = "\n\nInspection: " + TempProduct->vInspection[TempLoop]->vName + "\nThresholds is zero.\nInspection disabled.";

						TempNoticeDialog.vType = cWarningMessage;
						TempNoticeDialog.DoModal();
					}
				}
				if (TempOK)
				if (!TempHaveContaminantTOrFM)
				if (vSystemData.vITIPCDig->vShowOnlyRealImages)
				{
					ReportErrorMessage("No FM or Metal Contaminant Inspection", cWriteToLog,0);
					TempOK = false;
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\nNo FM or Metal Contaminant Inspection.\nFM or Metal Contaminant is required for proper inspection.";
					TempNoticeDialog.vType = cWarningMessage;
					TempNoticeDialog.DoModal();
				}
			}
			if (TempOK)
			{
				for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
				if (TempOK)
				{
					if ((TempProduct->vExternalDetectorEnable) && (TempProduct->vExternalDetectorMode[TempLoop]) && (TempProduct->vExternalDetectorMode[TempLoop] < cBackupDetectorMode))
					{
						TempEjectorUsed = TempEjectorUsed | TempProduct->vExternalDetectorEjector[TempLoop];
						//if ((TempProduct->vExternalDetectorMode[TempLoop] == 3) ||
						//	(TempProduct->vExternalDetectorMode[TempLoop] == 4))
						//{
						//	TempProduct->SetExternalDetectorWindowEnd(TempLoop,
						//		TempProduct->vExternalDetectorWindowStart[TempLoop]);
						//}
						if (!TempProduct->vExternalDetectorEjector[TempLoop])
						{
							TempOK = false;
							CNoticeDialog TempNoticeDialog;
							TempText.LoadString(IDS_NoExternalDetectorEjectorConfigured);
							TempNoticeDialog.vNoticeText = TempText;
							TempNoticeDialog.vType = cWarningMessage;
							TempNoticeDialog.DoModal();
						}
						else
						for (BYTE TempLoopE = 0; TempLoopE < cNumberOfEjectors; TempLoopE++)
						if (TempOK)
						if (TempProduct->vExternalDetectorEjector[TempLoop] & (1 << TempLoopE))
						if (!vConfigurationData->vEjector[TempLoopE].vEnabled)
						{
							TempOK = false;
							CNoticeDialog TempNoticeDialog;
							TempText.LoadString(IDS_DetectorsEjectorEjectorDisabled);
							TempNoticeDialog.vNoticeText = TempText;
							TempNoticeDialog.vType = cWarningMessage;
							TempNoticeDialog.DoModal();
						}
					}
				}
			}
			if (TempOK)
			{
				CheckEjectorsConfigured(TempProduct, TempEjectorUsed);
			}
			/*
			if (TempOK)
			{
				if (!TempProduct->vReferenceWidth)
				{
					TempOK = false;
					CNoticeDialog TempNoticeDialog;
					TempText = "\n\nContainer Width is not set, must re-learn product";
					TempNoticeDialog.vNoticeText = TempText;
					TempNoticeDialog.vType = cWarningMessage;
					TempNoticeDialog.DoModal();
				}
			}
			*/
			/*
			if (TempOK)
			if (TempProduct->vReferenceWidth)
			{
				if (TempProduct->vProductLockOutWidth > ((TempProduct->vReferenceWidth /
					vGlobalPixelsPerUnit) + .25))
				{
					TempOK = false;
					CNoticeDialog TempNoticeDialog;
					TempText = "\n\nRetrigger Lockout Width is wider than the container.\nContainer is: " +
						dtoa(TempProduct->vReferenceWidth /	vGlobalPixelsPerUnit,2) +
						" " + vConfigurationData->vUnitsString + " wide.";
					TempNoticeDialog.vNoticeText = TempText;
					TempNoticeDialog.vType = cWarningMessage;
					TempNoticeDialog.DoModal();
				}
			}
			*/
		}
	}
	return TempOK;
}

bool CScanTracDlg::CheckEjectorsConfigured(CProduct *TempProduct, DWORD TempEjectorUsed)
{
	bool TempOK = true;
	CString TempText = "";
	double TempMargin = 1.0;

	if (TempProduct->vProductImageWidth + 1 > TempMargin)
		TempMargin = TempProduct->vProductImageWidth + 1;
	double TempMinimumEjectorDistance = TempProduct->vProductBodyTriggerToImageBeltPositionOffset + TempMargin;

	if (TempOK)
	{
		for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
		if (vConfigurationData->vEjector[TempLoop].vEnabled)
		{
			if (TempEjectorUsed & (1 << TempLoop))
			if (TempProduct->vEjectorDelayPosition[TempLoop] == 0)
			{
				TempOK = false;
				CNoticeDialog TempNoticeDialog;
				TempText.LoadString(IDS_UsedEjectorHasZeroPosition);
				TempText = "\n\n\nEjector: " + dtoa(TempLoop + 1,0) + " has zero Position,\nSetting to Minimum Distance.";
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cWarningMessage;
				TempNoticeDialog.DoModal();
				TempProduct->vEjectorDelayPosition[TempLoop] = (float)TempMinimumEjectorDistance;
				TempLoop = cNumberOfEjectors;
				TempProduct->CalculateEndOfLineTimeOut();
			}
		}
	}
	if (TempOK)
	{
		for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
		if (vConfigurationData->vEjector[TempLoop].vEnabled)
		{
			if (TempEjectorUsed & (1 << TempLoop))
			if (TempProduct->vEjectorDelayPosition[TempLoop] < (WORD)TempMinimumEjectorDistance)
			{
				if (vSystemData.vInAutoSetup)  //if in autosetup, up the position so will not think ejectors too close and process image before get
				{
					WORD TempPosition = (WORD)TempMinimumEjectorDistance;
					//if (vConfigurationData->vUseMetric)
					//	TempPosition = (WORD)(TempPosition + (30 * 25.4));
					//else
						TempPosition = TempPosition + 30;
					
					TempProduct->vEjectorDelayPosition[TempLoop] = TempPosition;
					TempProduct->CalculateEndOfLineTimeOut();
				}
				else
				{
					TempOK = false;
					CNoticeDialog TempNoticeDialog;
					TempText = "\n\n\nEjector: " + dtoa(TempLoop + 1,0) + " below minimum Position";
					TempNoticeDialog.vNoticeText = TempText + ": " + dtoa(TempMinimumEjectorDistance,2);
					TempNoticeDialog.vType = cWarningMessage;
					TempNoticeDialog.DoModal();
					TempLoop = cNumberOfEjectors;
				}
			}
		}
	}
	/*
	if (TempOK)
	{
		for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
		{
			if (TempEjectorUsed & (1 << TempLoop))
			if (TempProduct->vEjectorResponseTime[TempLoop] == 0)
			{
				TempOK = false;
				TempProduct->vEjectorResponseTime[TempLoop] = (float).1;
				CNoticeDialog TempNoticeDialog;
				TempText.LoadString(IDS_UsedEjectorHasZeroResponseFactor);
				TempText = TempText + "\nSetting to default of .1";
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cWarningMessage;
				TempNoticeDialog.DoModal();
				TempLoop = cNumberOfEjectors;
			}
		}
	}
	*/
	//if (TempOK)
	//{
	//	for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
	//	if (vConfigurationData->vEjector[TempLoop].vEnabled)
	//	{
	//		if (TempEjectorUsed & (1 << TempLoop))
	//		if (TempProduct->vEjectorDwellTime[TempLoop] == 0)
	//		{
	//			TempOK = false;
	//			TempProduct->vEjectorDwellTime[TempLoop] = 300;
	//			CNoticeDialog TempNoticeDialog;
	//			TempText.LoadString(IDS_UsedEjectorHasZeroDwellTime);
	//			TempText = "\n\n\nEjector: " + dtoa(TempLoop + 1,0) + " has zero Dwell Time";
	//			TempText = TempText + "\nSetting to default of 300";
	//			TempNoticeDialog.vNoticeText = TempText;
	//			TempNoticeDialog.vType = cWarningMessage;
	//			TempNoticeDialog.DoModal();
	//			TempLoop = cNumberOfEjectors;
	//		}
	//	}
	//}
	return TempOK;
}

bool CheckSystemFullyConfigured(CSystemConfigurationData *TempConfigurationData)
{
	bool TempOK = true;
	bool TempAtleastOne = false;
	for (BYTE TempLoop = 0; TempLoop < cNumberOfBodyTriggers; TempLoop++)
	if (TempConfigurationData->vBodyTrigger[TempLoop].vEnabled)
		TempAtleastOne = true;
	if (!TempAtleastOne)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\nNo Container Trigger enabled\n\nCannot setup products or run properly";
		TempNoticeDialog.vType = cWarningMessage;
		TempNoticeDialog.DoModal();
		TempOK = false;
	}

	//if configured for more good than take samples, set good to number of samples
	if (TempConfigurationData->vAlarmEjectorReEnableX > TempConfigurationData->vAlarmEjectorReEnableY)
			TempConfigurationData->vAlarmEjectorReEnableX = TempConfigurationData->vAlarmEjectorReEnableY;

	TempAtleastOne = false;
	for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
	if (TempConfigurationData->vEjector[TempLoop].vEnabled)
		TempAtleastOne = true;
	if (TempOK)
	if (!TempAtleastOne)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\nNo Ejector enabled\n\nYou cannot setup products or run properly";
		TempNoticeDialog.vType = cWarningMessage;
		TempNoticeDialog.DoModal();
		TempOK = false;
	}
	if (TempOK)
	{
		if (TempConfigurationData->vScanTracScreenShotDirectory.GetLength() < 5)
		{
			TempOK = false;
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\nScreen Shot Directory not Configured.\nScreen Shots Disabled.\nCall Service to configure.";
			TempNoticeDialog.vType = cWarningMessage;
			TempNoticeDialog.DoModal();
		}
	}
	if (TempOK)
	{
// have default ScanTracProductionReportDirectory, 9/17/2012
//		if (TempConfigurationData->vScanTracProductionReportDirectory.GetLength() < 5)
//		{
//			TempOK = false;
//			CNoticeDialog TempNoticeDialog;
//			TempNoticeDialog.vNoticeText = "\n\nProduction Report Directory not Configured.\nProduction Reports Disabled.\nCall Service to configure.";
//			TempNoticeDialog.vType = cWarningMessage;
//			TempNoticeDialog.DoModal();
//		}
	}
	if (TempOK)
	{
		if (TempConfigurationData->vScanTracImagesDirectory.GetLength() < 5)
		{
			TempOK = false;
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\nImage Save Directory not Configured.\nImage Saves Disabled.\nCall Service to configure.";
			TempNoticeDialog.vType = cWarningMessage;
			TempNoticeDialog.DoModal();
		}
	}
	// test for vScanTracEventLogDirectory not applicable, using default name.  9/17/2012 kjh
//	if (TempOK)
//	{
//		if (TempConfigurationData->vScanTracEventLogDirectory.GetLength() < 5)
//		{
//			TempOK = false;
//			CNoticeDialog TempNoticeDialog;
//			TempNoticeDialog.vNoticeText = "\n\nEvent Log Directory not Configured.\nEvent Logs Disabled.\nCall Service to configure.";
//			TempNoticeDialog.vType = cWarningMessage;
//			TempNoticeDialog.DoModal();
//		}
//	}
	/*
	if (TempOK)
	{
		if (TempConfigurationData->vScanTracRejectedImagesDirectory.GetLength() < 5)
		{
			TempOK = false;
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\nRejected Images Directory not Configured.\nRejected Image Saving Disabled.\nCall Service to configure.";
			TempNoticeDialog.vType = cWarningMessage;
			TempNoticeDialog.DoModal();
			TempLoop = cNumberOfEjectors;
		}
	}
	*/
	if (TempOK)
	{
		if (TempConfigurationData->vScanTracCalibrationImagesDirectory.GetLength() < 5)
		{
			TempOK = false;
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\nCalibration Images Directory not Configured.\nCalibration Image Saving Disabled.\nCall Service to configure.";
			TempNoticeDialog.vType = cWarningMessage;
			TempNoticeDialog.DoModal();
		}
	}
	if (TempOK)
	{
		if (TempConfigurationData->vScanTracSerialLogsDirectory.GetLength() < 5)
		{
			TempOK = false;
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\nSerial Log Directory not Configured.\nSerial Logging Disabled.\nCall Service to configure.";
			TempNoticeDialog.vType = cWarningMessage;
			TempNoticeDialog.DoModal();
		}
	}
	return TempOK;
}

void CScanTracDlg::ClearVersionDisplay()
{
	vDisplayingVersion = false;
	SetCursorPos(vGlobalDisplaySizeH,vGlobalDisplaySizeV);
	m_MainBackground.ShowWindow(SW_SHOW);
	
	if (((!vConfigurationData->vContinuousFeedContainerRate) && (!vConfigurationData->vBulkProductMode) && ((vGlobalCurrentProduct) && (!vGlobalCurrentProduct->vBulkProductMode))) || //not Continuous Feed, or a Pipeline
		(vSystemData.vSystemRunMode == cConditionXRayTubeMode))
		m_ContainersPerMinuteControl.ShowWindow(SW_SHOW);

	if (!vConfigurationData->vEjectContainersNotInspected)
		m_SubFunction2Button.ShowWindow(SW_SHOW);

	m_PercentRejectedControl.ShowWindow(SW_SHOW);
	m_SubFunction8Button.ShowWindow(SW_SHOW);
	m_StatusLine.ShowWindow(SW_SHOW);
	m_TotalEjectsStaticText.ShowWindow(SW_SHOW);
	m_DialogTitleStaticText1.ShowWindow(SW_SHOW);
	m_PercentRejectedControl.ShowWindow(SW_SHOW);
	m_PercentRejectedLabelControl.ShowWindow(SW_SHOW);
	UpdateCustomerNameLine();
	m_ShiftControl.ShowWindow(SW_SHOW);
	m_TotalContainersControl.ShowWindow(SW_SHOW);
	m_TotalContainersLabelControl.ShowWindow(SW_SHOW);
	m_TotalEjectsLabelStaticTextControl.ShowWindow(SW_SHOW);
	
	KillTimer(vSplashScreenTimerHandle);

	//Start counter timers
	if (!vSystemData.vCompletelyInitialized)
	{
		m_CurrentProductLabel.ShowWindow(SW_SHOW);
		m_ProductLabelControl.ShowWindow(SW_SHOW);
		m_Clock.ShowWindow(SW_SHOW);
		m_Date.ShowWindow(SW_SHOW);
		if (vConfigurationData->vDemoMode)
			SetDlgItemText(IDC_uControllerStatus, _T(""));
		else
		{
			//SetDlgItemText(IDC_uControllerStatus,"");
			if ((!vConfigurationData->vSimulateLightControlBoard) && (vSystemData.vOldNoCommunicationsWithUController))
			{
				vSystemData.vOpenInterlock.LoadString(IDS_NouC);
				vShowuControllerStatusInRed = true;
				vSystemData.vOldOpenInterlock = vSystemData.vOpenInterlock;
				SetDlgItemText(IDC_uControllerStatus,vSystemData.vOldOpenInterlock);
			}
		}
		m_uControllerStatus.ShowWindow(SW_SHOW);
		vSystemData.vCompletelyInitialized = true;
		int TempTimerResult = SetTimer(vSendSyncCommandTimerHandle,1000,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-Sync Timer Failed",cEMailInspx,32000);
		
		TempTimerResult = SetTimer(vUpdateDisplayTimerHandle,500,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-Display Timer Failed",cEMailInspx,32000);

		TempTimerResult = SetTimer(vCheckForErrorMessagesTimerHandle,10,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-CheckForErrorMessages Timer Failed",cEMailInspx,32000);

		ChangeDisplays();  
		UpdateDisableEjectorsButton();
	}
	OneSecondDisplayUpdate();

	int TempTimerResult = SetTimer(v50HertzTimerHandle,20,NULL);
	if (!TempTimerResult)
		ReportErrorMessage("Error-SerialPort Timer Failed",cEMailInspx, 32000);

	TempTimerResult = SetTimer(vOneHourUpdatesTimerHandle,3600000,NULL);
	if (!TempTimerResult)
		ReportErrorMessage("Error-AC Power Monitor Background 1 hour Timer Failed",cEMailInspx, 32000);

	if (vConfigurationData->vAskForProductionReportProductCode)
	if (vGlobalCurrentProduct)
	if (!CurrentProductIsInspxProduct())
	{
		EditShift(true);	// ** kjh changes for Select Product code added to Edit Shift *****
	}
	ConditionTubeIfNeeded(); //do after editshift
	vConditioningBeforeRun = false;  //don't run after done

	//mike manual don't show help button
	if (vConfigurationData->vDemoMode)
		m_DemoHelpButton.ShowWindow(SW_SHOW);
	if ((!vConfigurationData->vXRayTubeHasCooled) && (!vConfigurationData->vSimulateLightControlBoard))
	{
		ReportErrorMessage("X-Ray Tube was not cooled properly on last shutdown", cEMailInspx, 32000); 
		ReportErrorMessage("X-Ray Tube was not cooled properly on last shutdown", cEMailMaintenance, 0); 
	}
	vConfigurationData->vXRayTubeHasCooled = true;
/*
	if (vConfigurationData->vJustRestoredPrimaryHardDrive)
	{
		vSystemData.vPrimaryDrive = "";
		vSystemData.vBackupDrive = "";

		CFileStatus TempFileStatus;
		CString TempPrimaryDriveString = "0_Primary_Hard_Drive";
		LPTSTR TempPrimaryDriveBuffer = TempPrimaryDriveString.GetBuffer(TempPrimaryDriveString.GetLength());
		for (BYTE TempDriveLoop = 0; TempDriveLoop < 10; TempDriveLoop++)
		{
			TempPrimaryDriveString = ":\\0_Primary_Hard_Drive";
			TempPrimaryDriveString = char(67 + TempDriveLoop) + TempPrimaryDriveString;
			TempPrimaryDriveBuffer = TempPrimaryDriveString.GetBuffer(TempPrimaryDriveString.GetLength());
			if ((CFile::GetStatus(TempPrimaryDriveBuffer, TempFileStatus)))
			{
				vSystemData.vPrimaryDrive = char(67 + TempDriveLoop);
				TempDriveLoop = 20;
			}
		}

		CString TempBackupDriveString = "0_Backup_Hard_Drive";
		LPTSTR TempBackupDriveBuffer = TempBackupDriveString.GetBuffer(TempBackupDriveString.GetLength());
		for (BYTE TempDriveLoop = 0; TempDriveLoop < 10; TempDriveLoop++)
		{
			TempBackupDriveString = ":\\0_Backup_Hard_Drive";
			TempBackupDriveString = char(67 + TempDriveLoop) + TempBackupDriveString;
			TempBackupDriveBuffer = TempBackupDriveString.GetBuffer(TempBackupDriveString.GetLength());
			if ((CFile::GetStatus(TempBackupDriveBuffer, TempFileStatus)))
			{
				vSystemData.vBackupDrive = char(67 + TempDriveLoop);
				TempDriveLoop = 20;
			}
		}

		if ((!vSystemData.vPrimaryDrive.GetLength()) && (vSystemData.vBackupDrive == "C"))  //C: Drive is backup, and no primary
		{
			bool TempFoundSecondBackupDrive = false;
			CString TempBackupDriveString = "0_Backup_Hard_Drive";
			LPTSTR TempBackupDriveBuffer = TempBackupDriveString.GetBuffer(TempBackupDriveString.GetLength());
			for (BYTE TempDriveLoop = 1; TempDriveLoop < 10; TempDriveLoop++)  //start looking for a second hard drive marked backup from the D Drive
			{
				CFileStatus TempFileStatus;
				TempBackupDriveString = ":\\0_Backup_Hard_Drive";
				TempBackupDriveString = char(67 + TempDriveLoop) + TempBackupDriveString;
				TempBackupDriveBuffer = TempBackupDriveString.GetBuffer(TempBackupDriveString.GetLength());
				if ((CFile::GetStatus(TempBackupDriveBuffer, TempFileStatus)))
				{
					TempFoundSecondBackupDrive = true;
					TempDriveLoop = 20;
				}
			}
			if (TempFoundSecondBackupDrive)
			{
				CFile TempFile;
				CString TempOldFolderName = "C:\\0_Backup_Hard_Drive";
				CString TempNewFolderName = "C:\\0_Primary_Hard_Drive";
				TRY
				{
					if (!CFile::GetStatus(TempNewFolderName, TempFileStatus))
						TempFile.Rename(TempOldFolderName,TempNewFolderName);
				}
				CATCH(CFileException, e)
				{
					ReportErrorMessage("Error-Ghost Restore Rename of Primary Hard Drive Failed",cEMailInspx,32000);
					TempFoundSecondBackupDrive = false;
				}
				END_CATCH
				if (TempFoundSecondBackupDrive)
				{
					ReportErrorMessage("Primary Hard Drive Was Just Restored Successfully",cEMailInspx,32000);
					ReportErrorMessage("Primary Hard Drive Was Just Restored Successfully",cAction,32000);
				}
			}
			else
			{
				ReportErrorMessage("Error-Ghost Restore of Primary Hard Drive Failed",cEMailInspx,32000);
				ReportErrorMessage("Error-Ghost Restore of Primary Hard Drive Failed",cError,32000);
			}
		}
		else
			ReportErrorMessage("Error-Ghost Restore of Primary Hard Drive Failed",cEMailInspx,32000);

		vConfigurationData->vJustRestoredPrimaryHardDrive = false;
	}
	*/

	//check uController version high enough for 10.8 and higher FPGA

#ifndef ScanTracDemo
	if (vSystemData.vFPGAVersion10Point7OrHigher)
	{
		if (vSystemData.vuCMajorVersionNumber <= 1)
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nNo Comm with uC Board.\nCould not read FPGA or uController software version";
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
		else
		if (((vSystemData.vuCMajorVersionNumber == 10) && (vSystemData.vuCMinorVersionNumber < 46)) ||
			(vSystemData.vuCMajorVersionNumber < 10))
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nInspx Manufacturing Error\nwrong FPGA or uController software version";
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
	}
	if (vSystemData.vuCMajorVersionNumber > 18)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nInspx Manufacturing Error\nwrong uController software version";
		TempNoticeDialog.vType = cErrorMessage;
		TempNoticeDialog.DoModal();
	}
	if (((vSystemData.vuCMajorVersionNumber == 18) && (vSystemData.vFPGAMajorVersionNumber != 18)) || ((vSystemData.vuCMajorVersionNumber != 18) && (vSystemData.vFPGAMajorVersionNumber == 18)))
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nInspx Manufacturing Error\nwrong FPGA or uController software version";
		TempNoticeDialog.vType = cErrorMessage;
		TempNoticeDialog.DoModal();
	}
#endif

	//check have atlease 512 meg of ram if FPGA version higher then 10.8
	MEMORYSTATUS memstat;
	GlobalMemoryStatus(&memstat);
	double TempAmountOfFreeMemory = memstat.dwAvailPageFile;
	double TempTotalRAMInPC = memstat.dwTotalPageFile;
	if ((vGlobalPCRunningWindowsXP >= cWindowsXP) && (TempTotalRAMInPC < 1000000000)) //in XP and less than 1 gig ram
	{
		if (vConfigurationData->vHaveCheckedForMoreRAM != 0xAB)
		{
			vConfigurationData->vHaveCheckedForMoreRAM = 0xAB;
			if (vGlobalFBWFEnable == 1)
			{
			}
			else
			{
				ReportErrorMessage("Should have 1 Gig of RAM, Rebooting to check one time", cEMailInspx, 32000);
				WriteConfigurationDataToFile(false); //write to main config file
				//tell system to look for more memory and reboot
				CNoticeDialog TempNoticeDialog;
				CString TempText = "\nMemory smaller than should be.\nWill Reboot in 10 seconds to check for more memory.\nAmount of Memory detected: " + dtoa(TempTotalRAMInPC,0);
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cInformationMessage;
				TempNoticeDialog.vAutoClose = 10000;
				TempNoticeDialog.DoModal();

				ClearDesignatedFrameGrabberMemorySettings(false);
			}
		}
		else
		{
			vSystemData.vMissingRAM = true;
			CNoticeDialog TempNoticeDialog;
			CString TempText = dtoa(TempTotalRAMInPC / 1000000, 0);
			TempText = "\n\nNotice, Should have 1 Gig (1000 Meg) of RAM\nOnly " + TempText + " meg of RAM detected.\nCall Service.";
			TempNoticeDialog.vNoticeText = TempText;
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
	}
	else
	if (vSystemData.vFPGAVersion10Point7OrHigher)
	{
		if (vGlobalPCRunningWindowsXP == cWindowsNT)
		if (TempTotalRAMInPC < 500000000) //if less than 500 meg ram, give warning
		{
			if (vConfigurationData->vHaveCheckedForMoreRAM != 0xAB)
			{
				vConfigurationData->vHaveCheckedForMoreRAM = 0xAB;
				ReportErrorMessage("Should have 500 Meg of RAM, Rebooting to check one time", cEMailInspx, 32000);
				WriteConfigurationDataToFile(false); //write to main config file
				//tell system to look for more memory and reboot
				ClearDesignatedFrameGrabberMemorySettings(false);
			}
			else
			{
				vSystemData.vMissingRAM = true;
				CNoticeDialog TempNoticeDialog;
				CString TempText = dtoa(TempTotalRAMInPC / 1000000, 0);
				TempText = "\n\nNotice, Should have 512 meg of RAM\nOnly " + TempText + " meg of RAM detected.\nCall Service.";
				TempNoticeDialog.vNoticeText = TempText;
				TempNoticeDialog.vType = cErrorMessage;
				TempNoticeDialog.DoModal();
			}
		}
	}
	if (TempTotalRAMInPC >= 900000000) //if 1 gig ram or more, clear flag checked for more
			vConfigurationData->vHaveCheckedForMoreRAM = 0;

	//if (vGlobalDXMXRayPort)
	//{
	//	if ((!vConfigurationData->vSimulateLightControlBoard) && (vGlobalDXMXRayPort->vNoCommunications))
	//	if (vSystemData.vACPowerOn)
	//	{
	//		ReportErrorMessage("Error-No Communication with DXM from Power On", cEMailInspx,32000);
	//	}
	//}
	//else
	//if (vGlobalMonoBlockXRayPort)
	//{
	//	if ((!vConfigurationData->vSimulateLightControlBoard) && (vGlobalMonoBlockXRayPort->vNoCommunications))
	//	if (vSystemData.vACPowerOn)
	//	{
	//		ReportErrorMessage("Error-No Communication with XRB210W MonoBlock from Power On", cEMailInspx,32000);
	//	}
	//}

	if (vGlobalCurrentProduct)
	if (!vSystemData.vITIPCDig->vCamera)
	{
#ifndef ScanTracDemo
		ReportErrorMessage("Error-No Frame Grabber",cEMailInspx,32000);
		ReportErrorMessage("Frame Grabber not connected, Call Service",cError,0);

		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\nError-No Frame Grabber detected in the computer.\nTurn off power and re-seat, or replace Frame Grabber";
		TempNoticeDialog.vType = cErrorMessage;
		//TempNoticeDialog.vAutoClose = 0xFFFF;  //force customer to shut down by not closing message
		TempNoticeDialog.DoModal();
#endif
	}
	SetInterlockStatus();

	double TempHardDriveSpaceFree = CheckDiskSpaceFree("C:\\"); //	double vGlobalHardDriveTotalBytes set in function call
	if (TempHardDriveSpaceFree < 25000000)//less than 25 meg free
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\nHard Disk Full.\nDelete some Files on Hard Disk.\nCall Service to configure Auto File Delete.\nThen run ScanTrac.";
		TempNoticeDialog.vType = cErrorMessage;
		TempNoticeDialog.DoModal();
	}
	if (TempHardDriveSpaceFree < 1000000000) // if less than a gig free, verify auto delete enabled and set if not
	{
		if ((vConfigurationData->vAutoDeleteFileTypes & 0x013) != 0x13)
			vConfigurationData->vAutoDeleteFileTypes = vConfigurationData->vAutoDeleteFileTypes | 0x013;
		if ((vConfigurationData->vNumberOfDaysToKeepLogs < 2) || (vConfigurationData->vNumberOfDaysToKeepLogs > 100))
			vConfigurationData->vNumberOfDaysToKeepLogs = 60;
	}

	PowerWiringOK(); //generates error message if wiring wrong

	Sleep(1000);
	CheckIPSettingsAndDisplayInHelpDialog(false);
	//BYTE TempCounter = 0;
	//while ((vGlobalIPAddressString == "IP Address Not Read ") && (TempCounter < 10))
	//{
	//	Sleep(2000);
	//	CheckIPSettingsAndDisplayInHelpDialog(false);
	//	TempCounter++;
	//}
	// temp for testing CheckForHalconLibrary();
	CheckHardDrives();
	if (vSystemData.vBackupDrive == "C") //if you booted to the backup drive
		VerifyScanTracIPAddress();
	if ((vSystemData.vPrimaryDrive == "C") || //if you booted to the primary drive
		((vConfigurationData->vIPDHCPEnabled) && (vGlobalIPDHCPEnabled))) //or they are both dynamic addressing, then update ScanTracs memory of what the IP Address is
		SaveIPSettingsInConfigurationData();

	//if (!vGlobalDisplayDialogThread)
	//{
	//	vGlobalDisplayDialogThread = (CDisplayDialogThread *)AfxBeginThread(RUNTIME_CLASS(CDisplayDialogThread), THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);

	//	if (!vGlobalDisplayDialogThread)
	//	{
	//		ReportErrorMessage("Error-Could Not Create Backup Display Dialog Thread", cEMailInspx,32000); 
	//	}
	//	else
	//	{
	//		CString TempText = " ";
	//		TempText.LoadString(IDS_BackingupSetupFilesPleaseWait);
	//		vGlobalDisplayDialogThread->vMessageToDisplay = "\n\nChecking Production Report\n\nPlease Wait....";
	//		vGlobalDisplayDialogThread->ResumeThread();
	//	}
	//}
	RenameProductionReportIfNeeded(false);
	FinalizeProductionReport(false);
	RenameProductionReportIfNeeded(true);
	FinalizeProductionReport(true);
	//if (vGlobalDisplayDialogThread)
	//{
	//	vGlobalDisplayDialogThread->ExitDisplayThread();
	//	vGlobalDisplayDialogThread = NULL;
	//}

	int TimerResult = SetTimer(vBackupToBackupHardDriveTimer,1800000,NULL); //30 minutes
	if (!TimerResult)
		ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx, 32000);

	TimerResult = SetTimer(vCheckForNewImageToDisplayTimerHandle,250,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-Check For New Image Timer Failed",cEMailInspx,32000);

	if ((vGlobalDisplaySizeH == 640) && (vGlobalDisplaySizeV == 480))
	{
		OnSubFunction5Button();
		OnFunction1Button();
	}
} //end of ClearVersionDisplay

bool KeepSetupChanges()
{
	CYesNoDialog TempYesNoDialog;
	CString TempText = " ";
	TempText.LoadString(IDS_KeepSetupChangesandExit);//"\n\nKeep Setup Changes and Exit?"
	TempYesNoDialog.vNoticeText = TempText;
	TempYesNoDialog.vQuestionType = cConfirmSave;
	int TempResult = TempYesNoDialog.DoModal();
	if (TempResult == IDOK)
	{
		return true;
	}
	return false;
}

bool AbortSetupChanges()
{
	CYesNoDialog TempYesNoDialog;
	CString TempText = " ";
	TempText.LoadString(IDS_AbandonSetupChangesandExit);//"\n\nAbandon Setup Changes and Exit?"
	TempYesNoDialog.vNoticeText = TempText;
	TempYesNoDialog.vQuestionType = cConfirmAbandon;
	int TempResult = TempYesNoDialog.DoModal();
	if (TempResult == IDOK)
	{
		return true;
	}
	return false;
}

void SetNumLock(BOOL bState)
{
  BYTE keyState[256];

  GetKeyboardState((LPBYTE)&keyState);
  if ((bState && !(keyState[VK_NUMLOCK] & 1)) ||
      (!bState && (keyState[VK_NUMLOCK] & 1)))
  {
  // Simulate a key press
     keybd_event(VK_NUMLOCK,
                  0x45,
                  KEYEVENTF_EXTENDEDKEY | 0,
                  0);

  // Simulate a key release
     keybd_event(VK_NUMLOCK,
                  0x45,
                  KEYEVENTF_EXTENDEDKEY | KEYEVENTF_KEYUP,
                  0);
  }
}

bool ThereIsEnoughMemory(DWORD TempMemorySizeNeeded, CString TempReasonNeeded)
{  //check amount of RAM or Memory
	MEMORYSTATUS memstat;
	GlobalMemoryStatus(&memstat);
	vGlobalAmountOfFreeMemory = memstat.dwAvailPageFile;

	if ((!vGlobalDemoMode) && (!vGlobalRunningCheckDisk))
	if (TempMemorySizeNeeded + 1000000 > vGlobalAmountOfFreeMemory)
	{
		if (vGlobalGaveMemoryError < 20)
		{
			ReportErrorMessage("Error-Out of Memory for: " + TempReasonNeeded,cEMailInspx,32000);
			ReportErrorMessage("Error-Out of Memory; Shut Down and Reboot ScanTrac",cError,0);
			vGlobalGaveMemoryError++;
		}
		return false;
	}
	else
	{
		if (vGlobalAmountOfFreeMemory < 32000000)
		if (!vGlobalGaveMemoryError)
		{
			vGlobalGaveMemoryError = 1;
			ReportErrorMessage("Warning-Running Low on Memory. Remaining: " + dtoaWithCommas(vGlobalAmountOfFreeMemory,0),cEMailInspx,32000);
		}

		if (vGlobalAmountOfFreeMemory < 10000000)
		if (vGlobalGaveMemoryError < 3)
		{
			vGlobalGaveMemoryError = 3;
			ReportErrorMessage("Warning-Running Low on Memory. Remaining: " + dtoaWithCommas(vGlobalAmountOfFreeMemory,0),cError,0);
		}

		if (vGlobalAmountOfFreeMemory < 5000000)
		if (vGlobalGaveMemoryError < 3)
		{
			vGlobalGaveMemoryError = 3;
			ReportErrorMessage("Running Low on Memory; Shut Down and Reboot ScanTrac" ,cError,0);
		}
	}
	return true;
}

/* old style passwords
bool PasswordOK()
{
	if (!PasswordOK(cTemporaryInspxPassword,false))
	{
		HWND TempWindow = NULL;
		TempWindow = FindWindow(NULL, "Password");
		if (TempWindow) 
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nA Password window is currently open.\nYou must Exit Help to return to it.";
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		else
		{
			//first check password
			CPasswordEntryDialog IPasswordEntryDialog;  

			//Set dialog box data titles and number value
			IPasswordEntryDialog.vEditString = "";
			IPasswordEntryDialog.m_DialogTitleStaticText1 = "Enter Special Setup Password";
			IPasswordEntryDialog.m_DialogTitleStaticText2 = "";
			//Pass control to dialog box and display
			int nResponse = IPasswordEntryDialog.DoModal();
			//dialog box is now closed, if user pressed select do this
			//if user pressed cancel, do nothing
			if (nResponse == IDOK)
			{
				if (("31415926" == IPasswordEntryDialog.vEditString) ||
					("72054328" == IPasswordEntryDialog.vEditString) ||
					("7205" == IPasswordEntryDialog.vEditString) ||
					("5104682199" == IPasswordEntryDialog.vEditString))
				{
					PasswordOK(cSuperInspxPassword,false) = true;
				}
				if (("31415926" == IPasswordEntryDialog.vEditString) ||
					("5104682199" == IPasswordEntryDialog.vEditString) ||
					("72054328" == IPasswordEntryDialog.vEditString) ||
					("7205" == IPasswordEntryDialog.vEditString) ||
					(vGlobalMainWindowPointer->vConfigurationData->vInspxPassword == IPasswordEntryDialog.vEditString) ||
					(vGlobalMainWindowPointer->vConfigurationData->vSystemSetupResetPassword == IPasswordEntryDialog.vEditString))
				{
					PasswordOK(cTemporaryInspxPassword,false) = true;
					::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
				}
				else
				if (DisposablePasswordOK(IPasswordEntryDialog.vEditString))
				{
					PasswordOK(cTemporaryInspxPassword,false) = true;
					vGlobalTemporaryPasswordOK = true;
					::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
				}
				else
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n\nPassword not correct";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
				}
			}
		}
	}
	return PasswordOK(cTemporaryInspxPassword,false);
}
*/

bool PasswordOK(int TempPasswordToTest, bool TempAskForPasswordIfNoPassword)
{
	bool TempPasswordOK = false;
	if (TempPasswordToTest == cNoPassword) //clear was pressed, clear the passwords
	{
		vGlobalPasswordLevel = cNoPassword;
		if (vGlobalCurrentUser != "No User")
			ReportErrorMessage(vGlobalCurrentUser + " logged out.", cUserChanges, 0);
		vGlobalCurrentUser = "No User";
		vGlobalDialogTitleColor = cDarkBlue;
		TempPasswordOK = false;
		SetCursorPos(vGlobalDisplaySizeH,vGlobalDisplaySizeV);
	}
	else
	{
		if (TempPasswordToTest <= vGlobalPasswordLevel)	//password is good, current password is of the level or higher than password resquest
		{
			TempPasswordOK = true;
			
		}
		else //need higher level password
		{
			if (TempPasswordToTest <= cCertifiedPassword)	//check if the password you are looking for is set
			{
				switch(TempPasswordToTest)
				{
					case cCertifiedPassword:
						if (vGlobalMainWindowPointer->vConfigurationData->vCertifiedSetupPassword.GetLength() <= 0)
						{	//one use password
							TempPasswordOK = true;
							//vGlobalDialogTitleColor = cDarkBlue;
							//TempAskForPasswordIfNoPassword = false;		//don't ask user for password
						}
					break;
					case cAdvancedSetupPassword:
						if (vGlobalMainWindowPointer->vConfigurationData->vAdvancedSetupPassword.GetLength() <= 0)
						{	//one use password
							TempPasswordOK = true;
							//vGlobalDialogTitleColor = cDarkBlue;
							//TempAskForPasswordIfNoPassword = false;		//don't ask user for password
						}
					break;
					case cSetupPassword:
						if (vGlobalMainWindowPointer->vConfigurationData->vProductSetupPassword.GetLength() <= 0)
						{	//one use password
							TempPasswordOK = true;
							//vGlobalDialogTitleColor = cDarkBlue;
							//TempAskForPasswordIfNoPassword = false;		//don't ask user for password
						}
					break;
					case cSimpleSetupPassword:
						if (vGlobalMainWindowPointer->vConfigurationData->vProductSimpleSetupPassword.GetLength() <= 0)
						{	//one use password
							TempPasswordOK = true;
							//vGlobalDialogTitleColor = cDarkBlue;
							//TempAskForPasswordIfNoPassword = false;		//don't ask user for password
						}
					break;
					case cResetPassword:
						if (vGlobalMainWindowPointer->vConfigurationData->vResetCountsPassword.GetLength() <= 0)
						{	//one use password
							TempPasswordOK = true;
							//vGlobalDialogTitleColor = cDarkBlue;
							//TempAskForPasswordIfNoPassword = false;		//don't ask user for password
						}
					break;
					case cOperatorPassword:
						if (vGlobalMainWindowPointer->vConfigurationData->vOperatorPassword.GetLength() <= 0)
						{	//one use password
							TempPasswordOK = true;
							//vGlobalDialogTitleColor = cDarkBlue;
							//TempAskForPasswordIfNoPassword = false;		//don't ask user for password
						}
					break;
				}
			}
			if (!TempPasswordOK)
			if (TempAskForPasswordIfNoPassword)
			{
				HWND TempWindow = NULL;
				TempWindow = FindWindow(NULL, _T("Password"));
				if (TempWindow) 
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n\nA Password window is currently open.\nYou must Exit Help to return to it.";
					TempNoticeDialog.vType = cNoticeMessage;
					TempNoticeDialog.DoModal();
				}
				else
				{
					CString TempPasswordLookingForNameString = "";
					
					CPasswordEntryDialog IPasswordEntryDialog;  

					//Set dialog box data titles and number value
					IPasswordEntryDialog.vEditString = "";
					IPasswordEntryDialog.m_DialogTitleStaticText2 = "";
					
					switch (TempPasswordToTest)
					{
						case cOperatorPassword:
							TempPasswordLookingForNameString.LoadString(IDS_EnterOperatorPassword);
						break;
						case cResetPassword:
							TempPasswordLookingForNameString.LoadString(IDS_EnterResetPassword);
						break;
						case cSetupPassword:
							TempPasswordLookingForNameString.LoadString(IDS_EnterSetupPassword);
						break;
						case cQAPassword:
							TempPasswordLookingForNameString.LoadString(IDS_EnterSetupPassword);
						break;
						case cSimpleSetupPassword:
							TempPasswordLookingForNameString.LoadString(IDS_EnterEasySetupPassword);
						break;
						case cAdvancedSetupPassword:
							TempPasswordLookingForNameString.LoadString(IDS_EnterAdvancedSetupPassword);
						break;
						case cCertifiedPassword:
							TempPasswordLookingForNameString.LoadString(IDS_EnterCertifiedPassword);
							IPasswordEntryDialog.m_DialogTitleStaticText2 = "Only given to customers with Advanced Training";
						break;
						case cTemporaryInspxPassword:
						case cInspxPassword:
							TempPasswordLookingForNameString = "Enter System Password";
						break;
						case cSuperInspxPassword:
							TempPasswordLookingForNameString = "Enter Super Inspx Password";
						break;
						default:
							//TempPasswordToTest = cSuperInspxPassword; //if they type in the super password, they can have access to the thing of unknown security level
							TempPasswordLookingForNameString = "Enter Password";
						break;
					}
					
					IPasswordEntryDialog.m_DialogTitleStaticText1 = TempPasswordLookingForNameString;
					
					//first check password
					//Pass control to dialog box and display
					int nResponse = IPasswordEntryDialog.DoModal();
					//dialog box is now closed, if user pressed select do this
					//if user pressed cancel, do nothing
					if (nResponse == IDOK)
					{			//super user
						if (("7205" == IPasswordEntryDialog.vEditString) || ("72054328" == IPasswordEntryDialog.vEditString))
						{	//20 minute use password
							vGlobalPasswordLevel = cSuperInspxPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
							ReportErrorMessage("Brian Higgins logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Brian Higgins";
						}
						else		//inspx
						if ("31415926" == IPasswordEntryDialog.vEditString)
						{	//20 minute use password
							vGlobalPasswordLevel = cSuperInspxPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
							ReportErrorMessage("Alex Gilevich logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Alex Gilevich";
						}
						else		//inspx
						if (("31415926" == IPasswordEntryDialog.vEditString) ||
							("72054328" == IPasswordEntryDialog.vEditString) ||
							("7205" == IPasswordEntryDialog.vEditString) ||
							("5104682199" == IPasswordEntryDialog.vEditString))
						{	//20 minute use password
							vGlobalPasswordLevel = cSuperInspxPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
							ReportErrorMessage("Universal Super Inspx Password logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Universal Super Inspx";
						}
						else		//inspx
						if (vGlobalMainWindowPointer->vConfigurationData->vInspxPassword == IPasswordEntryDialog.vEditString)
						{	//20 minute use password
							vGlobalPasswordLevel = cInspxPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);	//password good for 20 min
							ReportErrorMessage("Universal Inspx Password logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Universal Inspx";
						}
						else		//Allans
						if ("10221022" == IPasswordEntryDialog.vEditString)
						{	//20 minute use password
							vGlobalPasswordLevel = cAllansPassword;
							vGlobalDialogTitleColor = cDarkGreen;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);	//password good for 20 min
							ReportErrorMessage("Allan Anderson logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Allan Anderson";
						}
						else 		//disposable inspx
						if (DisposablePasswordOK(IPasswordEntryDialog.vEditString, cTemporaryInspxPassword))
						{	//20 minute use password
							vGlobalPasswordLevel = cTemporaryInspxPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
							ReportErrorMessage("Universal Temporary Inspx Password logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Universal Temporary Inspx";
						}
						else		//certified password
						if (vGlobalMainWindowPointer->vConfigurationData->vCertifiedSetupPassword == IPasswordEntryDialog.vEditString)
						{	//20 minute use password
							vGlobalPasswordLevel = cCertifiedPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);	//password good for 20 min
							ReportErrorMessage("Universal Certified Password logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Universal Certified";
						}
						else		//advanced setup password
						if ((vGlobalMainWindowPointer->vConfigurationData->vAdvancedSetupPassword.GetLength() > 0) &&
							((vGlobalMainWindowPointer->vConfigurationData->vAdvancedSetupPassword == IPasswordEntryDialog.vEditString)
							|| (DisposablePasswordOK(IPasswordEntryDialog.vEditString, cTemporaryAdvancedPassword))))
						{
							vGlobalPasswordLevel = cAdvancedSetupPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);	//password good for 20 min
							ReportErrorMessage("Universal Advanced Setup Password logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Universal Advanced";
						}
						else		//QA password
						if (vGlobalMainWindowPointer->vConfigurationData->vQAPassword == IPasswordEntryDialog.vEditString)
						{	//20 minute use password
							vGlobalPasswordLevel = cQAPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);	//password good for 20 min
							ReportErrorMessage("Universal QA Password logged in", cUserChanges,0); 
							vGlobalCurrentUser = "QA";
						}
						else		//setup password
						if (vGlobalMainWindowPointer->vConfigurationData->vProductSetupPassword == IPasswordEntryDialog.vEditString)
						{	//20 minute use password
							vGlobalPasswordLevel = cSetupPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);	//password good for 20 min
							ReportErrorMessage("Universal Setup Password logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Universal Setup";
						}
						else		//Simple Setup Password
						if (vGlobalMainWindowPointer->vConfigurationData->vProductSimpleSetupPassword == IPasswordEntryDialog.vEditString)
						{	//20 minute use password
							vGlobalPasswordLevel = cSimpleSetupPassword;
							::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);	//password good for 20 min
							ReportErrorMessage("Universal Simple Setup Password logged in", cUserChanges,0); 
							vGlobalCurrentUser = "Universal Simple Setup";
						}
						else		//reset password
						if ((vGlobalMainWindowPointer->vConfigurationData->vResetCountsPassword.GetLength() > 0) && (vGlobalMainWindowPointer->vConfigurationData->vResetCountsPassword == IPasswordEntryDialog.vEditString))
						{	//one use password
							vGlobalPasswordLevel = cResetPassword;
							ReportErrorMessage("Universal Reset Password Entered 1 Time Use", cUserChanges,0); 
						}
						else		//operator password
						if (((vGlobalMainWindowPointer->vConfigurationData->vOperatorPassword.GetLength() > 0) || (TempPasswordToTest == cOperatorPassword)) &&
							(vGlobalMainWindowPointer->vConfigurationData->vOperatorPassword == IPasswordEntryDialog.vEditString))
						{	//one use password
							vGlobalPasswordLevel = cOperatorPassword;
							ReportErrorMessage("Universal Operator Password Entered 1 Time Use", cUserChanges,0); 
						}
						else // vqn
						{
							UserPasswords* TempUser = PasswordExist(vGlobalRunningData->vUserCollection, IPasswordEntryDialog.vEditString);
							if (TempUser)
							{
								vGlobalPasswordLevel = TempUser->vLevel;
								vGlobalCurrentUser = TempUser->vUserName;
								if (vGlobalPasswordLevel >= cSimpleSetupPassword)
								{
									ReportErrorMessage(vGlobalCurrentUser + " logged in", cUserChanges,0); 
								}
								else
								{
									ReportErrorMessage(vGlobalCurrentUser + " entered 1 time use password", cUserChanges,0); 
								}
							}
						}
						//note: this not included: 
							//if (vGlobalMainWindowPointer->vConfigurationData->vSystemSetupResetPassword == IPasswordEntryDialog.vEditString))	
						//password only used in system counters dialog to reset waranty counters
						if ((cNoPassword < vGlobalPasswordLevel) && (TempPasswordToTest > vGlobalPasswordLevel))//if a password was accepted, make sure it was high enough
						{
							TempPasswordOK = false;
							CNoticeDialog TempNoticeDialog;
							if (vGlobalCurrentUser == "No User")
							{
								TempNoticeDialog.vNoticeText = "\n\n\nPassword Not Correct";
							}
							else
							if (TempAskForPasswordIfNoPassword)
							{
								ReportErrorMessage(vGlobalCurrentUser + " can not access this function", cUserChanges, 0);
								TempNoticeDialog.vNoticeText = "\n\n\n" + vGlobalCurrentUser + " can not access this function";
							}
							TempNoticeDialog.vType = cErrorMessage;
							TempNoticeDialog.DoModal();

							vGlobalPasswordLevel = cNoPassword;
							vGlobalCurrentUser = "No User";
						}
						else
						{
							switch (vGlobalPasswordLevel)
							{
								case cResetPassword:
								case cOperatorPassword:
									if (TempPasswordToTest <= vGlobalPasswordLevel)
										TempPasswordOK = true;
									vGlobalPasswordLevel = cNoPassword; //these are 1 time use passwords that must be entered each time
									vGlobalCurrentUser = "No User";
								case	cNoPassword:
									vGlobalDialogTitleColor = cDarkBlue;
								break;
								case cSimpleSetupPassword:
									vGlobalDialogTitleColor = cMediumDarkGreen;
									if (TempPasswordToTest <= vGlobalPasswordLevel)
										TempPasswordOK = true;
								break;
								case cQAPassword:
								case cSetupPassword:
								case cAdvancedSetupPassword:
								case cCertifiedPassword:
								case cAllansPassword:
									vGlobalDialogTitleColor = cDarkGreen;
									if (TempPasswordToTest <= vGlobalPasswordLevel)
										TempPasswordOK = true;
								break;
								case cTemporaryInspxPassword:
								case cInspxPassword:
								case cSuperInspxPassword:
									vGlobalDialogTitleColor = cBrilliantBlue;
									if (TempPasswordToTest <= vGlobalPasswordLevel)
										TempPasswordOK = true;
								break;
								default:
									vGlobalPasswordLevel = cNoPassword;
									vGlobalDialogTitleColor = cDarkBlue;
									TempPasswordOK = false;
								break;
							}
							if (!TempPasswordOK)
							{
								CNoticeDialog TempNoticeDialog;
								CString TempText = " ";
								TempText.LoadString(IDS_PasswordNotCorrect);
								TempNoticeDialog.vNoticeText = TempText;
								TempNoticeDialog.vType = cErrorMessage;
								TempNoticeDialog.DoModal();
							}
						}
					}
				}
			}
			//else if (!PasswordOK(cTemporaryInspxPassword))	//code for clarity, this is effectively done
				//TempPasswordOK = false;
		}
	}
	return TempPasswordOK;
}

void CScanTracDlg::CalibrateDetectorEdges(bool TempSaveEdgeCalibrateValues)
{
	if (vGlobalDXMXRayPort)
		vGlobalDXMXRayPort->EnableWatchDog(false);  //calculations can take a long time, so disable watch dog

	if (vSystemData.vSystemRunMode != cStoppedSystemMode)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nSystem must be stopped, operation aborted";
		TempNoticeDialog.vType = cNoticeMessage;
		TempNoticeDialog.DoModal();
	}
	else
	if (InterlocksOK())
	{
		if (TempSaveEdgeCalibrateValues)
			vSystemData.vFindingProductBrightness = 1;
		else
			vSystemData.vFindingProductBrightness = 0;
		//vSystemData.vHVPSInterlockDelay = 0;
		ReportErrorMessage("Start Calibrate Detector Edges", cWriteToLog,0);
		if (vConfigurationData->vUseXScanDetectors)
		{
			if (vSystemData.vCalibratingXScanPoint4mmDetectors)
				ReportErrorMessage("Calibrate Detector Edges in X-Scan .4mm Detector Mode", cAction,0);
			else
				ReportErrorMessage("Calibrate Detector Edges in X-Scan .8mm Detector Mode", cAction,0);
		}

		KillTimer(vStopRunningTimerHandle);
		vStopRunningTimerActive = false;
		KillTimer(vConveyorStartTimerHandle);
		MakeProductionReportIfNeeded();
		ResetCounters();
		ResetFPGAABFrameCounters();

		vUpdateGainAndOffsetConfiguration = TempSaveEdgeCalibrateValues;
		vSystemData.vCalibrationImageNumber = 0;
		vSystemData.vSystemRunMode = cCalibratingDetectorEdgesMode;
		CString TempText = " ";
		TempText.LoadString(IDS_Abort);
		SetDlgItemText(IDC_SubFunction1Button,TempText);
		UpdateRunButton();
		//TempText.LoadString(IDS_Calibrating);
		if (TempSaveEdgeCalibrateValues)
			TempText = "Calibrate Pixels";
		else
			TempText = "Verify Pixels";
		SetDlgItemText(IDC_Calibrating,TempText);
		m_Calibrating.ShowWindow(SW_SHOW);

		double TempMaximumCurrent = vConfigurationData->vMaximumCurrent;
		double TempMaxValue = GetMaximumCurrentFromVoltage(vGlobalCurrentProduct->vXRaySourceVoltage * 6);
		if (TempMaximumCurrent > TempMaxValue)
			TempMaximumCurrent = TempMaxValue;

		TempMaxValue = GetMaximumCurrentFromPower(vGlobalCurrentProduct->vXRaySourceVoltage * 6, vConfigurationData->vMaximumPower);
		if (TempMaximumCurrent > TempMaxValue)
			TempMaximumCurrent = TempMaxValue;

		if (vGlobalCurrentProduct->vXRaySourceCurrent > TempMaximumCurrent)
			vGlobalCurrentProduct->vXRaySourceCurrent = (float)TempMaximumCurrent;

		vCalibrateCurrentStep = (double)vGlobalCurrentProduct->vXRaySourceCurrent / (double)cNumberOfCalibrationImages;
		vCalibrateCurrent = 0;
		if (TempSaveEdgeCalibrateValues)
			vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;  //set product current to product to adjust product brightness
		else
			vSystemData.vRampXRayCurrentAmount = 0;  //set current to 0 for first step so will ramp to it

		if (TempSaveEdgeCalibrateValues)
		{
			//start the X-Rays
			SendSourceCurrentToUController(vSystemData.vRampXRayCurrentAmount);		
			ReportErrorMessage("Turn on X-Rays to Calibrate Pixels", cWriteToLog, 0);
			SendXRayPowerOnOffToUController(1);
			Sleep(cSendCommandSleepTime);
		}
		else
			StartImageAcquisition();

		if (vCalibrationAverageImage != NULL)
		{
			free(vCalibrationAverageImage);
			vCalibrationAverageImage = NULL;
		}
		DWORD TempCalibrationAverageImageSize = vSystemData.vITIPCDig->vOriginalBufferSizeX * (cNumberOfCalibrationImages + cNumberOfCalibrationResults); //was 18
		if (ThereIsEnoughMemory(TempCalibrationAverageImageSize * 8, "Average Calibration Image"))
		{
			vCalibrationAverageImage = (double *)malloc(TempCalibrationAverageImageSize * 8);
			if (vCalibrationAverageImage)
				ZeroMemory(vCalibrationAverageImage,TempCalibrationAverageImageSize);
			
			vCalibrationAverageImageMaximum = vCalibrationAverageImage + TempCalibrationAverageImageSize;

		}
		TurnSimulatedContainersOff();
		if (vGlobaluCSerialPort)
		if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
			vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterOpen); 
		//SetFastestSimulatedEncoder(1);  //done in StartImageAquistion
	}
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("End CalibrateDetectorEdges ScanTracDlg",cDebugMessage);

	if (!TempSaveEdgeCalibrateValues)
		SimulateOneContainerIn10MS(1000); //for verify, dont turn on source as start at zero, just start by taking an image to get the black level calibration
}

void CScanTracDlg::CalibrateADCDetectorOffset(bool TempAutoCalibrate, bool TempCalibrateWhileRunning)
{
	SendAllADCDetectorOffsetsToZero();
	vSystemData.vSystemRunMode = cCalibratingDetectorOffsetMode;
	vSystemData.vCalibrateUsingDAC = false;
	vSystemData.vLogFile.WriteToLogFile("Calibrate ADC Offset Start",cDebugMessage);
	vSystemData.vAutoCalibrate = TempAutoCalibrate;
	vSystemData.vAutoCalibrateWhileRunning = TempCalibrateWhileRunning;
	vSystemData.vRampXRayStep = 0;
	vSystemData.vCalibrationImageNumber = 0;
	vCalibrateCurrentStep = 0;

	if (vConfigurationData->vDriftCompensationEnabled)
	if (vSystemData.vKeepDensityFeedbackLoopLocked)
		vSystemData.vITIPCDig->vDriftCompensationLocked = false;

	vSystemData.vDriftCompensationThresholdReductionAmount = vConfigurationData->vDriftCompensationThresholdReductionMaximum;
	vSystemData.vDriftCompensationThresholdIncreaseAmount = vConfigurationData->vDriftCompensationThresholdReductionMaximum;

	KillTimer(vStopRunningTimerHandle);
	vStopRunningTimerActive = false;
	KillTimer(vConveyorStartTimerHandle);
	vSystemData.vCheckConveyor = false;
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("CalibrateDetectorOffset Reset Counters and Queues",cDebugMessage);
	ResetFPGAABFrameCounters();

	if (vGlobalImageAquisitionThread)
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Start Calibrate Offsets Reset a/b frame Counters",cDebugMessage);
		vGlobalImageAquisitionThread->vAFrameCounter = 0;
		vGlobalImageAquisitionThread->vBFrameCounter = 0;
		vGlobalImageAquisitionThread->vPreviousHardwareFrameCount = -1;
	}

	if (vGlobalCurrentProduct)
	{
		m_Calibrating.ShowWindow(SW_SHOW);
		CString TempStringSSD = vConfigurationData->vScanTracCalibrationImagesDirectory;
		TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
		LPTSTR TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
		CFileStatus TempFileStatus;
		if (vConfigurationData->vScanTracCalibrationImagesDirectory.GetLength() > 2)
		if (CFile::GetStatus(TempStringSSDP, TempFileStatus))
			vSystemData.vWriteCalibrationImages = true;
		else
			vSystemData.vWriteCalibrationImages = false;

		//Send Container Trigger to Image Delay
		BYTE TempActiveHigh = 0;
		if ((vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBodyTrigger - 1].vActiveHigh) || (vSystemData.vFPGAVersion10Point7OrHigher)) //always active high in FPGA 10.7 and above
			TempActiveHigh = 0x80;

		WORD TempBTToImagePosition = 10;
		tSerialCommand TempCommand;
		TempCommand[0] = 0x18;
		TempCommand[1] = (BYTE)(TempBTToImagePosition >> 8);
		TempCommand[2] = (BYTE)TempBTToImagePosition;
		TempCommand[3] = TempActiveHigh;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime + 10);

		TurnSimulatedContainersOff();
		Sleep(cSendCommandSleepTime + 10);

		if (vSystemData.vActualEncoderRate == 0)
			vSystemData.vActualEncoderRate = 466;  //turned on simulated encoder, so say running
		Sleep(cSendCommandSleepTime + 10);

		vCalibrateCurrent = (double)vGlobalCurrentProduct->vXRaySourceCurrent;
		//vSystemData.vRampXRayCurrentAmount = (float)vCalibrateCurrent;  
		//don't change current as was set correctly ahead of time
		StartImageAcquisition();

		vSystemData.vLastCalibrationTime = CTime::GetCurrentTime();

		ReportErrorMessage("Start Calibrate Detector ADC Offset", cWriteToLog,0);
		if (TempCalibrateWhileRunning)
		{
			if (vConfigurationData->vRadiationShutterInSystem)
			{
				if (vGlobaluCSerialPort)
				if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
					vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterClose); 
			}
			else
			{
				SendXRayPowerOnOffToUController(0);
				vOldXRayOnNotice = true;
				vSystemData.vShuttingDownXRays = false;
			}
		}
		if ((!TempAutoCalibrate) && (!TempCalibrateWhileRunning))
			ResetCounters();
		vSystemData.vCalibrationImageNumber = 0;
		if (vGlobalFPGAVersion18point0orAbove)
			vSystemData.vCalibrationADCOffsetMaximumBit = 0x80;  //8 bits to test, 9th bit is sign bit
		else 
			vSystemData.vCalibrationADCOffsetMaximumBit = 0x400;  //11 bits to test  

		vSystemData.vCalibrationOffsetRange = vSystemData.vCalibrationADCOffsetMaximumBit;
		for (BYTE TempLoop = 0; TempLoop < cMaximumNumberOfDetectors12; TempLoop++)
		{
			vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] = vSystemData.vCalibrationOffsetRange; 
		}

		vSystemData.vSendDACValues = 0; //cancel sending any DAC Values as will send all now
		vSystemData.vSendADCValues = 0; //cancel sending any ADC Values as will send all now
		if (vGlobaluCSerialPort)
		for (BYTE TempLoop = 0; TempLoop < vSystemData.vNumberOfXRayDetectorsUsing; TempLoop++)
		{
			vGlobaluCSerialPort->SendADCOffset(TempLoop, vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] - vSystemData.vCalibrationADCOffsetMaximumBit);
			Sleep(cSendCommandSleepTime + 10);
		}

		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Calibrate ADC Simulate next container", cDebugMessage);

		int TimerResult = SetTimer(vSimulateOneContainerTimer,200,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx, 32000);
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("End CalibrateDetectorOffset ScanTracDlg",cDebugMessage);
	}
}

void CScanTracDlg::CalibrateDACDetectorOffset()
{
	vSystemData.vCalibrationSimulationStarted = false;
	vSystemData.vCalibrateUsingDAC = true;
	SendAllADCDetectorOffsetsToZero();
	if (vGlobalCurrentProduct)
	if (PrepareToRun())
	{
		SendRetriggerLockout(15); //Turn off the container re-trigger lockout

		vSystemData.vCalibrateDACPreFrames = 2;
		ReportErrorMessage("Start Calibrate Detector DAC Offset", cWriteToLog,0);
		vSystemData.vReceivedACalibrationImage = false;
		//vSystemData.vCalibrationSimulationStarted = false;
		ResetFPGAABFrameCounters();
		//this will send command to disable body triggers, which will clear out
		//the queues in micro-controller that have frame starts and stops accumulated in them.
		//start conveyor to reset the FPGA a and b frame counters

		if (vSystemData.vAutoCalibrateWhileRunning)
		if (vGlobaluCSerialPort)
		{
			if (vConfigurationData->vRadiationShutterInSystem)
			{
				if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
					vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterClose); 
			}
			else
			{
				SendXRayPowerOnOffToUController(0);
				vOldXRayOnNotice = true;
				vSystemData.vShuttingDownXRays = false;
			}
		}

		BYTE TempNumberOfOffsetBits = cNumberOfOffsetBits;
		if (!vGlobalFPGAVersion10Point0OrHigher)
			TempNumberOfOffsetBits = 10;

		if ((!vSystemData.vAutoCalibrate) && (!vSystemData.vAutoCalibrateWhileRunning) &&
			(!vSystemData.vCalibrateADCAfterDAC))
			ResetCounters();
		vSystemData.vDriftCompensationADCOffset = 0;
		vSystemData.vDriftCompensationDACOffset = 0;
		vSystemData.vCalibrationImageNumber = 0;
		if (TempNumberOfOffsetBits == 8)
			vSystemData.vCalibrationOffsetRange = 0x80;  //testing 11th bit first
		else
		if (TempNumberOfOffsetBits == 9)
			vSystemData.vCalibrationOffsetRange = 0x100;  //testing 11th bit first
		else
		if (TempNumberOfOffsetBits == 10)
			vSystemData.vCalibrationOffsetRange = 0x200;  //testing 11th bit first
		else
		if (TempNumberOfOffsetBits == 11)
			vSystemData.vCalibrationOffsetRange = 0x400;  //testing 11th bit first
		else
			vSystemData.vCalibrationOffsetRange = 0x800;  //testing 12th bit first
		for (BYTE TempLoop = 0; TempLoop < cMaximumNumberOfDetectors12; TempLoop++)
		{
			if (TempNumberOfOffsetBits == 8)
				vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] = 0x80;  //set 8th bit in test number
			else
			if (TempNumberOfOffsetBits == 9)
				vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] = 0x100;  //set 9th bit in test number
			else
			if (TempNumberOfOffsetBits == 10)
				vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] = 0x200;  //set 10th bit in test number
			else
			if (TempNumberOfOffsetBits == 11)
				vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] = 0x400;  //set 11th bit in test number
			else
				vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] = 0x800;  //set 12th bit in test number
		}
		vSystemData.vSystemRunMode = cCalibratingDetectorOffsetMode;
		if (!vSystemData.vAutoCalibrateWhileRunning)
		{
			CString TempText = " ";
			if (vSystemData.vAutoCalibrateWhileRunning) 
				TempText.LoadString(IDS_Stop);
			else
				TempText.LoadString(IDS_Abort);
			SetDlgItemText(IDC_SubFunction1Button,TempText);
			UpdateRunButton();
		}

		if ((PasswordOK(cTemporaryInspxPassword,false)) && (!vSystemData.vCalibrateADCAfterDAC))
			SetDlgItemText(IDC_Calibrating, _T("Calibrate DAC"));
		else
		{
			CString TempText = " ";
			TempText.LoadString(IDS_Wait);
			SetDlgItemText(IDC_Calibrating,TempText);
		}
		m_Calibrating.ShowWindow(SW_SHOW);

		if (vGlobalCurrentProduct)
		{
			CString TempStringSSD = vConfigurationData->vScanTracCalibrationImagesDirectory;
			TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
			LPTSTR TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
			CFileStatus TempFileStatus;
			if (vConfigurationData->vScanTracCalibrationImagesDirectory.GetLength() > 2)
			if (CFile::GetStatus(TempStringSSDP, TempFileStatus))
				vSystemData.vWriteCalibrationImages = true;
			else
			{
				vSystemData.vWriteCalibrationImages = false;
						ReportErrorMessage("Cannot access Calibration Image Folder on Server", cEMailInspx, 32000);
			}

			//Send Container Trigger to Image Delay
			BYTE TempActiveHigh = 0;
			if ((vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBodyTrigger - 1].vActiveHigh) ||
					(vSystemData.vFPGAVersion10Point7OrHigher)) //always active high in FPGA 10.7 and above
				TempActiveHigh = 0x80;
			WORD TempBTToImagePosition = 10;
			tSerialCommand TempCommand;
			TempCommand[0] = 0x18;
			TempCommand[1] = (BYTE)(TempBTToImagePosition >> 8);
			TempCommand[2] = (BYTE)TempBTToImagePosition;
			TempCommand[3] = TempActiveHigh;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime + 10);
			if (vSystemData.vInAutoSetup)
				vSystemData.vNumberOfXRayDetectorsUsing = vConfigurationData->vNumberOfXRayDetectors;

			if (vGlobalCurrentProduct)
			if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes) //if doing multi lane, then using all detectors
				vSystemData.vNumberOfXRayDetectorsUsing = vConfigurationData->vNumberOfXRayDetectors;

			//set detector offsets to zero to start with
			vSystemData.vSendDACValues = 0; //cancel sending any DAC offsets that we were going to as now calibrating offset
			vSystemData.vSendADCValues = 0; //cancel sending any DAC offsets that we were going to as now calibrating offset
			if (vGlobaluCSerialPort)
			//for (BYTE TempLoop = 0; TempLoop < vSystemData.vNumberOfXRayDetectorsUsing; TempLoop++)
			for (BYTE TempLoop = 0; TempLoop < vConfigurationData->vNumberOfXRayDetectors; TempLoop++)
			{
				vGlobaluCSerialPort->SendAbsoluteDACDetectorOffset(TempLoop, vSystemData.vCalibrationOffsetCurrentOffset[TempLoop]); //set the offset of first detector mid way
				Sleep(cSendCommandSleepTime + 10);
			}

			vSystemData.vSendADCValues = 0; //cancel sending any ADC Values as will send all now
			for (BYTE TempLoop = 0; TempLoop < vConfigurationData->vNumberOfXRayDetectors; TempLoop++)
			{
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->SendADCOffset(TempLoop,0);
			}

			vSystemData.vLogFile.WriteToLogFile(
				"Calibrate DAC Offset Start",cDebugMessage);

			TurnSimulatedContainersOff();
			Sleep(cSendCommandSleepTime + 10);

			vSystemData.vRampXRayStep = 0;
			vCalibrateCurrentStep = 0;
			vCalibrateCurrent = (double)vGlobalCurrentProduct->vXRaySourceCurrent;
			//vSystemData.vRampXRayCurrentAmount = (float)vCalibrateCurrent;  
			//don't change current, already set as needed
			//why was this here 12/2/2005 commented out
			//vSystemData.vSourceRampedUp = true;
			StartImageAcquisition();

			//6/2/2004 worked good at 1000 ms
			int TimerResult = SetTimer(vSimulateOneContainerTimer,1000,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx,32000);
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("End CalibrateDACDetectorOffset ScanTracDlg",cDebugMessage);
			if (vGlobalFPGAVersion16point0orAbove)
				vSystemData.vNeedToVerifyDACValues = true;
			ReportErrorMessage("Start Calibrate Black Level, Verify DACs after", cWriteToLog, 0);
			vSystemData.vVerifyDACErros = 0;
		}
	}
}

void CScanTracDlg::LoadMeasureSourceStrengthProduct()
{
	MakeProductionReportIfNeeded();
	ResetCounters();
	//if (!vSystemData.vFullDetectorCalibration)
	//{
	//	vCalibrateHoldCurrentProduct = vGlobalCurrentProduct;
	//	if (vCalibrateHoldCurrentProduct)
	//		ReportErrorMessage("Save Original Product so can restore after calibration complete: " + *vCalibrateHoldCurrentProduct->GetProductName(), cWriteToLog, 0);
	//}

	vSystemData.vDensityIndex = 0;
	//look for product "~SourceStrength"
	CProduct *TempProduct = GetProductByName("~SourceStrength");
	//if don't find a calibrate product, create and save it, then use it
	if (!TempProduct)
	if (ThereIsEnoughMemory(sizeof(CProduct), "New Measure Product "))
	{
		TempProduct = new CProduct;
		if (TempProduct)
		{
			TempProduct->SetProductName("~SourceStrength");
			TempProduct->vUsingXScanPoint4mmDetectors = 0;
			vSystemData.vCalibratingXScanPoint4mmDetectors = 0;
			vConfigurationData->SetDetectorLength(vConfigurationData->vDetectorLength);
			//if ((vConfigurationData->vUseXScanDetectors) && (vConfigurationData->vScanTracType != cForteScanTrac) && (vConfigurationData->vScanTracType != cCaseInspectorScanTrac))
			//{
			//	TempProduct->vUsingXScanPoint4mmDetectors = 1;
			//	vSystemData.vCalibratingXScanPoint4mmDetectors = 1;
			//	vConfigurationData->SetDetectorLength(vConfigurationData->vDetectorLength);
			//}

			TempProduct->vProductImageHeightTop = (float)(vConfigurationData->vDetectorLength * vConfigurationData->vNumberOfXRayDetectors);
			//if (vConfigurationData->vUseMetric)
			//	TempProduct->vProductImageHeightTop = (WORD)(TempProduct->vProductImageHeightTop * 25.4);

			double TempDelay = 2;
			//if (vConfigurationData->vUseMetric)
			//	TempDelay = TempDelay * 25.4;
			TempProduct->SetProductBodyTriggerToImageBeltPositionOffset((float)TempDelay);
			TempProduct->SetProductImageWidth((float)TempDelay * 2);
			TempProduct->SetProductLockOutWidth((float)TempDelay);

			TempProduct->vEndOfLineTimeOut = (float)(16);
			//if (vConfigurationData->vUseMetric)
			//	TempProduct->vEndOfLineTimeOut = (float)(16 * 25.4);
			TempProduct->SetEndOfLineTimeOut(TempProduct->vEndOfLineTimeOut);

			TempProduct->vEdgeLocationBottom = (float)(.5);
			TempProduct->SetEdgeLocationBottom(TempProduct->vEdgeLocationBottom);
			TempProduct->vEdgeLocationHeight = (float)(1);
			TempProduct->SetEdgeLocationHeight(TempProduct->vEdgeLocationHeight);

			float TempDefaultVoltage = (float)GetDefaultMeasureSourceStrengthVoltage();

			//just set the voltage if more than a KV off from what should be
			if (((TempProduct->vXRaySourceVoltage * 6) > (TempDefaultVoltage + 1.0)) || 
				((TempProduct->vXRaySourceVoltage * 6) < (TempDefaultVoltage - 1.0)))
				TempProduct->vXRaySourceVoltage = (float)(TempDefaultVoltage / 6);

			float TempDefaultCurrent = (float)GetDefaultMeasureSourceStrengthCurrent(vConfigurationData->vXRaySourceFilter);

		//just set the current if more than a .5 mA off from what should be
			if ((TempProduct->vXRaySourceCurrent > (float)(TempDefaultCurrent + 0.5)) || 
				(TempProduct->vXRaySourceCurrent < (float)(TempDefaultCurrent - 0.5)))
				TempProduct->vXRaySourceCurrent = (float)TempDefaultCurrent;

			if (vConfigurationData->vMaximumCurrent < TempProduct->vXRaySourceCurrent)
				TempProduct->vXRaySourceCurrent = (float)vConfigurationData->vMaximumCurrent;

			if (vConfigurationData->vMaximumVoltage < TempProduct->vXRaySourceVoltage)
				TempProduct->vXRaySourceVoltage = (float)vConfigurationData->vMaximumVoltage;

			TempProduct->vXRayIntegrationTime = 750; //.3 ms
			TempProduct->vBodyTrigger = 1;
			TempProduct->SetEjectorBeltPositionOffset(0,(float)40);
			//if (vConfigurationData->vUseMetric)
			//	TempProduct->SetEjectorBeltPositionOffset(0,(float)(40 * 25.4));
			TempProduct->vNotes = "Auto Product for Measuring Source Strength";
			TempProduct->CalculateEndOfLineTimeOut();

			AddProduct(((CProduct *)TempProduct));
		}
	}
	if (TempProduct)
	{
		if ((TempProduct->vUsingXScanPoint4mmDetectors) && (vConfigurationData->vScanTracType != cForteScanTrac) && (vConfigurationData->vScanTracType != cCaseInspectorScanTrac))
		{
			vConfigurationData->vUseXScanDetectors = 1;
			vSystemData.vCalibratingXScanPoint4mmDetectors = 1;
			vConfigurationData->SetDetectorLength(vConfigurationData->vDetectorLength);
		}

		if (TempProduct->vImageWidthPosition < cCalibrationImageWidth)
		{
			if (!vGlobalPixelsPerUnit)
				ReportErrorMessage("Error-vGlobalPixelsPerUnit = 0, would cause crash", cEMailInspx, 32000);
			else
				TempProduct->vProductImageWidth  = (float)(cCalibrationImageWidth * 2 / vGlobalPixelsPerUnit);
			TempProduct->SetProductImageWidth(TempProduct->vProductImageWidth);
		}
		//always use new standard settings 6/25/2012 //new source strength code
		if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cUpSideDownSoloScanTrac) || 
			(vConfigurationData->vScanTracType == cFermataScanTrac))  //if a solo, set default value automatically 
		{
			TempProduct->vXRaySourceVoltage = (float)(GetDefaultMeasureSourceStrengthVoltage() / 6);
			TempProduct->vXRaySourceCurrent = (float)GetDefaultMeasureSourceStrengthCurrent(vConfigurationData->vXRaySourceFilter);

			if (vConfigurationData->vMaximumCurrent < TempProduct->vXRaySourceCurrent)
				TempProduct->vXRaySourceCurrent = (float)vConfigurationData->vMaximumCurrent;

			if (vConfigurationData->vMaximumVoltage < TempProduct->vXRaySourceVoltage)
				TempProduct->vXRaySourceVoltage = (float)vConfigurationData->vMaximumVoltage;

			TempProduct->vXRayIntegrationTime = 750; //.3 ms
		}

		SetupProduct(TempProduct, false);
	}
	else
		ReportErrorMessage("Could not create ~SourceStrength product", cError, 0);
}

void CScanTracDlg::StartAlignTubeMode()
{
	vSystemData.vSystemRunMode = cAlignTubeMode;
	if (InterlocksOK())
	{
		//vSystemData.vHVPSInterlockDelay = 0;
		ReportErrorMessage("Start Align Tube", cWriteToLog,0);
		MakeProductionReportIfNeeded();
		ResetCounters();
		ResetFPGAABFrameCounters();
		vSystemData.vDensityIndex = 0;
		vSystemData.vCalibrationImageNumber = 0;
		CString TempText = " ";
		TempText.LoadString(IDS_Abort);
		SetDlgItemText(IDC_SubFunction1Button,TempText);
		UpdateRunButton();
		CString TempText1 = " ";
		TempText.LoadString(IDS_Measuring);
		SetDlgItemText(IDC_Calibrating,TempText);
		m_Calibrating.ShowWindow(SW_SHOW);
		//set product current to first step so will ramp to it
		//start the X-Rays
		SendXRayPowerOnOffToUController(1);
		Sleep(cSendCommandSleepTime);
		vCalibrateCurrentStep =  0;
		vCalibrateCurrent = (double)vGlobalCurrentProduct->vXRaySourceCurrent;

		TurnSimulatedContainersOff();

		//SetFastestSimulatedEncoder(1);//done in StartImageAquistion
	}
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Exit Start Align Tube ScanTracDlg",cDebugMessage);
}

void CScanTracDlg::MeasureSourceStrength()
{
	if (vSystemData.vSystemRunMode != cStoppedSystemMode)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nSystem must be stopped, operation aborted";
		TempNoticeDialog.vType = cNoticeMessage;
		TempNoticeDialog.DoModal();
	}
	else
	if (InterlocksOK())
	{
		//vSystemData.vHVPSInterlockDelay = 0;
		ReportErrorMessage("Start Measure Source Strength", cWriteToLog,0);
		MakeProductionReportIfNeeded();
		ResetCounters();
		ResetFPGAABFrameCounters();
		vSystemData.vDensityIndex = 0;
		vSystemData.vCalibrationImageNumber = 0;
		vSystemData.vSystemRunMode = cMeasureSourceStrengthMode;
		CString TempText = " ";
		TempText.LoadString(IDS_Abort);
		SetDlgItemText(IDC_SubFunction1Button,TempText);
		UpdateRunButton();
		CString TempText1 = " ";
		TempText.LoadString(IDS_Measuring);
		SetDlgItemText(IDC_Calibrating,TempText);
		m_Calibrating.ShowWindow(SW_SHOW);
		//set product current to first step so will ramp to it
		if (vGlobalCurrentProduct)
			vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;  
		//start the X-Rays
		SendXRayPowerOnOffToUController(1);
		Sleep(cSendCommandSleepTime);
		vCalibrateCurrentStep =  0;
		vCalibrateCurrent = (double)vGlobalCurrentProduct->vXRaySourceCurrent;

		TurnSimulatedContainersOff();

		//SetFastestSimulatedEncoder(1);//done in StartImageAquistion
	}
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Exit MeasureSourceStrength ScanTracDlg",cDebugMessage);
}

void CScanTracDlg::SimulateOneContainerIn10MS(DWORD TempMilliSeconds)
{
	if (TempMilliSeconds == 0)
		TempMilliSeconds = cCalibrateOffsetTimeInterval;
	int TimerResult = SetTimer(vSimulateOneContainerTimer,TempMilliSeconds,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx,32000);
}

void CScanTracDlg::SimulateOneContainer()
{
	if (vSystemData.vActualEncoderRate)
	{
		if (vSystemData.vCheckConveyor)
			vSystemData.vCheckConveyor = 1;  //reset conveyor check to give 5 more seconds

		vSystemData.vCalibrationSimulationStarted = true;
		//vSystemData.vReadyForImage = true;
	//	simulate one container 
		tSerialCommand TempCommand;
		TempCommand[0] = 0x16;
		TempCommand[1] = 0x2;
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x00;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime);

		ReportErrorMessage("Simulate a container command sent",cWriteToLog,32000);
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Command uC to simulate a container mode: " + dtoa(vSystemData.vSystemRunMode),cDebugMessage);
		if (vConfigurationData->vDemoMode)
			vSystemData.vLastBodyTriggerLength = (WORD)(vGlobalPixelsPerUnit * 3);

		//start timeout in case do not get an image can generate error message
		if ((vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode) || (vSystemData.vSystemRunMode == cAlignTubeMode))
			vSystemData.vWaitingForImage = 1;
	}
	else
	if (vSystemData.vSystemRunMode != cStoppedSystemMode)
	{
		ReportErrorMessage("Warning-Conveyor not moving when should simulate a container",cWriteToLog,32000);
		int TimerResult = SetTimer(vSimulateOneContainerTimer,200,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx, 32000);
	}
	else
		ReportErrorMessage("Simulate a container, but stopped mode",cWriteToLog,32000);
}

void CScanTracDlg::ProcessMeasureSourceStrengthFrame()
{
	if ((vSystemData.vITIPCDig->vOriginalImage) && (vSystemData.vITIPCDig->vOriginalImage->vGreyImage))
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("STD-ProcessMeasureSourceStrengthFrame",cDebugMessage);
		//take frame and output to a file
		vSystemData.vCalibrationImageNumber++;
		CString TempString = " ";
		TempString.LoadString(IDS_Measuring);
		TempString = TempString + " " + dtoa(vSystemData.vCalibrationImageNumber, 0);
		SetDlgItemText(IDC_Calibrating,TempString);


		//do souce density average here
		float TempSum = 0;
		BYTE *TempPointer = NULL;
		DWORD TempCount = 0;

		//add up all the pixels in all the lines except the blocked bottom and last 10 pixels 
		//that are calibrated
		//in each line
		WORD TempBottom = 10;
		if (vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration)
			TempBottom = vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration;

		WORD TempTop = vSystemData.vITIPCDig->vOriginalBufferSizeX - 10;
		if (vConfigurationData->vNumberOfDetectorsToCalibrate)
			TempTop = (vConfigurationData->vNumberOfDetectorsToCalibrate * vConfigurationData->vPixelsPerDetector) - 10; 

		if ((vSystemData.vITIPCDig->vNextImageToDisplay) && (vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage))
		if (vSystemData.vITIPCDig->vNextImageToDisplayLock.Lock())
		{
			CopyMemory(vSystemData.vITIPCDig->vOriginalImage->vGreyImage, vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage, vSystemData.vITIPCDig->vOriginalBufferSize);
			vSystemData.vITIPCDig->vNextImageToDisplayLock.Unlock();
		}

		for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vOriginalBufferSizeY; TempLoopY++)
		{
			TempPointer = vSystemData.vITIPCDig->vOriginalImage->vGreyImage + TempBottom + (TempLoopY * vSystemData.vITIPCDig->vOriginalBufferSizeX);
			for (WORD TempLoopX = TempBottom; TempLoopX < TempTop; TempLoopX++)
			{
				TempSum = TempSum + *TempPointer++;
				TempCount++;
			}
		}

		double TempImageDensityValue = 0;
		if (TempCount)
			TempImageDensityValue = TempSum / TempCount;
		if (TempImageDensityValue > 255)
			TempImageDensityValue = 255;

		if (vSystemData.vDensityIndex == 0)  
		{//if first time through collecting averageinitialize array
			if (vSystemData.vDensityDataD)
			{
				free(vSystemData.vDensityDataD);
				vSystemData.vDensityDataD = NULL;
			}
			if (ThereIsEnoughMemory(cStandardDeviationSampleSize * sizeof(double),"Density Sample Array"))
			{
				vSystemData.vDensityDataD = (double*)malloc(cStandardDeviationSampleSize * sizeof(double));
			}
			double *TempInitPointer = vSystemData.vDensityDataD;
			for (WORD TempInitLoop = 0; TempInitLoop < vConfigurationData->vNumberOfXRayDetectors; TempInitLoop++)
					*TempInitPointer++ = 0;

			//Create data structures for each detectors data
			for (WORD TempLoopDetector = 0; TempLoopDetector < vConfigurationData->vNumberOfXRayDetectors; TempLoopDetector++)
			{
				if (vSystemData.vDetectorDensityData[TempLoopDetector])
				{
					free(vSystemData.vDetectorDensityData[TempLoopDetector]);
					vSystemData.vDetectorDensityData[TempLoopDetector] = NULL;
				}
				if (ThereIsEnoughMemory(cStandardDeviationSampleSize * sizeof(double),"Density Sample Array"))
				{
					vSystemData.vDetectorDensityData[TempLoopDetector] = (double*)malloc(cStandardDeviationSampleSize * sizeof(double));
				}
			}
		}  //end first image of measure source strength

		if ((vSystemData.vFindingProductBrightness) && (vSystemData.vITIPCDig->vShowOnlyRealImages))
		{
			vSystemData.vCalibrationImageNumber = 0;
			if (TempImageDensityValue < 150) //image too dark
			{
				if (vGlobalCurrentProduct->vXRaySourceCurrent < vConfigurationData->vMaximumCurrent)
				{
					if (vSystemData.vFindingProductBrightness & 2) //already was too dark, now too bright
						vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent + .01);
					else
						vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent + .1);

					vSystemData.vFindingProductBrightness = vSystemData.vFindingProductBrightness | 4;

					if (vGlobalCurrentProduct->vXRaySourceCurrent > vConfigurationData->vMaximumCurrent)
						vGlobalCurrentProduct->vXRaySourceCurrent = (float)vConfigurationData->vMaximumCurrent;

					vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;
					SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

					ReportErrorMessage("Source Strength Too Dark (" + dtoa(TempImageDensityValue,2) + ") Increased Current to: " + dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1),cWriteToLog,0);
	/*
					if (PasswordOK(cTemporaryInspxPassword,false))
					{
						CNoticeDialog TempNoticeDialog;
						TempNoticeDialog.vNoticeText = 
							"\n\n~Source Strength Product too Dark (" + dtoa(TempImageDensityValue,2) +
							")\n Increased Current to: " + dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1) +
							" and Trying Again";
						TempNoticeDialog.vAutoClose = 1500;
						TempNoticeDialog.vType = cNoticeMessage;
						TempNoticeDialog.DoModal();
					}
					*/
				}
				else
				if (vGlobalCurrentProduct->vXRaySourceVoltage < vConfigurationData->vMaximumVoltage / 6.0)
				{
					if (vSystemData.vFindingProductBrightness & 2) //already was too dark, now too bright
						vGlobalCurrentProduct->vXRaySourceVoltage = 
							(float)(vGlobalCurrentProduct->vXRaySourceVoltage + .01);
					else
						vGlobalCurrentProduct->vXRaySourceVoltage = 
							(float)(vGlobalCurrentProduct->vXRaySourceVoltage + .1);

					vSystemData.vFindingProductBrightness = vSystemData.vFindingProductBrightness | 4;

					if (vGlobalCurrentProduct->vXRaySourceVoltage > vConfigurationData->vMaximumVoltage / 6.0)
						vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vConfigurationData->vMaximumVoltage / 6.0);

					vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;
					SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

					ReportErrorMessage("Source Strength Too Dark (" + dtoa(TempImageDensityValue,2) + ") Increased Voltage to: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cWriteToLog,0);
	/*
					if (PasswordOK(cTemporaryInspxPassword,false))
					{
						CNoticeDialog TempNoticeDialog;
						TempNoticeDialog.vNoticeText = 
							"\n\n~Source Strength Product too Dark (" + dtoa(TempImageDensityValue,2) +
							")\n Increased Voltage to: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1) +
							" and Trying Again";
						TempNoticeDialog.vAutoClose = 1500;
						TempNoticeDialog.vType = cNoticeMessage;
						TempNoticeDialog.DoModal();
					}
					*/
				}
				else
				{
					ReportErrorMessage("Source Strength Too Dark (" + dtoa(TempImageDensityValue,2) + ") Maxed Out Current and Voltage",cWriteToLog,0);

					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = 
						"\n\n~Source Strength Product too Dark (" + dtoa(TempImageDensityValue,2) +
						")\nIf results are not good, Increase Brightness, Calibrate Pixels Again";
					TempNoticeDialog.vType = cNoticeMessage;
					TempNoticeDialog.DoModal();
					vSystemData.vFindingProductBrightness = false;
				}
			}
			else
			if (TempImageDensityValue > 200) //image too bright
			{
				if (vGlobalCurrentProduct->vXRaySourceCurrent > .2)
				{
					if (vSystemData.vFindingProductBrightness & 4) //already was too dark, now too bright
						vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent - .01);
					else
						vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent - .1);

					vSystemData.vFindingProductBrightness = vSystemData.vFindingProductBrightness | 2;

					vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;
					SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

					ReportErrorMessage("Source Strength Too Bright (" + dtoa(TempImageDensityValue,2) + ") Decreased Current to: " + dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1),cWriteToLog,0);
	/*
					if (PasswordOK(cTemporaryInspxPassword,false))
					{
						CNoticeDialog TempNoticeDialog;
						TempNoticeDialog.vNoticeText = 
							"\n\n~Source Strength Product too Bright (" + dtoa(TempImageDensityValue,2) +
							")\n Decreased Current to: " + dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1) +
							" and Trying Again";
						TempNoticeDialog.vAutoClose = 1500;
						TempNoticeDialog.vType = cNoticeMessage;
						TempNoticeDialog.DoModal();
					}
					*/
				}
				else
				if (vGlobalCurrentProduct->vXRaySourceVoltage > 33.0 / 6.0)
				{
					if (vSystemData.vFindingProductBrightness & 4) //already was too dark, now too bright
						vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vGlobalCurrentProduct->vXRaySourceVoltage - .01);
					else
						vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vGlobalCurrentProduct->vXRaySourceVoltage - .1);

					vSystemData.vFindingProductBrightness = vSystemData.vFindingProductBrightness | 2;

					vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;
					SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

					ReportErrorMessage("Source Strength Too Bright (" + dtoa(TempImageDensityValue,2) + ") Decreased Voltage to: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cWriteToLog,0);
	/*
					if (PasswordOK(cTemporaryInspxPassword,false))
					{
						CNoticeDialog TempNoticeDialog;
						TempNoticeDialog.vNoticeText = 
							"\n\n~Source Strength Product too Bright (" + dtoa(TempImageDensityValue,2) +
							")\n Decreased Voltage to: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1) +
							" and Trying Again";
						TempNoticeDialog.vAutoClose = 1500;
						TempNoticeDialog.vType = cNoticeMessage;
						TempNoticeDialog.DoModal();
					}
					*/
				}
				else
				{
					ReportErrorMessage("Source Strength Too Bright (" + dtoa(TempImageDensityValue,2) + ") Maxed Out Current and Voltage",cWriteToLog,0);

					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = 
						"\n\n~Source Strength Product too Bright (" + dtoa(TempImageDensityValue,2) + ")\nIf results are not good, Decrease Brightness, Calibrate Pixels Again";
					TempNoticeDialog.vType = cNoticeMessage;
					TempNoticeDialog.DoModal();

					vSystemData.vFindingProductBrightness = false;
				}
			}
			else
			{
				if (vSystemData.vFindingProductBrightness & 6) //if adjusted brightness, up .1ma
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent + .01);
				else
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent + .1);

				vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;

				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount, vSystemData.vRampXRayCurrentAmount);

				vSystemData.vFindingProductBrightness = false;

				ReportErrorMessage("Source Strength Has Good Exposure " + dtoa(TempImageDensityValue,2),cWriteToLog,0);
	/*
				if (PasswordOK(cTemporaryInspxPassword,false))
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = 
						"\n\n~Source Strength Product Good Exposure (" + dtoa(TempImageDensityValue,2) +
						")";
					TempNoticeDialog.vType = cNoticeMessage;
					TempNoticeDialog.DoModal();
				}
				*/
			}
		}
		else
		{
			if (vSystemData.vFullDetectorCalibration)
			{
				ReportErrorMessage("Full Detector Calibration Completed", cUserChanges,0);
				vSystemData.vFullDetectorCalibration = false;
			}
			//find the data for entire detector
			if (vSystemData.vDensityDataD)
			{
				vSystemData.vITIPCDig->vLastDensityValue[0] = TempImageDensityValue;
				//if (vSystemData.vITIPCDig->vLastDensityValue[0] < vSystemData.vITIPCDig->vDensityMinimumValue)
				//	vSystemData.vITIPCDig->vDensityMinimumValue = vSystemData.vITIPCDig->vLastDensityValue[0];

				//if (vSystemData.vITIPCDig->vLastDensityValue[0] > vSystemData.vITIPCDig->vDensityMaximumValue)
				//	vSystemData.vITIPCDig->vDensityMaximumValue = vSystemData.vITIPCDig->vLastDensityValue[0];

				double *TempDataPointer = vSystemData.vDensityDataD + vSystemData.vDensityIndex;

				*TempDataPointer = vSystemData.vITIPCDig->vLastDensityValue[0];

				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Measure Source Strength Image:" + dtoa(vSystemData.vDensityIndex,0) + " All Detectors Result: " + dtoa(*TempDataPointer,2),cDebugMessage);
			}

			double TempDetectorDensityValue = 0;
			//do souce density average for each detector
			float TempSum[cMaximumNumberOfDetectors12];
			for (WORD TempLoopDetector = 0; TempLoopDetector < vConfigurationData->vNumberOfXRayDetectors; TempLoopDetector++) //for each detector
			if (vSystemData.vDetectorDensityData[TempLoopDetector])
			{
				WORD TempBottom = 4;
				if (!TempLoopDetector)
				if (vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration)
					TempBottom = vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration;

				TempSum[TempLoopDetector] = 0;
				BYTE *TempPointer = NULL;

				//add up all the pixels in all the lines except the first 4 and last 4 pixels 
				//in each line
				DWORD TempCount = 0;
				for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vOriginalBufferSizeY; TempLoopY++) //for each line in the image
				{
					TempPointer = vSystemData.vITIPCDig->vOriginalImage->vGreyImage + TempBottom + (TempLoopDetector * vConfigurationData->vPixelsPerDetector) + (TempLoopY * vSystemData.vITIPCDig->vOriginalBufferSizeX);
					for (WORD TempLoopX = TempBottom; TempLoopX < vConfigurationData->vPixelsPerDetector - 4 - TempBottom; TempLoopX++)  //for each pixel in this detector
					{
						if ((DWORD)((TempLoopDetector * vConfigurationData->vPixelsPerDetector) + TempLoopX + (TempLoopY  * vSystemData.vITIPCDig->vOriginalBufferSizeX)) < vSystemData.vITIPCDig->vOriginalBufferSize)
						{
							TempSum[TempLoopDetector] = TempSum[TempLoopDetector] + *TempPointer++;
							TempCount++;
						}
						else
							DWORD TempDWORD = TempCount;
					}
				}

				//if (!vSystemData.vITIPCDig->vOriginalBufferSize)
				//	ReportErrorMessage("Error-vSystemData.vITIPCDig->vOriginalBufferSize = 0, would cause crash", cEMailInspx, 32000);
				//else
				//if (!vConfigurationData->vNumberOfXRayDetectors)
				//	ReportErrorMessage("Error-vConfigurationData->vNumberOfXRayDetectors = 0, would cause crash", cEMailInspx, 32000);
				//else
				//	TempDetectorDensityValue = TempSum[TempLoopDetector] / ((vSystemData.vITIPCDig->vOriginalBufferSize / vConfigurationData->vNumberOfXRayDetectors));

				if (TempCount)
					TempDetectorDensityValue = TempSum[TempLoopDetector] / TempCount;
				else
					TempDetectorDensityValue = 0;

				double *TempDataPointer = vSystemData.vDetectorDensityData[TempLoopDetector] + vSystemData.vDensityIndex; //densityIndex is the picture number of the 20 images taken

				*TempDataPointer = TempDetectorDensityValue;

				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Measure Source Strength Image:" + dtoa(vSystemData.vDensityIndex,0) + " Detector: " + dtoa(TempLoopDetector,0) + " Result: " + dtoa(TempDetectorDensityValue,2),cDebugMessage);
			}

			//if last image, save intensity value for each image
			if (cNumberOfCalibrationImages == vSystemData.vCalibrationImageNumber)
			{
				CString TempFirst = "  ";
				vSystemData.vPixelValuesCorrectedPixels = vSystemData.vApplyGainAndOffsetDuringCalibration;
				if (vConfigurationData->vScanTracType == cBriosoScanTrac)
					vSystemData.vPixelValuesString = "0 = Black, 255 = White\nBack detector";
				else
					vSystemData.vPixelValuesString = "0 = Black, 255 = White\n" + vGlobalBottomString + " detector";
				double TempSum = 0;
				BYTE *TempPointer = NULL;

				//add up all the pixels in all the lines to record pixel value
				DWORD TempCount = 0;
				for (WORD TempLoopY = 1; TempLoopY < vSystemData.vITIPCDig->vOriginalBufferSizeX; TempLoopY++)
				{
					TempCount = 0;
					TempSum = 0;
					TempPointer = vSystemData.vITIPCDig->vOriginalImage->vGreyImage + TempLoopY;
					for (WORD TempLoopX = 0; TempLoopX < vSystemData.vITIPCDig->vOriginalBufferSizeY; TempLoopX++)
					{
						TempSum = TempSum + *TempPointer;
						TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
						TempCount++;
					}
					double TempPixelDensityValue = 0;
					if (TempCount)
						TempPixelDensityValue = TempSum / TempCount;

					if (vGlobalCurrentProduct)
					if (vConfigurationData->vOverWriteBadPixel[TempLoopY][vGlobalCurrentProduct->vUsingXScanPoint4mmDetectors])
					if (vConfigurationData->vOverWriteBadPixel[0][vGlobalCurrentProduct->vUsingXScanPoint4mmDetectors] == 0xAAAB)
					if (TempLoopY)
					if (PasswordOK(cTemporaryInspxPassword,false))
					{
						vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "\n*++++++++++COPY PIXEL: " + dtoa(vConfigurationData->vOverWriteBadPixel[TempLoopY][vGlobalCurrentProduct->vUsingXScanPoint4mmDetectors], 0) + " ON TOP OF PIXEL: " + dtoa(TempLoopY, 0);
					}

					TempFirst = " ";
					if ((TempPixelDensityValue < 20) || (TempPixelDensityValue > 234))
						TempFirst = "*";

					vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "\n" + TempFirst +
						"Pixel " + dtoa(TempLoopY,0) + " = " + dtoa(TempPixelDensityValue,1);

					if (vConfigurationData->vPixelsPerDetector == 128)
					{
						if ((TempLoopY == 1) || (TempLoopY == 127))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 1";

						if ((TempLoopY == 128) || (TempLoopY == 255))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 2";

						if ((TempLoopY == 256) || (TempLoopY == 383))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 3";

						if ((TempLoopY == 384) || (TempLoopY == 511))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 4";

						if ((TempLoopY == 512) || (TempLoopY == 639))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 5";

						if ((TempLoopY == 640) || (TempLoopY == 767))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 6";

						if ((TempLoopY == 127) || (TempLoopY == 255) || (TempLoopY == 383) || (TempLoopY == 511) || (TempLoopY == 639))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "\n---------------------------";
					}
					else //64 pixels per detector
					{
						if ((TempLoopY == 1) || (TempLoopY == 63))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 1";

						if ((TempLoopY == 64) || (TempLoopY == 127))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 2";

						if ((TempLoopY == 128) || (TempLoopY == 191))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 3";

						if ((TempLoopY == 192) || (TempLoopY == 255))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 4";

						if ((TempLoopY == 256) || (TempLoopY == 319))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 5";

						if ((TempLoopY == 320) || (TempLoopY == 383))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 6";

						if ((TempLoopY == 384) || (TempLoopY == 447))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 7";

						if ((TempLoopY == 448) || (TempLoopY == 511))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 8";

						if ((TempLoopY == 512) || (TempLoopY == 575))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 9";

						if ((TempLoopY == 576) || (TempLoopY == 639))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 10";

						if ((TempLoopY == 640) || (TempLoopY == 703))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 11";

						if ((TempLoopY == 704) || (TempLoopY == 767))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "    Detector 12";

						if ((TempLoopY == 63) || (TempLoopY == 127) || (TempLoopY == 191) || 
							(TempLoopY == 255) || (TempLoopY == 319) || (TempLoopY == 383) || (TempLoopY == 447) || (TempLoopY == 511) || 
							(TempLoopY == 575) || (TempLoopY == 639) || (TempLoopY == 703))
							vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "\n---------------------------";
					}
				}
				if (vConfigurationData->vScanTracType == cBriosoScanTrac)
					vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "\nFront detector\n\n\n";
				else
					vSystemData.vPixelValuesString = vSystemData.vPixelValuesString + "\n" + vGlobalTopString + " detector\n\n\n";
			}

			if (vSystemData.vDensityIndex < (cStandardDeviationSampleSize - 1))
				vSystemData.vDensityIndex++;
		}

		if (cNumberOfCalibrationImages == vSystemData.vCalibrationImageNumber)
		{ //have taken the cNumberOfCalibrationImages (20) images, so stop calibration mode
			EndMeasureSourceStrength(false);
		}
		else
		{ 
			int TimerResult = SetTimer(vSimulateOneContainerTimer,500,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx,32000);
		}
	}
}

void CScanTracDlg::ProcessCalibrateDetectorEdgeFrame()
{
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("STD-ProcessCalibrateDetectorEdgeFrame: " + dtoa(vSystemData.vCalibrationImageNumber,0),cDebugMessage);

	if ((vSystemData.vITIPCDig->vNextImageToDisplay) && (vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage))
	if ((vSystemData.vFindingProductBrightness) && (vSystemData.vITIPCDig->vShowOnlyRealImages))
	{
		double TempMinimumVoltage = 21;
		if (vConfigurationData->vHVPSType == cMNXHVPS)
			TempMinimumVoltage = 11;

		WORD TempBottom = 10;
		if (vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration)
			TempBottom = vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration;

		WORD TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfXRayDetectors - vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration;
		if (vConfigurationData->vNumberOfDetectorsToCalibrate)
			TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfDetectorsToCalibrate - vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration;
		WORD TempNumberOfPixels = TempNumberOfDetectorsToAdjustGain * vConfigurationData->vPixelsPerDetector - 8;

		//add up all the pixels in all the lines
		double TempSum = 0;
		BYTE *TempPointer = NULL;
		//add up all the pixels in all the lines except the first 4 and last 4 pixels 
		//in each line
		DWORD TempCount = 0;
		//for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vOriginalBufferSizeY; TempLoopY++)
		//{
		//	TempPointer = vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage + (TempLoopY * vSystemData.vITIPCDig->vOriginalBufferSizeX) + TempBottom;

		//	for (WORD TempLoopX = TempBottom; TempLoopX < TempNumberOfPixels; TempLoopX++)
		//	{
		//		if (*TempPointer)
		//		{
		//			TempSum = TempSum + *TempPointer;
		//			TempCount++;
		//		}
		//		TempPointer++;
		//	}
		//}
		for (WORD TempLoopDetector = vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector < vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration + TempNumberOfDetectorsToAdjustGain; TempLoopDetector++)
		for (WORD TempLoopX = 4; TempLoopX < vConfigurationData->vPixelsPerDetector - 4; TempLoopX++)
		if (TempLoopX + (TempLoopDetector * vConfigurationData->vPixelsPerDetector) > vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration)
		{
			TempPointer = vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage + (TempLoopDetector * vConfigurationData->vPixelsPerDetector) + TempLoopX;

			for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vOriginalBufferSizeY; TempLoopY++)
			{
				if (*TempPointer)
				{
					TempSum = TempSum + *TempPointer;
					TempCount++;
				}
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
			}
		}
		double TempDensityValue = 0;
		if (TempCount)
			TempDensityValue = TempSum / TempCount;
		bool TempMustWaitToFinishCalibratingPixels = false;

		if (TempDensityValue < 240) //image too dark
		{
			double TempMaximumCurrent = vConfigurationData->vMaximumCurrent;
			double TempMaxValue = GetMaximumCurrentFromVoltage(vGlobalCurrentProduct->vXRaySourceVoltage * 6);
			if (TempMaximumCurrent > TempMaxValue)
				TempMaximumCurrent = TempMaxValue;

			TempMaxValue = GetMaximumCurrentFromPower(vGlobalCurrentProduct->vXRaySourceVoltage * 6, vConfigurationData->vMaximumPower);
			if (TempMaximumCurrent > TempMaxValue)
				TempMaximumCurrent = TempMaxValue;

			if (vGlobalCurrentProduct->vXRaySourceCurrent + .01  < TempMaximumCurrent)
			{
				if (vSystemData.vFindingProductBrightness & 2) //already was too dark, now too bright
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent + .01);
				else
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent + .1);

				vSystemData.vFindingProductBrightness = vSystemData.vFindingProductBrightness | 4;

				if (vGlobalCurrentProduct->vXRaySourceCurrent > vConfigurationData->vMaximumCurrent)
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)vConfigurationData->vMaximumCurrent;

				vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;
				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

				ReportErrorMessage("Calibrate Pixels Too Dark (" + dtoa(TempDensityValue,2) + ") Increased Current to: " + 
					dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1),cWriteToLog,0);
/*
				if (PasswordOK(cTemporaryInspxPassword,false))
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = 
						"\n\n~Calibrate Pixels Product too Dark (" + dtoa(TempDensityValue,2) +
						")\n Increased Current to: " + dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1) +
						" and Trying Again";
					TempNoticeDialog.vAutoClose = 1500;
					TempNoticeDialog.vType = cNoticeMessage;
					TempNoticeDialog.DoModal();
				}
				*/
			}
			else
			if (vGlobalCurrentProduct->vXRaySourceVoltage + .01 < vConfigurationData->vMaximumVoltage / 6.0)
			{
				if (vSystemData.vFindingProductBrightness & 2) //already was too dark, now too bright
					vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vGlobalCurrentProduct->vXRaySourceVoltage + .01);
				else
					vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vGlobalCurrentProduct->vXRaySourceVoltage + .1);

				vSystemData.vFindingProductBrightness = vSystemData.vFindingProductBrightness | 4;

				if (vGlobalCurrentProduct->vXRaySourceVoltage > vConfigurationData->vMaximumVoltage / 6.0)
					vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vConfigurationData->vMaximumVoltage / 6.0);

				vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;

				double TempMaximumCurrent = vConfigurationData->vMaximumCurrent;
				double TempMaxValue = GetMaximumCurrentFromVoltage(vGlobalCurrentProduct->vXRaySourceVoltage * 6);
				if (TempMaximumCurrent > TempMaxValue)
					TempMaximumCurrent = TempMaxValue;

				TempMaxValue = GetMaximumCurrentFromPower(vGlobalCurrentProduct->vXRaySourceVoltage * 6, vConfigurationData->vMaximumPower);
				if (TempMaximumCurrent > TempMaxValue)
					TempMaximumCurrent = TempMaxValue;
				if (vGlobalCurrentProduct->vXRaySourceCurrent > TempMaximumCurrent)
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)TempMaximumCurrent;

				vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;

				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

				ReportErrorMessage("Calibrate Pixels Too Dark (" + dtoa(TempDensityValue,2) + ") Increased Voltage to: " + 
					dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,2),cWriteToLog,0);
/*
				if (PasswordOK(cTemporaryInspxPassword,false))
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = 
						"\n\n~Calibrate Pixels Product too Dark (" + dtoa(TempDensityValue,2) +
						")\n Increased Voltage to: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1) +
						" and Trying Again";
					TempNoticeDialog.vAutoClose = 1500;
					TempNoticeDialog.vType = cNoticeMessage;
					TempNoticeDialog.DoModal();
				}
				*/
			}
			else
			{
				ReportErrorMessage("Calibrate Pixels Too Dark (" + dtoa(TempDensityValue,2) + ") Maxed Out Current and Voltage",cWriteToLog,0);

				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\n~Calibrate Pixels Product too Dark (" + dtoa(TempDensityValue,2) +
					")\nIf results are not good, Increase Brightness by Calibrating Pixels Again with longer Integration Time";
				TempNoticeDialog.vType = cNoticeMessage;
				TempNoticeDialog.DoModal();

				vSystemData.vFindingProductBrightness = false;
			}
		}
		else
		if (TempDensityValue > 254.9) //image too bright
		{
			if (vGlobalCurrentProduct->vXRaySourceVoltage * 6 > TempMinimumVoltage)
			{
				if (vSystemData.vFindingProductBrightness & 4) //already was too dark, now too bright
					vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vGlobalCurrentProduct->vXRaySourceVoltage - .01);
				else
					vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vGlobalCurrentProduct->vXRaySourceVoltage - .1);

				vSystemData.vFindingProductBrightness = vSystemData.vFindingProductBrightness | 2;

				vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;
				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

				ReportErrorMessage("Calibrate Pixels Too Bright (" + dtoa(TempDensityValue,2) + ") Decreased Voltage to: " + 
					dtoa(vGlobalCurrentProduct->vXRaySourceVoltage,1),cWriteToLog,0);
				//ReportErrorMessage("Calibrate Pixels Too Bright (" + dtoa(TempDensityValue,2) + ")\nIf results are not good, Decrease Brightness by Calibrating Pixels Again with shorter Integration Time", cCritical, 0);
/*
				if (PasswordOK(cTemporaryInspxPassword,false))
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = 
						"\n\n~Calibrate Pixels Product too Bright (" + dtoa(TempDensityValue,2) +
						")\n Decreased Voltage to: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1) +
						" and Trying Again";
					TempNoticeDialog.vAutoClose = 1500;
					TempNoticeDialog.vType = cNoticeMessage;
					TempNoticeDialog.DoModal();
				}
				*/
			}
			else
			if (vGlobalCurrentProduct->vXRaySourceCurrent > .5)
			{
				if (vSystemData.vFindingProductBrightness & 4) //already was too dark, now too bright
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent - .01);
				else
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent - .1);

				vSystemData.vFindingProductBrightness = vSystemData.vFindingProductBrightness | 2;

				vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;
				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

				ReportErrorMessage("Calibrate Pixels Too Bright (" + dtoa(TempDensityValue,2) + ") Decreased Current to: " + 
					dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1),cWriteToLog,0);
/*
				if (PasswordOK(cTemporaryInspxPassword,false))
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = 
						"\n\n~Calibrate Pixels Product too Bright (" + dtoa(TempDensityValue,2) +
						")\n Decreased Current to: " + dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1) +
						" and Trying Again";
					TempNoticeDialog.vAutoClose = 1500;
					TempNoticeDialog.vType = cNoticeMessage;
					TempNoticeDialog.DoModal();
				}
				*/
			}
			else
			{
				ReportErrorMessage("Calibrate Pixels Too Bright (" + dtoa(TempDensityValue,2) + ") Maxed Out Current and Voltage",cWriteToLog,0);

				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\n~Calibrate Pixels Product too Bright (" + dtoa(TempDensityValue,2) + ")\nIf results are not good, Decrease Brightness, Calibrate Pixels Again";
				TempNoticeDialog.vType = cNoticeMessage;
				TempNoticeDialog.DoModal();

				vSystemData.vFindingProductBrightness = false;
			}
		}
		else
		{
			ReportErrorMessage("Calibrate Pixels, finished adjusting brightness", cWriteToLog, 0);

			if (vSystemData.vFindingProductBrightness & 6) //if adjusted brightness, up .1V
				vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent + .01);
			else
				vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent + .1);

			vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;
			//don't send now as just going to set current to zero to start calibrating.  SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

			vCalibrateCurrentStep = (double)vGlobalCurrentProduct->vXRaySourceCurrent / (double)cNumberOfCalibrationImages;
			vCalibrateCurrent = 0;
			vSystemData.vRampXRayCurrentAmount = vCalibrateCurrent;  //set product current to first step so will ramp to it

			if (vConfigurationData->vHVPSType == c100WMonoBlockHVPS) //100 w monoblock gave over current error if changed from 1ma to .15, so turn X-Rays off, then back on again at the new value
			{
				if (vGlobalDXMXRayPort)
					vGlobalDXMXRayPort->TurnOnOffXRays(false);
				vSystemData.vSourceRampedUp = false;
				ReportErrorMessage("100Watt MonoBlock, turn off X-Rays before Calibrate", cWriteToLog, 0);
				TempMustWaitToFinishCalibratingPixels = true;
			}
			vSystemData.vFindingProductBrightness = false;

			if (TempMustWaitToFinishCalibratingPixels)
			{
				int TimerResult = SetTimer(vWaitToCalibrateForXRaysToSettleTimer,5000,NULL);
				if (!TimerResult)
					ReportErrorMessage("Error-vWaitToCalibrateForXRaysToSettleTimer Timer Failed",cEMailInspx,32000);
			}
			else
			{
				ReportErrorMessage("Calibrate Pixels, set current to Zero to begin B", cWriteToLog, 0);
				SendSourceCurrentToUController(vSystemData.vRampXRayCurrentAmount);		
			}
			ReportErrorMessage("Calibrate Pixels Has Good Exposure " + dtoa(TempDensityValue,2),cWriteToLog,0);
		}
		if (!TempMustWaitToFinishCalibratingPixels)
		{
			int TimerResult = SetTimer(vSimulateOneContainerTimer,cCalibrateEdgesTimeInterval,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx,32000);
		}

		if (!vSystemData.vFindingProductBrightness)
		{ //done finding brightness, so use those settings for ~SizeExposure product
			CProduct *TempProduct = GetProductByName("~SizeExposure");
			if (TempProduct)
			{
				TempProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent * 1.5);
				TempProduct->vXRaySourceVoltage = vGlobalCurrentProduct->vXRaySourceVoltage;

				if (vConfigurationData->vMaximumCurrent < TempProduct->vXRaySourceCurrent)
					TempProduct->vXRaySourceCurrent = (float)vConfigurationData->vMaximumCurrent;

				if (vConfigurationData->vMaximumVoltage < TempProduct->vXRaySourceVoltage)
					TempProduct->vXRaySourceVoltage = (float)vConfigurationData->vMaximumVoltage;

			}
		}
	}
	else  //calibrating pixels
	{
		//take frame and output to a file
		vSystemData.vCalibrationImageNumber++;
		ReportErrorMessage("Calibrate Pixels, Step " + dtoa(vSystemData.vCalibrationImageNumber, 0), cWriteToLog, 0);
				CString TempString = "Calibrate Pixels";
		if (vSystemData.vApplyGainAndOffsetDuringCalibration)
			TempString = "Verify Pixels";
		TempString = TempString + " " + dtoa(vSystemData.vCalibrationImageNumber, 0);
		SetDlgItemText(IDC_Calibrating,TempString);

		OutputImageToFile();
		FillInAverageCalibrationImageLine();

		if (cNumberOfCalibrationImages == vSystemData.vCalibrationImageNumber)
		{ //have taken the cNumberOfCalibrationImages (20) images, so stop calibration mode
			//vGlobalCurrentProduct->vXRaySourceCurrent = vCalibrateProductCurrent;  //save product current in a temporary variable so can restore later
			SendXRayPowerOnOffToUController(0);
			StopImageAcquisition();
			vSystemData.vDigitalInputLine3Mask = 0x00;
			vSystemData.vCurrentBodyTriggerMask = 0;
			vSystemData.vSystemRunMode = cStoppedSystemMode;

			CalibrationModeDoneCalculateResults();
			EndCalibrateDetectorEdges(false);
		}
		else
		{  //Set source current 5% higher, and simulate another body trigger
			vCalibrateCurrent = vCalibrateCurrent + vCalibrateCurrentStep;
			vSystemData.vRampXRayCurrentAmount = vCalibrateCurrent;
			//Send X-Ray Current
			//if (vGlobalDXMXRayPort)
			//{
			//	SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount, vSystemData.vRampXRayCurrentAmount);
			//	vGlobalDXMXRayPort->TurnOnOffXRays(true);
			//}
			//else
				SendSourceCurrentToUController(vSystemData.vRampXRayCurrentAmount);		

			if (vSystemData.vCalibrationImageNumber == 0)
			{
				SendXRayPowerOnOffToUController(0);
				//for debugging
				//ReportErrorMessage("Calibrate Detectors Step 0 turn off x-rays", cError, 0);
			}
			double TempMinimumCurrent = .2;
			if (vGlobalDXMXRayPort)
				TempMinimumCurrent = vGlobalDXMXRayPort->vMinimumCurrent;

			if ((!vSystemData.vXRayOnNotice) && (vSystemData.vCalibrationImageNumber >= 2) && (vSystemData.vRampXRayCurrentAmount >= TempMinimumCurrent))
			{
				SendXRayPowerOnOffToUController(1);
				//for debugging
				//ReportErrorMessage("Calibrate Detectors Step " + dtoa(vSystemData.vCalibrationImageNumber, 0) + " turn on x-rays", cError, 0);
				Sleep(5000);
			}

			//testing only
			//ReportErrorMessage("Calibrate Pixels Voltage: " + dtoa(vSystemData.vRampXRayVoltageAmount * 6, 2) + ", Current: " + dtoa(vSystemData.vRampXRayCurrentAmount, 2),cAction,0);

			int TimerResult = SetTimer(vSimulateOneContainerTimer,cCalibrateEdgesTimeInterval,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx,32000);
		}
	}
}

void CScanTracDlg::FillInAverageCalibrationImageLine()
{
	if ((vSystemData.vITIPCDig->vOriginalImage) && (vSystemData.vITIPCDig->vOriginalImage->vGreyImage))
	if (vCalibrationAverageImage)
	{
		double *TempPointer;
		DWORD TempSum = 0;
		BYTE *TempSumPointer;
		TempPointer = vCalibrationAverageImage + 
			((vSystemData.vCalibrationImageNumber - 1) * vSystemData.vITIPCDig->vOriginalBufferSizeX);
		//for each pixel in the line scan array
		for (DWORD TempLoop = 0; TempLoop < vSystemData.vITIPCDig->vOriginalBufferSizeX; TempLoop++)
		{
			TempSum = 0;
			TempSumPointer = vSystemData.vITIPCDig->vOriginalImage->vGreyImage + TempLoop;
			//for each data point taken for this scan pixel
			for (WORD TempSumLoop = 0; TempSumLoop < vSystemData.vITIPCDig->vAquisitionSizeY; TempSumLoop++)
			{
				TempSum = TempSum + *TempSumPointer;
				TempSumPointer = TempSumPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
			}
			//put average of all data points taken on the line for this pixel into average image
			double TempResult = 1;

			if (!vSystemData.vITIPCDig->vAquisitionSizeY)
				ReportErrorMessage("Error-vSystemData.vITIPCDig->vAquisitionSizeY = 0, would cause crash", cEMailInspx, 32000);
			else
				TempResult = (double)TempSum / (double)vSystemData.vITIPCDig->vAquisitionSizeY;
			*TempPointer = TempResult;
			TempPointer++;
		}
	}
}

void CScanTracDlg::CalibrationModeDoneCalculateResults()  //calibrate edges and Pixels
{
	WORD TempNumberOfBadPixels = 0;
	//calculate YMin and other values
	ReportErrorMessage("Start Calculate Calibrate Edge Pixels ", cAction, 0);
	if (vCalibrationAverageImage)
	{
		BYTE *TempLineDataPoints = (BYTE *)malloc(20);
		if (vUpdateGainAndOffsetConfiguration)
		for (DWORD TempLoop = 0; TempLoop < cNumberOfPixelsToAdjustAllPixels1152; TempLoop++)
		{
			vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 0;
			vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 0;
		}

		//for each pixel in the line scan array
		double TempStandardGain = 0;
		double TempGainAdjustStep = 0;
		double TempStandardOffset = 0;
		double TempCalculatedGain[cNumberOfPixelsToAdjustAllPixels1152 + 10];
		double TempGainAdjust[cNumberOfPixelsToAdjustAllPixels1152 + 10];
		double TempCalculatedOffset[cNumberOfPixelsToAdjustAllPixels1152 + 10];
		double TempOffsetAdjust[cNumberOfPixelsToAdjustAllPixels1152 + 10];
		double *TempPointer = NULL;
		double *TempPreviousPointPointer = NULL;
		//double *TempPrevious2PointPointer = NULL;
		double *TempExtraPointer = NULL;
		double TempGainResult = 0;
		double TempOffsetResult = 0;

		for (WORD TempLoop = 0; TempLoop < cNumberOfPixelsToAdjustAllPixels1152; TempLoop++)
		{
			TempCalculatedGain[TempLoop] = 0;
			TempGainAdjust[TempLoop] = 0;
			TempCalculatedOffset[TempLoop] = 0;
			TempOffsetAdjust[TempLoop] = 0;
		}
		//for each complete scan of the detector array, look at each pixel
		CInspection *TempCurveFitInspection;
		TempCurveFitInspection = new CInspection;
		if (TempCurveFitInspection)
		{
			for (WORD TempLoop = 0; TempLoop < vSystemData.vITIPCDig->vOriginalBufferSizeX; TempLoop++)
			{
				//ReportErrorMessage("Calculate Calibrate Edge Pixels: " + dtoa(TempLoop, 0), cAction, 0);
				double TempXMin = 0;
				double TempXMin1 = 0;
				//double TempXMin2 = 0;
				double TempYMin = 0xFF;
				double TempYMin1 = 0;
				//double TempYMin2 = 0;
				double TempXMax = 0;
				double TempXMax1 = 0;
				//double TempXMax2 = 0;
				double TempYMax = 0;
				double TempYMax1 = 0;
				BYTE TempSumStart = 3;
				if (vConfigurationData->vHVPSType == c100WMonoBlockHVPS) //100 w monoblock minimum current is .15, so ignore bottom 4 values as may not have real data
					TempSumStart = 4;
					
				TempSumStart = 5;
				//double TempYMax2 = 0;
				//point to starting pixel of each scan line
				TempPointer = vCalibrationAverageImage + TempLoop;
				TempPreviousPointPointer = vCalibrationAverageImage + TempLoop;
				//TempPrevious2PointPointer = vCalibrationAverageImage + TempLoop;
				//for each data point taken for this scan pixel in the 20 images
				for (DWORD TempSumLoop = 0; TempSumLoop < cNumberOfCalibrationImages; TempSumLoop++)
				if (TempPointer + (40 * 8) > vCalibrationAverageImageMaximum)
				{
					ReportErrorMessage("Calibrate Pixel Pointer Overflow", cEMailInspx, 32000);
				}
				else
				{
					//edge and pixel linearization calculations
					if (TempSumLoop >= TempSumStart) //3 gave good results
						if (*TempPointer > 25)  //was 15
							if (*TempPointer < TempYMin)//find the minimum intensity of the averages that is more than 15
							{
								TempYMin = *TempPointer;  //save the minimum intensity
								TempExtraPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
								TempYMin1 = *TempExtraPointer; //find the next value up from the minimum intensity
								//TempExtraPointer = TempExtraPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
								//TempYMin2 = *TempExtraPointer; //find the value 2 up from the minimum intensity

								TempXMin = (BYTE)TempSumLoop + 0; //record which image number minimum intensity at
								TempXMin1 = (BYTE)TempSumLoop + 1;//record which image number next up from minimum intensity at
								//TempXMin2 = (BYTE)TempSumLoop + 3;//record which image number is 2 up from minimum intensity at
							}
					//if (TempSumLoop <= 10)
					if (TempSumLoop <= 18) //10 gave good results, was 17
					if (TempSumLoop > TempSumStart)
					if (*TempPointer < 240)//was 240  
					if (*TempPointer > TempYMax)
					{
						TempYMax = *TempPointer;//save the maximum average pixel intensity below 255
						TempYMax1 = *TempPreviousPointPointer; //save the value below the maximum pixel intensity
						//TempYMax2 = *TempPrevious2PointPointer; //save the value below the maximum pixel intensity
						TempXMax = (BYTE)TempSumLoop + 0; //save which image was maximum value at
						TempXMax1 = (BYTE)TempSumLoop - 1; //save which image number was before maximum average intensity
						//TempXMax2 = (BYTE)TempSumLoop - 1; //save which image number was before maximum average intensity
					}
					//TempPrevious2PointPointer = TempPreviousPointPointer;
					TempPreviousPointPointer = TempPointer;
					//check this pixel point in next image
					TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				}
				if ((TempYMin == 255) || (TempYMax == 0)) // if line was saturated or black entire time
				{
					TempYMin = 0;
					TempXMin = 1;
					TempXMin1 = 2;
					//TempXMin2 = 3;
					TempXMax = cNumberOfCalibrationImages;
					TempXMax1 = cNumberOfCalibrationImages - 1;
					//TempXMax2 = cNumberOfCalibrationImages - 2;
				}

				//save intermediate math step data for this pixel in the average array to write to file
				//Minimum Intensity, Next greater than minimum intensity, Image # of Minimum Intensity,
				//Next Greater Image # than Minimum Intensity,Value before Maximum Image Intensity, 
				//Maximum Image Intensity, Image # of value before maximum intensity, 
				//Image # of maximum intensity, Minimum Intensity used, Maximum Intensity Used,
				//Image # of Minimum Intensity used, Image # of Maximum Intensity used,
				//Calculated gain of this pixel, calculated offset of this pixel
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempYMin;
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempYMin1;

				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempXMin;
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempXMin1;

				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempYMax;
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempYMax1;

				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempXMax;
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempXMax1;

				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				/*
							double TempYLow = (double)(TempYMin1 + TempYMin) / 2.0;
							*TempPointer = TempYLow;
							TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
							double TempYHigh = (double)(TempYMax1 + TempYMax) / 2.0;
							*TempPointer = TempYHigh;
							TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
							double TempXLow = (double)(TempXMin1 + TempXMin) / 2.0;
							*TempPointer = TempXLow;
							TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
							double TempXHigh = (double)(TempXMax1 + TempXMax) / 2.0;
							*TempPointer = TempXHigh;
							TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
							*/

				double TempYLow = (double)TempYMin;  //pick final low value used
				if (vGlobalMonoBlockXRayPort) //on XRB210W monoblock ignore min as cant take min
					TempYLow = TempYMin1;

				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempYLow;//save low value used in table
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				double TempYHigh = TempYMax; //pick final high value used
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempYHigh; //save have 
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				double TempXLow = (double)TempXMin; //pick final low value used
				if (vGlobalMonoBlockXRayPort) //on XRB210W monoblock ignore min as cant take min
					TempXLow = TempXMin1;

				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempXLow; //save low value used in table

				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				double TempXHigh = (double)TempXMax;
				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempXHigh;
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				//for testing
				//ReportErrorMessage("Calc Pix X: " + dtoa(TempXLow,2) + ", " + dtoa(TempXHigh,2) + " Y: " + dtoa(TempYLow,2) + ", " + dtoa(TempYHigh,2), cAction, 0);

				//convert the X units from steps to units of X-Ray Current
				//TempXLow = vGlobalCurrentProduct->vXRaySourceCurrent * TempXLow / 20;
				//TempXHigh = vGlobalCurrentProduct->vXRaySourceCurrent * TempXHigh / 20;

				//for testing
				//ReportErrorMessage("Cal Pix X: " + dtoa(TempXLow,2) + ", " + dtoa(TempXHigh,2) + " Y: " + dtoa(TempYLow,2) + ", " + dtoa(TempYHigh,2), cAction, 0);

				if ((TempXHigh - TempXLow) != 0)
					TempCalculatedGain[TempLoop] = (TempYHigh - TempYLow) / (TempXHigh - TempXLow);

				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempCalculatedGain[TempLoop];

				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				TempCalculatedOffset[TempLoop] = TempYLow - ((TempXLow)* TempCalculatedGain[TempLoop]);

				if (TempPointer >= vCalibrationAverageImageMaximum)
					ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
				else
					*TempPointer = TempCalculatedOffset[TempLoop];
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				//curve fitting in here to find the line to fit

				if (TempLineDataPoints)
				{
					BYTE *TempLineDataPointsPointer = TempLineDataPoints;
					BYTE TempTop = (BYTE)(TempXHigh);
					BYTE TempBottom = (BYTE)(TempXLow);
					if (TempTop > 20)
					{
						ReportErrorMessage("Calibrate Pixel: " + dtoa(TempLoop, 0) + " Top > 20. Top: " + dtoa(TempTop, 0), cWriteToLog, 32000);
						*TempPointer = 0;
						TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
						*TempPointer = 0;
						TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
					}
					else
					if (TempBottom + 4 >= TempTop)
					{
						ReportErrorMessage("Calibrate Pixel: " + dtoa(TempLoop, 0) + " Bottom >= Top. Bottom, Top: " + dtoa(TempBottom, 0) + ", " + dtoa(TempTop, 0), cWriteToLog, 32000);
						*TempPointer = 0;
						TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
						*TempPointer = 0;
						TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
					}
					else
					{
						BYTE TempNumberOfCurveFitPoints = (BYTE)(TempXHigh - TempXLow + 1);
						double *TempCurveDataPointer = vCalibrationAverageImage + (DWORD)(TempLoop + ((TempXLow - 1) * vSystemData.vITIPCDig->vOriginalBufferSizeX));
						for (BYTE TempCurveDataLoop = (BYTE)(TempXLow); TempCurveDataLoop <= (BYTE)(TempXHigh); TempCurveDataLoop++)
						{
							*TempLineDataPointsPointer++ = (BYTE)(*TempCurveDataPointer);
							TempCurveDataPointer = TempCurveDataPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
						}

						tCurveFitAnalysisData vCurveFitAnalysisData;
						double vStartTime = CIFCOS::GetSystimeMicrosecs();
						vCurveFitAnalysisData.vTime = 0;
						vCurveFitAnalysisData.vCallsToSquare = 0;
						vCurveFitAnalysisData.vMainCalls = 0;
						vCurveFitAnalysisData.vNumberOfPointsToPlot = 0;
						for (BYTE TempLoopI = 0; TempLoopI < 10; TempLoopI++)
							vCurveFitAnalysisData.vTerms[TempLoopI] = 1;
						vCurveFitAnalysisData.vTerms[1] = 10;
						vCurveFitAnalysisData.vTerminationReason = -1;
						vCurveFitAnalysisData.vFNorm = 0;

						TempCurveFitInspection->ReturnCurveFitLine(TempLineDataPoints, TempNumberOfCurveFitPoints, &vCurveFitAnalysisData, 2);  // use 2 terms to fit line
						double vEndTime = CIFCOS::GetSystimeMicrosecs();
						vCurveFitAnalysisData.vTime = vEndTime - vStartTime;

						TempCalculatedGain[TempLoop] = vCurveFitAnalysisData.vTerms[1];  //curve fit term 1 is gain
						if (TempPointer >= vCalibrationAverageImageMaximum)
							ReportErrorMessage("Calibrate Pixel Pointer Overflow B", cEMailInspx, 32000);
						else
							*TempPointer = vCurveFitAnalysisData.vTerms[1];  //curve fit term 1 is gain
						TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

						TempCalculatedOffset[TempLoop] = vCurveFitAnalysisData.vTerms[0] - ((TempXLow - 1) * vCurveFitAnalysisData.vTerms[1]);//Term 0 is offset, but must correct for our offset
						if (TempPointer >= vCalibrationAverageImageMaximum)
							ReportErrorMessage("Calibrate Pixel Pointer Overflow A", cEMailInspx, 32000);
						else
							*TempPointer = vCurveFitAnalysisData.vTerms[0] - ((TempXLow - 1) * vCurveFitAnalysisData.vTerms[1]);//Term 0 is offset, but must correct for our offset
						TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
					}
				}

				// test only
				/*
				if (TempLoop == 32)
				//	if ((TempCalculatedGain[TempLoop] > 2.5) || (TempCalculatedGain[TempLoop] < .25) ||
				//	(TempCalculatedOffset[TempLoop] > 52) || (TempCalculatedOffset[TempLoop] < -52))
				{
				ReportErrorMessage("Pixel: " + dtoa(TempLoop,0) + " Gain: " + dtoa(TempCalculatedGain[TempLoop],2) + " Offset: " + dtoa(TempCalculatedOffset[TempLoop],1),cEMailInspx, 32000);

				ReportErrorMessage("Gain = (" + dtoa(TempYHigh,1) + " - " + dtoa(TempYLow,1) + ") / (" + dtoa(TempXHigh,1) + " - " + dtoa(TempXLow,1) + ")",cEMailInspx, 32000);
				ReportErrorMessage("Offset = " + dtoa(TempYLow,1) + " - ((" + dtoa(TempXLow,1) + " - 1) * " + dtoa(TempCalculatedGain[TempLoop],1) + ")",cEMailInspx, 32000);

				ReportErrorMessage("TempYMin: " + dtoa(TempYMin,1),cEMailInspx, 32000);
				ReportErrorMessage("TempYMin1: " + dtoa(TempYMin1,1),cEMailInspx, 32000);
				ReportErrorMessage("TempYMin2: " + dtoa(TempYMin2,1),cEMailInspx, 32000);
				ReportErrorMessage("TempXMin: " + dtoa(TempXMin,1),cEMailInspx, 32000);
				ReportErrorMessage("TempXMin1: " + dtoa(TempXMin1,1),cEMailInspx, 32000);
				ReportErrorMessage("TempXMin2: " + dtoa(TempXMin2,1),cEMailInspx, 32000);
				ReportErrorMessage("TempYMax2: " + dtoa(TempYMax2,1),cEMailInspx, 32000);
				ReportErrorMessage("TempYMax1: " + dtoa(TempYMax1,1),cEMailInspx, 32000);
				ReportErrorMessage("TempYMax: " + dtoa(TempYMax,1),cEMailInspx, 32000);
				ReportErrorMessage("TempXMax2: " + dtoa(TempXMax2,1),cEMailInspx, 32000);
				ReportErrorMessage("TempXMax1: " + dtoa(TempXMax1,1),cEMailInspx, 32000);
				ReportErrorMessage("TempXMax: " + dtoa(TempXMax,1),cEMailInspx, 32000);
				}
				*/
			} // end of loop for every pixel in linear scan array
			//ReportErrorMessage("Calculate Calibrate Edge Pixels-Calculated gains and offsets done", cAction, 0);
			delete TempCurveFitInspection;
		}
		if (vConfigurationData->vCorrectDetectorEdges == 1)
		{//correct only edge pixels
			for (WORD TempLoop = 1; TempLoop < vSystemData.vITIPCDig->vOriginalBufferSizeX; TempLoop++)
			{
				if (vUpdateGainAndOffsetConfiguration)
				{
					if (TempLoop == (WORD)(vSystemData.vITIPCDig->vOriginalBufferSizeX - 1))
					{//correct just the top edge of this detector because top detector
						//set gain adjust to try to get it to the 4th pixel downs gain
						TempStandardGain = ((TempCalculatedGain[TempLoop - 4] + TempCalculatedGain[TempLoop - 3]) / 2);

						if (TempCalculatedGain[TempLoop - 2] != 0)
							TempGainAdjust[TempLoop - 2] = TempStandardGain / TempCalculatedGain[TempLoop - 2];

						if (TempCalculatedGain[TempLoop - 1] != 0)
							TempGainAdjust[TempLoop - 1] = TempStandardGain / TempCalculatedGain[TempLoop - 1];

						if (TempCalculatedGain[TempLoop] != 0)
							TempGainAdjust[TempLoop] = TempStandardGain / TempCalculatedGain[TempLoop];

						TempOffsetAdjust[TempLoop - 2] = -TempCalculatedOffset[TempLoop - 2];
						TempOffsetAdjust[TempLoop - 1] = -TempCalculatedOffset[TempLoop - 1];
						TempOffsetAdjust[TempLoop] = -TempCalculatedOffset[TempLoop];
					} //end of top pixel loop
					else
					if ((TempLoop == 63) || (TempLoop == 127) || (TempLoop == 191) || 
						(TempLoop == 255) || (TempLoop == 319) || (TempLoop == 383))
					{
						//if ((TempCalculatedGain[TempLoop + 4] > (TempCalculatedGain[TempLoop - 3] / 2)) &&
						//	(TempCalculatedGain[TempLoop + 4] < (TempCalculatedGain[TempLoop - 3] * 1.5)))
						{ //if the gains are within 1.5 times of each other, continue to adjust gains
							{ //correct both top of this detector and bottom of next detector up
								/*
								double TempReferenceGain = TempCalculatedGain[TempLoop - 3];

								TempGainAdjustStep = (TempCalculatedGain[TempLoop + 4] - 
									TempCalculatedGain[TempLoop - 3]) / 7;
									*/

								double TempReferenceGain = TempCalculatedGain[TempLoop - 6];

								if (TempLoop + 7 < vSystemData.vITIPCDig->vOriginalBufferSizeX)
								TempGainAdjustStep = (TempCalculatedGain[TempLoop + 7] - TempCalculatedGain[TempLoop - 6]) / 7;

								//adjust gain for top edge of this detector
								TempStandardGain = TempReferenceGain + TempGainAdjustStep;
								if (TempCalculatedGain[TempLoop - 2] != 0)
									TempGainAdjust[TempLoop - 2] = TempStandardGain / TempCalculatedGain[TempLoop - 2];

								TempStandardGain = TempReferenceGain + (2 * TempGainAdjustStep);
								if (TempCalculatedGain[TempLoop - 1] != 0)
									TempGainAdjust[TempLoop - 1] = TempStandardGain / TempCalculatedGain[TempLoop - 1];

								TempStandardGain = TempReferenceGain + (3 * TempGainAdjustStep);
								if (TempCalculatedGain[TempLoop] != 0)
									TempGainAdjust[TempLoop] = TempStandardGain / TempCalculatedGain[TempLoop];

								//adjust bottom edge of next detector up
								TempStandardGain = TempReferenceGain + (4 * TempGainAdjustStep);
								if (TempLoop + 1 < vSystemData.vITIPCDig->vOriginalBufferSizeX)
								if (TempCalculatedGain[TempLoop + 1] != 0)
									TempGainAdjust[TempLoop + 1] = TempStandardGain / TempCalculatedGain[TempLoop + 1];

								TempStandardGain = TempReferenceGain + (5 * TempGainAdjustStep);
								if (TempLoop + 2 < vSystemData.vITIPCDig->vOriginalBufferSizeX)
								if (TempCalculatedGain[TempLoop + 2] != 0)
									TempGainAdjust[TempLoop + 2] = TempStandardGain / TempCalculatedGain[TempLoop + 2];

								TempStandardGain = TempReferenceGain + (6 * TempGainAdjustStep);
								if (TempLoop + 3 < vSystemData.vITIPCDig->vOriginalBufferSizeX)
								if (TempCalculatedGain[TempLoop + 3] != 0)
									TempGainAdjust[TempLoop + 3] = TempStandardGain / TempCalculatedGain[TempLoop + 3];

								//adjust offset for top edge of this detector
								if (TempLoop > 1)
									TempOffsetAdjust[TempLoop - 2] = -TempCalculatedOffset[TempLoop - 2];
								if (TempLoop > 1)
									TempOffsetAdjust[TempLoop - 1] = -TempCalculatedOffset[TempLoop - 1];
								TempOffsetAdjust[TempLoop] = -TempCalculatedOffset[TempLoop];

								//adjust offset for bottom edge of next detector up
								if (TempLoop + 1 < vSystemData.vITIPCDig->vOriginalBufferSizeX)
									TempOffsetAdjust[TempLoop + 1] = -TempCalculatedOffset[TempLoop + 1];
								if (TempLoop + 2 < vSystemData.vITIPCDig->vOriginalBufferSizeX)
									TempOffsetAdjust[TempLoop + 2] = -TempCalculatedOffset[TempLoop + 2];
								if (TempLoop + 3 < vSystemData.vITIPCDig->vOriginalBufferSizeX)
									TempOffsetAdjust[TempLoop + 3] = -TempCalculatedOffset[TempLoop + 3];
							}
						}
					}
					if (TempLoop == 4)
					{
						//if ((TempCalculatedGain[TempLoop + 4] > (TempCalculatedGain[TempLoop - 3] / 2)) &&
						//	(TempCalculatedGain[TempLoop + 4] < (TempCalculatedGain[TempLoop - 3] * 1.5)))
						{
							TempStandardGain = ((TempCalculatedGain[TempLoop - 1] + TempCalculatedGain[TempLoop]) / 2);

							if (TempCalculatedGain[TempLoop - 4] != 0)
								TempGainAdjust[TempLoop - 4] = TempStandardGain / TempCalculatedGain[TempLoop - 4];

							if (TempCalculatedGain[TempLoop - 3] != 0)
								TempGainAdjust[TempLoop - 3] = TempStandardGain / TempCalculatedGain[TempLoop - 3];

							if (TempCalculatedGain[TempLoop - 2] != 0)
								TempGainAdjust[TempLoop - 2] = TempStandardGain / TempCalculatedGain[TempLoop - 2];

							TempOffsetAdjust[TempLoop - 4] = -TempCalculatedOffset[TempLoop - 4];
							TempOffsetAdjust[TempLoop - 3] = -TempCalculatedOffset[TempLoop - 3];
							TempOffsetAdjust[TempLoop - 2] = -TempCalculatedOffset[TempLoop - 2];
						}
					}
				}  //end of entering gain and offset correction factors
			} // end of loop for every pixel in linear scan array

			WORD TempNumberOfPixelsToAdjust = vSystemData.vITIPCDig->vOriginalBufferSizeX;
				//cNumberOfEdgePixelsToAdjust * 2 * 
				//vConfigurationData->vNumberOfXRayDetectors;
			if (vUpdateGainAndOffsetConfiguration)
			for (DWORD TempLoop = 0; TempLoop < TempNumberOfPixelsToAdjust; TempLoop++)
			{
				vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = TempGainAdjust[TempLoop];
				vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = TempOffsetAdjust[TempLoop];

				if (vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] > 2.5)
					vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 2.5;

				if ((vConfigurationData->vUseXScanDetectors) && (vConfigurationData->vScanTracType != cForteScanTrac) && (vConfigurationData->vScanTracType != cCaseInspectorScanTrac))
				{
					if (vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] == 0)
						ReportErrorMessage("Notice, X-Scan detector offset is zero", cEMailInspx, 32000);
				}
				else
				{
					if (vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] < .25)
						vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = .25;
				}

				if (vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] > 52)
					vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 0;

				if (vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] < -52)
					vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 0;
			}
			if (vUpdateGainAndOffsetConfiguration)
			{
				ReportErrorMessage("Calibrate Edge Pixels complete. IT: " + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3) + " KV: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cEMailInspx, 32000);
				ReportErrorMessage("Calibrate Edge Pixels complete. IT: " + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3) + " KV: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cAction,0);
			}
			else
			{
				ReportErrorMessage("Verify Edge Pixels complete. IT: " + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3) + " KV: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cAction,0);
			}
		} //end of algorith for correcting only edge pixels
		else
		{  //correcting all pixels, or no pixels
			//TempIndex is which pixel to use as the reference pixel to match all other pixels
			//to its gain.  It must be a good, functioning pixel
			WORD TempIndex = vConfigurationData->vPixelsPerDetector / 2;

			//if the pixel to use as the gain reference is below the conveyor, 
			//select one in next detector
			BYTE TempDetectorToUse = 0;
			while (vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration >= TempIndex)
				TempIndex = (vConfigurationData->vPixelsPerDetector / 2) + (vConfigurationData->vPixelsPerDetector * TempDetectorToUse++);

			TempStandardGain = TempCalculatedGain[TempIndex];

			//ReportErrorMessage("Standard Pixel: " + dtoa(TempIndex,0) + " Gain: " + dtoa(TempStandardGain,2) + " Offset: 0",cEMailInspx, 32000);

			WORD TempNumberOfPixelsToCorrect = vSystemData.vITIPCDig->vOriginalBufferSizeX;
			if (vConfigurationData->vNumberOfDetectorsToCalibrate)
			{
				TempNumberOfPixelsToCorrect = vConfigurationData->vNumberOfDetectorsToCalibrate * vConfigurationData->vPixelsPerDetector;
			}

			vNumberOfBadPixels = 0;
			for (WORD TempLoop = 0; TempLoop < vSystemData.vITIPCDig->vOriginalBufferSizeX; TempLoop++)
			{
				TempGainResult = 1;
				if (TempCalculatedGain[TempLoop] != 0)
					TempGainResult = TempStandardGain / TempCalculatedGain[TempLoop];

				TempPointer = vCalibrationAverageImage + TempLoop + (36 * vSystemData.vITIPCDig->vOriginalBufferSizeX);  //was 34

				*TempPointer = vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors];//previous gain adjust factor
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				*TempPointer = TempGainResult;
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				if (vUpdateGainAndOffsetConfiguration)
					vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = TempGainResult;
					
				TempOffsetResult = -TempCalculatedOffset[TempLoop];

				*TempPointer = vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors]; //previous offset adjust factor
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				*TempPointer = TempOffsetResult;
				TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				if (vUpdateGainAndOffsetConfiguration)
				{
					vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = TempOffsetResult;

					if (vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] > 2.5)
					{
						if ((TempLoop >= TempNumberOfPixelsToCorrect) || (TempLoop <= vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration))
							vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 1;
						else
						{
							vNumberOfBadPixels++;
							ReportErrorMessage("Calibrate Detector Pixel: " + dtoa(TempLoop,0) + " Gain: " + dtoa(vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors],2) + " too high, set to 2.5",cEMailInspx, 32000);
							vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 2.5;
						}
					}
					if (vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] < 0.25)
					{
						if ((TempLoop >= TempNumberOfPixelsToCorrect) || (TempLoop <= vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration))
							vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 1;
						else
						{
							vNumberOfBadPixels++;
							ReportErrorMessage("Calibrate Detector Pixel: " + dtoa(TempLoop,0) + " Gain: " + dtoa(vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors],2) + " too low, set to .25",cEMailInspx, 32000);
							vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 0.25;
						}
					}
					if (vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] > 52)
					{
						if ((TempLoop >= TempNumberOfPixelsToCorrect) || (TempLoop <= vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration))
							vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 0;
						else
						{
							if ((vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] != 2.5) && 
								(vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] != 0.25))
								vNumberOfBadPixels++;
							ReportErrorMessage("Calibrate Detector Pixel: " + dtoa(TempLoop,0) + " Offset: " + dtoa(vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors],2) + " too high, set to 52",cEMailInspx, 32000);
							vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 52;
						}
					}
					if (vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] < -52)
					{
						if ((TempLoop >= TempNumberOfPixelsToCorrect) || (TempLoop <= vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration))
							vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = 0;
						else
						{
							if ((vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] != 2.5) && (vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] != 0.25))
								vNumberOfBadPixels++;
							vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = -52;
							ReportErrorMessage("Calibrate Detector Pixel: " + dtoa(TempLoop,0) + " Offset: " + dtoa(vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors],2) + " too low, set to -52",cEMailInspx, 32000);
						}
					}
				}
			}
			if (vUpdateGainAndOffsetConfiguration)
			{
				CString TempTextX = " ";
				if (vConfigurationData->vUseXScanDetectors)
				{
					if ((vConfigurationData->vPixelsPerDetector == 64) && (vConfigurationData->vDetectorLength == 2))
						TempTextX = " @ .8mm ";
					else
					if ((vConfigurationData->vPixelsPerDetector == 128) && (vConfigurationData->vDetectorLength == 2))
						TempTextX = " @ .4mm ";
					else
					if ((vConfigurationData->vPixelsPerDetector == 64) && (vConfigurationData->vDetectorLength == 4))
						TempTextX = " @ 1.6mm ";
				}

				ReportErrorMessage("Calibrate All Pixels" + TempTextX + "complete. IT: " + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3) + " KV: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cEMailInspx, 32000);
				ReportErrorMessage("Calibrate All Pixels" + TempTextX + "complete. IT: " + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3) + " KV: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cUserChanges,0);
				if (vNumberOfBadPixels > 1)
					ReportErrorMessage(dtoa(vNumberOfBadPixels) + " Pixels have calibrate factors out of acceptable range",cEMailInspx,0);

				//mark all products that they need to be calibrated
				CProduct *TempProductPointer = NULL;

				ReportErrorMessage("Mark all Products for re-learn.  Calibrated Detectors", cAction,0);

				int TempNumberOfProducts = vProductCollection.GetSize();
				if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac))
				for (WORD TempLoop = 1; TempLoop <= TempNumberOfProducts; TempLoop++)
				{
					TempProductPointer = GetProductByNumber(TempLoop);
					if (TempProductPointer)
					{
						CString TempName = *TempProductPointer->GetProductName();
						int TempPosition = TempName.Find(_T("~"), 0);
						if (TempPosition < 0) //did not find "~" so not an Inspx Product, so mark it 
							TempProductPointer->vNeedToRelearn = 1;
					}
				}
			}
			else
			{
				CString TempTextX = " ";
				if (vConfigurationData->vUseXScanDetectors)
				{
					if ((vConfigurationData->vPixelsPerDetector == 64) && (vConfigurationData->vDetectorLength == 2))
						TempTextX = " @ .8mm ";
					else
					if ((vConfigurationData->vPixelsPerDetector == 128) && (vConfigurationData->vDetectorLength == 2))
						TempTextX = " @ .4mm ";
					else
					if ((vConfigurationData->vPixelsPerDetector == 64) && (vConfigurationData->vDetectorLength == 4))
						TempTextX = " @ 1.6mm ";
				}

				ReportErrorMessage("Verify All Pixels" + TempTextX + "complete. IT: " + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3) + " KV: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cAction,0);
			}
		}

		if (!vUpdateGainAndOffsetConfiguration)
		{ //Verifying, so display data on how it turned out
			BYTE TempPixelToStartAt = 20;
			BYTE TempPixelToEndAt = 20;

			if (vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration > TempPixelToStartAt)
			{
				TempPixelToStartAt = 10 + vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration;
				TempPixelToEndAt = TempPixelToStartAt + 10;
			}

			BYTE TempFrameToCompare = 8;
			//find average of center pixels in bottom detector to compare how each pixel did to the average
			//bool TempAverageValuesAllZero = true;
			//look at 8th image data should be in gray region
			//start at pixel 20 as may have conveyor at bottom of image, and ignore top 20 pixels
			double *TempSource = (vCalibrationAverageImage + TempPixelToStartAt + (TempFrameToCompare * vSystemData.vITIPCDig->vOriginalBufferSizeX));  

			int TempSize = TempPixelToEndAt - TempPixelToStartAt;
			double TempAverage = 0;
			double TempStandardDeviation = 0;
			if (TempSize > 3)
				TempStandardDeviation = CalculateStandardDeviation(TempSource, TempSize, &TempAverage);

			if (TempAverage)
			{
				double TempMinus1 = TempAverage - 2.5;
				double TempPlus1 = TempAverage + 2.5;
				double TempMinimumOK = TempAverage - 5.0;
				double TempMaximumOK = TempAverage + 5.0;

				CString TempString = "Pixel Linearization Verification Results";
				if (vConfigurationData->vCorrectDetectorEdges == 1)
				{
					TempString = TempString + "\nCorrecting Only Edge Pixels";
				}
				else
				if (vConfigurationData->vCorrectDetectorEdges == 2)
				{
					CString TempString = " In All Detectors";
					if (vConfigurationData->vNumberOfDetectorsToCalibrate)
							TempString = " In Lower " + dtoa(vConfigurationData->vNumberOfDetectorsToCalibrate,0) + " Detectors";
					TempString = TempString + "\nCorrecting All Pixels" + TempString;
				}
				else
				{
					TempString = TempString + "\nNot Correcting Any Pixels";
				}
				TempString = TempString + "\nAverage = " + dtoa(TempAverage,4) +
					", Standard Deviation = " + dtoa(TempStandardDeviation,4) +
					"\nPixel #, Pixel Value, (Difference), Gain Adjust, Offset Adjust";

					TempString = TempString + "\n" + vGlobalBottomString + " of Image";

				TempSource = (vCalibrationAverageImage + (TempFrameToCompare * vSystemData.vITIPCDig->vOriginalBufferSizeX));
				TempSource++;  //skip first pixel since a frame b frame indicator

				WORD TempNumberOfPixelsToCorrect = vSystemData.vITIPCDig->vOriginalBufferSizeX;
				if (vConfigurationData->vNumberOfDetectorsToCalibrate)
				{
					TempNumberOfPixelsToCorrect = vConfigurationData->vNumberOfDetectorsToCalibrate * vConfigurationData->vPixelsPerDetector;
				}
				vNumberOfBadPixels = 0;
				for (WORD TempLoop = 1; TempLoop < TempNumberOfPixelsToCorrect; TempLoop++)
				{
					if ((*TempSource - TempAverage < -10) || (*TempSource - TempAverage > 10))
					if (TempLoop > 1)
					if (TempLoop > vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration)
					if (TempLoop < TempNumberOfPixelsToCorrect)
						vNumberOfBadPixels++;

					TempString = TempString + "\n";
					if (*TempSource > TempMaximumOK)
						TempString = TempString + "*+";
					else
					if (*TempSource < TempMinimumOK)
						TempString = TempString + "*--";
					else
					if (*TempSource > TempPlus1)
						TempString = TempString + "+  ";
					else
					if (*TempSource < TempMinus1)
						TempString = TempString + "--  ";
					else
						TempString = TempString + "    ";

					TempString = TempString + "  " + dtoa(TempLoop,0) + "  ";
					TempString = TempString + dtoa(*TempSource,4) + "   (" + dtoa(*TempSource - TempAverage,4) + 
						")    " + dtoa(vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors],4) +
						"    " + dtoa(vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors],4);

					TempSource++;
				}
				TempString = TempString + "\n" + vGlobalTopString + " of Image";
				TempString = TempString + "\n";
				TempString = TempString + "\n";
				vCalibratePixelResultsDisplayString = TempString;

				WORD TempMinimumPixels = 4 * vConfigurationData->vNumberOfDetectorsToCalibrate;
				if (TempMinimumPixels < 8)
					TempMinimumPixels = 4 * 6;

				if (vNumberOfBadPixels > TempMinimumPixels)
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n" + dtoa(vNumberOfBadPixels) + " pixels could not be calibrated.\nDetectors may be worn out.\nReplace if old.";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
					ReportErrorMessage("Calibrate verify out of specifications (+-10) on " + dtoa(vNumberOfBadPixels) + " Pixels", cEMailInspx, 0);
				}
				else
				if (vNumberOfBadPixels > 1)
				{
					CNoticeDialog TempNoticeDialog;
					TempNoticeDialog.vNoticeText = "\n\n\n" + dtoa(vNumberOfBadPixels) + " pixels could not be calibrated.\nCheck for Bad Pixels/Detectors.";
					TempNoticeDialog.vType = cErrorMessage;
					TempNoticeDialog.DoModal();
					ReportErrorMessage("Calibrate verify out of specifications (+-10) on " + dtoa(vNumberOfBadPixels) + " Pixels", cEMailInspx, 0);
				}

				CHelpDialog IHelpDialog;
				IHelpDialog.vHelpContext = 16;
				IHelpDialog.vHelpType = 0;
				IHelpDialog.vWindowType = cTextWindow;
				IHelpDialog.vLocalProductCollection = &vProductCollection;
				IHelpDialog.vLocalSystemData = &vSystemData;
				IHelpDialog.vMainWindowPointer = this;
				IHelpDialog.vLocalConfigurationData = vConfigurationData;
				IHelpDialog.vProductPointer = vGlobalCurrentProduct;
				IHelpDialog.vTextString = TempString;
				IHelpDialog.vTitleString = "Pixel Linearization Verification Results";
				int TempResult = IHelpDialog.DoModal();
			}
		}
		//calculate measured gain and offset of each detector
		for (BYTE TempLoopDetector = 0; TempLoopDetector < vConfigurationData->vNumberOfXRayDetectors; TempLoopDetector++)
		{
			double TempGainSum = 0;
			double TempOffsetSum = 0;
			BYTE TempDetector = (BYTE)(vConfigurationData->vNumberOfXRayDetectors - TempLoopDetector - 1);
			for (BYTE TempLoop = 3; TempLoop < vConfigurationData->vPixelsPerDetector - 3; TempLoop++)
			{

				TempGainSum = TempGainSum + TempCalculatedGain[TempLoop + (TempDetector * vConfigurationData->vPixelsPerDetector)];
				TempOffsetSum = TempOffsetSum + TempCalculatedOffset[TempLoop + (TempDetector * vConfigurationData->vPixelsPerDetector)];
			}
			double TempAverageGain = TempGainSum / 58;
			vConfigurationData->vMeasuredDetectorGain[TempDetector] = (((TempGainSum / 58) / 255) / 20) * 100;
			if (TempAverageGain)
				vConfigurationData->vMeasuredDetectorOffset[TempDetector] = (((TempOffsetSum / 58) / TempAverageGain) / 20 ) * 100;
			else
				vConfigurationData->vMeasuredDetectorOffset[TempDetector] = 0;
		}

		CString TempDirectoryString = vConfigurationData->vScanTracCalibrationImagesDirectory;
		CString TempString = TempDirectoryString + "CalibratePixelsData.csv";
		if (!vUpdateGainAndOffsetConfiguration)
			TempString = TempDirectoryString + "CalibratePixelsVerifyData.csv";

		TempString.Insert(TempString.GetLength() - 4, dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3) + "mSec" + 
			dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6.0, 1) + "kV");

		//crashed here in the past writing to file
		LPCTSTR TempFileName = TempString;
		CFileException TempFileException;
		if (ThereIsEnoughMemory(sizeof(CFile), "Calibration Average Data File"))
		{
			vCalibrationDataFile = new CFile;
			if (vCalibrationDataFile)
			{
				int TempFileOpened = vCalibrationDataFile->Open(TempFileName, (CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException);
				if (TempFileOpened == 0)
				{
					//could not open serial log file
					ReportErrorMessage("Error-Open File Failed: " + TempString, cEMailInspx,32000);// + TempFileException.m_cause); 
					#ifdef _DEBUG
						afxDump << "Could Not Calibration Data File"  << "\n";
					#endif
				}
				else
				{
					//write the image data to the file
					TRY
					{
						CString TempString = "I1,I2,I3,I4,I5,I6,I6,I8,I9,I10,I11,I12,I13,I14,I15,I16,I17,I18,I19,I20,YMin,YMin+1,XMin,XMin+1,YMax,YMax-1,XMax,XMax-1,YMinF,YMaxF,XMinF,XMaxF,CGain,COff,CVGain,CVOff,OGainAdj,GainAdj,OOffsetAdj,OffsetAdj\n";
						CW2A TempStringToWrite(TempString);
						vCalibrationDataFile->Write(TempStringToWrite, TempString.GetLength());
						//for each pixel in the line scan array
						double *TempPointer;
						for (WORD TempLoop = 0; TempLoop < vSystemData.vITIPCDig->vOriginalBufferSizeX; TempLoop++)
						{
							TempPointer = vCalibrationAverageImage + TempLoop;
							//for each data point taken and each result, write to file
							for (DWORD TempLoop = 0; TempLoop < cNumberOfCalibrationImages + cNumberOfCalibrationResults; TempLoop++)
							{
								TempString = dtoa(*TempPointer,4);
								TempString = TempString + ',';
								CW2A TempStringToWrite(TempString);
								vCalibrationDataFile->Write(TempStringToWrite, TempString.GetLength() );
								TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
							}
							TempString = "\n ";
							CW2A TempStringToWrite(TempString);
							vCalibrationDataFile->Write(TempStringToWrite, TempString.GetLength() );
						} // end of loop for every pixel in linear scan array
					}
					CATCH_ALL(TempFileException)
					{
						ReportErrorMessage("Error Writing to CSV File",cEMailInspx,32000);
						//#ifdef _DEBUG
						//	afxDump << "Could Not Write Calibration File"  << "\n";
						//#endif
					}
					END_CATCH_ALL
					TRY
					{
						vCalibrationDataFile->Close();
					}
					CATCH_ALL(TempFileException)
					{
						ReportErrorMessage("Error Closing CSV File",cEMailInspx,32000);
					 #ifdef _DEBUG
							afxDump << "Could Not Close Calibration Image File"  << "\n";
					 #endif
					}
					END_CATCH_ALL
				}
				delete vCalibrationDataFile;
				vCalibrationDataFile = NULL;
			}
		}
		SendPreAmpGain(1); //send preamp gain of 2 for the measure source strength
 		vSystemData.vInAutoSetup = false;
		if (TempLineDataPoints)
			free(TempLineDataPoints);
	}
 	vSystemData.vInAutoSetup = false;
	ReportErrorMessage("End Calculate Calibrate Edge Pixels ", cAction, 0);
}

void CScanTracDlg::OutputImageToFile()
{
	if ((vSystemData.vITIPCDig->vOriginalImage) && (vSystemData.vITIPCDig->vOriginalImage->vGreyImage))
	{
		CString TempString = " ";
		TempString = " ";
		TempString.LoadString(IDS_Calibrating);
		TempString = TempString + " " + dtoa(vSystemData.vCalibrationImageNumber, 0);
		//SetDlgItemText(IDC_Calibrating,TempString);

		CString TempDirectoryString = vConfigurationData->vScanTracCalibrationImagesDirectory;
		TempString = TempDirectoryString + "ScanTracCalImage" + TempString + ".csv";
		LPCTSTR TempFileName = TempString;
		CFileException TempFileException;
		if (ThereIsEnoughMemory(sizeof(CFile), "Calibration Data File"))
		{
			vCalibrationDataFile = new CFile;
			if (vCalibrationDataFile)
			{
				int TempFileOpened = vCalibrationDataFile->Open(TempFileName, (CFile::modeCreate | CFile::modeReadWrite), &TempFileException);
				if (TempFileOpened == 0)
				{
					//could not open serial log file
					ReportErrorMessage("Error-Open File Failed: " + TempString, cEMailInspx,32000);// + TempFileException.m_cause); 
					#ifdef _DEBUG
						afxDump << "Could Not Calibration Data File"  << "\n";
					#endif
				}
				else
				{
					//write the image data to the file
					TRY
					{
						CString TempString = "Data";
						BYTE TempByte = 0;
						BYTE *TempImageBuffer;
						TempImageBuffer = vSystemData.vITIPCDig->vOriginalImage->vGreyImage;
						WORD TempX = 0;


						for (DWORD TempLoop = 0; TempLoop < vSystemData.vITIPCDig->vOriginalBufferSize; TempLoop++) 
						{

							TempX = (WORD)((TempLoop + 1) % vSystemData.vITIPCDig->vAquisitionSizeX);

							TempByte = *TempImageBuffer;
							TempImageBuffer++;
							if (TempX <= vSystemData.vITIPCDig->vOriginalBufferSizeX)
							{
								TempString = dtoa(TempByte, 0);

								TempString = TempString + ',';
								CW2A TempStringToWrite(TempString);
								vCalibrationDataFile->Write(TempStringToWrite, TempString.GetLength());
								if (((TempLoop + 1) % vSystemData.vITIPCDig->vOriginalBufferSizeX) == 0)
								{
									TempString = "\n ";
									CW2A TempStringToWrite(TempString);
									vCalibrationDataFile->Write(TempStringToWrite, TempString.GetLength());
								}
							}
						}
					}
					CATCH_ALL(TempFileException)
					{
					 //#ifdef _DEBUG
					//		afxDump << "Could Not Write Calibration File"  << "\n";
					 //#endif
					}
					END_CATCH_ALL
					TRY
					{
						vCalibrationDataFile->Close();
					}
					CATCH_ALL(TempFileException)
					{
					 #ifdef _DEBUG
							afxDump << "Could Not Close Calibration Image File"  << "\n";
					 #endif
					}
					END_CATCH_ALL
				}
				delete vCalibrationDataFile;
				vCalibrationDataFile = NULL;
			}
		}
	}
}

void CScanTracDlg::EndCalibrateDetectorEdges(bool TempAbort)
{
	if (vAbortCalibration)
		TempAbort = true;

	bool TempStartedNextProcess = false;

	KillTimer(vConveyorStartTimerHandle);
	SendXRayPowerOnOffToUController(0);
	Sleep(cSendCommandSleepTime);
	if (TempAbort)
	{
		vSystemData.vSystemRunMode = cStoppedSystemMode;
		Sleep(1000);  //allow time for last frame to be processed
	}
	SendConveyorOnOffToUController(0);
	TurnSimulatedEncoderOff();
	StopImageAcquisition();
	vSystemData.vDigitalInputLine3Mask = 0x00;
	vSystemData.vCurrentBodyTriggerMask = 0;
	vSystemData.vSystemRunMode = cStoppedSystemMode;
	Sleep(cSendCommandSleepTime);
				
	TurnSimulatedContainersOff();
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter EndCalibrateDetectorEdges ScanTracDlg",cDebugMessage);

	//turn simulated encoder off
	//must do when start to select real encoder
	if (!TempAbort)
	{
		//Sleep(2000); //give HVPS time to drop voltage

		if (vSystemData.vApplyGainAndOffsetDuringCalibration)
			ReportErrorMessage("Verified Detector Pixel Calibration",cAction,0);
		else
			ReportErrorMessage("Calibrated Detector Pixels",cUserChanges,0);

		if (vSystemData.vFullDetectorCalibration)
		{
			if (vSystemData.vApplyGainAndOffsetDuringCalibration)
			{  //verified pixel calibration, now measure source strength or do .4 X-scan
				if ((vConfigurationData->vUseXScanDetectors) && (vSystemData.vCalibratingXScanPoint4mmDetectors == 0) && 
					(vConfigurationData->vScanTracType != cForteScanTrac) && (vConfigurationData->vScanTracType != cCaseInspectorScanTrac))
				{ //start calibrating .4mm detector mode
					TempStartedNextProcess = true;
					vSystemData.vCalibratingXScanPoint4mmDetectors = 1;
					vConfigurationData->SetPixelsPerDetector(128);  //if using X-Scan, calibrate .4 mm mode next
					StartCalibrateDetectorEdgesForXScanPoint4Mode();
				}
				else
				{
					LoadMeasureSourceStrengthProduct();

					bool TempOKToRun = 1;
					if ((vConfigurationData->vScanTracType != cSoloScanTrac) && (vGlobalScanTracType != cSoloPlusScanTrac) && (vConfigurationData->vScanTracType != cUpSideDownSoloScanTrac) && 
						(vConfigurationData->vScanTracType != cFermataScanTrac)) //if not a solo, and values are too far off, ask customer what values to use, original or default //new source strength code
					{
						if ((dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6.0, 1) != dtoa(GetDefaultMeasureSourceStrengthVoltage(), 1)) || 
							(dtoa(vGlobalCurrentProduct->vXRaySourceCurrent, 1) != dtoa(GetDefaultMeasureSourceStrengthCurrent(vConfigurationData->vXRaySourceFilter), 1)) ||
							(vGlobalCurrentProduct->vXRayIntegrationTime != 750))
						{
							TempOKToRun = ChangeFilter();
							if (TempOKToRun)
								LoadMeasureSourceStrengthProduct();
						}
					}

					if (TempOKToRun)
					{
						TempStartedNextProcess = true;
						//set gains to 10
						if ((dtoa(vGlobalCurrentProduct->vXRaySourceVoltage, 1) != dtoa(GetDefaultMeasureSourceStrengthVoltage(), 1)) ||
							(vGlobalCurrentProduct->vXRayIntegrationTime != 750) ||
							(dtoa(vGlobalCurrentProduct->vXRaySourceCurrent, 1) != dtoa(GetDefaultMeasureSourceStrengthCurrent(vConfigurationData->vXRaySourceFilter), 1)))
						{
							SendADCGainsAndOffsets(true);
								
							if (vGlobalFPGAVersion10Point0OrHigher)
								SendPreAmpGain(1);//preamp gain of 2 
							else
								SendPreAmpGain(2);//preamp gain of 4 
						}
						vSystemData.vApplyGainAndOffsetDuringCalibration = false;
						vSystemData.vModeToRunAfterCalibrateOffset = cMeasureSourceStrengthMode;
						//this will calibrate detectors, then do measure source strength
						vSystemData.vCalibrateErrorCount = 0;
						vSystemData.vHadErrorTryRestart = 0;
						vSystemData.vCalibrateADCAfterDAC = true;
						vSystemData.vAutoCalibrate = true;
						vSystemData.vAutoCalibrateWhileRunning = false;
						if (vConfigurationData->vUseDACAndADCinDensityCompensation)
							CalibrateDACDetectorOffset();
						else
							CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
					}
				}
			}
			else
			{//just calibrated pixels, now verify pixels
				TempStartedNextProcess = true;
				vSystemData.vApplyGainAndOffsetDuringCalibration = true;
				vSystemData.vModeToRunAfterCalibrateOffset = cCalibratingDetectorEdgesMode;
				//this will calibrate detectors, then do gain adjustments
				vSystemData.vCalibrateErrorCount = 0;
				vSystemData.vHadErrorTryRestart = 0;
				vSystemData.vCalibrateADCAfterDAC = true;
				vSystemData.vAutoCalibrate = true;
				vSystemData.vAutoCalibrateWhileRunning = false;
				if (vConfigurationData->vUseDACAndADCinDensityCompensation)
					CalibrateDACDetectorOffset();
				else
					CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
			}
		}
		else
		{
			if (!vSystemData.vApplyGainAndOffsetDuringCalibration)
			{//just calibrated pixels, now verify pixels
				TempStartedNextProcess = true;
				vSystemData.vApplyGainAndOffsetDuringCalibration = true;
				vSystemData.vModeToRunAfterCalibrateOffset = cCalibratingDetectorEdgesMode;
				//this will calibrate detectors, then do gain adjustments
				vSystemData.vCalibrateErrorCount = 0;
				vSystemData.vHadErrorTryRestart = 0;
				vSystemData.vCalibrateADCAfterDAC = true;
				vSystemData.vAutoCalibrate = true;
				vSystemData.vAutoCalibrateWhileRunning = false;
				if (vConfigurationData->vUseDACAndADCinDensityCompensation)
					CalibrateDACDetectorOffset();
				else
					CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
			}
			else
			{
				vTurnOffSourceWhenStopRunning = TempAbort;
				int TimerResult = SetTimer(vEndCalibrateDetectorsTimerHandle,10,NULL);
				if (!TimerResult)
					ReportErrorMessage("Error-EndCalibrate Timer Failed",cEMailInspx,32000);
			}
		}
	}
	else
	{
		ReportErrorMessage("Aborted Calibrate Detector Pixels",cAction,0);
		vTurnOffSourceWhenStopRunning = TempAbort;
		int TimerResult = SetTimer(vEndCalibrateDetectorsTimerHandle,10,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-EndCalibrate Timer Failed",cEMailInspx,32000);

		RestoreBackupGainAndPixelAdjustments();
	}
	if (vGlobalDXMXRayPort)
		vGlobalDXMXRayPort->EnableWatchDog(false);  //calculations can take a long time, so disable watch dog
	//if (vGlobalDXMXRayPort)
	//	vGlobalDXMXRayPort->EnableWatchDog(true);  //calculations can take a long time, so disable watch dog

	if (TempAbort)
		RestoreOriginalProduct();
	else
	if ((!vSystemData.vFullDetectorCalibration) && (!TempStartedNextProcess))
		RestoreOriginalProduct();
}

void CScanTracDlg::EndCalibrateADCDetectorOffset(bool TempAbort)
{
	if (vAbortCalibration)
		TempAbort = true;

	KillTimer(vConveyorStartTimerHandle);
	bool TempDoneCalibrating = false;
	if ((TempAbort) || (!((vSystemData.vAutoCalibrate) || (vSystemData.vAutoCalibrateWhileRunning))))
	{
		m_SubFunction1Button.ShowWindow(SW_HIDE);
		this->InvalidateRect(&m_SubFunction1Button.GetRectToInvalidateArrow());
		m_Calibrating.ShowWindow(SW_HIDE);
	}
	KillTimer(vSourceStabilizeTimerHandle);
	BYTE TempNumberOfDetectorsThatDidNotCalibrate = 0;
	if (TempAbort)
		vSystemData.vSystemRunMode = cStoppedSystemMode;
	else
	{//if any value not in range then calibration did not work right, do again
		if (vSystemData.vITIPCDig->vShowOnlyRealImages)
		for (BYTE TempLoop = 0; TempLoop < vSystemData.vNumberOfXRayDetectorsUsing; TempLoop++)
		if ((vConfigurationData->vNumberOfDetectorsToCalibrate == 0) || (TempLoop < vConfigurationData->vNumberOfDetectorsToCalibrate))
		if ((vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration == 0) || (TempLoop >= vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration))
		{
			if (vConfigurationData->vPreAmplifierGain <= 2) //if gain is 4 or lower
			{
				if ((vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] - vSystemData.vCalibrationADCOffsetMaximumBit < -120) || (vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] - vSystemData.vCalibrationADCOffsetMaximumBit > 120)) //was 30
				{
					TempNumberOfDetectorsThatDidNotCalibrate++;
					ReportErrorMessage("Detector: " + dtoa(1 + TempLoop, 0) + " Failed ADC Calibration.  Value: " + dtoa(vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] - vSystemData.vCalibrationADCOffsetMaximumBit, 0),cEMailInspx,32000);
				}
			}
			else
			{
				if ((vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] - vSystemData.vCalibrationADCOffsetMaximumBit < -250) || (vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] - vSystemData.vCalibrationADCOffsetMaximumBit > 250)) //was 250
				{
					TempNumberOfDetectorsThatDidNotCalibrate++;
					ReportErrorMessage("Detector: " + dtoa(1 + TempLoop, 0) + " Failed ADC Calibration.  Value: " + dtoa(vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] - vSystemData.vCalibrationADCOffsetMaximumBit, 0),cEMailInspx,32000);
				}
			}
		}

		if ((TempNumberOfDetectorsThatDidNotCalibrate) && ((vSystemData.vCalibrateErrorCount & 0x7F) < 3))
		{
			vSystemData.vCalibrateErrorCount++;
			vSystemData.vCalibrateErrorCount = vSystemData.vCalibrateErrorCount | 0x80; //set flag to indicate ADC Calibration Failed.
			vSystemData.vHadErrorTryRestart = 1;
			ReportErrorMessage("ADC try: " + dtoa((vSystemData.vCalibrateErrorCount & 0x7F), 0) + " Going to try Stop, Reload Product, and Run",cEMailInspx,32000);
			TempAbort = true;

			int TempTimerResult = SetTimer(vSetupProductTimerHandle,2000,NULL);
			if (!TempTimerResult)
				ReportErrorMessage("Error-Display Timer Failed",cEMailInspx,32000);
		}
		else
		{
			if (TempNumberOfDetectorsThatDidNotCalibrate)
			{
				if (vSystemData.vCalibrateErrorCount > 0x80)
				{
					ReportErrorMessage("ADC Calibration Failed 3 Times, continuing...", cEMailInspx, 32000);
					ReportErrorMessage("Check Image - call service if not correct", cEMailMaintenance, 0);
				}
				else
					ReportErrorMessage("ADC Calibration Failed too, continuing...", cEMailInspx, 32000);
			}
			else
			if (vSystemData.vCalibrateErrorCount > 0x80) //if had an ADC cal failure
			{
				vSystemData.vCalibrateErrorCount = 0;
				ReportErrorMessage("ADC Calibration Successful, Starting Run", cEMailInspx, 32000);
			}
		}
		vSystemData.vLastCalibrationTime = CTime::GetCurrentTime();
		//install new calibration values if they were good
		for (BYTE TempLoop = 0; TempLoop < vConfigurationData->vNumberOfXRayDetectors; TempLoop++)
		{
			vSystemData.vADCDetectorOffset[TempLoop] = vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] - vSystemData.vCalibrationADCOffsetMaximumBit;

			vSystemData.vSendADCValues = 0; //cancel sending any ADC Values as will send all now
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendADCOffset(TempLoop,vSystemData.vADCDetectorOffset[TempLoop] + int(vSystemData.vDriftCompensationADCOffset));

			if (((vSystemData.vModeToRunAfterCalibrateOffset == cStoppedSystemMode) && (!vSystemData.vAutoCalibrateWhileRunning) && (!vSystemData.vAutoCalibrate)) || (vSystemData.vFullDetectorCalibration))
			{
				vConfigurationData->vADCDetectorOffset[TempLoop] = vSystemData.vADCDetectorOffset[TempLoop];
				ReportErrorMessage("Saved ADC Offset in Configuration Data: " + dtoa(TempLoop,0) + " - " + dtoa(vConfigurationData->vADCDetectorOffset[TempLoop],2),cWriteToLog,0);
			}
		}
	}

	if ((TempAbort) || (!((vSystemData.vModeToRunAfterCalibrateOffset == cRunningSystemMode) &&
		(vConfigurationData->vRadiationShutterInSystem))))
	{
		if ((!vSystemData.vAutoCalibrateWhileRunning) || (TempAbort))
		{
			vSystemData.vSourceRampedUp = false;
			StopImageAcquisition();
			vSystemData.vDigitalInputLine3Mask = 0x00;
			vSystemData.vCurrentBodyTriggerMask = 0;
			vSystemData.vSystemRunMode = cStoppedSystemMode;

			if ((!vSystemData.vAutoCalibrate) || (TempAbort))
				SendConveyorOnOffToUController(0);

			//9/28/2009
			if (TempAbort)
				FinishStopRunning(true);

		}
		//Send Container Trigger to Image Delay
		if (vGlobalCurrentProduct)
		{
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Enter EndCalibrateDetectorOffset ScanTracDlg",cDebugMessage);

			if (vGlobaluCSerialPort)
			if (!((vSystemData.vModeToRunAfterCalibrateOffset == cRunningSystemMode) &&
				(vConfigurationData->vRadiationShutterInSystem)))
				vGlobaluCSerialPort->SendContainerTriggerToImageDelay(vGlobalCurrentProduct);
		}
		//turn simulated encoder off
		//must do when start to select real encoder
		TurnSimulatedEncoderOff();
	}

	vTurnOffSourceWhenStopRunning = TempAbort;

	if (vSystemData.vModeToRunAfterCalibrateOffset == cStoppedSystemMode)
	{
		FinishCalibrateADCDetectorOffset(TempAbort);
		RestoreOriginalProduct();
	}

	if ((TempAbort) && (CurrentProductIsInspxProduct()))
		RestoreOriginalProduct();

	if ((!vSystemData.vAutoCalibrateWhileRunning) || (TempAbort))
		vSystemData.vSystemRunMode = cStoppedSystemMode;

		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendContainerTriggerToImageDelay(vGlobalCurrentProduct);

	//turn simulated encoder on if configured, otherwise will turn it off
	//must do when start to select real encoder
	TurnSimulatedEncoderOn();

	if (TempAbort)
		TempDoneCalibrating = true;
	if (vSystemData.vAutoCalibrateWhileRunning)
	if (vGlobaluCSerialPort)
	{
		vSystemData.vDriftCompensationADCOffset = vHoldDriftCompensationADCOffset;
		vSystemData.vDriftCompensationDACOffset = vHoldDriftCompensationDACOffset;
		SendAllDACDetectorOffsets();
		SendAllADCOffsets();
	}

	if (!TempAbort)
	if (vGlobalImageAquisitionThread)
	{
		//if you had good calibration values, or were running and calibrated, continue 

		CString TempString = "Final ADC Offset: ";
		for (BYTE TempLoop = 0; TempLoop < vSystemData.vNumberOfXRayDetectorsUsing; TempLoop++)
			TempString = TempString + dtoa(vSystemData.vADCDetectorOffset[TempLoop],2) + ", ";
		ReportErrorMessage(TempString, cWriteToLog,0);

		{
			TempDoneCalibrating = true;

			if (!InterlocksOK())
			{
				CString TempString1 = " ";
				CString TempString = " ";
				TempString1.LoadString(IDS_XRaysShutDown);
				TempString.LoadString(IDS_InterlockOpen);
				ReportErrorMessage(TempString + ", " + TempString1, cEMailMaintenance,9);
				vSystemData.vSystemRunMode = cStoppedSystemMode;
				StopRunning(true);
			}
			else
			{
				if (vSystemData.vModeToRunAfterCalibrateOffset == cCalibratingDetectorEdgesMode)
					CalibrateDetectorEdges(!vSystemData.vApplyGainAndOffsetDuringCalibration);
				else
				if (vSystemData.vModeToRunAfterCalibrateOffset == cCalibratingDetectorGainMode)
					CalibrateDetectorGain();
				else
				if (vSystemData.vModeToRunAfterCalibrateOffset == cMeasureSourceStrengthMode)
					MeasureSourceStrength();
				else
				if (vSystemData.vModeToRunAfterCalibrateOffset == cAlignTubeMode)
					StartAlignTubeMode();
				else
				if ((vSystemData.vModeToRunAfterCalibrateOffset == cRunningSystemMode) &&
					((vConfigurationData->vRadiationShutterInSystem) && 
					(!vSystemData.vAutoCalibrateWhileRunning)))
					TestShutter();
				else
				{ //normal run or auto setup
					//send retrigger lockout if not going to test shutter
					SendRetriggerLockout(vGlobalCurrentProduct->vLockoutPosition);

					//if interlocks were OK and it ran set mode to correct run mode
					if (vSystemData.vAutoCalibrate)
						StartRunning(true,true);
					else
					{
						ReportErrorMessage("End Calibrate ADC, Not Auto Calibrate", cWriteToLog,0);
					}
					if (vSystemData.vSystemRunMode != cConditionXRayTubeMode)
					{
						vSystemData.vSystemRunMode = vSystemData.vModeToRunAfterCalibrateOffset;
						ShowOrHideProductDensityCompensation();
						if (vSystemData.vAutoCalibrateWhileRunning)
						{
							if (vConfigurationData->vRadiationShutterInSystem)
							{
								if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
								if (vGlobaluCSerialPort)
									if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
										vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterAutoControl);
								//vSystemData.vSystemRunMode == cRunningSystemMode;
								if (vSystemData.vLogFile.vLogSerialData)
									vSystemData.vLogFile.WriteToLogFile("End vAutoCalibrateWhileRunning ScanTracDlg",cDebugMessage);
								if (vGlobaluCSerialPort)
									vGlobaluCSerialPort->SendContainerTriggerToImageDelay(vGlobalCurrentProduct);

								//turn simulated encoder on if configured, otherwise will turn it off
								//must do when start to select real encoder
								TurnSimulatedEncoderOn();
								StartImageAcquisition();
							}
							else
							{
								vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;
								vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;
								SendXRayPowerOnOffToUController(1);
							}
						}
					}
				}
			}
		}
	}

	UpdateRunButton();
	SetInterlockStatus();

	if (TempDoneCalibrating)
	{
		vSystemData.vAutoCalibrate = false;
		vSystemData.vAutoCalibrateWhileRunning = false;
	}
	if (TempAbort)
	if ((vSystemData.vFullDetectorCalibration) || 
		(vSystemData.vModeToRunAfterCalibrateOffset == cCalibratingDetectorGainMode) ||
		(vSystemData.vModeToRunAfterCalibrateOffset == cCalibratingDetectorEdgesMode))
		RestoreBackupGainAndPixelAdjustments();
	vSystemData.vBodyTriggerLines = 0;
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("EndCalibrateADCDetectorOffset vBodyTriggerLines = 0",cDebugMessage);
}

void CScanTracDlg::FinishCalibrateADCDetectorOffset(bool TempAbort)
{
	TurnSimulatedEncoderOn();

	if (vCalibrationAverageImage != NULL)
	{
		free(vCalibrationAverageImage);
		vCalibrationAverageImage = NULL;
	}

	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("End EndCalibrateDetectorOffset ScanTracDlg",cDebugMessage);

	if ((!vSystemData.vAutoCalibrate) && (!vSystemData.vAutoCalibrateWhileRunning))
	if (TempAbort)
		ReportErrorMessage("Aborted calibrating detector offset", cAction,0);
	else
		ReportErrorMessage("Completed calibrating detector offset", cAction,0);
}

void CScanTracDlg::EndCalibrateDACDetectorOffset(bool TempAbort)
{
	if (vAbortCalibration)
		TempAbort = true;

	KillTimer(vConveyorStartTimerHandle);
	KillTimer(vSourceStabilizeTimerHandle);
	if (TempAbort)
	{
		m_SubFunction1Button.ShowWindow(SW_HIDE);
		this->InvalidateRect(&m_SubFunction1Button.GetRectToInvalidateArrow());
		m_Calibrating.ShowWindow(SW_HIDE);
		vSystemData.vSystemRunMode = cStoppedSystemMode;
		vSystemData.vSourceRampedUp = false;
		StopImageAcquisition();
		vSystemData.vDigitalInputLine3Mask = 0x00;
		vSystemData.vCurrentBodyTriggerMask = 0;
		vSystemData.vSystemRunMode = cStoppedSystemMode;

		SendConveyorOnOffToUController(0);
		TurnSimulatedEncoderOff();

		//9/28/2009
		if (TempAbort)
			FinishStopRunning(true);

		vSystemData.vSystemRunMode = cStoppedSystemMode;
		vTurnOffSourceWhenStopRunning = TempAbort;
		FinishCalibrateDACDetectorOffset(TempAbort);
		ReportErrorMessage("Aborted calibrating DAC detector offset", cAction,0);
	}
	else
	if (vGlobalImageAquisitionThread)
	{
		// if the current autocalibrate values are more than 5 off from the initial setup 
		// calibrate values, probably got a bad image, so re-auto-calibrate offset
		BYTE TempNumberOfDetectorsThatDidNotCalibrate = 0;

		//double TempNumberOfDetectorsToCheckD = vGlobalCurrentProduct->vProductImageHeightTop / vConfigurationData->vDetectorLength;
		//BYTE TempNumberOfDetectorsToCheck = (BYTE)(TempNumberOfDetectorsToCheckD);
		//if (TempNumberOfDetectorsToCheckD > TempNumberOfDetectorsToCheck)  //if truncated a fractional part of a detector, need to check one more detector
		//	TempNumberOfDetectorsToCheck++;

		//if (vConfigurationData->vNumberOfDetectorsToCalibrate) 
		//if (vConfigurationData->vNumberOfDetectorsToCalibrate < TempNumberOfDetectorsToCheck) 
		//	TempNumberOfDetectorsToCheck = vConfigurationData->vNumberOfDetectorsToCalibrate;

		if (vSystemData.vITIPCDig->vShowOnlyRealImages)
		for (BYTE TempLoop = 0; TempLoop < vSystemData.vNumberOfXRayDetectorsUsing; TempLoop++)
			if ((vConfigurationData->vNumberOfDetectorsToCalibrate == 0) || (TempLoop < vConfigurationData->vNumberOfDetectorsToCalibrate))
			if ((vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration == 0) || (TempLoop >= vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration))
		{
			if (vGlobalFPGAVersion10Point0OrHigher)
			{
				if (vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] * 100.0 / 0x800 > 12)// || (vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] * 100.0 / 0x800 < 0.25))
				{
					TempNumberOfDetectorsThatDidNotCalibrate++;
					ReportErrorMessage("Detector: " + dtoa(1 + TempLoop, 0) + " Failed DAC Calibration.  Value: " + dtoa(vSystemData.vCalibrationOffsetCurrentOffset[TempLoop], 0),cEMailInspx,32000);
				}
			}
			else
			{
				if ((vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] * 100.0 / 0x800 > 30) || (vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] * 100.0 / 0x800 < 10))
				{
					TempNumberOfDetectorsThatDidNotCalibrate++;
					ReportErrorMessage("Detector: " + dtoa(1 + TempLoop, 0) + " Failed DAC Calibration.  Value: " + dtoa(vSystemData.vCalibrationOffsetCurrentOffset[TempLoop], 0),cEMailInspx,32000);
				}
			}
		}
		{
			//save in configuration to use from now on
			CString TempString = "Calibrated Detectors DAC Offset: ";
			for (BYTE TempLoop = 0; TempLoop < vSystemData.vNumberOfXRayDetectorsUsing; TempLoop++)
			{
				vSystemData.vDACDetectorOffset[TempLoop] = vSystemData.vCalibrationOffsetCurrentOffset[TempLoop] * 100.0 / 0x800;
				TempString = TempString + Pad(dtoa(vSystemData.vDACDetectorOffset[TempLoop],2),2,2) + ", ";
				if (((vSystemData.vModeToRunAfterCalibrateOffset == cStoppedSystemMode) && (!vSystemData.vAutoCalibrateWhileRunning) && (!vSystemData.vAutoCalibrate)) || (vSystemData.vFullDetectorCalibration))
				{
					vConfigurationData->vDACDetectorOffset[TempLoop] = vSystemData.vDACDetectorOffset[TempLoop];
					ReportErrorMessage("Saved DAC Offset in Configuration Data: " + dtoa(TempLoop,0) + " - " + dtoa(vConfigurationData->vDACDetectorOffset[TempLoop],2),cWriteToLog,0);
				}
			}
			ReportErrorMessage(TempString, cWriteToLog,0);

			if (vSystemData.vCalibrateADCAfterDAC)
			{
				vSystemData.vCalibrateADCAfterDAC = false;
				CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate,vSystemData.vAutoCalibrateWhileRunning);
			}
			else
			{
				vTurnOffSourceWhenStopRunning = TempAbort;
				FinishCalibrateDACDetectorOffset(TempAbort);
			}
		}
		if ((TempNumberOfDetectorsThatDidNotCalibrate) && ((vSystemData.vCalibrateErrorCount & 0x7F) < 3))
		{
			//ReportErrorMessage("Image may be impaired, " + dtoa(TempNumberOfDetectorsThatDidNotCalibrate,0) + "	detector(s) failed DAC calibration",cError,23);
			//CString TempString = "Bad DAC Offset Value: ";
			//for (BYTE TempLoop = 0; TempLoop < vSystemData.vNumberOfXRayDetectorsUsing; TempLoop++)
			//{
			//	TempString = TempString + Pad(dtoa(vSystemData.vDACDetectorOffset[TempLoop],2),2,2) + ", ";
			//}
			//ReportErrorMessage(TempString, cEMailInspx, 32000);

			//for (WORD TempLoop = 0; TempLoop < vSystemData.vNumberOfXRayDetectorsUsing; TempLoop++)
			//{
			//	if (vGlobalFPGAVersion10Point0OrHigher)
			//	{
			//		if ((vSystemData.vDACDetectorOffset[TempLoop] > 15) || (vSystemData.vDACDetectorOffset[TempLoop] == 0))
			//				vSystemData.vDACDetectorOffset[TempLoop] = 4;  //set to 4%
			//	}
			//	else
			//	{
			//		if ((vSystemData.vDACDetectorOffset[TempLoop] > 30) || (vSystemData.vDACDetectorOffset[TempLoop] < 10))
			//				vSystemData.vDACDetectorOffset[TempLoop] = 16.0; //set to 16%
			//	}
			//}
			//if (vGlobalFPGAVersion10Point0OrHigher)
			//	ReportErrorMessage("DAC good range 15 to .25, full range 100 to 0, bad set to 4",cEMailInspx,32000);
			//else
			//	ReportErrorMessage("DAC good range 30 to 15, full range 100 to 0, bad set to 16",cEMailInspx,32000);

			//SendAllDACDetectorOffsets();

			vSystemData.vCalibrateErrorCount++;
			vSystemData.vHadErrorTryRestart = 1;
			ReportErrorMessage("DAC try: " + dtoa((vSystemData.vCalibrateErrorCount & 0x7F), 0) + " Going to try Stop, Reload Product, and Run",cEMailInspx,32000);
			OnSubFunction1Button();

			int TempTimerResult = SetTimer(vSetupProductTimerHandle,2000,NULL);
			if (!TempTimerResult)
				ReportErrorMessage("Error-Display Timer Failed",cEMailInspx,32000);
		}
		else
		{
			if (TempNumberOfDetectorsThatDidNotCalibrate)
			{
				ReportErrorMessage("DAC Calibration Failed 3 Times, continuing...", cEMailInspx, 32000);
				ReportErrorMessage("Check Image - call service if not correct", cEMailMaintenance, 0);
			}
			else
			if ((vSystemData.vCalibrateErrorCount) && (!(vSystemData.vCalibrateErrorCount & 0x80))) //if DAC caused failure first time then indicate was successful and clear flag this time
			{
				vSystemData.vCalibrateErrorCount = 0;
				if (TempNumberOfDetectorsThatDidNotCalibrate == 0)
					ReportErrorMessage("DAC Calibration Successfull, Starting Run", cEMailInspx, 32000);
			}
			if (vSystemData.vCalibrateADCAfterDAC)
			{
				vSystemData.vCalibrateADCAfterDAC = false;
				CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, vSystemData.vAutoCalibrateWhileRunning);
			}
			else
			{
				vTurnOffSourceWhenStopRunning = TempAbort;
				FinishCalibrateDACDetectorOffset(TempAbort);
			}
		}
		if (!vSystemData.vSendADCValues) //just finished programming the ADCs
		if (!vSystemData.vSendDACValues) //don't need to program the DACs
		if (vSystemData.vNeedToVerifyDACValues)
		if (vGlobalFPGAVersion15Point31OrHigher) //does a verify of the DACs against the last programmed value
		{
			//set a timer that will verify the DAC values in a second if nothing else is going on and started inspection
			ReportErrorMessage("Programmed ADCs Done, End CAL, so Need To Verify DACs soon", cWriteToLog, 0);
			int TempTimerResult = SetTimer(vNeedToTestDACsTimerHandle,1000,NULL);
			if (!TempTimerResult)
				ReportErrorMessage("Error-Hold Sent Test Display Timer Failed",cEMailInspx,32000);
		}
	}
	UpdateRunButton();
	if (TempAbort)
	if ((vSystemData.vFullDetectorCalibration) || (vSystemData.vModeToRunAfterCalibrateOffset == cCalibratingDetectorGainMode) || (vSystemData.vModeToRunAfterCalibrateOffset == cCalibratingDetectorEdgesMode))
		RestoreBackupGainAndPixelAdjustments();
}

//only called when not calibrating all parts of detectors
void CScanTracDlg::FinishCalibrateDetectorEdges(bool TempAbort)
{
	TurnSimulatedEncoderOn();

	if ((TempAbort) || ((!vSystemData.vFullDetectorCalibration) && (vSystemData.vApplyGainAndOffsetDuringCalibration)))
		RestoreOriginalProduct();

	if (!TempAbort)
	if (!vSystemData.vApplyGainAndOffsetDuringCalibration)
	{
		WriteConfigurationDataToFile(false); //write to main config file
	}

	if (vSystemData.vModeToRunAfterCalibrateOffset == cStoppedSystemMode)
	{
		m_Calibrating.ShowWindow(SW_HIDE);
		m_SubFunction1Button.ShowWindow(SW_HIDE);
		this->InvalidateRect(&m_SubFunction1Button.GetRectToInvalidateArrow());
		vSystemData.vInAutoSetup = false;
	}

	if (vCalibrationAverageImage != NULL)
	{
		free(vCalibrationAverageImage);
		vCalibrationAverageImage = NULL;
	}

	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("End EndCalibrateDetectorEdges ScanTracDlg",cDebugMessage);

	//if just calibrated all pixels, do verify now
	if ((!vSystemData.vApplyGainAndOffsetDuringCalibration) &&
		(!TempAbort) && (InterlocksOK()))
	{
		vSystemData.vApplyGainAndOffsetDuringCalibration = true;
		vSystemData.vCalibrationImageNumber = 0;
		//LoadCalibrateEdgesProduct();
		vSystemData.vModeToRunAfterCalibrateOffset = cStoppedSystemMode;
		//this will verify detector calibration
		vSystemData.vCalibrateErrorCount = 0;
		vSystemData.vHadErrorTryRestart = 0;
		CalibrateDetectorEdges(false);
	}
	else
		StopRunning(true);
}

void CScanTracDlg::FinishCalibrateDACDetectorOffset(bool TempAbort)
{
	SetFastestSimulatedEncoder(1); //run simulated conveyor to complete any images

	m_SubFunction1Button.ShowWindow(SW_HIDE);
	this->InvalidateRect(&m_SubFunction1Button.GetRectToInvalidateArrow());
	if (vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode)
	{
		m_Calibrating.ShowWindow(SW_HIDE);
		if (!vSystemData.vXRayOnNotice)
			m_XRaysOn.ShowWindow(SW_HIDE);
	}

	if (TempAbort)
		StopImageAcquisition();

	if (TempAbort)
	if (CurrentProductIsInspxProduct())
		RestoreOriginalProduct();

	if (vCalibrationAverageImage != NULL)
	{
		free(vCalibrationAverageImage);
		vCalibrationAverageImage = NULL;
	}

	Sleep(25);  //was 250

	//9/28/2009
	if (TempAbort)
		FinishStopRunning(true);

	//m_Calibrating.ShowWindow(SW_HIDE);
	//UpdateRunButton();
}

void CScanTracDlg::EndMeasureSourceStrength(bool TempAbort)
{
	if (vAbortCalibration)
		TempAbort = true;

	KillTimer(vConveyorStartTimerHandle);
	SendXRayPowerOnOffToUController(0);
	Sleep(cSendCommandSleepTime);
	if (TempAbort)
	{
		vSystemData.vSystemRunMode = cStoppedSystemMode;
		Sleep(1000);  //allow time for last frame to be processed
	}
	SendConveyorOnOffToUController(0);
	TurnSimulatedEncoderOff();

		//calculate Average and Standard Deviation
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter EndMeasureSourceStrength ScanTracDlg",cDebugMessage);
	if (!TempAbort)
	if (vSystemData.vDensityIndex >= cNumberOfCalibrationImages)
	if (vSystemData.vDensityDataD)
	{
		BYTE TempNumberOfSaturatedDetectors = 0;
		//Image *TempImage = NULL;
		//if (ThereIsEnoughMemory(vSystemData.vDensityIndex * 4 + sizeof(Image), "Temp Image"))
		//	TempImage = im_create(IM_FLOAT, vSystemData.vDensityIndex, 1);

		//if ((TempImage) && (TempImage->pix))
		{
			double TempAverage = 0;
			double TempStandardDeviation = 0;
			TempStandardDeviation = CalculateStandardDeviation(vSystemData.vDensityDataD, vSystemData.vDensityIndex, &TempAverage);

			CString TempDetectorDataString = "   ";
			int TempErrorCode = IM_OK;
			for (WORD TempLoopDetector = 0; TempLoopDetector < vConfigurationData->vNumberOfXRayDetectors; TempLoopDetector++)
			{
				double TempAverageValue = 0;
				double TempStandardDeviation = 0;
				TempStandardDeviation = CalculateStandardDeviation(vSystemData.vDetectorDensityData[TempLoopDetector], vSystemData.vDensityIndex, &TempAverageValue);

				if (TempLoopDetector == 6)
					TempDetectorDataString = TempDetectorDataString + "\n\t\t\t";

				TempDetectorDataString = TempDetectorDataString + Pad(dtoa(TempAverageValue,0),3,5);
				if (TempAverageValue > 252)
					TempNumberOfSaturatedDetectors++;

				if (vConfigurationData->vSaveNextSourceStrengthValuesAsInitial)
				{
					vConfigurationData->vSourceStrengthInitialValues[TempLoopDetector] = (BYTE)(TempAverageValue + 0.5); //save detector strength for initial 100 % value
					ReportErrorMessage("Source Strength Save Initial Detector " + dtoa(TempLoopDetector + 1, 0) + " Value: " + dtoa(TempAverageValue, 0), cAction, 0);
				}
				else
					ReportErrorMessage("Measured Source Strength Detector " + dtoa(TempLoopDetector + 1, 0) + " Value: " + dtoa(TempAverageValue, 0), cAction, 0);

				//if (TempLoopDetector < vConfigurationData->vNumberOfXRayDetectors - 1)
				//	TempDetectorDataString = TempDetectorDataString;
			}
			bool TempSameSettings = false;

			CString TempCurrentSettingsString = "V=" + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,2) + " I=" +
				dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,2) + " t=" + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3);

			CString TempCurrentSettingsOldStyleString = "V:" + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,2) + " I:" +
				dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,2) + " T:" + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3);

			CString TempNewComment = vConfigurationData->vSourceStrengthComment[0];

			bool TempStillChecking = true;
			if (vConfigurationData->vSourceStrengthCount)
	for (int TempLoop = vConfigurationData->vSourceStrengthCount - 1; TempLoop >= 0; TempLoop--)
			if (TempStillChecking)
			{
				int TempPosition = vConfigurationData->vSourceStrengthComment[TempLoop].Find(TempCurrentSettingsString,0);
				if (TempPosition >= 0)
					TempSameSettings = true;
				else
				TempPosition = vConfigurationData->vSourceStrengthComment[TempLoop].Find(TempCurrentSettingsOldStyleString,0);
				if (TempPosition >= 0)
					TempSameSettings = true;

				TempPosition = vConfigurationData->vSourceStrengthComment[TempLoop].Find(_T("V"),0);
				if (TempPosition >= 0)
					TempStillChecking = false;
			}

			CString TempCommentString = "    Temp " + dtoa(ConvertToDegreesC(vSystemData.vTemperatureLiquid, vConfigurationData->vTemperatureLiquidAdjust),0);

			if (!TempSameSettings)
			{
				if (vConfigurationData->vSourceStrengthCount)
				{
					if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cUpSideDownSoloScanTrac) || 
						(vConfigurationData->vScanTracType == cFermataScanTrac)) //on solos set the voltage and current to standard values each time. //new source strength code
					if (vConfigurationData->vXRaySourceFilter)
						TempCurrentSettingsString = "Standard AL Filter " + TempCurrentSettingsString;
					else
						TempCurrentSettingsString = "Standard NO AL Filter " + TempCurrentSettingsString;

					TempCommentString = TempCommentString + "\n*\t" + TempCurrentSettingsString;
				}
				else
					TempCommentString = TempCommentString + "\n \t" + TempCurrentSettingsString;
			}

			vConfigurationData->vSourceStrengthDate[vConfigurationData->vSourceStrengthCount] = CTime::GetCurrentTime();
			vConfigurationData->vSourceStrengthData[vConfigurationData->vSourceStrengthCount] = TempAverage;
			vConfigurationData->vSourceStrengthComment[vConfigurationData->vSourceStrengthCount] = TempDetectorDataString + TempCommentString;

			if (vConfigurationData->vSaveNextSourceStrengthValuesAsInitial)
			{
				vConfigurationData->vSourceStrengthInitialValues[vConfigurationData->vNumberOfXRayDetectors] = (BYTE)(TempAverage + 0.5); //save image strength for initial 100 % value
				vConfigurationData->vSaveNextSourceStrengthValuesAsInitial = false;

				ReportErrorMessage("Source Strength Save Initial Whole Value: " + dtoa(TempAverage, 0), cUserChanges, 0);
#ifdef CompileInOperationsGuardian
				SendOGInfo("DetectorStrength", std::string(dtoa(TempAverage, 0)));
#endif
			}
			else
			{
				ReportErrorMessage("Measured Source Strength Whole Value: " + dtoa(TempAverage, 0), cUserChanges, 0);
				//socketio source strength whole value
#ifdef CompileInOperationsGuardian
				SendOGInfo("DetectorStrength", std::string(dtoa(TempAverage, 0)));
#endif
			}
			if (vConfigurationData->vSourceStrengthCount < cMaximumSourceStrengthCount)
				vConfigurationData->vSourceStrengthCount++;
			else
				vConfigurationData->vSourceStrengthCount = vConfigurationData->vSourceStrengthCount / 10;

		}
		if (TempNumberOfSaturatedDetectors)
		if (vConfigurationData->vXRaySourceFilter)
		if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cUpSideDownSoloScanTrac) || 
			(vConfigurationData->vScanTracType == cFermataScanTrac)) //new source strength code
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n" + dtoa(TempNumberOfSaturatedDetectors) + " detectors are saturated.\nX-Ray AL Filter Not Engaged.\nCall Inspx.";
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
	}
	vSystemData.vDensityIndex = 0;

	StopImageAcquisition();
	vSystemData.vDigitalInputLine3Mask = 0x00;
	vSystemData.vCurrentBodyTriggerMask = 0;
	vSystemData.vSystemRunMode = cStoppedSystemMode;
	Sleep(cSendCommandSleepTime);
	SendXRayPowerOnOffToUController(0);

	TurnSimulatedContainersOff();

	//turn simulated encoder off
	//must do when start to select real encoder
	TurnSimulatedEncoderOff();

	vTurnOffSourceWhenStopRunning = TempAbort;
	int TimerResult = SetTimer(vEndMeasureSourceStrengthTimerHandle,10,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-EndMeasureSourceStrength Timer Failed",cEMailInspx,32000);
	vSystemData.vInAutoSetup = false;

	RestoreOriginalProduct();
}

void CScanTracDlg::FinishMeasureSourceStrength(bool TempAbort)
{
	//vSystemData.vFPGASimulateEncoderRate = vNeedToTurnOffSimulatedEncoderAfterCalibration;
	TurnSimulatedEncoderOn();

	vSystemData.vModeToRunAfterCalibrateOffset = cStoppedSystemMode; //5/30/2013PM
	RestoreOriginalProduct(); //7/19/2005

	SendADCGainsAndOffsets(false);

	SendPreAmpGain(vConfigurationData->vPreAmplifierGain);

	m_Calibrating.ShowWindow(SW_HIDE);
	UpdateRunButton();

	if (!TempAbort)
	{
		WriteConfigurationDataToFile(false); //write to main config file

		vConfigurationData->vTimeLastMeasuredSourceStrength = CTime::GetCurrentTime();
		
		int TempTimerResult = SetTimer(vShowSourceStrengthTimerHandle,100,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-Display Timer Failed",cEMailInspx,32000);
	}
	vSystemData.vInAutoSetup = false;
	if (TempAbort)
		ReportErrorMessage("Abort Measure Source Strength",cWriteToLog,0);
	else
		ReportErrorMessage("End Measure Source Strength", cWriteToLog,0);
}

void CScanTracDlg::DisplayWaitToSetupProduct()
{
	if (!vGlobalDisplayDialogThread)
	{
		vGlobalDisplayDialogThread = (CDisplayDialogThread *)AfxBeginThread(
			RUNTIME_CLASS(CDisplayDialogThread), THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
		if (!vGlobalDisplayDialogThread)
		{
			ReportErrorMessage("Error-Could Not Create Display Dialog Thread", cEMailInspx,32000); 
		}
		else
		{
			//vGlobalDisplayDialogThread->vMessageToDisplay = "\n\nEmergency Stop\nPlease Wait...";

			vGlobalDisplayDialogThread->vDisplaySplashScreenLogo = true;
			TempAfinity = (AFFINITYMASK_DISPLAY & vGlobalSystemAffinityMask );
			/*
			if ((TempAfinity != 0)&&(vGlobalSystemAffinityMask >= 0x0F))
			{
				if (vGlobalSystemAffinityMask == 0xFF)
					DWORD TempOriginalAffinityMask = ::SetThreadAffinityMask(vGlobalDisplayDialogThread->m_hThread, 0x04);
				else
				if (::SetThreadAffinityMask(vGlobalDisplayDialogThread->m_hThread,TempAfinity))
				{
					vReplyOK |= 0x08 ;
				}
			}
			*/
			vGlobalDisplayDialogThread->ResumeThread();
		}
	}
}

void CScanTracDlg::CloseWaitToSetupProduct()
{
	if (vGlobalDisplayDialogThread)
	{
		vGlobalDisplayDialogThread->ExitDisplayThread();
		vGlobalDisplayDialogThread = NULL;
	}
}

void CScanTracDlg::RemoveAllContainers()
{  //Remove all containers from collection as not running anymore
	vSystemData.vOutstandingEjects = 0;
	vSystemData.vOutstandingAuxiliaryDetectorEnables = 0;
	if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
	{
		if (vSystemData.vContainerCollection->GetCount() > 0)
		{
			CContainer *TempContainer = vSystemData.vContainerCollection->GetHead();
			//Check Each Containter until get one before timeout
			while (TempContainer != NULL)
			{
				if (vSystemData.vLogFile.vLogSerialData)
				{
					vSystemData.vLogFile.WriteToLogFile("ScanTracDlg:StopRunning-RemoveAllContainers:" + dtoa(TempContainer->vContainerNumber, 0),cDebugMessage);
				}
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->RemoveContainerFromCollection();
				//get next container to check
				if (vSystemData.vContainerCollection->GetCount() > 0)
					TempContainer = vSystemData.vContainerCollection->GetHead();
				else
					TempContainer = NULL;
			}  // while not done
		}  //end if have containers
		vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();
	}
}  //end function

void CScanTracDlg::ShowSourceStrengthData()
{
	CHelpDialog IHelpDialog;
	IHelpDialog.vHelpContext = 21;
	IHelpDialog.vHelpType = 0;
	IHelpDialog.vWindowType = cSourceStrengthWindow;
	IHelpDialog.vLocalProductCollection = &vProductCollection;
	IHelpDialog.vLocalSystemData = &vSystemData;
	IHelpDialog.vMainWindowPointer = this;
	IHelpDialog.vLocalConfigurationData = vConfigurationData;
	IHelpDialog.vProductPointer = vGlobalCurrentProduct;
	int TempResult = IHelpDialog.DoModal();
}

void CScanTracDlg::SendEMail(CString TempString, BYTE TempLevel)
{
	// e-mail comment out temporary as does not work 7/2/2012
	//BYTE TempSubjectIndex = -1;
	//if (TempLevel == cEMailPlantOperations)
	//	TempSubjectIndex = 0;
	//else
	//if (TempLevel == cEMailInspx)
	//	TempSubjectIndex = 1;
	//else
	//if (TempLevel == cEMailMaintenance)
	//	TempSubjectIndex = 2;
	//else
	//if (TempLevel == cEMailReport)
	//	TempSubjectIndex = 3;

	//if (TempSubjectIndex >= 0)
	//if (vConfigurationData->vEMailEnable[TempSubjectIndex])
	//if (vConfigurationData->vNumberOfEMailRecievers[TempSubjectIndex])
	//if (vConfigurationData->vEMailSubject[TempSubjectIndex] != "")
	//{
	//	BYTE TempUserIndex = cMaximumEMailRecievers * TempSubjectIndex;
	//	CTime TempTime;
	//	TempTime = CTime::GetCurrentTime();
	//	CString TempTimeString = TempTime.Format("%#I:%M:%S%p, %B %d, %Y");
	//	CString TempEMailString = TempTimeString + " > " + TempString;

	//	tagVARIANT var;
	//	CMapiSession MapiSession;
	//	MapiSession.Create(NULL,WS_DISABLED,CRect(0,0,0,0),vGlobalMainWindowPointer,1);
	//	CMapiMessages MapiMessage;
	//	MapiMessage.Create(NULL,WS_DISABLED,CRect(0,0,0,0),vGlobalMainWindowPointer,1);
	//	//UpdateData(true);
	//	if (MapiSession.GetSessionID() == 0) 
	//		MapiSession.SignOn();
	//	MapiMessage.SetSessionID(MapiSession.GetSessionID());
	//	MapiMessage.Compose();
	//	for (BYTE TempLoop = 0;  TempLoop < vConfigurationData->vNumberOfEMailRecievers[TempSubjectIndex]; TempLoop++)
	//	{
	//		if ((vConfigurationData->vEMailUser[TempUserIndex + TempLoop] != "") && (vConfigurationData->vEMailDomain[TempUserIndex + TempLoop] != ""))
	//		{
	//			MapiMessage.SetRecipIndex(MapiMessage.GetRecipCount());
	//			MapiMessage.SetRecipType(1);
	//			MapiMessage.SetRecipDisplayName(vConfigurationData->vEMailUser[TempUserIndex + TempLoop] + "@" + vConfigurationData->vEMailDomain[TempUserIndex + TempLoop]);
	//		}
	//	}

	//	MapiMessage.ResolveName();

	//	MapiMessage.SetMsgSubject(vConfigurationData->vEMailSubject[TempSubjectIndex] + " From: " + vConfigurationData->vScanTracID);
	//	MapiMessage.SetMsgNoteText(TempEMailString);
	//	MapiMessage.SetAddressResolveUI(true);
	//	VariantInit(&var);
	//	var.vt = VT_BOOL;
	//	var.boolVal = false;
	//	MapiMessage.Send(var);
	//	MapiSession.SignOff();
	//}
}


void CScanTracDlg::SaveReportStartTime()
{
	vSystemData.vReportingPeriodStartTime = CTime::GetCurrentTime();
}

void CScanTracDlg::GenerateProductionReport(BYTE TempReason)
{ //Reason: 0=Manual, 1=Select Product or Lost Power, 2=?, 3=Reset Counters, 4=Configured Time, 5=?, 6=Stop-Run Incomplete, 7=Time Update-Run Incomplete
	bool TempHaveNewDataToWrite = true;
	if ((TempReason == cStopInspectingProductionReport) ||	(TempReason == cTimeUpdateProductoinReport))
	if (vLastProductionReportCount == vSystemData.vTotalContainers)
		TempHaveNewDataToWrite = false;

	if (TempHaveNewDataToWrite)
	if (vSystemData.vTotalContainers > 0)
	if (vGlobalCurrentProduct)
	{
		CFileStatus TempFileStatus;
		CFileStatus TempFileServerStatus;
		CString TempTimeString;
		CString TempDirectoryString;
		CString TempFileNameString;
		LPCTSTR TempFileNameStringPtr;

		CString TempStringDirectorySSD = cScanTracProductionReportDirectory;
		CString TempStringDirectoryServerSSD = vConfigurationData->vScanTracProductionReportDirectory;
		TempStringDirectorySSD.Delete(TempStringDirectorySSD.GetLength() -1, 1);
		TempStringDirectoryServerSSD.Delete(TempStringDirectoryServerSSD.GetLength() -1, 1);
		LPTSTR TempStringDirectorySSDP = TempStringDirectorySSD.GetBuffer(TempStringDirectorySSD.GetLength());
		LPTSTR TempStringDirectoryServerSSDP = TempStringDirectoryServerSSD.GetBuffer(TempStringDirectoryServerSSD.GetLength());
		
		CString TempCSVFileHeaderString = "-";
		CString TempCSVFileString = "-";
		// if directory exists
		if ((CFile::GetStatus(TempStringDirectorySSDP, TempFileStatus)) || ((CompareBit(vGlobalShadowImages,cShadowProductionReportBit) == cShadowProductionReportBit) && (CFile::GetStatus(TempStringDirectoryServerSSDP, TempFileServerStatus))))
		{
			//fill in header row
			char TempFieldSeperator = ',';
			if (vGlobalUseCommaForDecimalPoint)
				TempFieldSeperator = ';';

			TempCSVFileHeaderString = "Product Code";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "ScanTrac ID";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Report Generated By";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Start Time";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "End Time";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Duration";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Product";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;

			if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))	// bulk mode
				TempCSVFileHeaderString = TempCSVFileHeaderString + "Total";
			else
				TempCSVFileHeaderString = TempCSVFileHeaderString + "Total Containers";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Total Ejected";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "% Ejected";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Total Rejected";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "% Rejected";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Total Good";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Production Stops";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Production Stop Duration";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Production Run Duration";
			TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
			TempCSVFileHeaderString = TempCSVFileHeaderString + "Shift Rate (CPM)";


			for (BYTE TempLoop = 0; TempLoop < vSystemData.vTotalNumberOfInspections; TempLoop++)
			{
				TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
				TempCSVFileHeaderString = TempCSVFileHeaderString + vSystemData.vCriteriaString[TempLoop];

				TempCSVFileHeaderString = TempCSVFileHeaderString + TempFieldSeperator;
				TempCSVFileHeaderString = TempCSVFileHeaderString + vSystemData.vCriteriaString[TempLoop] + " but disabled";
			}
			TempCSVFileHeaderString = TempCSVFileHeaderString + (char)0x0D;
			//done making header strong

			WORD TempHeaderLength = TempCSVFileHeaderString.GetLength();
			//start filling in data
			TempCSVFileString = vSystemData.vShiftProductCode;
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			vSystemData.vLastReport = "ScanTrac Production Report from " + vConfigurationData->vScanTracID;

			TempCSVFileString = TempCSVFileString + vConfigurationData->vScanTracID;
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			CString TempString = "Operator Manual Action";
			switch (TempReason)
			{
				case cManualProductionReport: TempString = "Manual Report"; break;
				case cSelectProductProductionReport: TempString = "Product Change"; break;
				case cShiftChangeProductionReport: TempString = "Shift Change"; break;
				case cResetCountersProductionReport: TempString = "Clearing Counters"; break;
				case cTimeSetupProductionReport: TempString = "Auto Report"; break;
				case cAutoSetupProductionReport: TempString = "Auto Setup"; break;
				case cStopInspectingProductionReport: TempString = "Stop-Run Incomplete"; break;
				case cTimeUpdateProductoinReport: TempString = "Time Update-Run Incomplete"; break;
				case cChangedInspectionsWhileRunning: TempString = "Changed Inspections While Inspecting"; break;
			}

			TempCSVFileString = TempCSVFileString + TempString;
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			CTime TempTime;
			TempTime = CTime::GetCurrentTime();
			CString TempTimeEnd = " ";
			if (vConfigurationData->vShow24HourTime)
				TempTimeEnd = TempTime.Format("%B %d %Y %H:%M:%S");//24 hour time format
			else
				TempTimeEnd = TempTime.Format("%B %d %Y %#I:%M:%S%p");//am pm time format

			CString TempTimeStart = " ";
			if (vConfigurationData->vShow24HourTime)
				TempTimeStart = vSystemData.vReportingPeriodStartTime.Format("%B %d %Y %H:%M:%S");//24 hour time format
			else
				TempTimeStart = vSystemData.vReportingPeriodStartTime.Format("%B %d %Y %#I:%M:%S%p");//am pm time format

			TempCSVFileString = TempCSVFileString + TempTimeStart;
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;
			TempCSVFileString = TempCSVFileString + TempTimeEnd;
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;
			
			CTimeSpan TempDeltaTime;
			TempDeltaTime = TempTime - vSystemData.vReportingPeriodStartTime;
			CString TempTimeStringDelta = TempDeltaTime.Format("%H:%M:%S %D");

			vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Production Duration: " + FormatRunTimeCounterString(vSystemData.vTotalDuration);

			TempCSVFileString = TempCSVFileString + TempTimeStringDelta + " days";
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;
			
			vSystemData.vLastReport = vSystemData.vLastReport + "\n\n" + "Product Code/Shift/Operator: " + vSystemData.vShiftProductCode;
			vSystemData.vLastReport = vSystemData.vLastReport + " \n" + "Report generated by: " + TempString;
			vSystemData.vLastReport = vSystemData.vLastReport + " \n" + "Start time: " + TempTimeStart;
			vSystemData.vLastReport = vSystemData.vLastReport + " \n" + "End time: " + TempTimeEnd;
			vSystemData.vLastReport = vSystemData.vLastReport + " \n" + "Duration: " + TempTimeStringDelta + " days";

			vSystemData.vLastReport = vSystemData.vLastReport + "\n\n" + "Product: " + *vGlobalCurrentProduct->GetProductName();

			TempCSVFileString = TempCSVFileString + *vGlobalCurrentProduct->GetProductName();
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			if (vGlobalCurrentProduct->vNotes.GetLength())
			if (vGlobalCurrentProduct->vNotes != "None")
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Product Notes: " + vGlobalCurrentProduct->vNotes;

			vSystemData.vLastReport = vSystemData.vLastReport + "\nDate product setup: " + vGlobalCurrentProduct->vHistoryTookAverageDate;

			char TempChars[100] = "";
			if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))	// bulk mode
				vSystemData.vLastReport = vSystemData.vLastReport + "\n\n" + "Total: " + dtoa(vSystemData.vTotalContainers, 0);
			else
				vSystemData.vLastReport = vSystemData.vLastReport + "\n\n" + "Total Containers: " + dtoa(vSystemData.vTotalContainers, 0);

			TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vTotalContainers, 0);
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Total Ejected: " + dtoa(vSystemData.vEjectCountTotal, 0);

			TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vEjectCountTotal, 0);
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			TempString = dtoa(vSystemData.vPercentEjected,2);
			vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Percent Ejected: " + TempString;

			TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vPercentEjected,4);
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			if (vSystemData.vMissedEjectsBecauseDisabledCount)
			{
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Total Rejected: " + dtoa(vSystemData.vRejectCountTotal,0);
				TempString = dtoa(vSystemData.vPercentRejected,2);
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Percent Rejected: " + TempString;
			}

			TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vRejectCountTotal,0);
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vPercentRejected,3);
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Total Good: " + dtoa(vSystemData.vGoodCountTotal, 0);

			TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vGoodCountTotal, 0);
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			vSystemData.vLastReport = vSystemData.vLastReport + "\n\n" + "Production Stops: " + dtoa(vSystemData.vProductionStopsCount, 0);

			TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vProductionStopsCount, 0);
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Production Stop Duration: " + FormatRunTimeCounterString(vSystemData.vStopDuration);

			TempCSVFileString = TempCSVFileString + FormatRunTimeCounterString(vSystemData.vStopDuration);
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;

			vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Production Run Duration: " + FormatRunTimeCounterString(vSystemData.vRunDuration);

			TempCSVFileString = TempCSVFileString + FormatRunTimeCounterString(vSystemData.vRunDuration);
			TempCSVFileString = TempCSVFileString + TempFieldSeperator;
			TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vShiftRateCPM,0);

			vSystemData.vLastReport = vSystemData.vLastReport + "\n" +
				"Shift Rate (CPM): " + dtoa(vSystemData.vShiftRateCPM,0);

			if (vSystemData.vTotalConfirmed)
				vSystemData.vLastReport = vSystemData.vLastReport + "\n\n" + "Total Confirmed Ejects: " + dtoa(vSystemData.vTotalConfirmed, 0);

			if (vSystemData.vTotalUnConfirmed)
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Total UnConfirmed Ejects: " + dtoa(vSystemData.vTotalUnConfirmed, 0);

			vSystemData.vLastReport = vSystemData.vLastReport + "\n\nInspection Reject Counts:";

			BYTE TempEndLoopCount = vSystemData.vTotalNumberOfInspections;
			for (BYTE TempLoop = 0; TempLoop < TempEndLoopCount; TempLoop++)
			{
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + vSystemData.vCriteriaString[TempLoop] + ": " + dtoa(vSystemData.vXRayCriteriaCount[TempLoop], 0);

				TempCSVFileString = TempCSVFileString + TempFieldSeperator;
				TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vXRayCriteriaCount[TempLoop], 0);

				if (vSystemData.vXRayCriteriaCountButDisabled[TempLoop])
					vSystemData.vLastReport = vSystemData.vLastReport + "\n" + vSystemData.vCriteriaString[TempLoop] + " but disabled: " + dtoa(vSystemData.vXRayCriteriaCountButDisabled[TempLoop], 0);

				TempCSVFileString = TempCSVFileString + TempFieldSeperator;
				TempCSVFileString = TempCSVFileString + dtoa(vSystemData.vXRayCriteriaCountButDisabled[TempLoop], 0);
			}
			vSystemData.vLastReport = vSystemData.vLastReport + "\n";
			for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
			{
				if (vConfigurationData->vEjector[TempLoop].vEnabled)
				if (vSystemData.vEjectorCount[TempLoop])
				{
					vSystemData.vLastReport = vSystemData.vLastReport + "\n" + vConfigurationData->vEjector[TempLoop].vName + " Ejects: " + dtoa(vSystemData.vEjectorCount[TempLoop], 0);

					if (vSystemData.vEjectorConfirmCount[TempLoop])
						vSystemData.vLastReport = vSystemData.vLastReport + "\n" + vConfigurationData->vEjector[TempLoop].vName + " Confirmed: " + dtoa(vSystemData.vEjectorConfirmCount[TempLoop], 0);
				}
			}
			vSystemData.vLastReport = vSystemData.vLastReport + "\n";
			vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Container Triggers: " + dtoa(vSystemData.vBodyTriggersCount, 0);
			vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Valid Container Triggers: " + dtoa(vSystemData.vValidBodyTriggersCount, 0);
			if (vGlobalCurrentProduct->vBackupBodyTrigger)
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Backup Container Triggers: " + dtoa(vSystemData.vBackupBodyTriggersCount, 0);

			vSystemData.vLastReport = vSystemData.vLastReport + "\n";
			if (vSystemData.vIncompleteDataCount)
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Incomplete Data: " + dtoa(vSystemData.vIncompleteDataCount, 0);

			if (vSystemData.vProcessingErrorCount)
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Processing Error: " + dtoa(vSystemData.vProcessingErrorCount, 0);

			if (vSystemData.vTooLateToEjectErrorCount)
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Too Late To Eject: " + dtoa(vSystemData.vTooLateToEjectErrorCount, 0);

			if (vSystemData.vMissedEjectsBecauseDisabledCount)
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Missed Ejects Because Ejectors Disabled: " + dtoa(vSystemData.vMissedEjectsBecauseDisabledCount, 0);
			
			if (vSystemData.vImageReferenceErrorCount)
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Reference Error: " + dtoa(vSystemData.vImageReferenceErrorCount, 0);

			if (vSystemData.vRealImageCountTotal)
				vSystemData.vLastReport = vSystemData.vLastReport + "\n" + "Real Images Processed: " + dtoa(vSystemData.vRealImageCountTotal, 0);

				//gives text report like shown in Production Report Menu
#ifdef CompileInHTTPClientOperationsGuardian
			if (TempReason <= cAutoSetupProductionReport)
				SendOGInfo(std::wstring(L"productreport"), vSystemData.vLastReport, false);
#endif
			//Write Production Report to a CSV File on local drive
			TempTime = CTime::GetCurrentTime();
			TempTimeString = TempTime.Format("%m-%d-%Y-%H-%M-%S");
			CFileException TempFileException;
			TempDirectoryString = cScanTracProductionReportDirectory;
			TempFileNameString = TempDirectoryString + "ScanTracProductionReportSummary.CSV";
			TempFileNameStringPtr = TempFileNameString.GetBuffer(TempFileNameString.GetLength());
			//char TempChars[100];

			if (CFile::GetStatus(TempFileNameStringPtr, TempFileStatus))
			{ //summary file exists, so open it and add a line
				if (ThereIsEnoughMemory(sizeof(CFile), "Production Report File"))
				{
					CFile *TempProductionReportFile = new CFile;
					if (TempProductionReportFile)
					{
						if (TempProductionReportFile->Open(TempFileNameStringPtr, (CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException))
						{
							if ((TempProductionReportFile->m_hFile) && (TempProductionReportFile->m_hFile != INVALID_HANDLE_VALUE))
							{
								CString TempOldHeaderString = " ";
								ULONGLONG TempFileIndex = 0;
								ULONGLONG TempLength = 0;
								bool TempThisIsTheFirstLoop = true;

								TRY
								{
									TempProductionReportFile->SeekToEnd();
								}
								CATCH_ALL(TempFileException)
								{
									ReportErrorMessage("Failed SeekToEnd of AC Production Report", cEMailInspx, 32000);
								}
								END_CATCH_ALL

								//find old header string in file
								
								int i = 0;
								ULONGLONG ByteCountTotal;
								ByteCountTotal = 0;

								while ((TempOldHeaderString.Find(_T("Product Code")) == -1) && (ByteCountTotal < TempFileStatus.m_size))
								{
									TempOldHeaderString = " ";

									for (i++; i < 100; i++) //condition is random, the code will break out of the for loop below
									{
										if ((i%10) == 0)
										{
											i = 0;
											if (TempThisIsTheFirstLoop == true)
											{
												TempFileIndex = TempProductionReportFile->Seek(-10, CFile::current);
												TempThisIsTheFirstLoop = false;

												TempLength = TempProductionReportFile->Read(TempChars,10);
												ByteCountTotal = ByteCountTotal + TempLength;
												if (TempLength < 10) //something not right, didn't get back expected amount of chars from read
													break;
											}
											else
											{
												TempFileIndex = TempProductionReportFile->Seek(0, CFile::current);

												if (TempFileIndex >= 20)
												{
													TempFileIndex = TempProductionReportFile->Seek(-20, CFile::current);
													TempLength = TempProductionReportFile->Read(TempChars,10);
													ByteCountTotal = ByteCountTotal + TempLength;
													if (TempLength < 10) //something not right, didn't get back expected amount of chars from read
														break;
												}
												else 
												if (TempFileIndex > 10)
												{
													TRY
													{
														TempProductionReportFile->SeekToBegin();
													}
													CATCH_ALL(TempFileException)
													{
														ReportErrorMessage("Failed SeekToBegin of Production Report", cEMailInspx, 32000);
													}
													END_CATCH_ALL
												
													TempLength = TempProductionReportFile->Read(TempChars, (UINT)(TempFileIndex-10));
													ByteCountTotal = TempFileStatus.m_size;

													i = (int)(20 - TempFileIndex);
													if (TempLength < (TempFileIndex-10)) //something not right, didn't get back expected amount of chars from read
														break;

													TempFileIndex = 0;
												}
												else
												{
													ByteCountTotal = TempFileStatus.m_size;
													break;
												}
											}
										}

//										if (TempChars[9 - i] == ',')
//										{
//											TempDataCount++;
//										}

										if (TempChars[9 - i] == (char)13)
												break;

										if (TempChars[9 - i] == (char)10)
											continue;

										TempOldHeaderString.Insert(0,TempChars[9-i]);
									}

								}

								TempOldHeaderString.Delete((TempOldHeaderString.GetLength() - 1), 1);
								TempOldHeaderString = TempOldHeaderString + (char)13;
								int TempOldHeaderStringLength = TempOldHeaderString.GetLength();
								int TempCSVFileHeaderStringLength = TempCSVFileHeaderString.GetLength();

								//add string to end of existing local disk file
								CString TempStringToWrite = TempCSVFileString;
								if (TempOldHeaderString.Compare(TempCSVFileHeaderString) != 0)
									TempStringToWrite = (char)0x0D + TempCSVFileHeaderString + TempStringToWrite;
								else
									TempStringToWrite = (char)0x0D + TempCSVFileString;

								//need to see if counters and type are different if type 6 or 7
								//read in current production report
								TempProductionReportFile->Close();
								int TempPosition = -1;
								int TempReportLength = vProductionReportString.GetLength();
								int TempStartSeachPosition = 0;

								if ((vLastProductionReportType == cStopInspectingProductionReport) || (vLastProductionReportType == cTimeUpdateProductoinReport)) //if it is a Run Incomplete type, then check if there is a previous one to overwrite
								{
									ReadInProductionReport(false);
									TempReportLength = vProductionReportString.GetLength();
									if (TempReportLength > 500)
										TempStartSeachPosition = TempReportLength - 500;

									TempPosition = vProductionReportString.Find(_T("Stop-Run Incomplete"), TempStartSeachPosition);
								}
								if (TempPosition != -1) //found a temporary production report, so replace it
								{
									if (TempPosition > 60)
										TempPosition = TempPosition - 60; //back up to find the end of the previous line
									else
										TempPosition = 0;

									int TempPositionOfCR = vProductionReportString.Find((char)0x0D, TempPosition); //find the beginning of this line

									if (TempPositionOfCR == -1)
										ReportErrorMessage("Did not find CR at start of Production Report Line to replace", cEMailInspx, 32000);
									else
									{
										int TempNumberOfCharactersToDelete = vProductionReportString.GetLength() - TempPositionOfCR;
										vProductionReportString.Delete(TempPositionOfCR, TempNumberOfCharactersToDelete); //remove old temporary section to replace with updated section

										vProductionReportString = vProductionReportString + TempStringToWrite;
										TempReportLength = vProductionReportString.GetLength();

										WriteOutProductionReport(false);
									}
								}
								else
								{
									TempPosition = vProductionReportString.Find(_T("Time Update-Run Incomplete"), TempStartSeachPosition);
									if (TempPosition != -1)
									{
										if (TempPosition > 60)
											TempPosition = TempPosition - 60; //back up to find the end of the previous line
										else
											TempPosition = 0;

										int TempPositionOfCR = vProductionReportString.Find((char)0x0D, TempPosition); //find the beginning of this line

										if (TempPositionOfCR == -1)
											ReportErrorMessage("Did not find CR at start of Production Report Line to replace", cEMailInspx, 32000);
										else
										{
											int TempNumberOfCharactersToDelete = vProductionReportString.GetLength() - TempPositionOfCR;
											vProductionReportString.Delete(TempPositionOfCR, TempNumberOfCharactersToDelete); //remove old temporary section to replace with updated section

											vProductionReportString = vProductionReportString + TempStringToWrite;

											WriteOutProductionReport(false);
										}
									}
									else
									{ //just add this line to the end of the production report
										if (TempProductionReportFile->Open(TempFileNameStringPtr, (CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException))
										TRY
										{
											TempProductionReportFile->SeekToEnd();
										}
										CATCH_ALL(TempFileException)
										{
											ReportErrorMessage("Failed SeekToEnd of Production Report", cEMailInspx, 32000);
										}
										END_CATCH_ALL

										//write new line in Production Report Now to local file
										TempLength = TempStringToWrite.GetLength();
										if (TempLength)
										{
											CW2A TempStringToWrite2(TempStringToWrite);
											TempProductionReportFile->Write(TempStringToWrite2, (UINT)TempLength);
										}
										TempProductionReportFile->Close();
									}
								}
							}
							else
								ReportErrorMessage("Failed to Write Production Report CSV File to Server",cEMailMaintenance,0);
						}
						else
							ReportErrorMessage("Failed to Write Production Report CSV File to Server",cEMailMaintenance,0);
						delete TempProductionReportFile;
					}
				}
			}
			else
			{ //summary file does not exist, so write new summary file to local hard drive
				if (ThereIsEnoughMemory(sizeof(CFile), "Production Report File"))
				{
					CFile *TempProductionReportFile = new CFile;
					if (TempProductionReportFile)
					{
						if (TempProductionReportFile->Open(TempFileNameStringPtr, (CFile::modeCreate | CFile::modeReadWrite), &TempFileException))
						{
							CString TempStringToWrite = TempCSVFileHeaderString + TempCSVFileString;
							WORD TempLength = TempStringToWrite.GetLength();
							if (TempLength)
							{
								CW2A TempStringToWrite2(TempStringToWrite);
								TempProductionReportFile->Write(TempStringToWrite2, TempLength);
							}
							TempProductionReportFile->Close();
						}
						else
						{
							//could not open serial log file
							#ifdef _DEBUG
								afxDump << "Could Not Open Production Report File"  << "\n";
							#endif
							ReportErrorMessage("Failed to Write Production Report CSV File to Server",cEMailMaintenance,0);
						}
						delete TempProductionReportFile;
					}
				}
			}
			// put write to server here 
			bool TempWriteToServer = false;
			//if TempStringDirectoryServerSSDP != c: or d: and cant write to, flag a yellow message //kjh here *
			if ((vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'C') && (vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'D') &&
				(vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'c') && (vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'd'))
			{
				TempStringDirectoryServerSSDP = vConfigurationData->vScanTracProductionReportDirectory.GetBuffer(vConfigurationData->vScanTracProductionReportDirectory.GetLength());
				if (CFile::GetStatus(TempStringDirectoryServerSSDP, TempFileServerStatus))
				{
					TempWriteToServer = true;
					SetBit(vGlobalShadowImages,cShadowProductionReportBit);
				}
				else
				{
					ClrBit(vGlobalShadowImages,cShadowProductionReportBit);
					// generate yellow message
					if (vGlobalCountErrorMsgPossibleDirectoryNotAvailableSent == 0)
					{
						ReportErrorMessage("Error-Could Not Write Report, Server Not Available", cEMailMaintenance, 0);
						vGlobalCountErrorMsgPossibleDirectoryNotAvailableSent++;
					}
				}
			}
			if (TempWriteToServer == true)
			{
				//Write Production Report Summary to a CSV File
				TempDirectoryString = vConfigurationData->vScanTracProductionReportDirectory;
				TempFileNameString = TempDirectoryString + "ScanTracProductionReportSummary.CSV";
				TempFileNameStringPtr = TempFileNameString.GetBuffer(TempFileNameString.GetLength());

				TRY
				{
					if (CFile::GetStatus(TempFileNameStringPtr, TempFileStatus))
					{ //summary file exists, so open it and add a line to file on Server
						if (ThereIsEnoughMemory(sizeof(CFile), "Production Report File"))
						{
							CFile *TempProductionReportFile = new CFile;
							if (TempProductionReportFile)
							{
								if (TempProductionReportFile->Open(TempFileNameStringPtr, (CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException))
								{
									if ((TempProductionReportFile->m_hFile) && (TempProductionReportFile->m_hFile != INVALID_HANDLE_VALUE))
									{
										CString TempOldHeaderString = " ";
										ULONGLONG TempFileIndex = 0;
										ULONGLONG TempLength = 0;
										bool TempThisIsTheFirstLoop = true;

											TempProductionReportFile->SeekToEnd();

										//find old header string in file
								
										int i = 0;
										ULONGLONG ByteCountTotal;
										ByteCountTotal = 0;
										while ((TempOldHeaderString.Find(_T("Product Code")) == -1) && (ByteCountTotal < TempFileStatus.m_size))		// causes infinte loop when not found . . . sigh kjh 9/2012
										{
											TempOldHeaderString = " ";

											for (i++; i < 100; i++) //condition is random, the code will break out of the for loop below
											{
												if ((i%10) == 0)
												{
													i = 0;
													if (TempThisIsTheFirstLoop == true)
													{
														TempFileIndex = TempProductionReportFile->Seek(-10, CFile::current);
														TempThisIsTheFirstLoop = false;

														TempLength = TempProductionReportFile->Read(TempChars,10);
														ByteCountTotal = ByteCountTotal + TempLength;
														if (TempLength < 10) //something not right, didn't get back expected amount of chars from read
															break;
													}
													else
													{
														TempFileIndex = TempProductionReportFile->Seek(0, CFile::current);

														if (TempFileIndex >= 20)
														{
															TempFileIndex = TempProductionReportFile->Seek(-20, CFile::current);
															TempLength = TempProductionReportFile->Read(TempChars,10);
															ByteCountTotal = ByteCountTotal + TempLength;
															if (TempLength < 10) //something not right, didn't get back expected amount of chars from read
																break;
														}
														else 
														if (TempFileIndex > 10)
														{
															TempProductionReportFile->SeekToBegin();
												
															TempLength = TempProductionReportFile->Read(TempChars, (UINT)(TempFileIndex-10));

															ByteCountTotal = TempFileStatus.m_size;
															i = (int)(20 - TempFileIndex);
															if (TempLength < (TempFileIndex-10)) //something not right, didn't get back expected amount of chars from read
																break;

															TempFileIndex = 0;
														}
														else
														{
															ByteCountTotal = TempFileStatus.m_size;
															break;
														}
													}
												}

		//										if (TempChars[9 - i] == ',')
		//										{
		//											TempDataCount++;
		//										}

												if ( TempChars[9 - i] == (char)13 )
														break;

												if ( TempChars[9 - i] == (char)10 )
													continue;

												TempOldHeaderString.Insert(0,TempChars[9-i]);
											}
										}

										TempOldHeaderString.Delete((TempOldHeaderString.GetLength() - 1),1);
										TempOldHeaderString = TempOldHeaderString + (char)13;

										int TempPosition = -1;
										int TempReportLength = vProductionReportString.GetLength();
										int TempStartSeachPosition = 0;

										if ((vLastProductionReportType == cStopInspectingProductionReport) || (vLastProductionReportType == cTimeUpdateProductoinReport)) //if it is a Run Incomplete type, then check if there is a previous one to overwrite
										{
											ReadInProductionReport(true);
											TempReportLength = vProductionReportString.GetLength();
											if (TempReportLength > 500)
												TempStartSeachPosition = TempReportLength - 500;

											TempPosition = vProductionReportString.Find(_T("Stop-Run Incomplete"), TempStartSeachPosition);
										}
										if (TempPosition != -1) //found a temporary production report, so replace it
										{
											if (TempPosition > 60)
												TempPosition = TempPosition - 60; //back up to find the end of the previous line
											else
												TempPosition = 0;

											int TempPositionOfCR = vProductionReportString.Find((char)0x0D, TempPosition); //find the beginning of this line

											if (TempPositionOfCR == -1)
												ReportErrorMessage("Did not find CR at start of Production Report Line to replace", cEMailInspx, 32000);
											else
											{
												int TempNumberOfCharactersToDelete = vProductionReportString.GetLength() - TempPositionOfCR;
												vProductionReportString.Delete(TempPositionOfCR, TempNumberOfCharactersToDelete); //remove old temporary section to replace with updated section

												vProductionReportString = vProductionReportString + (char)0x0D + TempCSVFileString;
												TempReportLength = vProductionReportString.GetLength();

												WriteOutProductionReport(true);
											}
										}
										else
										{
											TempPosition = vProductionReportString.Find(_T("Time Update-Run Incomplete"), TempStartSeachPosition);
											if (TempPosition != -1)
											{
												if (TempPosition > 60)
													TempPosition = TempPosition - 60; //back up to find the end of the previous line
												else
													TempPosition = 0;

												int TempPositionOfCR = vProductionReportString.Find((char)0x0D, TempPosition); //find the beginning of this line

												if (TempPositionOfCR == -1)
													ReportErrorMessage("Did not find CR at start of Production Report Line to replace", cEMailInspx, 32000);
												else
												{
													int TempNumberOfCharactersToDelete = vProductionReportString.GetLength() - TempPositionOfCR;
													vProductionReportString.Delete(TempPositionOfCR, TempNumberOfCharactersToDelete); //remove old temporary section to replace with updated section on server

													vProductionReportString = vProductionReportString + (char)0x0D + TempCSVFileString;

													WriteOutProductionReport(true);
												}
											}
											else
											{ //just add this line to the end of the production report
												//write production report to end of file on server
												CString TempStringToWrite = TempCSVFileString;
												if (TempOldHeaderString.Compare(TempCSVFileHeaderString) != 0)
													TempStringToWrite = (char)0x0D + TempCSVFileHeaderString + TempStringToWrite;
												else
													TempStringToWrite = (char)0x0D + TempCSVFileString;

												TempProductionReportFile->SeekToEnd();
												TempLength = TempStringToWrite.GetLength();
												if (TempLength)
												{
													CW2A TempStringToWrite2(TempStringToWrite);
													TempProductionReportFile->Write(TempStringToWrite2, (UINT)TempLength);
												}
												TempProductionReportFile->Close();
											}
										}
									}
									else
										ReportErrorMessage("Failed to Write Production Report CSV File to Server",cEMailMaintenance,0);
								}
								else
									ReportErrorMessage("Failed to Write Production Report CSV File to Server",cEMailMaintenance,0);
								delete TempProductionReportFile;
							}
						}
					}
					else
					{ //summary file does not exist, so write new summary file on Server
						if (ThereIsEnoughMemory(sizeof(CFile), "Production Report File"))
						{
							CFile *TempProductionReportFile = new CFile;
							if (TempProductionReportFile)
							{
								if (TempProductionReportFile->Open(TempFileNameStringPtr, (CFile::modeCreate | CFile::modeReadWrite), &TempFileException))
								{
									CString TempStringToWrite = TempCSVFileHeaderString + TempCSVFileString;

									WORD TempLength = TempStringToWrite.GetLength();
									if (TempLength)
									{
										CW2A TempStringToWrite2(TempStringToWrite);
										TempProductionReportFile->Write(TempStringToWrite2, TempLength);
									}
									TempProductionReportFile->Close();
								}
								else
								{
									//could not open serial log file
									#ifdef _DEBUG
										afxDump << "Could Not Open Production Report File"  << "\n";
									#endif
									ReportErrorMessage("Failed to Write Production Report CSV File to Server",cEMailMaintenance,0);
								}
								delete TempProductionReportFile;
							}
						}
					}
				}
				CATCH_ALL(TempFileException)
				{
					ReportErrorMessage("Failed SeekToEnd of AC Production Report", cEMailInspx, 32000);
				}
				END_CATCH_ALL
			}
		}
		else
		{
			ReportErrorMessage("Could not access Server to write Production Report",cEMailMaintenance, 32000);
		}
		vLastProductionReportCount = vSystemData.vTotalContainers;
		vLastProductionReportType = TempReason;
	}
}

void CScanTracDlg::SendProductionReport(BYTE TempReason)
{
	if (vConfigurationData)
//	if (vConfigurationData->vScanTracProductionReportDirectory.GetLength() > 3)
	{
		CString TempStringSSD = cScanTracProductionReportDirectory;
		TempStringSSD.Delete(TempStringSSD.GetLength() -1, 1);
		LPTSTR TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
		CFileStatus TempFileStatus;
		if (CFile::GetStatus(TempStringSSDP, TempFileStatus))
		{
			int TempGoodReport = vSystemData.vLastReport.Find(_T("None Generated"));
			if (!vConfigurationData->vDemoMode)
			if (TempGoodReport == -1)  //did not find "None Generated" so it is a real report
			{
				//Write Production Report
				/*
				CTime TempTime;
				TempTime = CTime::GetCurrentTime();
				//CString TempTimeString = TempTime.Format("%d-%B-%Y-%H-%M-%S");
				CString TempTimeString = TempTime.Format("%m-%d-%Y-%H-%M-%S");
				CString TempDirectoryString(vConfigurationData->vScanTracProductionReportDirectory);
				TempTimeString = TempDirectoryString + "ScanTracProductionReport" + TempTimeString + ".txt";
				LPCTSTR TempFileName = TempTimeString;
				CFileException TempFileException;
				if (ThereIsEnoughMemory(sizeof(CFile), "Production Report File"))
				{
					CFile *TempProductionReportFile = new CFile;
					if (TempProductionReportFile)
					{
						if (TempProductionReportFile->Open(TempFileName, (CFile::modeCreate | CFile::modeReadWrite), &TempFileException))
						{
							WORD TempLength = vSystemData.vLastReport.GetLength();
							if (TempLength)
								TempProductionReportFile->Write(vSystemData.vLastReport, TempLength);
							TempProductionReportFile->Close();
						}
						else
						{
							//could not open serial log file
							#ifdef _DEBUG
								afxDump << "Could Not Open Production Report File"  << "\n";
							#endif
							ReportErrorMessage("Failed to Write Production Report File to Disk",cError,0);
						}
						delete TempProductionReportFile;
					}
				}
				*/

				SendEMail(vSystemData.vLastReport,cEMailReport);
		/*
				if (TempReason == 2)  //2 = changed shifts,  0 = Manually generate report from Display window
				{  // 1 = Changed Products, Setup Product, 3 = Reset Counters
					CHelpDialog IHelpDialog;
					IHelpDialog.vHelpContext = 21;
					IHelpDialog.vHelpType = 0;
					IHelpDialog.vWindowType = cProductionReportWindow;
					IHelpDialog.vLocalProductCollection = &vProductCollection;
					IHelpDialog.vLocalSystemData = &vSystemData;
					IHelpDialog.vMainWindowPointer = this;
					IHelpDialog.vLocalConfigurationData = vConfigurationData;
					IHelpDialog.vProductPointer = vGlobalCurrentProduct;
					int TempResult = IHelpDialog.DoModal();
				}
				*/
			}
		}
	}
}

void CScanTracDlg::CheckLamps()
{
	KillTimer(vCheckLampsTimerHandle);
	int TimerResult = SetTimer(vCheckLampsTimerHandle,1000,NULL);//cSplashScreenDelay,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-Check Lamps Timer Failed",cEMailInspx,32000);
}

void CScanTracDlg::DisableEjectorsInXSeconds(WORD TempMilliSeconds)
{
	KillTimer(vCheckLampsTimerHandle);
	int TimerResult = SetTimer(vDisableEjectorsTimerHandle,TempMilliSeconds,NULL);//cSplashScreenDelay,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-Disable Ejectors Timer Failed",cEMailInspx,32000);
}

void CScanTracDlg::EnableDisableEjectors(bool TempEnable)
{
	if (TempEnable)
	{
		if (!vConfigurationData->vEnableEjectors)
		{
#ifdef CompileInHTTPClientOperationsGuardian
			SendOGInfo(std::wstring(L"ejectorstatus"), "Enabled", false);
#endif

			vConfigurationData->vEnableEjectors = true;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->EnableDisableEjectors(vConfigurationData->vEnableEjectors);
			UpdateDisableEjectorsButton();
			WriteConfigurationDataToFile(false); //write to main config file

			//Kill yellow light if the system is running properly
			if (!vSystemData.vCantInspectError)
			{
				KillTimer(vFlashYellowLightTimerHandle);
				if (vGlobaluCSerialPort)
				if (vSystemData.vYellowMessageButtonYellow)
					vGlobaluCSerialPort->TurnOnOffYellowLamp(true);
				else
					vGlobaluCSerialPort->TurnOnOffYellowLamp(false);
			}
		}
	}
	else
	if (vConfigurationData->vEjectContainersNotInspected)
	{
		if (vSystemData.vSystemRunMode == cRunningSystemMode)
		{
			StopRunning(true);
		}
	}
	else
	{
		if (vConfigurationData->vEnableEjectors)
		{
			vConfigurationData->vEnableEjectors = false;
#ifdef CompileInHTTPClientOperationsGuardian
			SendOGInfo(std::wstring(L"ejectorstatus"), "Disabled", false);
#endif

			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->EnableDisableEjectors(vConfigurationData->vEnableEjectors);
			UpdateDisableEjectorsButton();
			WriteConfigurationDataToFile(false); //write to main config file
			//flash yellow 
			int TimerResult = SetTimer(vFlashYellowLightTimerHandle,500,NULL);
		}
	}
}

void CScanTracDlg::BackupSetupFiles(bool BackupHardDiskAlso) 
{  //backup setup
	if (BackupHardDiskAlso)
		vBackupHardDisk++;

	WORD TempLength = vConfigurationData->vScanTracSetupBackupDirectory.GetLength();
	if (!vConfigurationData->vDemoMode)
	if (TempLength)
	{
		if ((vSystemData.vSystemRunMode == cStoppedSystemMode) && (!vBackupNoticeDialog))
		{
			if (!vGlobalDisplayDialogThread)
			{
				vGlobalDisplayDialogThread = (CDisplayDialogThread *)AfxBeginThread(RUNTIME_CLASS(CDisplayDialogThread), THREAD_PRIORITY_BELOW_NORMAL, 0, CREATE_SUSPENDED);

				if (!vGlobalDisplayDialogThread)
				{
					ReportErrorMessage("Error-Could Not Create Backup Display Dialog Thread", cEMailInspx,32000); 
				}
				else
				{
					//vGlobalDisplayDialogThread->vDisplaySplashScreenLogo = true;
					CString TempText = " ";
					TempText.LoadString(IDS_BackingupSetupFilesPleaseWait);
					vGlobalDisplayDialogThread->vMessageToDisplay = TempText;
					vGlobalDisplayDialogThread->ResumeThread();
				}
			}

			int TempTimerResult = SetTimer(vBackupTimerHandle,100,NULL);
			if (!TempTimerResult)
				ReportErrorMessage("Error-Display Timer Failed",cEMailInspx,32000);
		}
	}
}

void CScanTracDlg::MakeSetupBackup() 
{  //backup setup button pressed
	ReportErrorMessage("Start Backup ScanTracFolder", cWriteToLog,0);
	CString TempSetupDirectoryString = " ";
	if (!vSystemData.vITIPCDig->vUsingLocalSetupDataFile)
		TempSetupDirectoryString = cSetupDataDirectory;
	else
		TempSetupDirectoryString = vGlobalCurrentDirectory;

	CTime TempTime;
	TempTime = CTime::GetCurrentTime();
	CString TempTimeString = TempTime.Format("%d");
	if (TempTimeString.GetLength() == 1)
		TempTimeString = "0" + TempTimeString;

	CString TempBackupDirectoryString1 = vConfigurationData->vScanTracSetupBackupDirectory;
	CString TempLastChar = TempBackupDirectoryString1.GetAt(
		TempBackupDirectoryString1.GetLength() - 1);
	while (TempLastChar == "\\")
	{
		TempBackupDirectoryString1.Delete(TempBackupDirectoryString1.GetLength() - 1, 1);
		TempLastChar = TempBackupDirectoryString1.GetAt(TempBackupDirectoryString1.GetLength() - 1);
	}
		
	TempBackupDirectoryString1 = TempBackupDirectoryString1 + "Day" + TempTimeString;

	CString TempBackupFileString1 = TempBackupDirectoryString1;

	LPTSTR TempString = TempBackupFileString1.GetBuffer(TempBackupDirectoryString1.GetLength());
	CFileStatus TempFileStatus;
	int TempDirectoryExists = CFile::GetStatus(TempString, TempFileStatus);

	int TempFileMonth = -1;
	if (TempDirectoryExists)
		TempFileMonth = TempFileStatus.m_atime.GetMonth();
	int TempCurrentMonth = TempTime.GetMonth();

	if (TempFileMonth != TempCurrentMonth)  //if from previous month, say it does not exist so
		TempDirectoryExists = false;       //will over write it

	if (!TempDirectoryExists)// && (TempFileStatus.m_ctime))
	{
		TempDirectoryExists = CreateDirectory(TempBackupDirectoryString1,NULL);

		if ((TempDirectoryExists))
		{
			DeleteFilesInDirectory(TempBackupDirectoryString1);

			CopyFilesInDirectoryToDirectory(TempSetupDirectoryString, TempBackupDirectoryString1);
			ReportErrorMessage("Daily Backup Setup Files", cWriteToLog,0);
		}
		else
		{
			CString TempString = " ";
			TempString.LoadString(IDS_CouldNotAccessServerToBackupSetup);
			ReportErrorMessage(TempString, cEMailInspx, 32000);
			ReportErrorMessage("Could Not Create: " + TempBackupDirectoryString1, cEMailInspx, 32000);
		}
	}
	else
	{
		CString TempSetupDirectoryString = " ";
		if (!vSystemData.vITIPCDig->vUsingLocalSetupDataFile)
			TempSetupDirectoryString = cSetupDataDirectory;
		else
			TempSetupDirectoryString = vGlobalCurrentDirectory;
		vConfigurationData->vLastBackupDirectoryUsed++;
		if (vConfigurationData->vLastBackupDirectoryUsed > 3)
			vConfigurationData->vLastBackupDirectoryUsed = 1;
		CString TempBackupDirectoryString1 = vConfigurationData->vScanTracSetupBackupDirectory;
		CString TempLastChar = TempBackupDirectoryString1.
			GetAt(TempBackupDirectoryString1.GetLength() - 1);
		while (TempLastChar == "\\")
		{
			TempBackupDirectoryString1.Delete(TempBackupDirectoryString1.GetLength() - 1, 1);
			TempLastChar = TempBackupDirectoryString1.
				GetAt(TempBackupDirectoryString1.GetLength() - 1);
		}
			
		TempBackupDirectoryString1 = TempBackupDirectoryString1 + dtoa(vConfigurationData->vLastBackupDirectoryUsed, 0) + "\\";

		LPTSTR TempString = TempBackupDirectoryString1.GetBuffer(TempBackupDirectoryString1.GetLength());
		CFileStatus TempFileStatus;
		if (!CreateDirectory(TempBackupDirectoryString1,NULL))

		DeleteFilesInDirectory(TempBackupDirectoryString1);

		CopyFilesInDirectoryToDirectory(TempSetupDirectoryString, TempBackupDirectoryString1);
		ReportErrorMessage("Backup Setup Files", cWriteToLog,0);
	}

	//delete backups more than 24 days old
	BYTE TempNumberOfDaysToDelete = 7;
	TempTime = CTime::GetCurrentTime();
	CString TempDayString = TempTime.Format("%d");
	CString TempDirectoryString = TempBackupDirectoryString1;
	for (BYTE TempLoop = 0; TempLoop < TempNumberOfDaysToDelete; TempLoop++)
	{
		BYTE TempDayNumber = _wtoi(TempDayString);
		TempDayNumber++;
		if (TempDayNumber > 31)
			TempDayNumber = 1;
		TempDayString = dtoa(TempDayNumber,0);
		if (TempDayString.GetLength() == 1)
			TempDayString = "0" + TempDayString;
		CString TempDirectoryNameString = vConfigurationData->vScanTracSetupBackupDirectory;
		while (TempDirectoryNameString.GetAt(TempDirectoryNameString.GetLength() - 1) == '\\')
			TempDirectoryNameString.Delete(TempDirectoryNameString.GetLength() - 1, 1);

		//CString TempFileNameString = TempDirectoryNameString + "Day" + TempDayString + "\\" + "*.*";
		CString TempFileNameString = TempDirectoryNameString + "Day" + TempDayString;

		LPTSTR TempFileToDeleteName = TempFileNameString.GetBuffer(TempFileNameString.GetLength());

		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Check if should Remove Directory: " + TempFileNameString,cDebugMessage);
		CFile TempFile;
		CFileStatus TempFileStatus;
		
		if (CFile::GetStatus(TempFileToDeleteName, TempFileStatus))
		{
			DeleteFilesInDirectory(TempFileNameString);

				//TempString = TempDirectoryNameString + "Day" + TempDayString + "\\";
				if (!RemoveDirectory(TempFileNameString))
				{
					ReportErrorMessage("Remove Directory Failed: " + TempFileNameString, cEMailInspx, 32000);
				}
				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Remove Directory: " + TempFileNameString,cDebugMessage);





			/*
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Found File: " + TempFileNameString,cDebugMessage);
			WIN32_FIND_DATA FindFileData;
			HANDLE hFind;
			hFind = FindFirstFile(TempFileToDeleteName, &FindFileData);

			if (hFind != INVALID_HANDLE_VALUE) 
			{
				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Got File: " + TempFileNameString,cDebugMessage);
				CString TempString = TempDirectoryNameString +
						"Day" + TempDayString + "\\"+ FindFileData.cFileName;
				if (TempString.GetAt(TempString.GetLength() - 1) != '.')
				{
					if (!DeleteFile(TempString))
						ReportErrorMessage("Failed to Delete File: " + TempString, cEMailInspx, 32000);
				}
				while (FindNextFile(hFind,&FindFileData))
				{
					TempString = TempDirectoryNameString +
						"Day" + TempDayString + "\\"+ FindFileData.cFileName;
					if (vSystemData.vLogFile.vLogSerialData)
						vSystemData.vLogFile.WriteToLogFile("Check if should Delete File: " + TempString,cDebugMessage);
					if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
					{
						if (!DeleteFile(TempString))
							ReportErrorMessage("Failed to Delete File: " + TempString, cEMailInspx, 32000);
						else
						if (vSystemData.vLogFile.vLogSerialData)
							vSystemData.vLogFile.WriteToLogFile("Delete File: " + TempString,cDebugMessage);
					}
				}
				FindClose(hFind);
				TempString = TempDirectoryNameString + "Day" + TempDayString + "\\";
				if (!RemoveDirectory(TempString))
				{
					ReportErrorMessage("Remove Directory Failed: " + TempString, cEMailInspx, 32000);
					//CNoticeDialog TempNoticeDialog;
					//TempNoticeDialog.vNoticeText = "\n\n\nRemove Directory Failed: " + TempDayString;
					//TempNoticeDialog.vType = cErrorMessage;
					//TempNoticeDialog.DoModal();
				}
				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Remove Directory: " + TempString,cDebugMessage);

			}
					*/
		}
	}
	if (vGlobalDisplayDialogThread)
	{
		vGlobalDisplayDialogThread->ExitDisplayThread();
		vGlobalDisplayDialogThread = NULL;
	}
	ReportErrorMessage("Finish Backup ScanTrac Folder", cWriteToLog,0);

	if (((vBackupHardDisk) && (vSystemData.vSystemRunMode == cStoppedSystemMode)) ||  //if you need to backup, and not running, backup now
		(vBackupHardDisk > 2))  //if you needed to backup yesterday, but constantly running, backup now anyway.
		StartCopyAllScanTracFoldersToBackupHardDrive();
}

void CScanTracDlg::CopyFilesInDirectoryToDirectory(CString TempFromDirectory, CString TempToDirectory) 
{
	vCopyDirectoryNextFileIndex = 0;
	CString TempLastChar = TempToDirectory.GetAt(TempToDirectory.GetLength() - 1);
	while (TempLastChar == "\\")
	{
		TempToDirectory.Delete(TempToDirectory.GetLength() - 1, 1);
		TempLastChar = TempToDirectory.GetAt(TempToDirectory.GetLength() - 1);
	}
	TempToDirectory = TempToDirectory + "\\";
		
	TempLastChar = TempFromDirectory.GetAt(TempFromDirectory.GetLength() - 1);
	while (TempLastChar == "\\")
	{
		TempFromDirectory.Delete(TempFromDirectory.GetLength() - 1, 1);
		TempLastChar = TempFromDirectory.GetAt(TempFromDirectory.GetLength() - 1);
	}	
	TempFromDirectory = TempFromDirectory + "\\";

	if (vCopyDirectoryNextFileIndex == 0)
	{
		CString TempAnyFileString = TempFromDirectory;
		TempAnyFileString = TempAnyFileString + "*.*";
		//vCopyDirectoryFromLPTSTR = TempAnyFileString.GetBuffer(TempAnyFileString.GetLength());

		vCopyDirectoryFromString = TempFromDirectory;
		vCopyDirectoryToString = TempToDirectory;
		vCopyDirectoryFindHandle = FindFirstFile(TempAnyFileString, &vCopyDirectoryFindFileData);

		if (vCopyDirectoryFindHandle == INVALID_HANDLE_VALUE) 
		{
			//CNoticeDialog TempNoticeDialog;
			//TempNoticeDialog.vNoticeText = "\n\n\nNo files in image directory to backup";
			//TempNoticeDialog.vType = cInformationMessage;
			//TempNoticeDialog.DoModal();
		} 
		else 
		{
			vCopyDirectoryNextFileIndex = 4;
			int TimerResult = SetTimer(vCopyNextFilesTimerHandle,25,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Startup Timer Failed",cEMailInspx,32000);
		}
	}
}

void CScanTracDlg::CopyNextFilesInDirectoryToDirectory() 
{
	bool TempContinue = true;
	bool TempGotError = false;
	CString TempStringOld = " ";
	CString TempStringNew = " ";
	if (vCopyDirectoryNextFileIndex == 4)
	{
		TempStringOld = vCopyDirectoryFromString + vCopyDirectoryFindFileData.cFileName;
		TempStringNew = vCopyDirectoryToString + vCopyDirectoryFindFileData.cFileName;
		if (TempStringOld.GetAt(TempStringOld.GetLength() - 1) != '.')
		if (!(vCopyDirectoryFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		if (!CopyFile(TempStringOld,TempStringNew,false))
		{
			DWORD ErrorNow = GetLastError();		// system error codes http://msdn.microsoft.com/en-us/library/ms681381(v=vs.85)
			if (vGlobalCopyDone == 0xAA)
			{
				vGlobalCopyDone = 0x54;
				CNoticeDialog TempNoticeDialog;
				if ((ErrorNow == 3) || (ErrorNow == 112))
					TempNoticeDialog.vNoticeText = "\nCopy File Error: "+ dtoa(ErrorNow) +"-Drive Full.\nFile: " + TempStringOld + "\nto: " + TempStringNew;
				else
					TempNoticeDialog.vNoticeText = "\nCopy File Error: "+ dtoa(ErrorNow) +"\nFile: " + TempStringOld + "\nto: " + TempStringNew;
				TempNoticeDialog.vType = cErrorMessage;
				TempNoticeDialog.DoModal();
			}
			else
			if (ErrorNow == 3)
				ReportErrorMessage("Copy File Error 6: "+ dtoa(ErrorNow) +" Drive Full.\nFile: " + TempStringOld + " to: " + TempStringNew, cEMailInspx, 32000);
			else
				ReportErrorMessage("Copy File Error 6: "+ dtoa(ErrorNow) +" File: " + TempStringOld + " to: " + TempStringNew, cEMailInspx, 32000);
			TempGotError = true;
		}
		else
			vGlobalCopyFileCount++;

	}
	while ((TempContinue) && (!TempGotError) && (FindNextFile(vCopyDirectoryFindHandle,&vCopyDirectoryFindFileData))) 
	{
		TempStringOld = vCopyDirectoryFromString + vCopyDirectoryFindFileData.cFileName;
		TempStringNew = vCopyDirectoryToString + vCopyDirectoryFindFileData.cFileName;

		if (TempStringOld.GetAt(TempStringOld.GetLength() - 1) != '.')
		if (!(vCopyDirectoryFindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
		if (!CopyFile(TempStringOld,TempStringNew,false))
		{
			DWORD ErrorNow = GetLastError();		// system error codes http://msdn.microsoft.com/en-us/library/ms681381(v=vs.85)
			if (vGlobalCopyDone == 0xAA)
			{
				vGlobalCopyDone = 0x54;
				CNoticeDialog TempNoticeDialog;
				if ((ErrorNow == 3) || (ErrorNow == 112))
					TempNoticeDialog.vNoticeText = "\nA Copy File Error: "+ dtoa(ErrorNow) +"-Drive Full.\nFile: " + TempStringOld + "\nto " + TempStringNew;
				else
					TempNoticeDialog.vNoticeText = "\nA Copy File Error: "+ dtoa(ErrorNow) +"\nFile: " + TempStringOld + "\nto " + TempStringNew;
				TempNoticeDialog.vType = cErrorMessage;
				TempNoticeDialog.DoModal();
			}
			else
			if (ErrorNow == 3)
				ReportErrorMessage("Copy File Error 6: "+ dtoa(ErrorNow) +" Drive Full.\nFile: " + TempStringOld + " to " + TempStringNew, cEMailInspx, 32000);
			else
				ReportErrorMessage("Copy File Error 6: "+ dtoa(ErrorNow) +" File: " + TempStringOld + " to " + TempStringNew, cEMailInspx, 32000);
			TempGotError = true;
		}
		else
			vGlobalCopyFileCount++;

		vCopyDirectoryNextFileIndex++;
		if (vCopyDirectoryNextFileIndex % 5 == 0)
			TempContinue = false;
	}
	if (TempContinue) //finished copying all the files, so close everything
	{
		vCopyDirectoryNextFileIndex = 0;
		FindClose(vCopyDirectoryFindHandle);

		if (vGlobalCopyDone == 0xAA)
			vGlobalCopyDone = 0x55;
	}
}

void CScanTracDlg::DeleteFilesInDirectory(CString TempDirectoryString) 
{
	WIN32_FIND_DATA FindFileData;
	HANDLE hFind;

	CString TempLastChar = TempDirectoryString.GetAt(TempDirectoryString.GetLength() - 1);
	while (TempLastChar == "\\")
	{
		TempDirectoryString.Delete(TempDirectoryString.GetLength() - 1, 1);
		TempLastChar = TempDirectoryString.GetAt(TempDirectoryString.GetLength() - 1);
	}
	TempDirectoryString = TempDirectoryString + "\\";

	//delete any files in backup directory
	CString TempAnyFileString = TempDirectoryString;
	TempAnyFileString = TempAnyFileString + "*.*";
	LPTSTR TempDirectoryName = TempAnyFileString.GetBuffer(TempAnyFileString.GetLength());

	hFind = FindFirstFile(TempDirectoryName, &FindFileData);

	if (hFind == INVALID_HANDLE_VALUE) 
	{
		//CNoticeDialog TempNoticeDialog;
		//TempNoticeDialog.vNoticeText = "\n\n\nNo files in image directory to backup";
		//TempNoticeDialog.vType = cInformationMessage;
		//TempNoticeDialog.DoModal();
	} 
	else 
	{
		BYTE TempPosition = TempDirectoryString.Find(_T("*.*"),0);
		if (TempPosition < 255)
			TempDirectoryString.Delete(TempPosition,TempDirectoryString.GetLength() - TempPosition);

		CString TempStringOld = FindFileData.cFileName;
		TempStringOld = TempDirectoryString + TempStringOld;
		LPTSTR TempOld = TempStringOld.GetBuffer(TempStringOld.GetLength());
		if (TempStringOld.GetAt(TempStringOld.GetLength() - 1) != '.')
		{
			if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				DeleteFilesInDirectory(TempOld);
			else
			if (!DeleteFile(TempOld))
				ReportErrorMessage("Failed to Delete File: " + TempStringOld, cEMailInspx, 32000);
		}
		while (FindNextFile(hFind,&FindFileData))
		{
			TempStringOld = FindFileData.cFileName;
			TempStringOld = TempDirectoryString + TempStringOld;
			TempOld = TempStringOld.GetBuffer(TempStringOld.GetLength());
			if (TempStringOld.GetAt(TempStringOld.GetLength() - 1) != '.')
			{
				if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					DeleteFilesInDirectory(TempOld);
					if (!RemoveDirectory(TempOld))
					{
						ReportErrorMessage("Remove Directory Failed: " + TempStringOld, cEMailInspx, 32000);
						//CNoticeDialog TempNoticeDialog;
						//TempNoticeDialog.vNoticeText = "\n\n\nRemove Directory Failed: " + TempStringOld;
						//TempNoticeDialog.vType = cErrorMessage;
						//TempNoticeDialog.DoModal();
					}
				}
				else
				{
					SetFileAttributes(TempOld,FILE_ATTRIBUTE_NORMAL);
					if (!DeleteFile(TempOld))
					{
						DWORD TempErrorReason = GetLastError();
						ReportErrorMessage("Failed to Delete File: " + TempStringOld, cEMailInspx, 32000);
					}
				}
			}
			//Sleep(1);
		}
		FindClose(hFind);
	}
}

void CScanTracDlg::ShowAuxiliaryDetectorEject(long TempContext, long TempType)
{
	//SetDlgItemText(IDC_RejectReason, vSystemData.vCriteriaString[vSystemData.vCountToUseForEjectReason[TempContext]]);

}

void CScanTracDlg::StartPecoPasswordTimeout()
{
	vGlobalPasswordTimeOut = 600;
}

void CScanTracDlg::SetTurnDiverterOnTimer()
{
	WORD TempDiverterOnDeltaPosition = (WORD)(vGlobalCurrentProduct->vEjectorDelayBeltPosition[vConfigurationData->vDiverterEjector - 1] - vGlobalCurrentProduct->vBTToImagePosition);

	if (vSystemData.vLogFile.vLogSerialData)
	if (vGlobaluCSerialPort)
	{
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter On " +
		dtoa(TempDiverterOnDeltaPosition,0) + "Encoder Pulses",
		vSystemData.vCurrentBeltPosition);

		vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter On " + dtoa(vGlobalCurrentProduct->vEjectorDelayBeltPosition[vConfigurationData->vDiverterEjector - 1],0) + "Ejector Position",
			vSystemData.vCurrentBeltPosition);

		vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter On " +
		dtoa(vGlobalCurrentProduct->vBTToImagePosition,0) + "Array Position",
		vSystemData.vCurrentBeltPosition);

		vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter On " +
		dtoa(vSystemData.vActualEncoderRate,2) + "Encoder Rate",
		vSystemData.vCurrentBeltPosition);
	}
	WORD TempDiverterOnTimeToDo = 1;
	if (vSystemData.vActualEncoderRate)
		TempDiverterOnTimeToDo = (WORD)((((double)TempDiverterOnDeltaPosition /  (double)vSystemData.vActualEncoderRate) * 1000.0) + 200.0);
	int TimerResult = SetTimer(vTurnDiverterOnTimerHandle,TempDiverterOnTimeToDo,NULL);//cSplashScreenDelay,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-DiverterOn Timer Failed",cEMailInspx,32000);
	if (vSystemData.vLogFile.vLogSerialData)
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter On " +
		dtoa(TempDiverterOnTimeToDo,2) + "mS",
		vSystemData.vCurrentBeltPosition);
}

void CScanTracDlg::SetTurnDiverterOffTimer()
{
	double TempDiverterOffDeltaPosition = (double)
		(vGlobalCurrentProduct->vEjectorDelayBeltPosition[vConfigurationData->vDiverterEjector - 1] - (((vConfigurationData->vDiverterMargin +   //br ht
		(vGlobalCurrentProduct->vProductImageWidth * 2)) * vGlobalPixelsPerUnit + vGlobalCurrentProduct->vBTToImagePosition) * vGlobalCurrentProduct->vOverScanMultiplier));

	if (TempDiverterOffDeltaPosition < 2)
		TempDiverterOffDeltaPosition = 2;
	if (vSystemData.vLogFile.vLogSerialData)
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter Off " +
			dtoa(TempDiverterOffDeltaPosition,0) + "Encoder Pulses", vSystemData.vCurrentBeltPosition);

		vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter Off " +
			dtoa(vGlobalCurrentProduct->vEjectorDelayBeltPosition[vConfigurationData->vDiverterEjector - 1],0) + "Ejector Position", vSystemData.vCurrentBeltPosition);

		vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter Off " +
			dtoa(vGlobalCurrentProduct->vBTToImagePosition,0) + "Array Position", vSystemData.vCurrentBeltPosition);

		vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter Off " +
			dtoa(vSystemData.vActualEncoderRate,2) + "Encoder Rate", vSystemData.vCurrentBeltPosition);
	}
	WORD TempDiverterOffTimeToDo = 0;
	if (vSystemData.vActualEncoderRate)
		TempDiverterOffTimeToDo = (WORD)((((double)TempDiverterOffDeltaPosition / (double)vSystemData.vActualEncoderRate) * 1000.0));
	if (TempDiverterOffTimeToDo < 10)
		TempDiverterOffTimeToDo = 10;
	if (TempDiverterOffTimeToDo > 20000)
		TempDiverterOffTimeToDo = 20000;
	int TimerResult = SetTimer(vTurnDiverterOffTimerHandle,TempDiverterOffTimeToDo,NULL);//cSplashScreenDelay,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-DiverterOff Timer Failed",cEMailInspx,32000);
	if (vSystemData.vLogFile.vLogSerialData)
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Wait to Turn Diverter Off " +
		dtoa(TempDiverterOffTimeToDo,2) + "mS",
		vSystemData.vCurrentBeltPosition);
}

void CScanTracDlg::TurnDiverterOn()
{
	if (vSystemData.vSystemRunMode == cRunningSystemMode)
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->SendEjectorOnOffCommand(vConfigurationData->vDiverterEjector,1); 
		//turn Diverter on to divert all containers down good shoot
		vSystemData.vDiverterOn = true;
		if (vSystemData.vLogFile.vLogSerialData)
			vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Turn Diverter On", vSystemData.vCurrentBeltPosition);
	}
}

void CScanTracDlg::TurnDiverterOff()
{
	//if (vSystemData.vSystemRunMode == cRunningSystemMode)
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->SendEjectorOnOffCommand(vConfigurationData->vDiverterEjector,0); 
		//turn Diverter on to divert all containers down good shoot
		vSystemData.vDiverterOn = false;
		if (vSystemData.vLogFile.vLogSerialData)
			vGlobaluCSerialPort->WriteToLogFileWithBeltPosition("Turn Diverter Off", vSystemData.vCurrentBeltPosition);
	}
}

double CheckDiskSpaceFree(CString TempCheckDirectory)
{
	LPCTSTR TempDirectory = TempCheckDirectory;
	DWORD TempSectorsPerCluster = 0;
	DWORD TempBytesPerSector = 0;
	DWORD TempNumberOfFreeClusters = 0;
	DWORD TempTotalNumberOfClusters = 0;
	double TempTotalBytesAvailable = 0;
	double TempCurrentUsedSpaceFBWF = 0;

	int TempResults = GetDiskFreeSpace(TempDirectory,&TempSectorsPerCluster, &TempBytesPerSector,&TempNumberOfFreeClusters,&TempTotalNumberOfClusters);

	if (TempResults)
	{
		TempTotalBytesAvailable = (double)TempNumberOfFreeClusters * (double)TempSectorsPerCluster * (double)TempBytesPerSector;
		vGlobalHardDriveTotalBytes = (double)TempTotalNumberOfClusters * (double)TempSectorsPerCluster * (double)TempBytesPerSector;

		// if FBWF need to calculate values differently
		WORD TempPosition = TempCheckDirectory.Find(_T("C"), 0);	//check if C: drive
		WORD TempDriveIsFBWFDrive = TempCheckDirectory.Find(_T("C"), 0);	//check if C: drive
		if (TempPosition > 1000)
			TempDriveIsFBWFDrive = TempCheckDirectory.Find(_T("D"), 0);	//check if D: drive

		if ((vGlobalFBWFEnable == 1) && (TempDriveIsFBWFDrive < 2))  //if FBWF is on, and checking size of a FBWF controlled drive
		{	// return in TempTotalBytes Available, Free Space on C:, change vGlobalHardDriveTotalBytes to Hard Drive total bytes
			//vGlobalHardDriveTotalBytes contains current used space on C:
			TempCurrentUsedSpaceFBWF = vGlobalHardDriveTotalBytes;
			vGlobalHardDriveTotalBytes = DetermineHardDiskSize(TempCheckDirectory);

			double TempTBA = vGlobalHardDriveTotalBytes - TempCurrentUsedSpaceFBWF;
			if (TempTBA != 1024)  //bug, sometimes get wrong values for TempCurrentUsed space, so don't use
				TempTotalBytesAvailable = TempTBA;  //2011 09 01 gave wrong answer sometimes
		}
		if ((TempTotalBytesAvailable <= 100000000) && (TempCheckDirectory == "C:\\"))
		{
			if (!vGlobalGaveHardDriveLowOnMemoryWarning)
			{
				vGlobalGaveHardDriveLowOnMemoryWarning = true;
				if (TempPosition < 2)
				{
					ReportErrorMessage("Delete files in Diagnostics, Comm. Menu",cEMailInspx,32000);
					ReportErrorMessage("Error-Hard Disk: " + TempCheckDirectory + " Space is getting low. Avail: " + dtoa(TempTotalBytesAvailable,0), cEMailInspx, 32000);
					if (TempTotalBytesAvailable <= 50000000)
					{
						ReportErrorMessage("Delete files in Diagnostics, Comm. Menu",cEMailMaintenance,0);
						ReportErrorMessage("Error-Hard Disk: " + TempCheckDirectory + " Space is getting low. Avail: " + dtoa(TempTotalBytesAvailable,0), cError, 0);
					}
				}
				else
				if (TempTotalBytesAvailable)
					ReportErrorMessage("Error-Hard Disk: " + TempCheckDirectory + " Space is getting low. Avail: " + dtoa(TempTotalBytesAvailable,0), cEMailInspx, 32000);
			}
		}
		if ((TempTotalBytesAvailable <= 20000000) && (TempCheckDirectory == "D:\\"))
		{
			if (TempPosition < 2)
			{
				ReportErrorMessage("Delete files in Diagnostics, Micro Contoller Comm. Menu",cEMailInspx,32000);
				ReportErrorMessage("Error-Hard Disk: " + TempCheckDirectory + " Space is getting low. Avail: " + dtoa(TempTotalBytesAvailable,0), cEMailInspx, 32000);
			}
			else
			if (TempTotalBytesAvailable)
				ReportErrorMessage("Error-Hard Disk: " + TempCheckDirectory + " Space is getting low. Avail: " + dtoa(TempTotalBytesAvailable,0), cEMailInspx, 32000);
		}
	}
	else
		vGlobalHardDriveTotalBytes = 0;

	return TempTotalBytesAvailable;
}

void CScanTracDlg::SendRadiationDoorParameters()
{
	if (vConfigurationData->vRadiationShutterInSystem)
	{
		tSerialCommand TempCommand;
		int TempMultiplier = 1;
		if (vGlobalCurrentProduct)
			TempMultiplier = vGlobalCurrentProduct->vOverScanMultiplier;
		vSystemData.vRadiationDoorDwellDistance = (WORD)((double)vConfigurationData->vRadiationDoorDistanceStayOpen * TempMultiplier * (double)vGlobalPixelsPerUnit / 8.0);
		vSystemData.vRadiationDoorDwellDistance = vSystemData.vRadiationDoorDwellDistance + 1;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xE0;
		TempCommand[2] = (BYTE)(vSystemData.vRadiationDoorDwellDistance >> 8);
		TempCommand[3] = (BYTE)(vSystemData.vRadiationDoorDwellDistance);
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime);

		
		vSystemData.vRadiationDoorInDoorDelaySteps = (WORD)((double)vConfigurationData->vRadiationDoorInDoorDistance * (double)vGlobalPixelsPerUnit / (double)8.0);
		if (vSystemData.vRadiationDoorInDoorDelaySteps > 63)
			vSystemData.vRadiationDoorInDoorDelaySteps = 63;

		BYTE TempByte = 0;
		if (vConfigurationData->vRadiationDoorInvertDoorOutput)
			TempByte = 0x40;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xE2;
		TempCommand[2] = TempByte;
		TempCommand[3] = (BYTE)(vSystemData.vRadiationDoorInDoorDelaySteps);
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime);
	}
}	

void CScanTracDlg::SetupRejectReasonNames()
{
	CString TempText = " ";
	BYTE TempInspectionsSoFar = 0;
	BYTE TempNumberOfInspectionsDisplayed = 0;

	for (BYTE TempLoop = 0; TempLoop < cMaximumRejectReason; TempLoop++)
		vSystemData.vCountToUseForEjectReason[TempLoop] = 0;

	TempText.LoadString(IDS_Disabled);
	if (vGlobalCurrentProduct)
	for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
	if (vGlobalCurrentProduct->vInspection[TempLoop])
	if (vGlobalCurrentProduct->vInspection[TempLoop]->vShowRejects)
	{
		//fill in the names to be displayed for the counts in order
		vSystemData.vCriteriaString[TempInspectionsSoFar] = vGlobalCurrentProduct->vInspection[TempLoop]->vName;

		if (!vGlobalCurrentProduct->vInspection[TempLoop]->vEnable)
			vSystemData.vCriteriaString[TempInspectionsSoFar] = vSystemData.vCriteriaString[TempInspectionsSoFar] + " " + TempText;

		//fill in the index for an inspection to use for it's count
		vSystemData.vCountToUseForEjectReason[cEjectInspectionOffset + TempLoop] = TempInspectionsSoFar;
		TempInspectionsSoFar++;
		TempNumberOfInspectionsDisplayed++;
	}
	else
	{
			vSystemData.vCriteriaString[cMaximumRejectReason - 1] = vGlobalCurrentProduct->vInspection[TempLoop]->vName;
		
		vSystemData.vCountToUseForEjectReason[cEjectInspectionOffset + TempLoop] = cMaximumNumberOfCountsDisplayed - 1;
	}
	
	vSystemData.vNumberOfShapeInspections = 0;

	//first shape checking is if passing slips and ejecting empties
	if (vConfigurationData->vShapeHandlingProcessIfAtSides == 2)
	{
		if (!vConfigurationData->vSlipsEjectEmptyContainers)
		{
			vSystemData.vNumberOfShapeInspections++;
			TempText.LoadString(IDS_EmptyContainer);
			vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
			vSystemData.vCountToUseForEjectReason[cEjectEmptySlippedContainer] = TempInspectionsSoFar++;

		}
	}

	//Wrong Widths Tolerance
	//if (vConfigurationData->vShapeHandlingProcessIfWrongWidth)
	{
		if (vGlobalCurrentProduct)
			vConfigurationData->vShapeHandlingWidthTolerancePixels = (WORD)((vConfigurationData->vShapeHandlingWidthTolerance * 
				vGlobalPixelsPerUnit * vGlobalCurrentProduct->vOverScanMultiplier) + .5);
		else
			vConfigurationData->vShapeHandlingWidthTolerancePixels = 
				(WORD)((vConfigurationData->vShapeHandlingWidthTolerance * vGlobalPixelsPerUnit) + .5);
	}
	//else
	//if ((vConfigurationData->vShapeHandlingWidthTolerancePixels > 12) || (vConfigurationData->vShapeHandlingWidthTolerancePixels < 3))
	//	vConfigurationData->vShapeHandlingWidthTolerancePixels = 6;

	//Wrong Height Tolerance
	//if (vConfigurationData->vShapeHandlingProcessIfWrongHeight)
	{
		vConfigurationData->vShapeHandlingHeightTolerancePixels = 
			(WORD)((vConfigurationData->vShapeHandlingHeightTolerance * vGlobalPixelsPerUnitInHeight) + .5);
	}
	//else
	//	vConfigurationData->vShapeHandlingHeightTolerancePixels = 0;

	//eject slips
	if (vConfigurationData->vShapeHandlingProcessIfAtSides == 1)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_Slipped);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cEjectSlippedContainer] = TempInspectionsSoFar++;
	}
	else
		//pass slips
	if (vConfigurationData->vShapeHandlingProcessIfAtSides == 2)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_Slipped);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cPassSlippedContainer] = TempInspectionsSoFar++;
	}
	/*  //don't do At Top checking anymore
	if (vConfigurationData->vShapeHandlingProcessIfAtTop == 1)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_AtTop);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cEjectContainerOnTop] = TempInspectionsSoFar++;
	}
	else
	if (vConfigurationData->vShapeHandlingProcessIfAtTop == 2)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_AtTop);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cPassContainerOnTop] = TempInspectionsSoFar++;
	}
	*/

	//eject Wrong Widths
	if (vConfigurationData->vShapeHandlingProcessIfWrongWidth == 1)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_WrongWidth);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cEjectContainerWrongWidth] = TempInspectionsSoFar++;
	}
	else
		//pass Wrong Widths
	if (vConfigurationData->vShapeHandlingProcessIfWrongWidth == 2)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_WrongWidth);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cPassContainerWrongWidth] = TempInspectionsSoFar++;
	}
	if (vConfigurationData->vShapeHandlingProcessIfWrongHeight == 1)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_WrongHeight);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cEjectContainerWrongHeight] = TempInspectionsSoFar++;
	}
	else
	if (vConfigurationData->vShapeHandlingProcessIfWrongHeight == 2)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_WrongHeight);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cPassContainerWrongHeight] = TempInspectionsSoFar++;
	}
	if (vConfigurationData->vShapeHandlingProcessIfConveyorStops == 1)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_ConveyorStop);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cEjectContainerOnConveyorStop] = TempInspectionsSoFar++;
	}
	else
	if (vConfigurationData->vShapeHandlingProcessIfConveyorStops == 2)
	{
		vSystemData.vNumberOfShapeInspections++;
		TempText.LoadString(IDS_ConveyorStop);
		vSystemData.vCriteriaString[TempInspectionsSoFar] = TempText;
		vSystemData.vCountToUseForEjectReason[cPassContainerOnConveyorStop] = TempInspectionsSoFar++;
	}
	
	//set fixed place for test eject that will not be show, but can display reason
	vSystemData.vCountToUseForEjectReason[cTestEject] = cTestEject;
	TempText.LoadString(IDS_TestEject);
	vSystemData.vCriteriaString[cTestEject] = TempText;

	if (vGlobalCurrentProduct)
	{
		vSystemData.vGoodImagesIndex = 1 + TempNumberOfInspectionsDisplayed + vSystemData.vNumberOfShapeInspections + vGlobalCurrentProduct->vNumberOfAuxiliaryDetectors;

		vGlobalCurrentProduct->vNumberOfAuxiliaryDetectors = 0;
		
		for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
		if (vGlobalCurrentProduct->vExternalDetectorEnable[TempLoop])
		if (vConfigurationData->vExternalDetector[TempLoop].vEnabled)
		{
			vSystemData.vCriteriaString[TempInspectionsSoFar] = vConfigurationData->vExternalDetector[TempLoop].vName;
			vSystemData.vCountToUseForEjectReason[cEjectAuxilaryDetectorOffset + TempLoop] = TempInspectionsSoFar;
			vSystemData.vAuxiliaryDetectorIndex[vGlobalCurrentProduct->vNumberOfAuxiliaryDetectors] = TempLoop;
			vGlobalCurrentProduct->vNumberOfAuxiliaryDetectors++;
			TempInspectionsSoFar++;
		}

		vSystemData.vTotalNumberOfInspections = vGlobalCurrentProduct->vNumberOfAuxiliaryDetectors + TempNumberOfInspectionsDisplayed + vSystemData.vNumberOfShapeInspections; 

		for (BYTE TempLoop = 0; TempLoop < 4 + cMaximumNumberOfInspections + cNumberOfExternalDetectors + 1; TempLoop++)
		{
			vSystemData.vButtonNameLong[TempLoop] = false;
			vSystemData.vButtonNameMedium[TempLoop] = false;
		}
		for (BYTE TempLoop = 0; TempLoop < vSystemData.vTotalNumberOfInspections; TempLoop++)
		{
			BYTE TempLength = FindLongestWord(vSystemData.vCriteriaString[TempLoop]);
			if (TempLength > 9)
				vSystemData.vButtonNameLong[TempLoop] = true;
			if (vSystemData.vCriteriaString[TempLoop].GetLength() > 15)
				vSystemData.vButtonNameMedium[TempLoop] = true;
		}

		//Set all inspections as viewing that reject type so none are hidden, but hide good in Inspx
		WORD TempMask = 1;
		TempMask = TempMask << (vSystemData.vGoodImagesIndex);
		TempMask = TempMask ^ 0xFFFF; //invert the bits

		//5/25/04 hide good containers by default
		vGlobalCurrentProduct->vTypesOfRejectsToView = vGlobalCurrentProduct->vTypesOfRejectsToView & TempMask;
	}
}

void CScanTracDlg::SendLinesPerFrame()
{
	tSerialCommand TempCommand;
	WORD TempImageWidthPosition = vGlobalCurrentProduct->vImageWidthPosition;
	//Send Number of Lines Per Frame to uController divided by 4 to make FEN Start Pulse
	TempCommand[0] = 0x1A;
	TempCommand[1] = (BYTE)(TempImageWidthPosition >> 10);
	TempCommand[2] = (BYTE)(TempImageWidthPosition >> 2);
	TempCommand[3] = 0;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTime);
	
	//Send Number of Lines Per Frame to FPGA
	TempCommand[0] = 0x23;
	TempCommand[1] = 0xCE;
	TempCommand[2] = (BYTE)(TempImageWidthPosition >> 8);
	TempCommand[3] = (BYTE)TempImageWidthPosition;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);
}

bool CScanTracDlg::HaveRejects(bool TempIncludeGoodImages)//bool TempIncludeImproveLearn)
{
	bool TempHaveRejects = false;
	if (vGlobalCurrentProduct)
	{
		/*
		if (TempIncludeImproveLearn)
		{
			if (vSystemData.vITIPCDig->vLastNRejectImages[0][cMaximumNumberOfCountsDisplayed - 1])
				TempHaveRejects = true;
		}
		else
		{
		*/
			WORD TempOuterLoopMax = vSystemData.vTotalNumberOfInspections; 
			if (TempIncludeGoodImages)
				TempOuterLoopMax++;
			if (TempOuterLoopMax > cMaximumNumberOfCountsDisplayed)
				TempOuterLoopMax = cMaximumNumberOfCountsDisplayed;
			for (WORD TempOuterLoop = 0; TempOuterLoop < TempOuterLoopMax; TempOuterLoop++)
			{
				if (vSystemData.vITIPCDig->vLastNRejectImages[0][TempOuterLoop])
					TempHaveRejects = true;
			}
		//}
	}
	return TempHaveRejects;
}

void CScanTracDlg::UpdateRunButton()
{
	if ((vSystemData.vMainDisplayMode == cMainDisplayImage) && (vSystemData.vSystemRunMode == cStoppedSystemMode) && (!vSystemData.vConveyorIsOn))
	{
		if (vGlobalCurrentProduct)
			vSubFunction4ButtonEnable = true;	//m_SubFunction4Button.EnableWindow(true);
		else
			vSubFunction4ButtonEnable = false;	//m_SubFunction4Button.EnableWindow(false);
		if (vRunButtonPressedLastNotStop)
		{
			m_SubFunction4Button.ShowWindow(SW_HIDE);
			this->InvalidateRect(&m_SubFunction4Button.GetRectToInvalidateArrow());
		}
		else
			m_SubFunction4Button.ShowWindow(SW_SHOW);
		m_SubFunction3Button.ShowWindow(SW_SHOW);
		CString TempText = " ";
		TempText.LoadString(IDS_SelectAProduct);//Select\nA\nProduct
		SetDlgItemText(IDC_SubFunction3Button,TempText);
	}
	else
	if (vSystemData.vMainDisplayMode == cMainDisplayImage)
	{
		m_SubFunction4Button.ShowWindow(SW_HIDE);
		this->InvalidateRect(&m_SubFunction4Button.GetRectToInvalidateArrow());
		m_SubFunction3Button.ShowWindow(SW_HIDE);
		this->InvalidateRect(&m_SubFunction3Button.GetRectToInvalidateArrow());
	}
	CWnd *TempWindow = CWnd::GetDlgItem(IDC_SubFunction3Button);
	if (TempWindow)
		TempWindow->Invalidate(false);

	if (vSystemData.vSystemRunMode == cStoppedSystemMode)
	{
		m_SubFunction1Button.ShowWindow(SW_HIDE);
			this->InvalidateRect(&m_SubFunction1Button.GetRectToInvalidateArrow());
	}
	else
	{
		m_SubFunction1Button.ShowWindow(SW_SHOW);
//		m_ArrowLeft1.ShowWindow(SW_SHOW);
	}
}

void CScanTracDlg::OnDialogTitleStaticText()
{
}

void CScanTracDlg::DisplayCSVFile()
{
	if (PasswordOK(cTemporaryInspxPassword,false))
	{
		LPCTSTR szFilter = _T("All Files (*.*)|*.*||; //CSV Files (*.CSV)|*.CSV|Text Files (*.TXT)|*.TXT||");
		CString TempFileString = "";

		CFileDialog *TempFileDialog = new CFileDialog(true, NULL, TempFileString, OFN_HIDEREADONLY, szFilter, this);
		vGlobalInWindowsDialog = true;
		int nResponse = TempFileDialog->DoModal();
		vGlobalInWindowsDialog = false;
		vSystemData.vPostedNewMainImageReadyToDisplayMessage = false;
		if (nResponse == IDOK)
		{
			CString TempString = TempFileDialog->GetFileName();
			LPCTSTR TempFileName = TempString;
			CFileException TempFileException;
			if (ThereIsEnoughMemory(sizeof(CFile), "Text File"))
			{
				CFile TempFile;
				if (TempFile)
				{
					int TempFileOpened = TempFile.Open(TempFileName, (CFile::modeRead | CFile::shareDenyNone), &TempFileException);
					if (TempFileOpened == 0)
					{
						//could not open text file
						ReportErrorMessage("Error-Open File Failed: " + TempString, cWriteToLog,32000);// + TempFileException.m_cause); 
						#ifdef _DEBUG
							afxDump << "Could Not Calibration Data File"  << "\n";
						#endif
					}
					else
					{
						//read data from the file
						TRY
						{
							ULONGLONG TempFileLength = TempFile.GetLength();
							if (ThereIsEnoughMemory((DWORD)TempFileLength, "Text File Buffer"))
							{
								BYTE *TempReadBuffer = (BYTE *)malloc((size_t)TempFileLength);
								if (TempReadBuffer)
								{
									DWORD TempLength = TempFile.Read(TempReadBuffer, (UINT)TempFileLength);

									CString TempTextString = TempReadBuffer;
									DWORD TempStringLength = TempTextString.GetLength();

									TempTextString.Delete(TempLength, TempStringLength - TempLength);

									int TempPosition = TempString.Find(_T(".CSV"));
									if (TempPosition > 0)
									{
										CYesNoDialog TempYesNoDialog;
										TempYesNoDialog.vNoticeText = _T("\n\nCSV File Read,\nDo you want to replace commas with Tabs?");
										TempYesNoDialog.vYesButtonText = "Replace Commas!";
										CString TempText;
										TempText.LoadString(IDS_LeaveAsIs);
										TempYesNoDialog.vNoButtonText = TempText;
										TempYesNoDialog.vQuestionType = cConfirmQuestion;
										int TempResult = TempYesNoDialog.DoModal();
										if (TempResult == IDOK)
											TempTextString.Replace(44, 9); //replace , with a tab
									}

									//display text
									CHelpDialog IHelpDialog;
									IHelpDialog.vWindowType = cTextWindow;
									IHelpDialog.vLocalConfigurationData = vConfigurationData;
									IHelpDialog.vLocalSystemData = &vSystemData;
									IHelpDialog.vLocalProductCollection = &vProductCollection;
									IHelpDialog.vMainWindowPointer = this;

									IHelpDialog.vTitleString= "File: " + TempString;
									if (TempLength)
									{
										IHelpDialog.vTextString = TempTextString;
										IHelpDialog.vTextString = IHelpDialog.vTextString  + "\n\n Length: " + dtoa(TempLength,0);
									}
									else 
										IHelpDialog.vTextString = "No Text In File";
									TRY
									{
										TempFile.Close();
									}
									CATCH_ALL(TempFileException)
									{
										#ifdef _DEBUG
											afxDump << "Could Not Close text File"  << "\n";
										#endif
									}
									END_CATCH_ALL
									int TempResult = IHelpDialog.DoModal();
									free(TempReadBuffer);
								}
							}
						}
						CATCH_ALL(TempFileException)
						{
							#ifdef _DEBUG
								afxDump << "Could Not read text File"  << "\n";
							#endif
						}
						END_CATCH_ALL
					}
				}
			}
		}
		delete TempFileDialog;
	}
}

BYTE CScanTracDlg::FindLongestWord(CString TempString)
{
	if (TempString.GetLength() > 24)
		return 20;
	else
	{
		BYTE TempLongestWord = 0;
		BYTE TempCurrentLocation = 0;
		BYTE TempSpaceLocation = TempString.Find(_T(" "),TempCurrentLocation);
		while (TempSpaceLocation != 255)
		{
			if (TempSpaceLocation - TempCurrentLocation > TempLongestWord)
				TempLongestWord = TempSpaceLocation - TempCurrentLocation;
			TempCurrentLocation = TempSpaceLocation + 1;
			TempSpaceLocation = TempString.Find(_T(" "),TempCurrentLocation);
			if (TempSpaceLocation == 255)
			{
				TempSpaceLocation = TempString.GetLength();
				if (TempSpaceLocation - TempCurrentLocation > TempLongestWord)
					TempLongestWord = TempSpaceLocation - TempCurrentLocation;
				TempSpaceLocation = 255;
			}
		}
		if (!TempLongestWord)
			TempLongestWord = TempString.GetLength();
		return TempLongestWord;
	}
}

void CScanTracDlg::SelectCurrentProduct()
{
	if (vSystemData.vSystemRunMode == cStoppedSystemMode)
	{
		int TempInt = vProductCollection.GetSize();
		if (TempInt > 0)  //if have any products configured
		{
		 //Create dialog box
			CEasySelectProductDialog ISelectProductDialog;  
			//Set dialog box data like product collection pointer
			ISelectProductDialog.vLocalProductCollection = &vProductCollection;
			ISelectProductDialog.vLocalSystemData = &vSystemData;

			//Pass control to dialog box and display
			int nResponse = ISelectProductDialog.DoModal();

			//dialog box is now closed, if user pressed select do this
			//if user pressed cancel, do nothing
			if (nResponse == IDOK)
			{
				//  closed with OK so update current product and display
				//Set current product to user's selection
				CProduct *TempProduct = GetProductByNumber(ISelectProductDialog.vProductNumberSelected);

				if (CheckSystemFullyConfigured(vConfigurationData))
					CheckProductFullyConfigured(TempProduct);
				vSystemData.vITIPCDig->vShowAverageMaskedWithHistogram = false;

				//make production report with old product and code and counters
				if (!vSystemData.vInAutoSetup)
				{
					if (vSystemData.vTotalContainers > 0)
					{
						GenerateProductionReport(cSelectProductProductionReport);
						SendProductionReport(cSelectProductProductionReport);
					}
				}

				ReportErrorMessage("Finished Inspecting Product: " + vSystemData.vCurrentProductName + ". Total containers: " + dtoa(vSystemData.vRejectCountTotal + vSystemData.vGoodCountTotal, 0), cUserChanges,0);
				ResetCounters();

				// save and clear product code
				vSaveProductCodeTemp = vSystemData.vShiftProductCode;
				vSystemData.vShiftProductCode = " ";		

				SetupProduct(TempProduct, false);
				ReportErrorMessage("Operator Loaded Current Product: " + vSystemData.vCurrentProductName, cUserChanges,0);

				tSerialCommand TempCommand;  //enable image correction when encoder pulses are too close together
				TempCommand[0] = 0x23;
				TempCommand[1] = 0xE5;
				TempCommand[2] = 0;
				TempCommand[3] = 0;
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->SendSerialCommand(TempCommand);

				vSystemData.vITIPCDig->DeleteUndoStructureLearnFiles(vGlobalCurrentProduct);
				if (vGlobalCurrentProduct)
				{
					if (vConfigurationData->vAskForProductionReportProductCode)
					if (!CurrentProductIsInspxProduct())
					{
						CString TempIsProductName = *vGlobalCurrentProduct->GetProductName();
						if (vSystemData.vPreviousProduct == TempIsProductName)
						{
							EditShift(false);	// ** kjh changes for Select Product code added to Edit Shift *****
						}
						else
						{
							EditShift(true);	// ** kjh changes for Select Product code added to Edit Shift *****
						}
					}
					ConditionTubeIfNeeded(); //do after editshift
					vConditioningBeforeRun = false;  //don't run after done

					vSystemData.vEjectTooLateMessageGivenThisRun = false;
					vSystemData.vPreviousProduct = *vGlobalCurrentProduct->GetProductName();
					WriteConfigurationDataToFile(false); //write to main config file
				}

				if (!vConfigurationData->vDemoMode)
				{
					vSystemData.vSimulateContainersRate = 0;
					//TurnSimulatedContainersOff();
					vSystemData.vFPGASimulateEncoderRate = 0;
					//TurnSimulatedEncoderOff();
					TurnOnOffFPGASimulatedData(false);
				}
				bool TempGaveWarning = false;
				if (vGlobalCurrentProduct)
				if (vGlobalCurrentProduct->vNeedToRelearn)
				if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac))
				if (!vConfigurationData->vAutoImproveEnabled) //auto improve will re-learn automatically, so only notify customer if auto improve is disabled.
				if (!CurrentProductIsInspxProduct())
				if (!vSystemData.vInAutoSetup)
				if (vSystemData.vSystemRunMode == cStoppedSystemMode)
				{
					CNoticeDialog TempNoticeDialog;
					if (vSystemData.vITIPCDig->HaveLearnImageFile("=Process 2"))
						TempNoticeDialog.vNoticeText = "\nThis product must be re-learned.\nThe detectors have been re-calibrated,\nwhich changed the product image.\nRelearn while inspecting.";
					else
						TempNoticeDialog.vNoticeText = "\n\nThis product must be learned.\nThere is no learn currently,\nso it can not be inspected.";
					TempNoticeDialog.vType = cNoticeMessage;
					TempNoticeDialog.DoModal();
					TempGaveWarning = true;
				}

				CString TempProcessType = "=Process 2";
				if (!TempGaveWarning)
				if (vGlobalCurrentProduct)
				if (vSystemData.vITIPCDig->HaveLearnImageFile(TempProcessType))
				{
					CString TempString1 =  *TempProduct->GetProductName() + TempProcessType;
					if (!vSystemData.vITIPCDig->vUsingLocalSetupDataFile)
						TempString1 = cSetupDataDirectory + TempString1;
					else
						TempString1 = vGlobalCurrentDirectory + TempString1;
					TempString1 = TempString1 + ".BMP";
					LPTSTR TempString = TempString1.GetBuffer(TempString1.GetLength());
					int TempHeight = 0;
					int TempWidth = 0;
					int TempBitsPerPixel = 0;
					int TempType = 0;
					
					CW2A TempFileNameString(TempString);
					CFileStatus TempFileStatus;
					if (CFile::GetStatus(TempString, TempFileStatus))
					{
						Erflag TempError = im_file_get_size(TempFileNameString, IM_BMP_FILE, &TempHeight, &TempWidth, &TempBitsPerPixel, &TempType);
						if (TempError == IM_OK)
						if (((TempWidth != vSystemData.vITIPCDig->vOriginalBufferSizeY) || (TempHeight != vSystemData.vITIPCDig->vOriginalBufferSizeX)) && (!vGlobalDemoMode) && (_wtoi(TempProcessType.Right(1))!=0))	//if it is process 0, it can handle wrong size
						{
							//ReportErrorMessage("Error" + TempProcessType +" Learned Image wrong size, ignored", cEMailInspx, 32000);
							ReportErrorMessage("Notice-This Product Must Be Relearned-Image Size Changed", cError, 0);
						}
					}
				}
				UpdateRunButton();
			}
		}
		else  //no products configured
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nNo products are configured to select from";
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
	}
}

void CScanTracDlg::CheckLearnQuality()
{
	vSystemData.vProductHasAPoorLearn = false;
	if (vGlobalCurrentProduct)
	if ((vConfigurationData->vLearnQualityPoorLimit) || (vConfigurationData->vLearnQualityMarginalLimit))
	{
		if (!CurrentProductIsInspxProduct())
		if (vSystemData.vITIPCDig->HaveLearnImageFile("=Process 1"))
		{
			double TempLearnQualityMiddleOfContainer = vSystemData.vITIPCDig->CalculateStructureDensityInDriftDensityROI(vGlobalCurrentProduct); 

			double TempLearnQualityWholeContainer = vSystemData.vITIPCDig->CalculateStructureDensityInProduct(vGlobalCurrentProduct); 

			if ((vConfigurationData->vLearnQualityPoorLimit) && (TempLearnQualityMiddleOfContainer > vConfigurationData->vLearnQualityPoorLimit))
			{
				ReportErrorMessage("Learn Quality of: " + dtoa(TempLearnQualityMiddleOfContainer,1) + " is poor, re-learn this product",cEMailMaintenance,0);
				vSystemData.vProductHasAPoorLearn = true;
				SetInterlockStatus();
			}
			else
			if ((vConfigurationData->vLearnQualityPoorLimit) && (TempLearnQualityWholeContainer > vConfigurationData->vLearnQualityPoorLimit + 20))
			{
				ReportErrorMessage("Whole Container Learn Quality of: " + dtoa(TempLearnQualityWholeContainer,1) + " is poor, re-learn",cEMailMaintenance,0);
				vSystemData.vProductHasAPoorLearn = true;
				SetInterlockStatus();
			}
			else
			if ((vConfigurationData->vLearnQualityMarginalLimit) && (TempLearnQualityMiddleOfContainer > vConfigurationData->vLearnQualityMarginalLimit))
			{
				ReportErrorMessage("Possible poor Quality of Learn: " + dtoa(TempLearnQualityMiddleOfContainer,1),cEMailMaintenance,0);
				ReportErrorMessage("Consider re-learning this product",cEMailMaintenance,0);
			}
			else
			if ((vConfigurationData->vLearnQualityMarginalLimit) && (TempLearnQualityWholeContainer > vConfigurationData->vLearnQualityMarginalLimit + 20))
			{
				ReportErrorMessage("Possible poor Quality of Learn: " + dtoa(TempLearnQualityWholeContainer,1),cEMailMaintenance,0);
				ReportErrorMessage("Consider re-learning this product",cEMailMaintenance,0);
			}
		}
	}
	SetInterlockStatus();
	UpdateClearYellowMessageButton();
}

void CScanTracDlg::UpdateRejectReasonOnScreen()
{
	if ((vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode) &&
		(vSystemData.vSystemRunMode != cCalibratingDetectorGainMode) &&
		(vGlobalCurrentProduct))
	{
		CString TempString = "";
		TempString = "";
		CString TempString1 = "";
		TempString1 = "";
		if (vGlobalProcessQuickLearnImagesThread)
		{
			if (vProcessCount < 4)
				vProcessCount++;
			else
				vProcessCount = 1;
			CString TempTimeString = " ";
			switch (vProcessCount)
			{
				case 1: TempTimeString = "-"; break;
				case 2: TempTimeString = "\\"; break;
				case 3: TempTimeString = "I"; break;
				case 4: TempTimeString = "/"; break;
			}
			TempString1.LoadString(IDS_ProcessingLearn);
			TempString1 = TempString1 + TempTimeString + "\n";
		}
		else
		if (vSystemData.vTakingQuickLearnImages)
		{
			if (vSystemData.vImprovingLearn)
				TempString1.LoadString(IDS_Improve);
			else
				TempString1.LoadString(IDS_QLearn);
			TempString1 = TempString1 + " " +
				dtoa(vSystemData.vQuickLearnImageIndex,0) +
				"/" + dtoa(vConfigurationData->vNumberOfQuickLearnImagesToTake,0) + "\n";
		}
		else
		if (vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled)
		{
			if (vSystemData.vImprovingLearn)
				TempString1.LoadString(IDS_Improve);
			else
				TempString1.LoadString(IDS_Learn);
			TempString1 = TempString1 + ": " + 
				dtoa(vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceCount,0) +
				"/" + dtoa(vConfigurationData->vCalibrateBodyTriggerReferenceDisableCount + 
				vConfigurationData->vAverageDisableCount + 
				vConfigurationData->vStructureDisableCount,0) + "\n";
		}
		else
		if (vSystemData.vITIPCDig->vAverageEnabled)
		{
			if (vSystemData.vImprovingLearn)
				TempString1.LoadString(IDS_Improve);
			else
				TempString1.LoadString(IDS_Learn);
			TempString1 = TempString1 + ": " + dtoa(vSystemData.vITIPCDig->vAverageCount,0) + "/" + dtoa(vConfigurationData->vAverageDisableCount + vConfigurationData->vStructureDisableCount,0) + "\n";
		}
		else
		if (vSystemData.vITIPCDig->vStructureEnabled)
		{
			if (vSystemData.vImprovingLearn)
				TempString1.LoadString(IDS_Improve);
			else
				TempString1.LoadString(IDS_Learn);

			TempString1 = TempString1 + ": " + dtoa(vSystemData.vITIPCDig->vStructureCount + vConfigurationData->vAverageDisableCount,0) +
				"/" + dtoa(vConfigurationData->vAverageDisableCount + vConfigurationData->vStructureDisableCount,0) + "\n";
		}
		else
		if (vSystemData.vAdjustingBrightnessBeforeLearning)
		{
			if (vSystemData.vImprovingLearn)
				TempString1.LoadString(IDS_Improve);
			else
				TempString1.LoadString(IDS_Learn);
			TempString1 = TempString1 + "-Adjusting" + "\n";
		}
		else
		if (vProcessCount)
		{
			vProcessCount = 0;
		}

		if (vSystemData.vITIPCDig->vHaveImage)
		if (vMainImageRejectReason < cMaximumRejectReason)
		{
			TempString = vSystemData.vCriteriaString[vSystemData.vCountToUseForEjectReason[vMainImageRejectReason]];

			if (vMainImageWeight.GetLength())
				TempString = TempString + vMainImageWeight;

			if (!vMainImageRejected)
			if ((vMainImageRejectReason <= vGlobalCurrentProduct->vNumberOfInspections) || (vMainImageRejectReason > vGlobalCurrentProduct->vNumberOfInspections + vSystemData.vNumberOfShapeInspections))
			if (vMainImageRejectDisable)
				TempString = "Disabled: " + TempString;
			else
			if (!vMainImageRejected)
				TempString = "Passed: " + TempString;
		}
		if (!TempString1.IsEmpty())
			TempString = TempString1 + TempString;

		if ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes) && (vMainImageLane))
		if (vSystemData.vITIPCDig->vHaveImage)
		{
			if (TempString.IsEmpty())
				TempString = "Lane " + dtoa(vMainImageLane, 0);
			else
				TempString = dtoa(vMainImageLane, 0) + ": " + TempString;
		}

		if (vSystemData.vSystemRunMode != cConditionXRayTubeMode)
			SetDlgItemText(IDC_RejectReason,TempString);
	}
	else
		SetDlgItemText(IDC_RejectReason, _T(""));

}

void CScanTracDlg::ReCalibrateWhileRunning()
{
	if ((vSystemData.vSystemRunMode == cRunningSystemMode) ||
		(vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
	if (vConfigurationData->vReCalibrateAfterStopTimePeriod)
	if (vGlobalCurrentProduct)
	if ((!vSystemData.vShutterFailedLastTest) || 
		(!vConfigurationData->vRadiationShutterInSystem))
	{
		RemoveAllContainers();
		vSystemData.vCalibrateErrorCount = 0;
		vSystemData.vHadErrorTryRestart = 0;
		vSystemData.vModeToRunAfterCalibrateOffset = vSystemData.vSystemRunMode;
		vHoldDriftCompensationADCOffset = vSystemData.vDriftCompensationADCOffset;
		vHoldDriftCompensationDACOffset = vSystemData.vDriftCompensationDACOffset;
		//CalibrateADCDetectorOffset(false,true); //auto calibrate
		vSystemData.vCalibrateADCAfterDAC = true;
		vSystemData.vAutoCalibrate = false;
		vSystemData.vAutoCalibrateWhileRunning = true;
		vSystemData.vFullDetectorCalibration = false;
		if (vConfigurationData->vUseDACAndADCinDensityCompensation)
			CalibrateDACDetectorOffset();
		else
			CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
	}
}

void CScanTracDlg::KillReCalibrationTimer()
{	
	if (vSystemData.vReCalibrationTimerRunning)
	{
		KillTimer(vReCalibrateOffsetTimerHandle);
		vSystemData.vReCalibrationTimerRunning = false;
	}
}

void CScanTracDlg::OnDemoHelpButton() 
{	//demo mode help
	if (vConfigurationData->vDemoMode)
		PostThreadMessage(vGlobalCallingThreadID,cShowHelp, 1, 0);
}

void CScanTracDlg::ShowSlippedIndicator()
{
	CString TempText = " ";
	TempText.LoadString(IDS_Slipped);
	SetDlgItemText(IDC_TriggerIndicator,TempText);
	m_TriggerIndicator.ShowWindow(SW_SHOW);

	int TimerResult = SetTimer(vClearSlippedTimerHandle, vConfigurationData->vSlippedIndicatorTime,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-Slipped Timer Failed",cEMailInspx,32000);
}

//void CScanTracDlg::ShowPipeEmptyIndicator()
//{
//	vShowingPipeEmpty = true;
//	if ((vConfigurationData->vScanTracType == cFermataScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac))
//		SetDlgItemText(IDC_TriggerIndicator,"Pipe Empty");
//	else
//		SetDlgItemText(IDC_TriggerIndicator,"Conveyor Empty");
//
//	m_TriggerIndicator.ShowWindow(SW_SHOW);
//	int TimerResult = SetTimer(vClearSlippedTimerHandle,
//		vConfigurationData->vSlippedIndicatorTime,NULL); //15 minutes
//	if (!TimerResult)
//		ReportErrorMessage("Error-Slipped Timer Failed",cEMailInspx,32000);
//}
//
//void CScanTracDlg::ShowAirInPipeIndicator()
//{
//	vShowingAirInPipe = true;
//		SetDlgItemText(IDC_TriggerIndicator,"Air In Pipe");
//
//	m_TriggerIndicator.ShowWindow(SW_SHOW);
//	int TimerResult = SetTimer(vClearSlippedTimerHandle,
//		vConfigurationData->vSlippedIndicatorTime,NULL);
//	if (!TimerResult)
//		ReportErrorMessage("Error-Slipped Timer Failed",cEMailInspx,32000);
//}

void CScanTracDlg::OpenModBusTCPIPInterface()
{
	if (!vModBusTCPIPInterfaceThread)
	{
		ReportErrorMessage("Create ModBus TCP/IP Interface Thread", cWriteToLog,0); 

		if (vSystemData.vMemoryOK)
			vModBusTCPIPInterfaceThread = (CModBusTCPIPInterface *)AfxBeginThread(RUNTIME_CLASS(CModBusTCPIPInterface), THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);

		if (!vModBusTCPIPInterfaceThread)
			ReportErrorMessage("Error-Could Not Create ModBus TCP/IP Interface Thread", cEMailInspx,32000); 
		else
		{
			vModBusTCPIPInterfaceThread->vLocalSystemData = &vSystemData;
			vModBusTCPIPInterfaceThread->vLocalConfigurationData = vConfigurationData;
			//vModBusTCPIPInterfaceThread->vMainWindowPointer = this;

			TempAfinity = (AFFINITYMASK_QUICK_LEARN & vGlobalSystemAffinityMask);

			vModBusTCPIPInterfaceThread->ResumeThread();
		}
	}
}

void CScanTracDlg::CloseModBusTCPIPInterface()
{
	if (vModBusTCPIPInterfaceThread)
	{
		vModBusTCPIPInterfaceThread->vCloseThread = true;
		vModBusTCPIPInterfaceThread = NULL;
	}
}

void CScanTracDlg::InitializeTCPIPServerSocket()
{
	if (!AfxSocketInit())
	{
		ReportErrorMessage("No Network Available",cEMailInspx,32000);
	}
	else
	{
		if (vListeningSocket)
		{
			delete vListeningSocket;
			vListeningSocket = NULL;
		}
		//initialize Network Server Connection
		vListeningSocket = new CListeningSocket(this);
		//where the zero is, put in the scantrac ID number
		if (vListeningSocket)
		if (vListeningSocket->Create(0 + 700))  //this creates a thread at normal priority
		{
			if (vListeningSocket->Listen())
			{
				//all OK
			}
			else
			{
				ReportErrorMessage("Cannot listen on Network.",cEMailInspx,32000);
			}
		}
	}
}

void CScanTracDlg::CloseOneClientSocket(CTCPIPServerSocket* TempClientSocket)
{
	POSITION TempListPosition,TempClientSocketPosition;
	for(TempListPosition = vClientConnectionList.GetHeadPosition(); TempListPosition != NULL;)
	{
		TempClientSocketPosition = TempListPosition;
		CTCPIPServerSocket* TempClientSocketConnection = 
			(CTCPIPServerSocket*)vClientConnectionList.GetNext(TempListPosition);
		if (TempClientSocketConnection == TempClientSocket)
		{
			vClientConnectionList.RemoveAt(TempClientSocketPosition);
			break;
		}
	}
}

void CScanTracDlg::CloseAllSockets()
{
	//delete vTCPIPServerSocket;
	//vTCPIPServerSocket = NULL;

	CSocketMessage TempMessage;
	TempMessage.vMessageFormat = 2;
	TempMessage.vMessageCommand = cSocketGeneralText;
	TempMessage.vMessageText = "The ScanTrac system has shut down.";
	SendSocketAMessageFromServerToClients(&TempMessage);

	TempMessage.vMessageText = "To connect to ScanTrac again,";
	SendSocketAMessageFromServerToClients(&TempMessage);

	TempMessage.vMessageText = "close this window and try again later.";
	SendSocketAMessageFromServerToClients(&TempMessage);

	while(!vClientConnectionList.IsEmpty())
	{
		CTCPIPServerSocket* TempClientSocketConnection = 
			(CTCPIPServerSocket*)vClientConnectionList.RemoveHead();
		CSocketMessage TempSocketMessage;
		TempSocketMessage.vMessageFormat = 0;
		TempSocketMessage.vMessageCommand = cSocketCloseConnection;

		SendSocketMessageToAClient(TempClientSocketConnection, &TempSocketMessage);

		if (!TempClientSocketConnection->IsAborted())
		{
			TempClientSocketConnection->ShutDown();

			BYTE Buffer[50];

			while (TempClientSocketConnection->Receive(Buffer,50) > 0);
			CloseOneClientSocket(TempClientSocketConnection);
			delete TempClientSocketConnection;
		}
	}

	vSocketMessageHistoryList.RemoveAll();
	//vTCPIPServerSocket.Close();

	POSITION TempListPosition,TempClientSocketPosition;
	for(TempListPosition = vClientConnectionList.GetHeadPosition(); TempListPosition != NULL;)
	{
		TempClientSocketPosition = TempListPosition;
		CTCPIPServerSocket* TempClientSocketConnection = 
			(CTCPIPServerSocket*)vClientConnectionList.GetNext(TempListPosition);
		if (TempClientSocketConnection)
		{
			vClientConnectionList.RemoveAt(TempClientSocketPosition);
			break;
		}
	}

	if (vListeningSocket)
	{
		//CloseOneClientSocket(vListeningSocket);
		delete vListeningSocket;
		vListeningSocket = NULL;
	}
}

void CScanTracDlg::ProcessMessageTCPIPServerSocket(CTCPIPServerSocket* TempSocketConnection,
																									 CSocketMessage *TempMessage)
{
	if (TempMessage)
	{
		CString TempString = TempMessage->vMessageText;
		if (TempMessage->vMessageCommand == cSocketResetAllCounter)
		{
			ResetCounters();
		}
		else
		if (TempMessage->vMessageCommand == cSocketGetStatus)
		{
			CSocketMessage TempMessageOut;
			TempMessageOut.vMessageFormat = 2;
			TempMessageOut.vMessageCommand = cSocketGetStatus;

			CString TempString = "STATUS:";
			TempMessageOut.vMessageText = "STATUS:";
			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);
			
			TempString = "ScanTrac Not Inspecting";

			if (vSystemData.vSystemRunMode == cRunningSystemMode)
			{
				TempMessageOut.vMessageText = "ScanTrac Inspecting";
				SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);

				if (vSystemData.vContainerRate)
					TempString = dtoa(vSystemData.vContainerRate,0) + " containers per minute";
				else
					TempString = "Production currently stopped";
			}
			if (vSystemData.vSystemRunMode == cAutoSetupRunningSystem)
				TempString = "ScanTrac in Auto Setup";
			if (vSystemData.vSystemRunMode == cConditionXRayTubeMode)
				TempString = "ScanTrac " + vSystemData.vConditionString + " X-Ray Tube";
			if (vSystemData.vSystemRunMode == cCalibratingDetectorOffsetMode)
				TempString = "ScanTrac Calibrating Detector Offset";
			if (vSystemData.vSystemRunMode == cCalibratingDetectorGainMode)
				TempString = "ScanTrac Calibrating Detector Gain";
			if (vSystemData.vSystemRunMode == cCalibratingDetectorEdgesMode)
				TempString = "ScanTrac Calibrating Detector Edges";
			if (vSystemData.vSystemRunMode == cTestShutterMode)
				TempString = "ScanTrac Test Shutter";
			if (vSystemData.vSystemRunMode == cMeasureSourceStrengthMode)
				TempString = "ScanTrac Measuring Source Strength";

			TempMessageOut.vMessageText = TempString;
			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);

		}
		if (TempMessage->vMessageCommand == cSocketGetStatusNumbers)
		{
			CSocketMessage TempMessageOut;
			TempMessageOut.vMessageFormat = 1;
			TempMessageOut.vMessageCommand = cSocketGetStatusNumbers;

			TempMessageOut.vMessageDWordArray[0] = vSystemData.vSystemRunMode;
			TempMessageOut.vMessageDWordArray[1] = vSystemData.vActualEncoderRate;
			//if (vConfigurationData->vUseMetric)
			//	TempMessageOut.vMessageDWordArray[2] = (DWORD)vSystemData.vBeltRate / 1000;
			//	else
				TempMessageOut.vMessageDWordArray[2] = (DWORD)vSystemData.vBeltRate / 12;
			TempMessageOut.vMessageDWordArray[3] = vSystemData.vContainerRate;
			TempMessageOut.vMessageDWordArray[4] = vSystemData.vShiftRateCPM;
			TempMessageOut.vMessageDWordArray[5] = vSystemData.vSourceInterLocks ^ 0x3F1F;  //xor to invert
			TempMessageOut.vMessageDWordArray[6] = vConfigurationData->vEnableEjectors;
			TempMessageOut.vMessageDWordArray[7] = vOldTestModesActive;
			TempMessageOut.vMessageDWordArray[8] = vSystemData.vYellowMessageButtonYellow;
			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);
		}
		else
		if (TempMessage->vMessageCommand == cSocketGetCounts)
		{
			CSocketMessage TempMessageOut;
			TempMessageOut.vMessageFormat = 2;
			TempMessageOut.vMessageCommand = cSocketGetCounts;

			TempMessageOut.vMessageText = "COUNTS:";
			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);
			
			TempString = "Total Containers: ";
			TempMessageOut.vMessageText = TempString + 
				dtoa(vSystemData.vTotalContainers,0);
			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);

			TempString = "Total Ejects: ";
			TempMessageOut.vMessageText = TempString + 
				dtoa(vSystemData.vEjectCountTotal,0);
			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);

			if (vSystemData.vMissedEjectsBecauseDisabledCount)
			{
				TempString = "Total Rejected: ";
				TempMessageOut.vMessageText = TempString + 
					dtoa(vSystemData.vRejectCountTotal,0);
				SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);
			}
		}
		else
		if (TempMessage->vMessageCommand == cSocketGetCountNumbers)
		{
			CSocketMessage TempMessageOut;
			TempMessageOut.vMessageFormat = 1;
			TempMessageOut.vMessageCommand = cSocketGetCountNumbers;

			TempMessageOut.vMessageDWordArray[0] = vSystemData.vTotalContainers;
			TempMessageOut.vMessageDWordArray[1] = vSystemData.vEjectCountTotal;
			TempMessageOut.vMessageDWordArray[2] = vSystemData.vRejectCountTotal;
			TempMessageOut.vMessageDWordArray[3] = 0;
			TempMessageOut.vMessageDWordArray[4] = 0;
			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);
		}
		else
		if (TempMessage->vMessageCommand == cSocketGetInspectionCounts)
		{
			CSocketMessage TempMessageOut;
			TempMessageOut.vMessageFormat = 5;
			TempMessageOut.vMessageCommand = cSocketGetInspectionCounts;
			CString TempString = "Inspection Counts:";
			TempMessageOut.vMessageList.AddTail(TempString);
			for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
			if (vGlobalCurrentProduct->vInspection[TempLoop])
			{
				TempMessageOut.vMessageList.AddTail(dtoa(vSystemData.vXRayCriteriaCount[TempLoop],0) + " Ejected " + vGlobalCurrentProduct->vInspection[TempLoop]->vName);

				if (vSystemData.vXRayCriteriaCountButDisabled[TempLoop])
					TempMessageOut.vMessageList.AddTail(dtoa(vSystemData.vXRayCriteriaCountButDisabled[TempLoop],0) + " Rejected " + vGlobalCurrentProduct->vInspection[TempLoop]->vName);
			}
			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);
		}
		else
		if (TempMessage->vMessageCommand == cSocketGetInspectionCountNumbers)
		{
			CSocketMessage TempMessageOut;
			TempMessageOut.vMessageFormat = 4;
			TempMessageOut.vMessageCommand = cSocketGetInspectionCountNumbers;
			TempMessageOut.vMessageDWordArray[0] = vGlobalCurrentProduct->vNumberOfInspections;
			for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
			{
				TempMessageOut.vMessageDWordArray[TempLoop * 3 + 1] = vSystemData.vXRayCriteriaCount[TempLoop];
				TempMessageOut.vMessageDWordArray[TempLoop * 3 + 2] = vSystemData.vXRayCriteriaCountTotal[TempLoop];
				if (vGlobalCurrentProduct->vInspection[TempLoop])
					TempMessageOut.vMessageDWordArray[TempLoop * 3 + 3] = vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType;
			}
			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);
		}
		else
		if (TempMessage->vMessageCommand == cSocketGetCurrentProductName)
		{
			CSocketMessage TempMessageOut;
			TempMessageOut.vMessageFormat = 3;
			TempMessageOut.vMessageCommand = cSocketGetCurrentProductName;
			TempMessageOut.vMessageText = vSystemData.vCurrentProductName;
			WORD TempProductNumber = 0;
			CProduct *TempProductPointer = NULL;
			int TempNumberOfProducts = vProductCollection.GetSize();
			for (WORD TempLoop = 1; TempLoop <= TempNumberOfProducts; TempLoop++)
			{
				TempProductPointer = GetProductByNumber(TempLoop);
				if (vGlobalCurrentProduct == TempProductPointer)
					TempProductNumber = TempLoop;
			}
			TempMessageOut.vMessageDWordArray[0] = TempProductNumber;
			TempMessageOut.vMessageDWordArray[1] = 0;
			TempMessageOut.vMessageDWordArray[2] = vGlobalCurrentProduct->vNumberOfInspections;

			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);
		}
		else
		if (TempMessage->vMessageCommand == cSocketGetCurrentProductInspectionNames)
		{
			CSocketMessage TempMessageOut;
			TempMessageOut.vMessageFormat = 5;
			TempMessageOut.vMessageCommand = cSocketGetCurrentProductInspectionNames;

			for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
			if (vGlobalCurrentProduct->vInspection[TempLoop])
				TempMessageOut.vMessageList.AddTail(vGlobalCurrentProduct->vInspection[TempLoop]->vName);

			SendSocketMessageToAClient(TempSocketConnection,&TempMessageOut);
		}
		else
		if ((TempMessage->vMessageCommand == cSocketTestMessage) ||
			(TempMessage->vMessageCommand == cSocketPrivateMessage))
		{  //echo back message only to client
			SendSocketMessageToAClient(TempSocketConnection,TempMessage);
		}
		else
		if (TempMessage->vMessageCommand == cSocketGeneralText)
		{  //echo back message
			SendSocketAMessageFromServerToClients(TempMessage);
		}
	}
}

void CScanTracDlg::OnUpdateConnections()
{
	//This finds out how many clients are connected
	//CString TempString("Number Of Sockets Connected: ");
	//SetDlgItemText(IDC_NumberOfSocketConnectionsdtoa(vClientConnectionList.GetCount(),0));
}

void CScanTracDlg::ProcessPendingAccept()
{
	if (vListeningSocket)
	{
		CTCPIPServerSocket* TempClientSocketConnection = new CTCPIPServerSocket(this);

		if (TempClientSocketConnection)
		if (vListeningSocket->Accept(*TempClientSocketConnection))
		{
			TempClientSocketConnection->Init();
			vClientConnectionList.AddTail(TempClientSocketConnection);
		}
		//if (TempClientSocketConnection)
		//	delete TempClientSocketConnection;
	}
}

void CScanTracDlg::ProcessPendingRead(CTCPIPServerSocket* TempClientSocketConnection)
{
	do
	{
		CSocketMessage* TempSocketMessage = ReadMessageFromClientSocket(TempClientSocketConnection);

		if (TempSocketMessage->vMessageCommand == cSocketCloseConnection)
		{
			CloseOneClientSocket(TempClientSocketConnection);
			break;
		}
	}
	while (!TempClientSocketConnection->vSocketArchiveIn->IsBufferEmpty());
}

CSocketMessage* CScanTracDlg::ReadMessageFromClientSocket(CTCPIPServerSocket* TempSocketConnection)
{
	static CSocketMessage TempSocketMessage;
	TempSocketMessage.vMessageCommand = 0;
	TempSocketMessage.vMessageFormat = 0;
	TempSocketMessage.vMessageText = ".";

	TRY
	{
		TempSocketConnection->ReceiveMsg(&TempSocketMessage);
		//vSocketMessageHistoryList.AddTail(TempSocketMessage.vSocketMessageText);

		ProcessMessageTCPIPServerSocket(TempSocketConnection, &TempSocketMessage);
	}
	CATCH(CFileException, e)
	{
		ReportErrorMessage("Error Reading Message from Socket",cEMailInspx,32000);

		TempSocketMessage.vMessageCommand = cSocketCloseConnection;
		TempSocketConnection->Abort();
	}
	END_CATCH

	return &TempSocketMessage;
}

void CScanTracDlg::SendSocketMessageToAClient(CTCPIPServerSocket* TempClientSocketConnection, 
																		 CSocketMessage* TempSocketMessage)
{
	TRY
	{
		TempClientSocketConnection->SendSocketMessage(TempSocketMessage);
	}
	CATCH(CFileException, e)
	{
		TempClientSocketConnection->Abort();

		//ReportErrorMessage("Error Sending Message to Socket",cEMailInspx,32000);
	}
	END_CATCH
}

void CScanTracDlg::SendSocketAMessageFromServerToClients(CSocketMessage* TempSocketMessage)
{
	/*
	static CSocketMessage TempSocketMessage;

	TempSocketMessage.Init();
	TempSocketMessage.vSocketMessageType = TempType;
	TempSocketMessage.vSocketMessageText = TempString;
	TempSocketMessage.vSocketMessageSendQueueList.AddTail(TempString);


	POSITION TempListPosition,TempClientSocketPosition;
	for(TempListPosition = vClientConnectionList.GetHeadPosition(); TempListPosition != NULL;)
	{
		TempClientSocketPosition = TempListPosition;
		CTCPIPServerSocket* TempClientSocketConnection = 
			(CTCPIPServerSocket*)vClientConnectionList.GetNext(TempListPosition);
		SendSocketMessageToAClient(TempClientSocketConnection, &TempSocketMessage);
	}
	*/
	POSITION TempListPosition,TempClientSocketPosition;
	for(TempListPosition = vClientConnectionList.GetHeadPosition(); TempListPosition != NULL;)
	{
		TempClientSocketPosition = TempListPosition;
		CTCPIPServerSocket* TempClientSocketConnection = 
			(CTCPIPServerSocket*)vClientConnectionList.GetNext(TempListPosition);
		SendSocketMessageToAClient(TempClientSocketConnection, TempSocketMessage);
	}
}

bool CScanTracDlg::HandlePecoPasswordKeyPress(int TempKey)
{
	if ((TempKey >=48) && (TempKey <= 57))
		TempKey = TempKey + 48;  //add 48 to change code from upper key board numbers to keypad number codes
	if ((TempKey >= c0) && (TempKey <= c9))
	{
		CString TempString = (char)(TempKey - c0 + 48);
		vPasswordEntryString = vPasswordEntryString + TempString;
		return true;
	}
	else
	if (TempKey == cPageUp)// Clear
	{
		BYTE TempLength = vPasswordEntryString.GetLength();
		if (TempLength)
			vPasswordEntryString.Delete(TempLength - 1,1);
		return true;
	}
	else
	if ((TempKey == cPageDown) || (TempKey == 111) || (TempKey == 13))// Help  or F2 or enter
	{
		vEnteringPecoPasswordMode = false;
		if ("31415926" == vPasswordEntryString)
		{
			vGlobalPasswordLevel = cSuperInspxPassword;
			vGlobalDialogTitleColor = cBrilliantBlue;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
			ReportErrorMessage("Alex Gilevich logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Alex Gilevich";
		}
		else
		if (("7205" == vPasswordEntryString) || ("72054328" == vPasswordEntryString))
		{
			vGlobalPasswordLevel = cSuperInspxPassword;
			vGlobalDialogTitleColor = cBrilliantBlue;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
			ReportErrorMessage("Brian Higgins logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Brian Higgins";
		}
		else
		if ("5104682199" == vPasswordEntryString)
		{
			vGlobalPasswordLevel = cSuperInspxPassword;
			vGlobalDialogTitleColor = cBrilliantBlue;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
			ReportErrorMessage("Universal Super Inspx Password logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Universal Super Inspx";
		}
		else
		if ("10221022" == vPasswordEntryString) //Allan's password
		{	//20 minute use password
			vGlobalDialogTitleColor = cDarkGreen;
			vGlobalPasswordLevel = cAllansPassword;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);	//password good for 20 min
			ReportErrorMessage("Allan Anderson logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Allan Anderson";
		}
		else
		if (vGlobalMainWindowPointer->vConfigurationData->vInspxPassword == vPasswordEntryString)// ||
			//(vGlobalMainWindowPointer->vConfigurationData->vSystemSetupResetPassword == vPasswordEntryString))
		{
			vGlobalPasswordLevel = cInspxPassword;
			vGlobalDialogTitleColor = cBrilliantBlue;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
			ReportErrorMessage("Universal Inspx Password logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Universal Inspx";
		}
		else
		if (DisposablePasswordOK(vPasswordEntryString, cTemporaryInspxPassword))
		{
			vGlobalPasswordLevel = cTemporaryInspxPassword;
			vGlobalDialogTitleColor = cBrilliantBlue;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
			ReportErrorMessage("Universal Temporary Inspx Password logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Universal Temporary Inspx";
		}
		else
		if (vGlobalMainWindowPointer->vConfigurationData->vCertifiedSetupPassword == vPasswordEntryString)// ||
		{
			vGlobalPasswordLevel = cCertifiedPassword;
			vGlobalDialogTitleColor = cDarkGreen;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
			ReportErrorMessage("Universal Certified Setup Password logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Universal Certified Setup";
		}
		else
		if (vGlobalMainWindowPointer->vConfigurationData->vAdvancedSetupPassword == vPasswordEntryString)// ||
		{
			vGlobalPasswordLevel = cAdvancedSetupPassword;
			vGlobalDialogTitleColor = cDarkGreen;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
			ReportErrorMessage("Universal Advanced Setup Password logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Universal Advanced Setup";
		}
		else
		if (vGlobalMainWindowPointer->vConfigurationData->vProductSetupPassword == vPasswordEntryString)// ||
		{
			vGlobalPasswordLevel = cSetupPassword;
			vGlobalDialogTitleColor = cDarkGreen;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
			ReportErrorMessage("Universal Product Setup Password logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Universal Product Setup";
		}
		else
		if (vGlobalMainWindowPointer->vConfigurationData->vProductSimpleSetupPassword == vPasswordEntryString)// ||
		{
			vGlobalPasswordLevel = cSimpleSetupPassword;
			vGlobalDialogTitleColor = cDarkGreen;
			::PostThreadMessage(vGlobalCallingThreadID,cStartPasswordTimerMessage,0,0);
			ReportErrorMessage("Universal Product Simple Setup Password logged in", cUserChanges,0); 
			vGlobalCurrentUser = "Universal Product Simple Setup";
		}
		CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
		if (TempWindow)
			TempWindow->Invalidate(false);
		return true;
	}
	else
	{
		vGlobalDialogTitleColor = cDarkBlue;
		vEnteringPecoPasswordMode = false;
		CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
		if (TempWindow)
			TempWindow->Invalidate(false);
		return false;
	}
}

void CScanTracDlg::HandleHiddenKeyPress(int TempShiftKeyDown, int TempKey)
{
	if (TempShiftKeyDown == 1)
	{
		vGlobalShiftKeyDown = 4;
		PostThreadMessage(vGlobalCallingThreadID,cUpdateTitleBarMessage, 0, 0);
	}
	else
	//if ((TempKey == 0x43) || (TempKey == 0x63))
	//{
	//	CNoticeDialog TempNoticeDialog1;
	//	//TempNoticeDialog1.vAutoClose = 3000;
	//	TempNoticeDialog1.vNoticeText = "\n\nCustomer: " + vConfigurationData->vScanTracCustomerName + "\n\nSerial #: " + vConfigurationData->vScanTracID;
	//	TempNoticeDialog1.vType = cInformationMessage;
	//	TempNoticeDialog1.DoModal();
	//	vGlobalShiftKeyDown = 0;
	//	PostThreadMessage(vGlobalCallingThreadID,cUpdateTitleBarMessage, 0, 0);
	//}
	//else
	if (TempKey == 0x61)
	if (vGlobalShiftKeyDown)
	{
//		PrintScreen();
//		vGlobalShiftKeyDown = 0;
//		PostThreadMessage(vGlobalCallingThreadID,cUpdateTitleBarMessage, 0, 0);
//			SaveScreenShotNow();

// string not needed
//		CNoticeDialog TempNoticeDialog1;
//		TempText.LoadString(IDS_SavingScreenImagePleaseWait);
//		TempNoticeDialog1.vNoticeText = TempText;
//		TempNoticeDialog1.vType = cInformationMessage;
//		TempNoticeDialog1.vAutoClose = 3000;
//		TempNoticeDialog1.DoModal();
		CString TempFileName = " ";
		TempFileName = "File Not Created";



//		HWND hWnd = GetDesktopWindow()->m_hWnd;

		HWND hWnd = ::GetDesktopWindow();


//		WindowCapture(); function start

//		CopyWindowToBitmap start
//		HBITMAP hBitmap = CopyWindowToBitmap(this , wnd);
//		HBITMAP CScanTracDlg::CopyWindowToBitmap(CWnd* wnd , HWND hWnd)

		HBITMAP hBitmap = NULL;  // handle to device-dependent bitmap      
		// check for a valid window handle      
		if (!hWnd)         
	//	    return NULL; 
			return;

			RECT    rectWnd; 
		::GetWindowRect(hWnd, &rectWnd);  

//	hBitmap = CopyScreenToBitmap(&rectWnd); 
// start CopyScreenToBitmap  

//HGDIOBJ     hTempOldBitmap , hTempBitmap;
// kjh this function creates objects,destroy them
//HBITMAP CScanTracDlg::CopyScreenToBitmap(LPRECT lpRect)
//{
		LPRECT	lpRect = &rectWnd; 	
		HDC			hScrDC, hMemDC;         // screen DC and memory DC     
//	HBITMAP     hBitmap; //, 
//	HBITMAP     hBitmap;
//	HBITMAP     hOldBitmap;    // handles to device-dependent bitmaps     
		int         nX, nY, nX2, nY2;       // coordinates of rectangle to grab     
		int         nWidth, nHeight;        // DIB width and height     
		int         xScrn, yScrn;           // screen resolution      
		HGDIOBJ     hTempOldBitmap , hTempBitmap;

		// check for an empty rectangle 
		if (IsRectEmpty(lpRect))       
	//	   return NULL;     
			return; 

	// create a DC for the screen and create     
	// a memory DC compatible to screen DC          
		hScrDC = CreateDC(_T("DISPLAY"), NULL, NULL, NULL);     
		hMemDC = CreateCompatibleDC(hScrDC);      // get points of rectangle to grab  
   
		nX = lpRect->left;     
		nY = lpRect->top;     
		nX2 = lpRect->right;     
		nY2 = lpRect->bottom;      // get screen resolution      
   
		xScrn = GetDeviceCaps(hScrDC, HORZRES);     
		yScrn = GetDeviceCaps(hScrDC, VERTRES);      
   
   //make sure bitmap rectangle is visible      
   
		if (nX < 0)         
			nX = 0;     
   
		if (nY < 0)         
			nY = 0;     
   
		if (nX2 > xScrn)         
			nX2 = xScrn;     
   
		if (nY2 > yScrn)         
			nY2 = yScrn;      

		nWidth = nX2 - nX;     
		nHeight = nY2 - nY;      
   
		 // create a bitmap compatible with the screen DC     
   
		hTempBitmap = CreateCompatibleBitmap(hScrDC, nWidth, nHeight);      
   
		 // select new bitmap into memory DC     
   
		hTempOldBitmap =   SelectObject (hMemDC, hTempBitmap);      
   
		 // bitblt screen DC to memory DC     
   
		BitBlt(hMemDC, 0, 0, nWidth, nHeight, hScrDC, nX, nY, SRCCOPY);     
   
		 // select old bitmap back into memory DC and get handle to     
		 // bitmap of the screen          
   
		hTempBitmap = SelectObject(hMemDC, hTempOldBitmap);      
   
		 // clean up      
		DeleteDC(hScrDC);     
		DeleteDC(hMemDC);  

		hBitmap =  (HBITMAP)hTempBitmap;  
   // return handle to the bitmap      

//   return (HBITMAP)hTempBitmap; 
// end CopyScreenToBitmap  
	
//	return hBitmap; 
//}
// end copy window to bit map function 

    HPALETTE hPal = NULL;
    if (hBitmap) 
		{
//       hPal = GetSystemPalette(); 
			ghBitmap = hBitmap;
			gbDrawImage = true;
			gbIsCaptured = true;
			CRect rect;
			GetClientRect(&rect);
			InvalidateRect(rect);
		//	   CCapITDoc* pDoc = GetDocument();
				 //replace DoSize function
		// DoSize(FromHandle(this->m_hWnd) ,hBitmap);
		//void CScanTracDlg::DoSize(CWnd* wnd , HBITMAP ghBitmap)
			BITMAP      bm;                     // Bitmap info structure 
			int         cxBitmap=0, cyBitmap=0; // Bitmap width and height 
			RECT        rectangle;                   // Client rectangle 
 
			CWnd* wnd2 = FromHandle(this->m_hWnd);
			// repaint if displaying bitmap  
			if (hBitmap) 
			{ 
				// Get info about bitmap 

				GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&bm); 

				// Get the width and height of the bitmap 

				cxBitmap = bm.bmWidth; 
				cyBitmap = bm.bmHeight; 

				// Find out the dimensions of the window, and the current thumb 
				// positions 

				wnd2->GetClientRect(&rectangle); 

			} 
			else  
				wnd2->InvalidateRect(NULL, true); 

// end function DoSize
//	   UpdateCaptureStatus(true);

		}
    else 
		{	
			gbIsCaptured = false;
			hPal = NULL; 

//			AfxMessageBox("Sorry !!!!");
		}
//end windows capture function

//		HPALETTE hPal = NULL;
		hPal = NULL;
		// next step loses a little memory
    hPal = GetSystemPalette(this->m_hWnd); 
		if(!hPal)
		{
//			AfxMessageBox("Error getting System Palette");
			return;
		}
		WORD   wBitCount = 24;
		DWORD   dwCompression = BI_RGB;//BI_RLE8; // // BI_RLE4 // BI_RGB;

//  loses memory
// move function here
//		HANDLE hDIB = ChangeBitmapFormat(ghBitmap, BitCount, dCompression, hPal, this->m_hWnd);

		//	HANDLE CScanTracDlg::ChangeBitmapFormat(HBITMAP hBitmap,WORD wBitCount,DWORD dwCompression,HPALETTE hPal,HWND hwnd) 
		HWND hwnd = this->m_hWnd;

    HDC                hDC;          // Screen DC 
    HANDLE             hNewDIB=NULL; // Handle to new DIB 
    BITMAP             Bitmap;       // BITMAP data structure 
    BITMAPINFOHEADER   bi;           // Bitmap info. header 
    LPBITMAPINFOHEADER lpbi;         // Pointer to bitmap header 
    HPALETTE           hOldPal=NULL; // Handle to palette 
    WORD               NewBPP;       // New bits per pixel 
    DWORD              NewComp;      // New compression format 
 
    // Check for a valid bitmap handle 
 
    if (!hBitmap) 
        return; //NULL; 
 
    // Validate wBitCount and dwCompression 
    // They must match correctly (i.e., BI_RLE4 and 4 BPP or 
    // BI_RLE8 and 8BPP, etc.) or we return failure 
     
    if (wBitCount == 0) 
    { 
        NewComp = dwCompression; 
        if (NewComp == BI_RLE4) 
            NewBPP = 4; 
        else if (NewComp == BI_RLE8) 
            NewBPP = 8; 
        else // Not enough info  
            return; //NULL; 
    } 
    else if (wBitCount == 1 && dwCompression == BI_RGB) 
    { 
        NewBPP = wBitCount; 
        NewComp = BI_RGB; 
    } 
    else if (wBitCount == 4) 
    { 
        NewBPP = wBitCount; 
        if (dwCompression == BI_RGB || dwCompression == BI_RLE4) 
            NewComp = dwCompression; 
        else 
            return;// NULL; 
    } 
    else if (wBitCount == 8) 
    { 
        NewBPP = wBitCount; 
        if (dwCompression == BI_RGB || dwCompression == BI_RLE8) 
            NewComp = dwCompression; 
        else 
            return;// NULL; 
    } 
    else if (wBitCount == 24 && dwCompression == BI_RGB) 
    { 
        NewBPP = wBitCount; 
        NewComp = BI_RGB; 
    } 
    else 
        return;// NULL; 
 
    // Get info about the bitmap 
 
    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&Bitmap); 
 
    // Fill in the BITMAPINFOHEADER appropriately 
 
    bi.biSize               = sizeof(BITMAPINFOHEADER); 
    bi.biWidth              = Bitmap.bmWidth; 
    bi.biHeight             = Bitmap.bmHeight; 
    bi.biPlanes             = 1; 
    bi.biBitCount           = NewBPP; 
    bi.biCompression        = NewComp; 
    bi.biSizeImage          = 0; 
    bi.biXPelsPerMeter      = 0; 
    bi.biYPelsPerMeter      = 0; 
    bi.biClrUsed            = 0; 
    bi.biClrImportant       = 0; 
 
    // Go allocate room for the new DIB 
 
//    hNewDIB = AllocRoomForDIB(bi, hBitmap , hwnd); 
//replace function AllocRoomForDIB
//HANDLE CScanTracDlg::AllocRoomForDIB(BITMAPINFOHEADER bi, HBITMAP hBitmap , HWND hwnd) 
//		HANDLE hNewDIB;

		DWORD               dwLen; 
    HANDLE              hDIB; 
    HDC                 hDC_2; 
//    LPBITMAPINFOHEADER  lpbi; 
    HANDLE              hTemp; 
 
    // Figure out the size needed to hold the BITMAPINFO structure 
    // (which includes the BITMAPINFOHEADER and the color table). 
 
    dwLen = bi.biSize + PaletteSize((LPSTR) &bi); 
    hDIB  = GlobalAlloc(GHND,dwLen); 
 
    // Check that DIB handle is valid 
 
    if (!hDIB) 
        hNewDIB = NULL; 
 
    // Set up the BITMAPINFOHEADER in the newly allocated global memory, 
    // then call GetDIBits() with lpBits = NULL to have it fill in the 
    // biSizeImage field for us. 
 
    lpbi  = (LPBITMAPINFOHEADER)GlobalLock(hDIB); 
    *lpbi = bi; 
 
    hDC_2 = CreateDC ( TEXT("DISPLAY"), NULL, NULL, NULL );
 
    GetDIBits(hDC_2, hBitmap, 0, (UINT) bi.biHeight, NULL, (LPBITMAPINFO)lpbi, 
            DIB_RGB_COLORS); 
 	::ReleaseDC(hwnd, hDC_2);
 
 
    // If the driver did not fill in the biSizeImage field, 
    // fill it in -- NOTE: this is a bug in the driver! 
     
    if (lpbi->biSizeImage == 0) 
        lpbi->biSizeImage = WIDTHBYTES((DWORD)lpbi->biWidth * 
                lpbi->biBitCount) * lpbi->biHeight; 
 
    // Get the size of the memory block we need 
 
    dwLen = lpbi->biSize + PaletteSize((LPSTR) &bi) + lpbi->biSizeImage; 
 
    // Unlock the memory block 
 
    GlobalUnlock(hDIB); 
 
    // ReAlloc the buffer big enough to hold all the bits  
 
    if (hTemp = GlobalReAlloc(hDIB,dwLen,0)) 
		{
        hNewDIB = hTemp; 
		}
    else 
    { 
        // Else free memory block and return failure  
        GlobalFree(hDIB); 
        hNewDIB = NULL; 
    } 
		//clean up kjh
		DeleteDC(hDC_2);
// end function AllocRoomForDIB

    if (!hNewDIB) 
        return ; //NULL; 
 
    // Get a pointer to the new DIB 
 
    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hNewDIB); 
 
    // If we have a palette, get a DC and select/realize it 
 
    if (hPal) 
    { 
 			hDC = CreateDC ( TEXT("DISPLAY"), NULL, NULL, NULL );
					hOldPal = SelectPalette(hDC, hPal, false); 
					RealizePalette(hDC); 
    } 
 
    // Call GetDIBits and get the new DIB bits 
 
    if (!GetDIBits(hDC, hBitmap, 0, (UINT) lpbi->biHeight, (LPSTR)lpbi + 
            (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi, 
            DIB_RGB_COLORS)) 
    { 
        GlobalUnlock(hNewDIB); 
        GlobalFree(hNewDIB); 
        hNewDIB = NULL; 
    } 
 
    // Clean up and return 
 
    if (hOldPal) 
    { 
        SelectPalette(hDC, hOldPal, true); 
        RealizePalette(hDC); 
//		::ReleaseDC(hwnd, hDC);
     } 
		if (hPal)
		{
				DeleteDC(hDC);
		}
 
    // Unlock the new DIB's memory block 
 
    if (hNewDIB) 
		{
			GlobalUnlock(hNewDIB); 
		}
 
//    return hNewDIB; 
	// end change bitmap function

		CTime TempTime;
		TempTime = CTime::GetCurrentTime();

		CString TempTimeString = TempTime.Format("%Y-%m-%d %H-%M-%S");

		if (vGlobalCurrentProduct != NULL) /* && (*vGlobalCurrentProduct->GetProductName()!= '\0') */	// if product assigned
			TempFileName = *vGlobalCurrentProduct->GetProductName();
		else
			TempFileName = "No Current Product" ;
		
		TempFileName = TempFileName + " ScreenShot " + TempTimeString;

		CString TempFileName2 = cScanTracScreenShotDirectory + TempFileName;
		TempFileName2 = TempFileName2 + ".BMP";

		TempFileName = vConfigurationData->vScanTracScreenShotDirectory + TempFileName;
		TempFileName = TempFileName + ".BMP";

		BYTE TempLength = TempFileName.GetLength();
		LPTSTR TempString = TempFileName.GetBuffer(TempLength);

		BYTE TempLength2 = TempFileName2.GetLength();
		wchar_t *TempString2 = TempFileName2.GetBuffer(TempLength2);

		WORD TempError2 = 1;
		WORD TempError1 = SaveDIB(hNewDIB, TempString);
		if (CompareBit(vGlobalShadowImages,cShadowScreenShotsBit) == cShadowScreenShotsBit)
		{
			TempError2 = SaveDIB(hNewDIB, TempString2);
		}
		hPal = NULL;

		if (!vGlobalDisplayDialogThread)
		{
			vGlobalDisplayDialogThread = (CDisplayDialogThread *)AfxBeginThread(RUNTIME_CLASS(CDisplayDialogThread), THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);

			if (!vGlobalDisplayDialogThread)
			{
				ReportErrorMessage("Error-Could Not Create Backup Display Dialog Thread", cEMailInspx, 32000); 
			}
			else
			{
				if (TempError1 == 0)
				{
					vGlobalDisplayDialogThread->vMessageToDisplay = 
						"\nSaving Screen Capture to File:\n" + TempFileName /* + "\n\nPlease Wait..."*/;
				}
				else if (TempError2 == 0)
				{
					vGlobalDisplayDialogThread->vMessageToDisplay = 
						"\nSaving Screen Capture to File:\n" + TempFileName2 /* + "\n\nPlease Wait..."*/;
				}

				//kjh priority
				TempAfinity = (AFFINITYMASK_DISPLAY & vGlobalSystemAffinityMask);
				/*
				if ((TempAfinity != 0)&&(vGlobalSystemAffinityMask >= 0x0F))
				{
					if (vGlobalSystemAffinityMask == 0xFF)
						DWORD TempOriginalAffinityMask = ::SetThreadAffinityMask(vGlobalDisplayDialogThread->m_hThread, 0x04);
					else
					if (::SetThreadAffinityMask(vGlobalDisplayDialogThread->m_hThread,TempAfinity))
					{
						vReplyOK |=  0x08 ;
					}
				}
				*/
				vGlobalDisplayDialogThread->ResumeThread();
			}
		}

	//clean up here	add kjh 11/29/10
		DeleteObject(hTempOldBitmap);
		DeleteObject(hTempBitmap);
		if (hNewDIB)
		{
			GlobalFree(hNewDIB); 
		}
		// Sleep(2250);
		//	start a timer instead of sleep, much better kjh 11/30/10
		int TimerResult = SetTimer(vClearScreenCaptureNoticeTimerHandle,3000,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-Screen Timer Failed",cEMailInspx,32000);
	}
}

void CScanTracDlg::StartXRayTubeCondition(BYTE TempDoBurnIn, BYTE TempProcedure)
{
	vSystemData.vXRayTubeConditionGlitchCount = 0;
	//brh merge 6/18/2018
	vSystemData.vXRayTubeConditionCurrentStep = 0;
	vSystemData.vXRayTubeConditionStepTimeLeft = 0;
	vSystemData.vXRayTubeConditionStepTime = 300000; //5 minutes

	if (TempDoBurnIn)
		vSystemData.vConditionString = "Burn-in";
	else
		vSystemData.vConditionString = "Condition";

	if (!InterlocksOK())
		ReportErrorMessage("Interlock Open, Cannot Condition X-Ray tube",cEMailMaintenance,9);

	if ((vGlobalMonoBlockXRayPort) || ((vGlobalDXMXRayPort) && ((vConfigurationData->vHVPSType == c100WMonoBlockHVPS) || (vConfigurationData->vHVPSType == cCheyneyMonoBlock) || (vConfigurationData->vHVPSType == c100WVJTMonoBlockHVPS))))
	{
		if (!TempDoBurnIn)
		{
			if (TempProcedure)
			{
				CYesNoDialog TempYesNoDialog;

				if (TempProcedure == 2)
					TempYesNoDialog.vNoticeText = _T("X-Ray Tube has not been used for more than 30 days.\nIt should be conditioned to prevent arcing and damage.\n\nUse Suggested X-Ray Tube Conditioning Procedure?\nSuggested procedure is 10 steps at 1 minute each.");
				else
				if (TempProcedure == 3)
					TempYesNoDialog.vNoticeText = _T("X-Ray Tube has not been used for more than 3 days.\nIt should be conditioned to prevent arcing and damage.\n\nUse Suggested X-Ray Tube Conditioning Procedure?\nSuggested procedure is 10 steps at 0.5 minute each.");
				else
				if (TempProcedure == 4)
					TempYesNoDialog.vNoticeText = _T("X-Ray Tube has not been used for more than 10 hours.\nIt should be conditioned to prevent arcing and damage.\n\nUse Suggested X-Ray Tube Conditioning Procedure?\nSuggested procedure is 10 steps at 10 seconds each.");
				else
				if (TempProcedure == 5)
					TempYesNoDialog.vNoticeText = _T("X-Ray Tube has not been used for more than 6 months.\nIt MUST be conditioned to prevent arcing and damage.\n\nUse Suggested X-Ray Tube Conditioning Procedure?\nSuggested procedure is 17 steps at 15 minutes each.");
				else
					TempYesNoDialog.vNoticeText = _T("X-Ray Tube has not been used for more than 90 days.\nIt should be conditioned to prevent arcing and damage.\n\nUse Suggested X-Ray Tube Conditioning Procedure?\nSuggested procedure is 10 steps at 5 minutes each.");

				TempYesNoDialog.vYesButtonText = "Suggested Procedure";
				TempYesNoDialog.vNoButtonText = "I Will Pick Procedure";
				TempYesNoDialog.vQuestionType = cConfirmSave;
				int TempResult = TempYesNoDialog.DoModal();
				if (TempResult != IDOK)
					TempProcedure = 0;
			}
			if (InterlocksOK())
			{
				if (!TempProcedure)
				{
					CSelectItemDialog ISelectItemDialog;  
					ISelectItemDialog.vTitleString = "X-Ray Tube has not been on for many days, must be conditioned to prevent arcing";
					ISelectItemDialog.vNumberOfItems = 5;
					ISelectItemDialog.vItems[0] = "X-Ray Tube unused > 3 months, 10*5 minute steps";
					ISelectItemDialog.vItems[1] = "X-Ray Tube unused > 1 months, 10*1 minute steps";
					ISelectItemDialog.vItems[2] = "X-Ray Tube unused > 3 days, 10*0.5 minute steps";
					ISelectItemDialog.vItems[3] = "X-Ray Tube unused > 10 hours, 10*10 second steps";
					ISelectItemDialog.vItems[4] = "X-Ray Tube unused > 6 months, 17*15 minute steps";

					//Set dialog box data titles and number value
					ISelectItemDialog.vTitleString = "Choose X-Ray Tube Condition Procedure";
					ISelectItemDialog.vBackgroundColor = cGreen;

					ISelectItemDialog.m_DialogTitleStaticText2 = "To Condition, or Season the X-Ray tube when it";
					ISelectItemDialog.m_DialogTitleStaticText3 = "has not been used for more than 3 days";
					//Pass control to dialog box and display
					int nResponse = ISelectItemDialog.DoModal();
					//dialog box is now closed, if user pressed select do this
					//if user pressed cancel, do nothing
					if (nResponse == IDOK)
					{
						TempProcedure = ISelectItemDialog.vItemNumberSelected;
					}
					else
						TempProcedure = 0;
				}
			}
		}
		if (InterlocksOK())
		{
			if (TempDoBurnIn)
			{
				vSystemData.vXRayTubeConditionStepTime = 1800000; //30 minutes
				//vSystemData.vXRayTubeConditionStepTime = 10000; //br htest 10 seconds
				//vSystemData.vXRayTubeConditionStepTime = 6000; //br htest 10 seconds
				vSystemData.vXRayTubeConditionStepTimeLeft = vSystemData.vXRayTubeConditionStepTime / 1000;

				vSystemData.vXRayTubeConditionVoltageTable[0] = 40; //DXM
				vSystemData.vXRayTubeConditionCurrentTable[0]	= 1;
				vSystemData.vXRayTubeConditionVoltageTable[1] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[1]	= 2;
				vSystemData.vXRayTubeConditionVoltageTable[2] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[2]	= 4;
				vSystemData.vXRayTubeConditionVoltageTable[3] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[3]	= 8.5;
				vSystemData.vXRayTubeConditionVoltageTable[4] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[4]	= 8.5;
				vSystemData.vXRayTubeConditionVoltageTable[5] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[5]	= 8.5;
				vSystemData.vXRayTubeConditionVoltageTable[6] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[6]	= 8.5;
				vSystemData.vXRayTubeConditionVoltageTable[7] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[7]	= 8.5;
				vSystemData.vXRayTubeConditionVoltageTable[8] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[8]	= 8.5;
				vSystemData.vXRayTubeConditionVoltageTable[9] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[9]	= 8.5;
				vSystemData.vXRayTubeConditionVoltageTable[10] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[10] = 8.5;
				vSystemData.vXRayTubeConditionVoltageTable[11] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[11] = 8.5;

				if ((vGlobalDXMXRayPort) && ((vConfigurationData->vHVPSType == c100WMonoBlockHVPS) || (vConfigurationData->vHVPSType == cCheyneyMonoBlock) || (vConfigurationData->vHVPSType == c100WVJTMonoBlockHVPS)))
				{
					vSystemData.vXRayTubeConditionVoltageTable[0] = 40;
					vSystemData.vXRayTubeConditionCurrentTable[0]	= .25;
					vSystemData.vXRayTubeConditionVoltageTable[1] = 50;
					vSystemData.vXRayTubeConditionCurrentTable[1]	= .5;
					vSystemData.vXRayTubeConditionVoltageTable[2] = 60;
					vSystemData.vXRayTubeConditionCurrentTable[2]	= .75;
					vSystemData.vXRayTubeConditionVoltageTable[3] = 65;
					vSystemData.vXRayTubeConditionCurrentTable[3]	= 1.25;
					vSystemData.vXRayTubeConditionVoltageTable[4] = 60;
					vSystemData.vXRayTubeConditionCurrentTable[4]	= .85;
					vSystemData.vXRayTubeConditionVoltageTable[5] = 65;
					vSystemData.vXRayTubeConditionCurrentTable[5]	= 1;
					vSystemData.vXRayTubeConditionVoltageTable[6] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[6]	= 1.15;
					vSystemData.vXRayTubeConditionVoltageTable[7] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[7]	= 1.25;
					vSystemData.vXRayTubeConditionVoltageTable[8] = 75;
					vSystemData.vXRayTubeConditionCurrentTable[8]	= 1.25;
					vSystemData.vXRayTubeConditionVoltageTable[9] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[9]	= 1.25;
					vSystemData.vXRayTubeConditionVoltageTable[10] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[10]	= 1.25;
					vSystemData.vXRayTubeConditionVoltageTable[11] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[11]	= 1.25;
					vSystemData.vXRayTubeConditionVoltageTable[12] = 0;
					vSystemData.vXRayTubeConditionCurrentTable[12]	= 0;
				}
				else
				{ //210 watt monoblock
					vSystemData.vXRayTubeConditionVoltageTable[0] = 50;
					vSystemData.vXRayTubeConditionCurrentTable[0]	= .35;
					vSystemData.vXRayTubeConditionVoltageTable[1] = 60;
					vSystemData.vXRayTubeConditionCurrentTable[1]	= .65;
					vSystemData.vXRayTubeConditionVoltageTable[2] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[2]	= .9;
					vSystemData.vXRayTubeConditionVoltageTable[3] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[3]	= 1.2;
					vSystemData.vXRayTubeConditionVoltageTable[4] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[4]	= 1.5;
					vSystemData.vXRayTubeConditionVoltageTable[5] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[5]	= 1.8;
					vSystemData.vXRayTubeConditionVoltageTable[6] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[6]	= 2.2;
					vSystemData.vXRayTubeConditionVoltageTable[7] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[7]	= 2.6;
					vSystemData.vXRayTubeConditionVoltageTable[8] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[8]	= 3;
					vSystemData.vXRayTubeConditionVoltageTable[9] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[9]	= 3;
					vSystemData.vXRayTubeConditionVoltageTable[10] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[10]	= 3;
					vSystemData.vXRayTubeConditionVoltageTable[11] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[11]	= 3;
					vSystemData.vXRayTubeConditionVoltageTable[12] = 0;
					vSystemData.vXRayTubeConditionCurrentTable[12]	= 0;
				}
				/*
				vSystemData.vXRayTubeConditionVoltageTable[0] = 20;
				vSystemData.vXRayTubeConditionCurrentTable[0]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[1] = 25;
				vSystemData.vXRayTubeConditionCurrentTable[1]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[2] = 30;
				vSystemData.vXRayTubeConditionCurrentTable[2]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[3] = 35;
				vSystemData.vXRayTubeConditionCurrentTable[3]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[4] = 40;
				vSystemData.vXRayTubeConditionCurrentTable[4]	= 1;
				vSystemData.vXRayTubeConditionVoltageTable[5] = 45;
				vSystemData.vXRayTubeConditionCurrentTable[5]	= 2;
				vSystemData.vXRayTubeConditionVoltageTable[6] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[6]	= 3;
				vSystemData.vXRayTubeConditionVoltageTable[7] = 55;
				vSystemData.vXRayTubeConditionCurrentTable[7]	= 4;
				vSystemData.vXRayTubeConditionVoltageTable[8] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[8]	= 5;
				vSystemData.vXRayTubeConditionVoltageTable[9] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[9]	= 6;
				vSystemData.vXRayTubeConditionVoltageTable[10] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[10]	= 8;
				vSystemData.vXRayTubeConditionVoltageTable[11] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[11]	= 8.5;
				*/
				/*
			CSelectItemDialog ISelectItemDialog;
			
			//Set dialog box data titles and number value
			ISelectItemDialog.vTitleString = "Burn In";
			ISelectItemDialog.vNumberOfItems = 4;
			ISelectItemDialog.vBackgroundColor = cGreen;
			for (BYTE TempLoop = 0; TempLoop < 4; TempLoop++)
			{
				ISelectItemDialog.vItems[TempLoop] = "Step " + dtoa(TempLoop + 1,0) + 
					" Voltage: " + dtoa(vSystemData.vXRayTubeConditionVoltageTable[TempLoop]) + 
					" Current: " + dtoa(vSystemData.vXRayTubeConditionCurrentTable[TempLoop]);
			}
			ISelectItemDialog.m_DialogTitleStaticText2 = "Select Starting Step";
			ISelectItemDialog.m_DialogTitleStaticText3 = "Normal Burnin Start at Step 1";

			//Pass control to dialog box and display
			int nResponse = ISelectItemDialog. DoModal();
			//dialog box is now closed, if user pressed select do this
			//if user pressed cancel, do nothing
			if (nResponse == IDOK)
			{
				vSystemData.vXRayTubeConditionCurrentStep = ISelectItemDialog.vItemNumberSelected - 1;
				if (vSystemData.vXRayTubeConditionCurrentStep == 3)
					vSystemData.vXRayTubeConditionStepTimeLeft = 0;
			}
			else
				TempOKToDo = false;
				vSystemData.vXRayTubeConditionCurrentStep = 11;
				vSystemData.vXRayTubeConditionStepTimeLeft = 0;
				*/
			}
			else
			if (TempProcedure)  //condition tube
			{
				vSystemData.vXRayTubeConditionCurrentStep = 0;
				if (TempProcedure == 2)
					vSystemData.vXRayTubeConditionStepTime = 60000; //1 minute
				else
				if (TempProcedure == 3)
					vSystemData.vXRayTubeConditionStepTime = 30000; //0.5 minute
				else
				if (TempProcedure == 4)
				//brh merge 6/18/2018
					vSystemData.vXRayTubeConditionStepTime = 10000; //10 second
				else
				if (TempProcedure == 5)
					vSystemData.vXRayTubeConditionStepTime = 900000; //15 minute
				else
					vSystemData.vXRayTubeConditionStepTime = 300000; //5 minutes

				vSystemData.vXRayTubeConditionStepTimeLeft = vSystemData.vXRayTubeConditionStepTime / 1000;

				if ((vGlobalDXMXRayPort) && ((vConfigurationData->vHVPSType == c100WMonoBlockHVPS) || (vConfigurationData->vHVPSType == cCheyneyMonoBlock) || (vConfigurationData->vHVPSType == c100WVJTMonoBlockHVPS)))
				{
					if (TempProcedure == 5)
					{
						vSystemData.vXRayTubeConditionVoltageTable[0] = 40;
						vSystemData.vXRayTubeConditionCurrentTable[0]	= .15;
						vSystemData.vXRayTubeConditionVoltageTable[1] = 40;
						vSystemData.vXRayTubeConditionCurrentTable[1]	= .25;
						vSystemData.vXRayTubeConditionVoltageTable[2] = 45;
						vSystemData.vXRayTubeConditionCurrentTable[2]	= .4;
						vSystemData.vXRayTubeConditionVoltageTable[3] = 50;
						vSystemData.vXRayTubeConditionCurrentTable[3]	= .55;
						vSystemData.vXRayTubeConditionVoltageTable[4] = 55;
						vSystemData.vXRayTubeConditionCurrentTable[4]	= .7;
						vSystemData.vXRayTubeConditionVoltageTable[5] = 60;
						vSystemData.vXRayTubeConditionCurrentTable[5]	= 0.85;
						vSystemData.vXRayTubeConditionVoltageTable[6] = 65;
						vSystemData.vXRayTubeConditionCurrentTable[6]	= 1;
						vSystemData.vXRayTubeConditionVoltageTable[7] = 70;
						vSystemData.vXRayTubeConditionCurrentTable[7]	= 1.15;
						vSystemData.vXRayTubeConditionVoltageTable[8] = 70;
						vSystemData.vXRayTubeConditionCurrentTable[8]	= 1.3;
						vSystemData.vXRayTubeConditionVoltageTable[9] = 75;
						vSystemData.vXRayTubeConditionCurrentTable[9]	= 1.3;
						vSystemData.vXRayTubeConditionVoltageTable[10] = 80;
						vSystemData.vXRayTubeConditionCurrentTable[10]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[11] = 80;
						vSystemData.vXRayTubeConditionCurrentTable[11]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[12] = 80;
						vSystemData.vXRayTubeConditionCurrentTable[12]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[13] = 80;
						vSystemData.vXRayTubeConditionCurrentTable[13]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[14] = 80;
						vSystemData.vXRayTubeConditionCurrentTable[14]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[15] = 80;
						vSystemData.vXRayTubeConditionCurrentTable[15]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[16] = 80;
						vSystemData.vXRayTubeConditionCurrentTable[16]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[17] = 0;
						vSystemData.vXRayTubeConditionCurrentTable[17]	= 0;
					}
					else
					{
						vSystemData.vXRayTubeConditionVoltageTable[0] = 40; //cheyney conditioning or seasoning
						vSystemData.vXRayTubeConditionCurrentTable[0]	= .25;
						vSystemData.vXRayTubeConditionVoltageTable[1] = 45;
						vSystemData.vXRayTubeConditionCurrentTable[1]	= .4;
						vSystemData.vXRayTubeConditionVoltageTable[2] = 50;
						vSystemData.vXRayTubeConditionCurrentTable[2]	= .55;
						vSystemData.vXRayTubeConditionVoltageTable[3] = 55;
						vSystemData.vXRayTubeConditionCurrentTable[3]	= .7;
						vSystemData.vXRayTubeConditionVoltageTable[4] = 60;
						vSystemData.vXRayTubeConditionCurrentTable[4]	= .85;
						vSystemData.vXRayTubeConditionVoltageTable[5] = 65;
						vSystemData.vXRayTubeConditionCurrentTable[5]	= 1;
						vSystemData.vXRayTubeConditionVoltageTable[6] = 70;
						vSystemData.vXRayTubeConditionCurrentTable[6]	= 1.15;
						vSystemData.vXRayTubeConditionVoltageTable[7] = 70;
						vSystemData.vXRayTubeConditionCurrentTable[7]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[8] = 75;
						vSystemData.vXRayTubeConditionCurrentTable[8]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[9] = 80;
						vSystemData.vXRayTubeConditionCurrentTable[9]	= 1.25;
						vSystemData.vXRayTubeConditionVoltageTable[10] = 0;
						vSystemData.vXRayTubeConditionCurrentTable[10]	= 0;
						vSystemData.vXRayTubeConditionVoltageTable[11] = 0;
						vSystemData.vXRayTubeConditionCurrentTable[11]	= 0;
						vSystemData.vXRayTubeConditionVoltageTable[12] = 0;
						vSystemData.vXRayTubeConditionCurrentTable[12]	= 0;
					}
				}
				else
				{ //210 watt monoblock
					vSystemData.vXRayTubeConditionVoltageTable[0] = 50;
					vSystemData.vXRayTubeConditionCurrentTable[0]	= .35;
					vSystemData.vXRayTubeConditionVoltageTable[1] = 60;
					vSystemData.vXRayTubeConditionCurrentTable[1]	= .65;
					vSystemData.vXRayTubeConditionVoltageTable[2] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[2]	= .9;
					vSystemData.vXRayTubeConditionVoltageTable[3] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[3]	= 1.2;
					vSystemData.vXRayTubeConditionVoltageTable[4] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[4]	= 1.5;
					vSystemData.vXRayTubeConditionVoltageTable[5] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[5]	= 1.8;
					vSystemData.vXRayTubeConditionVoltageTable[6] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[6]	= 2.2;
					vSystemData.vXRayTubeConditionVoltageTable[7] = 80;
					vSystemData.vXRayTubeConditionCurrentTable[7]	= 2.6;
					vSystemData.vXRayTubeConditionVoltageTable[8] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[8]	= 3;
					vSystemData.vXRayTubeConditionVoltageTable[9] = 50;
					vSystemData.vXRayTubeConditionCurrentTable[9]	= 4;
					vSystemData.vXRayTubeConditionVoltageTable[10] = 40;
					vSystemData.vXRayTubeConditionCurrentTable[10]	= 5.2;
					vSystemData.vXRayTubeConditionVoltageTable[11] = 0;
					vSystemData.vXRayTubeConditionCurrentTable[11]	= 0;
					vSystemData.vXRayTubeConditionVoltageTable[12] = 0;
					vSystemData.vXRayTubeConditionCurrentTable[12]	= 0;
				}

				vSystemData.vShuttingDownXRays = false;
				vSystemData.vSystemRunMode = cConditionXRayTubeMode;
				m_Calibrating.ShowWindow(SW_SHOW);
				SetDlgItemText(IDC_Calibrating, vSystemData.vConditionString);
			}
			//brh merge 6/18/2018
			if ((TempProcedure) || (TempDoBurnIn))
			{
				vSystemData.vShuttingDownXRays = false;
				vSystemData.vSystemRunMode = cConditionXRayTubeMode;
				m_Calibrating.ShowWindow(SW_SHOW);
				SetDlgItemText(IDC_Calibrating, vSystemData.vConditionString + " Tube");

				vSystemData.vRampXRayVoltageAmount = vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep] / 6;
				vSystemData.vRampXRayCurrentAmount = vSystemData.vXRayTubeConditionCurrentTable[vSystemData.vXRayTubeConditionCurrentStep];

				if (vSystemData.vRampXRayVoltageAmount > vConfigurationData->vMaximumVoltage / 6)
					vSystemData.vRampXRayVoltageAmount = vConfigurationData->vMaximumVoltage / 6;
				if (vSystemData.vRampXRayCurrentAmount > vConfigurationData->vMaximumCurrent)
					vSystemData.vRampXRayCurrentAmount = vConfigurationData->vMaximumCurrent;

				vSystemData.vSourceRampedUp = false;
				::PostThreadMessage(vGlobalCallingThreadID,cRampingSourceMessage,0,0);
				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount, vSystemData.vRampXRayCurrentAmount);
				//if (vGlobalMonoBlockXRayPort)
				//	vGlobalMonoBlockXRayPort->SendXRaySourceSettings(vSystemData.vRampXRayVoltageAmount, vSystemData.vRampXRayCurrentAmount);
				Sleep(10);
				SendXRayPowerOnOffToUController(1);

				m_RejectReason.ShowWindow(SW_SHOW);

				SetDlgItemText(IDC_RejectReason, "X-Ray Tube " + vSystemData.vConditionString + " Step: " + dtoa(vSystemData.vXRayTubeConditionCurrentStep + 1,0) +
					" " + dtoa(vSystemData.vRampXRayVoltageAmount * 6,1) + "KV  " + dtoa(vSystemData.vRampXRayCurrentAmount,2) + "mA");

				UpdateRunButton();

				//int TimerResult = 
				//	SetTimer(vXRayTubeConditionTimerHandle,vSystemData.vXRayTubeConditionStepTime,NULL);
				//if (!TimerResult)
				//	ReportErrorMessage("Error-Condition Tube Timer Failed",cEMailInspx, 32000);

				ReportErrorMessage("Started X-Ray Tube " + vSystemData.vConditionString + " Step " + dtoa(vSystemData.vXRayTubeConditionCurrentStep + 1,0) + 
							" Voltage: " + dtoa(vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep]) + 
							" Current: " + dtoa(vSystemData.vXRayTubeConditionCurrentTable[vSystemData.vXRayTubeConditionCurrentStep]), cAction,0);
			}
		}
	}
	else
	{ //have a DXM or XLF
		bool TempOKToDo = true;
		//vSystemData.vHVPSInterlockDelay = 0;
		vSystemData.vXRayTubeConditionCurrentStep = 0;
		if (TempDoBurnIn)
		{
			vSystemData.vXRayTubeConditionStepTime = 1800000; //30 minutes
			//test
			//vSystemData.vXRayTubeConditionStepTime = 2000; //br htest 2 seconds
			vSystemData.vXRayTubeConditionStepTimeLeft = vSystemData.vXRayTubeConditionStepTime / 1000;

			if ((vGlobalDXMXRayPort) && ((vConfigurationData->vHVPSType == c100WMonoBlockHVPS) || (vConfigurationData->vHVPSType == cCheyneyMonoBlock) || (vConfigurationData->vHVPSType == c100WVJTMonoBlockHVPS)))
			{
				if (TempProcedure == 2)
					vSystemData.vXRayTubeConditionStepTime = 60000; //1 minute
				else
				if (TempProcedure == 3)
					vSystemData.vXRayTubeConditionStepTime = 30000; //0.5 minute
				else
				if (TempProcedure == 4)
					vSystemData.vXRayTubeConditionStepTime = 6000; //10 second
				else
					vSystemData.vXRayTubeConditionStepTime = 300000; //5 minutes

				vSystemData.vXRayTubeConditionStepTimeLeft = vSystemData.vXRayTubeConditionStepTime / 1000;
				vSystemData.vXRayTubeConditionVoltageTable[0] = 20;
				vSystemData.vXRayTubeConditionCurrentTable[0]	= .15;
				vSystemData.vXRayTubeConditionVoltageTable[1] = 30;
				vSystemData.vXRayTubeConditionCurrentTable[1]	= .2;
				vSystemData.vXRayTubeConditionVoltageTable[2] = 40;
				vSystemData.vXRayTubeConditionCurrentTable[2]	= .25;
				vSystemData.vXRayTubeConditionVoltageTable[3] = 45;
				vSystemData.vXRayTubeConditionCurrentTable[3]	= .4;
				vSystemData.vXRayTubeConditionVoltageTable[4] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[4]	= .55;
				vSystemData.vXRayTubeConditionVoltageTable[5] = 55;
				vSystemData.vXRayTubeConditionCurrentTable[5]	= .7;
				vSystemData.vXRayTubeConditionVoltageTable[6] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[6]	= .85;
				vSystemData.vXRayTubeConditionVoltageTable[7] = 65;
				vSystemData.vXRayTubeConditionCurrentTable[7]	= 1;
				vSystemData.vXRayTubeConditionVoltageTable[8] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[8]	= 1.1;
				vSystemData.vXRayTubeConditionVoltageTable[9] = 70;
				vSystemData.vXRayTubeConditionCurrentTable[9]	= 1.25;
				vSystemData.vXRayTubeConditionVoltageTable[10] = 75;
				vSystemData.vXRayTubeConditionCurrentTable[10]	= 1.25;
				vSystemData.vXRayTubeConditionVoltageTable[11] = 80;
				vSystemData.vXRayTubeConditionCurrentTable[11]	= 1.25;
				vSystemData.vXRayTubeConditionVoltageTable[12] = 80;
				vSystemData.vXRayTubeConditionCurrentTable[12]	= 1.25;
			}
			else
			if (vConfigurationData->vHVPSType == cMNXHVPS)
			{
				vSystemData.vXRayTubeConditionVoltageTable[0] = 10;
				vSystemData.vXRayTubeConditionCurrentTable[0]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[1] = 15;
				vSystemData.vXRayTubeConditionCurrentTable[1]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[2] = 20;
				vSystemData.vXRayTubeConditionCurrentTable[2]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[3] = 25;
				vSystemData.vXRayTubeConditionCurrentTable[3]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[4] = 30;
				vSystemData.vXRayTubeConditionCurrentTable[4]	= .1;
				vSystemData.vXRayTubeConditionVoltageTable[5] = 35;
				vSystemData.vXRayTubeConditionCurrentTable[5]	= .2;
				vSystemData.vXRayTubeConditionVoltageTable[6] = 40;
				vSystemData.vXRayTubeConditionCurrentTable[6]	= .3;
				vSystemData.vXRayTubeConditionVoltageTable[7] = 45;
				vSystemData.vXRayTubeConditionCurrentTable[7]	= .4;
				vSystemData.vXRayTubeConditionVoltageTable[8] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[8]	= .5;
				vSystemData.vXRayTubeConditionVoltageTable[9] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[9]	= .6;
				vSystemData.vXRayTubeConditionVoltageTable[10] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[10]	= .7;
				vSystemData.vXRayTubeConditionVoltageTable[11] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[11]	= .8;
				vSystemData.vXRayTubeConditionVoltageTable[12] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[12]	= .9;
			}
			else
			{
				vSystemData.vXRayTubeConditionVoltageTable[0] = 40;
				vSystemData.vXRayTubeConditionCurrentTable[0]	= 1;
				vSystemData.vXRayTubeConditionVoltageTable[1] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[1]	= 2;
				vSystemData.vXRayTubeConditionVoltageTable[2] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[2]	= 4;
				vSystemData.vXRayTubeConditionVoltageTable[3] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[3]	= 8;
				vSystemData.vXRayTubeConditionVoltageTable[4] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[4]	= 8;
				vSystemData.vXRayTubeConditionVoltageTable[5] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[5]	= 8;
				vSystemData.vXRayTubeConditionVoltageTable[6] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[6]	= 8;
				vSystemData.vXRayTubeConditionVoltageTable[7] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[7]	= 85;
				vSystemData.vXRayTubeConditionVoltageTable[8] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[8]	= 8;
				vSystemData.vXRayTubeConditionVoltageTable[9] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[9]	= 85;
				vSystemData.vXRayTubeConditionVoltageTable[10] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[10] = 8;
				vSystemData.vXRayTubeConditionVoltageTable[11] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[11] = 8;
				vSystemData.vXRayTubeConditionVoltageTable[11] = 60;
				vSystemData.vXRayTubeConditionCurrentTable[11] = 8;
				if (vConfigurationData->vHVPSType >= cDXMHVPS)
				{
					vSystemData.vXRayTubeConditionVoltageTable[3] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[3]	= 8.5;
					vSystemData.vXRayTubeConditionVoltageTable[4] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[4]	= 8.5;
					vSystemData.vXRayTubeConditionVoltageTable[5] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[5]	= 8.5;
					vSystemData.vXRayTubeConditionVoltageTable[6] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[6]	= 8.5;
					vSystemData.vXRayTubeConditionVoltageTable[7] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[7]	= 8.5;
					vSystemData.vXRayTubeConditionVoltageTable[8] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[8]	= 8.5;
					vSystemData.vXRayTubeConditionVoltageTable[9] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[9]	= 8.5;
					vSystemData.vXRayTubeConditionVoltageTable[10] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[10] = 8.5;
					vSystemData.vXRayTubeConditionVoltageTable[11] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[11] = 8.5;
					vSystemData.vXRayTubeConditionVoltageTable[12] = 70;
					vSystemData.vXRayTubeConditionCurrentTable[12]	= 8.5;
				}
			}
			/*
			CSelectItemDialog ISelectItemDialog;
			
			//Set dialog box data titles and number value
			ISelectItemDialog.vTitleString = "Burn In";
			ISelectItemDialog.vNumberOfItems = 12;
			ISelectItemDialog.vBackgroundColor = cGreen;
			for (BYTE TempLoop = 0; TempLoop < 12; TempLoop++)
			{
				ISelectItemDialog.vItems[TempLoop] = "Step " + dtoa(TempLoop + 1,0) + 
					" Voltage: " + dtoa(vSystemData.vXRayTubeConditionVoltageTable[TempLoop]) + 
					" Current: " + dtoa(vSystemData.vXRayTubeConditionCurrentTable[TempLoop]);
			}
			ISelectItemDialog.m_DialogTitleStaticText2 = "Select Starting Step";
			ISelectItemDialog.m_DialogTitleStaticText3 = "Normal Burnin Start at Step 1";

			//Pass control to dialog box and display
			int nResponse = ISelectItemDialog. DoModal();
			//dialog box is now closed, if user pressed select do this
			//if user pressed cancel, do nothing
			if (nResponse == IDOK)
			{
				vSystemData.vXRayTubeConditionCurrentStep = ISelectItemDialog.vItemNumberSelected - 1;
				if (vSystemData.vXRayTubeConditionCurrentStep == 11)
					vSystemData.vXRayTubeConditionStepTimeLeft = 0;
			}
			else
				TempOKToDo = false;
			*/
			vSystemData.vXRayTubeConditionCurrentStep = 11;
			vSystemData.vXRayTubeConditionStepTimeLeft = 0;
		}
		else
		//if (vConfigurationData->vHVPSType)
		{
			vSystemData.vXRayTubeConditionStepTime = 300000; //5 minutes
			vSystemData.vXRayTubeConditionStepTimeLeft = vSystemData.vXRayTubeConditionStepTime / 1000;

			vSystemData.vXRayTubeConditionVoltageTable[0] = 20;
			vSystemData.vXRayTubeConditionCurrentTable[0]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[1] = 25;
			vSystemData.vXRayTubeConditionCurrentTable[1]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[2] = 30;
			vSystemData.vXRayTubeConditionCurrentTable[2]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[3] = 35;
			vSystemData.vXRayTubeConditionCurrentTable[3]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[4] = 40;
			vSystemData.vXRayTubeConditionCurrentTable[4]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[5] = 45;
			vSystemData.vXRayTubeConditionCurrentTable[5]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[6] = 50;
			vSystemData.vXRayTubeConditionCurrentTable[6]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[7] = 55;
			vSystemData.vXRayTubeConditionCurrentTable[7]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[8] = 60;
			vSystemData.vXRayTubeConditionCurrentTable[8]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[9] = 0;
			vSystemData.vXRayTubeConditionCurrentTable[9]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[10] = 0;
			vSystemData.vXRayTubeConditionCurrentTable[10]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[11] = 0;
			vSystemData.vXRayTubeConditionCurrentTable[11]	= 0;
			vSystemData.vXRayTubeConditionVoltageTable[12] = 0;
			vSystemData.vXRayTubeConditionCurrentTable[12]	= 0;
			if (vConfigurationData->vHVPSType)
			{
				vSystemData.vXRayTubeConditionVoltageTable[9] = 65;
				vSystemData.vXRayTubeConditionVoltageTable[10] = 70;
			}

			if (vConfigurationData->vHVPSType == cMNXHVPS)
			{
				vSystemData.vXRayTubeConditionVoltageTable[0] = 20;
				vSystemData.vXRayTubeConditionCurrentTable[0]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[1] = 25;
				vSystemData.vXRayTubeConditionCurrentTable[1]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[2] = 30;
				vSystemData.vXRayTubeConditionCurrentTable[2]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[3] = 35;
				vSystemData.vXRayTubeConditionCurrentTable[3]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[4] = 40;
				vSystemData.vXRayTubeConditionCurrentTable[4]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[5] = 45;
				vSystemData.vXRayTubeConditionCurrentTable[5]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[6] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[6]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[7] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[7]	= 0.2;
				vSystemData.vXRayTubeConditionVoltageTable[8] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[8]	= 0.4;
				vSystemData.vXRayTubeConditionVoltageTable[9] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[9]	= 0.5;
				vSystemData.vXRayTubeConditionVoltageTable[10] = 50;
				vSystemData.vXRayTubeConditionCurrentTable[10]	= 0.6;
				vSystemData.vXRayTubeConditionVoltageTable[11] = 0;
				vSystemData.vXRayTubeConditionCurrentTable[11]	= 0;
				vSystemData.vXRayTubeConditionVoltageTable[12] = 0;
				vSystemData.vXRayTubeConditionCurrentTable[12]	= 0;
			}
		}

		if (TempOKToDo)
		{
			vSystemData.vShuttingDownXRays = false;
			vSystemData.vSystemRunMode = cConditionXRayTubeMode;
			m_Calibrating.ShowWindow(SW_SHOW);
			SetDlgItemText(IDC_Calibrating, vSystemData.vConditionString + " Tube");

			if (!TempDoBurnIn)
			if (vGlobalDXMXRayPort)
			{
				vGlobalDXMXRayPort->SetXRayFilamentPreHeat(0);//.2 = .5 Amp Preheat
				vGlobalDXMXRayPort->SetXRayFilamentLimit(0);// 1 = full scale, or 4.6Amp limit
			}

			vSystemData.vRampXRayVoltageAmount = vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep] / 6.0;
			vSystemData.vRampXRayCurrentAmount = vSystemData.vXRayTubeConditionCurrentTable[vSystemData.vXRayTubeConditionCurrentStep];
			//vSystemData.vSourceRampedUp = false;
			//::PostThreadMessage(vGlobalCallingThreadID,cRampingSourceMessage,0,0);
			SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount, vSystemData.vRampXRayCurrentAmount);
			Sleep(10);
			if (vGlobaluCSerialPort)
			{
				SendXRayPowerOnOffToUController(1);
				if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
					vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterClose);
			}

			m_RejectReason.ShowWindow(SW_SHOW);
			if (vSystemData.vConditionString == "Burn-in")
				SetDlgItemText(IDC_RejectReason, "X-Ray Tube Burn-in\n" + 
					dtoa(vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep],0) + "kV  " + dtoa(vSystemData.vRampXRayCurrentAmount,2) + "mA");
			else
				SetDlgItemText(IDC_RejectReason, "X-Ray Tube " + vSystemData.vConditionString + " Step: " + dtoa(vSystemData.vXRayTubeConditionCurrentStep + 1,0) +
					" " + dtoa(vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep],0) + "kV  " + dtoa(vSystemData.vRampXRayCurrentAmount,2) + "mA");
			UpdateRunButton();

			ReportErrorMessage("Started X-Ray Tube " + vSystemData.vConditionString + " Step " + dtoa(vSystemData.vXRayTubeConditionCurrentStep + 1,0) + 
						" Voltage: " + dtoa(vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep]) + 
						" Current: " + dtoa(vSystemData.vXRayTubeConditionCurrentTable[vSystemData.vXRayTubeConditionCurrentStep]), cAction,0);
		}
	}
}

void CScanTracDlg::NextTubeConditionStep()
{
	ReportErrorMessage("Completed X-Ray Tube " + vSystemData.vConditionString + " Step: " + dtoa(vSystemData.vXRayTubeConditionCurrentStep + 1, 0) +
		" " + dtoa(vSystemData.vRampXRayVoltageAmount * 6,0) + "KV  " + dtoa(vSystemData.vRampXRayCurrentAmount,2) + "mA", cAction,0);

	vSystemData.vXRayTubeConditionCurrentStep++;
	//brh merge 6/18/2018
	if (((!vSystemData.vXRayTubeConditionCurrentTable[vSystemData.vXRayTubeConditionCurrentStep]) &&
		(!vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep])) ||
		(vSystemData.vXRayTubeConditionCurrentStep > 16))
	{ //done tube Condition
		if (vSystemData.vConditionString != "Burn-in")
		{
			ReportErrorMessage("Completed X-Ray Tube " + vSystemData.vConditionString, cUserChanges,0);

			if (vConditioningBeforeRun)
			{ //operator pressed Run, but needed to condition tube first, so now start running 
				vConditioningBeforeRun = false;

				SetDlgItemText(IDC_RejectReason, _T(" ")); //merge 12/6/2012
				SetDlgItemText(IDC_ContainersPerMinute, _T(" "));

				vSystemData.vModeToRunAfterCalibrateOffset = cRunningSystemMode;
				vSystemData.vCalibrateErrorCount = 0;
				vSystemData.vHadErrorTryRestart = 0;
				vSystemData.vCalibrateADCAfterDAC = true;
				vSystemData.vAutoCalibrate = true;
				vSystemData.vAutoCalibrateWhileRunning = false;
				vSystemData.vFullDetectorCalibration = false;
				if (vConfigurationData->vUseDACAndADCinDensityCompensation)
					CalibrateDACDetectorOffset();
				else
					CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
			}
			else
				StopRunning(true);
		}
	}
	else
	{  //set x-ray voltage and current for next step and display
		vSystemData.vRampXRayVoltageAmount = vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep] / 6.0;
		vSystemData.vRampXRayCurrentAmount = vSystemData.vXRayTubeConditionCurrentTable[vSystemData.vXRayTubeConditionCurrentStep];

		if (vSystemData.vRampXRayVoltageAmount > vConfigurationData->vMaximumVoltage / 6)
			vSystemData.vRampXRayVoltageAmount = vConfigurationData->vMaximumVoltage / 6;

		if (vSystemData.vRampXRayCurrentAmount > vConfigurationData->vMaximumCurrent)
			vSystemData.vRampXRayCurrentAmount = vConfigurationData->vMaximumCurrent;

		SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount, vSystemData.vRampXRayCurrentAmount);

		if (vSystemData.vXRayTubeConditionCurrentStep < 17)
			vSystemData.vXRayTubeConditionStepTimeLeft = vSystemData.vXRayTubeConditionStepTime / 1000;

		m_RejectReason.ShowWindow(SW_SHOW);
		SetDlgItemText(IDC_RejectReason, "X-Ray Tube " + vSystemData.vConditionString + " Step: " + dtoa(vSystemData.vXRayTubeConditionCurrentStep + 1,0) +
			" " + dtoa(vSystemData.vXRayTubeConditionVoltageTable[vSystemData.vXRayTubeConditionCurrentStep],0) + "KV  " + dtoa(vSystemData.vRampXRayCurrentAmount,2) + "mA");
	}
}

void CScanTracDlg::OnClose() 
{
	// TODO: Add your message handler code here and/or call default
	ReportErrorMessage("ScanTrac Close Main Window", cAction,0);
	if (vSystemData.vOKToCloseProgram)
		CDialog::OnClose();
}

void CScanTracDlg::MarkAllContainersAsConveyorStop()
{
	//ReportErrorMessage("Conveyor Stopped",cAction,0);
	if ((vConfigurationData->vShapeHandlingProcessIfConveyorStops == 1) &&
		(vConfigurationData->vShapeHandlingEjectors))
	if (vSystemData.vContainerCollection->GetCount())  //if have containers in tunnel
	{
		if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
		{  //eject each container in container collection
			//ReportErrorMessage(
			//	dtoa(vSystemData.vContainerCollection->GetCount(),0) +
			//	" Containers in Tunnel",cAction,0);

			POSITION TempIndex = vSystemData.vContainerCollection->GetHeadPosition();
			CContainer *TempContainer = vSystemData.vContainerCollection->GetAt(TempIndex);//GetHead();
			//Check Each Containter until get one before timeout
			while (TempContainer != NULL)
			{
				if (TempContainer->vTheImage)
				if (TempContainer->vTheImage->vContainerEjectReason == 255) //if already ejected, too late to mark conveyor stopped
				if (!TempContainer->vImageAnalyzed)//image analyzed and good, so don't mark conveyor stopped
				{
					//vSystemData.vConveyorJustStopped = true;
					TempContainer->vTheImage->vContainerEjectReason = cEjectContainerOnConveyorStop;
					ReportErrorMessage("Mark Container During Conveyor Stop, c: " + dtoa(TempContainer->vContainerNumber,0),cWriteToLog,0);
				}

				//get next container to check
				if (TempIndex)
					TempContainer = vSystemData.vContainerCollection->GetNext(TempIndex);
				else
					TempContainer = NULL;
			}
			vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();		
		}
	}

	if (vConfigurationData->vShapeHandlingProcessIfConveyorStops == 2)
	if (vSystemData.vContainerCollection->GetCount())  //if have containers in tunnel
	{
		if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
		{  //accept all containers in queueu
			//ReportErrorMessage(
			//	dtoa(vSystemData.vContainerCollection->GetCount(),0) +
			//	" Containers in Tunnel",cAction,0);

			POSITION TempIndex = vSystemData.vContainerCollection->GetHeadPosition();
			CContainer *TempContainer = vSystemData.vContainerCollection->GetAt(TempIndex);//GetHead();
			//Check Each Containter until get one before timeout
			while (TempContainer != NULL)
			{
				if (TempContainer->vTheImage)
				if (TempContainer->vTheImage->vContainerEjectReason == 255) //if alread ejected, too late to mark conveyor stopped
				if (!TempContainer->vImageAnalyzed) //alread analyzed and good, so don't mark conveyor stopped
				{
					TempContainer->vTheImage->vContainerEjectReason = cPassContainerOnConveyorStop;
				}

				//get next container to check
				if (TempIndex)
					TempContainer = vSystemData.vContainerCollection->GetNext(TempIndex);
				else
					TempContainer = NULL;
			}
			vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();		
		}
	}
}

void CScanTracDlg::ResetFPGAABFrameCounters()
{
	//set the on bit
	vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x10;

	Send0x9ACommand();
	//clear the on bit
	vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & 0xFFEF;

	Send0x9ACommand();
}

void CScanTracDlg::DisplayRejectHiddenMessage(int TempRejectReason)
{
	if (vGlobalCurrentProduct)
	if (TempRejectReason < vGlobalCurrentProduct->vNumberOfInspections)
		SetDlgItemText(IDC_Shift, "Rejected " + vSystemData.vCriteriaString[TempRejectReason] + " Hidden");
	KillTimer(vClearRejectHiddenTimerHandle);
	int TimerResult = SetTimer(vClearRejectHiddenTimerHandle,vConfigurationData->vSlippedIndicatorTime,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-ClearRejectHidden Timer Failed",cEMailInspx,32000);
}

void CScanTracDlg::ShowIndexPulseError(int TempSeamer)
{
	if ((TempSeamer == cFillerSamplingType) || (TempSeamer == cSeamerSamplingType))
		SetDlgItemText(IDC_Shift, vSystemData.vSamplingName[TempSeamer] + " Index Pulse Error");
	else
		SetDlgItemText(IDC_Shift, _T("Index Pulse Error"));

	KillTimer(vClearRejectHiddenTimerHandle);
	int TimerResult = SetTimer(vClearRejectHiddenTimerHandle,vConfigurationData->vSlippedIndicatorTime,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-ClearRejectHidden Timer Failed",cEMailInspx,32000);
}

void CScanTracDlg::SetFastestSimulatedEncoder(double TempFactor)
{
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->ClearEncoderHistory();

		if (vGlobalCurrentProduct)
			vSystemData.vMaximumEncoderRate = CalculateMaximumEncoderRate(vGlobalCurrentProduct->vXRayIntegrationTime);

	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("SetFastestSimulatedEncoder: " + dtoa(vSystemData.vMaximumEncoderRate,0),cDebugMessage);

	vSystemData.vSimulatingFastestEncoder = true;
	if (vSystemData.vFPGAVersion9Point0OrHigher)
	{  //uses micro-seconds for simulated encoder
		WORD Temp100KCounts = (WORD)(((1.0/(vSystemData.vMaximumEncoderRate * TempFactor) * cMaximumConveyorSpeedDerating * 1000) - 1.0) * 1.1); //the * 1.1 make it run at 92% of full speed.

		if (Temp100KCounts < 0x2B)
			Temp100KCounts = 0x2B;

		BYTE TempUpperByte = (BYTE)(Temp100KCounts >> 8);
		tSerialCommand TempCommand;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xBA;
		TempCommand[2] = TempUpperByte;
		TempCommand[3] = (BYTE)Temp100KCounts;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime);
		if (vSystemData.vActualEncoderRate == 0)
			vSystemData.vActualEncoderRate = 50;
			ReportErrorMessage("Set Simulated Encoder to Fastest: " + dtoa(vSystemData.vMaximumEncoderRate,0),cAction,0);
	}
	else
	{  //uses codes for simulated encoder
		//this code is for simulated encoder off. vSystemData.vFPGASimulateEncoderRate == 255
		//SimEncoder
		WORD TempCode = 0xFF00;  //code 255 for turn off simulated encoder
		if (vSystemData.vMaximumEncoderRate <= 50)
			TempCode = 240;  // 12Hz
		else
		if (vSystemData.vMaximumEncoderRate <= 100)
			TempCode = 60;  // 50Hz
		else
		if (vSystemData.vMaximumEncoderRate <= 200)
			TempCode = 30;  // 100Hz
		else
		if (vSystemData.vMaximumEncoderRate <= 500)
			TempCode = 15;  // 200Hz
		else
		if (vSystemData.vMaximumEncoderRate <= 1000)
			TempCode = 6;  // 500Hz
		else
		if (vSystemData.vMaximumEncoderRate <= 2307)
			TempCode = 3;  // 1000Hz
		else
			TempCode = 1;  // 2307Hz

		TempCode = TempCode << 8;  //must shift up to MSByte

		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetSimulatedEncoderRate(TempCode);
		if (vSystemData.vActualEncoderRate == 0)
			vSystemData.vActualEncoderRate = 50;
		ReportErrorMessage("Set Simulated Encoder to Fastest, code: " + dtoa(TempCode,0),cAction,0);
	}
	//enable or disable the encoder in the FPGA
	vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x01;
	//enable encoder for simulated encoder

	Send0x9ACommand();

	KillTimer(vConveyorStartTimerHandle);
	int TempTimerResult = SetTimer(vConveyorStartTimerHandle,5000,NULL);
	if (!TempTimerResult)
		ReportErrorMessage("Error-vConveyorStart Timer Failed",cEMailInspx,32000);
}

void CScanTracDlg::TurnSimulatedEncoderOn()
{
	vSystemData.vSimulatingFastestEncoder = false;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->ClearEncoderHistory();
	bool TempTurnedEncoderOn = false;
	if (vGlobaluCSerialPort)
	if (vSystemData.vFPGAVersion9Point0OrHigher)
	{  //uses micro-seconds for simulated encoder
		if (vSystemData.vFPGASimulateEncoderRate)
		{
			if (vSystemData.vFPGASimulateEncoderRate > 50000)
				vSystemData.vFPGASimulateEncoderRate = 50000;

			TempTurnedEncoderOn = true;
			//if (vSystemData.vActualEncoderRate == 0)
			//	vSystemData.vActualEncoderRate = 50;
			//vGlobaluCSerialPort->SetSimulatedEncoderRate(vSystemData.vFPGASimulateEncoderRate);
			//convert to counts then back to hertz so can see actual value obtained
			WORD Temp100KCounts = (WORD)(((1.0/(double)vSystemData.vFPGASimulateEncoderRate) * 100000.0) - 1.0);
			//if (Temp100KCounts < 0x2B)
			//	Temp100KCounts = 0x2B;
			BYTE TempUpperByte = (BYTE)(Temp100KCounts >> 8);
			tSerialCommand TempCommand;
			TempCommand[0] = 0x23;
			TempCommand[1] = 0xBA;
			TempCommand[2] = TempUpperByte;
			TempCommand[3] = (BYTE)Temp100KCounts;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);

			ReportErrorMessage("1. Set Simulated Encoder to: " + dtoa(vSystemData.vFPGASimulateEncoderRate,0),cAction,0);
			Sleep(cSendCommandSleepTime);
		}
		else
		{
			//convert to counts then back to hertz so can see actual value obtained
			WORD Temp100KCounts = 0;

			if (vGlobalCurrentProduct->vXRayIntegrationTime == 750)
			if (vConfigurationData->vContinuousFeedEncoderRate > 2250)
				vConfigurationData->vContinuousFeedEncoderRate = 2250;

			if (vConfigurationData->vContinuousFeedEncoderRate > 50000)
				vConfigurationData->vContinuousFeedEncoderRate = 50000;
			if (vConfigurationData->vContinuousFeedEncoderRate)
			{
				Temp100KCounts = (WORD)(((1.0/(double)vConfigurationData->vContinuousFeedEncoderRate) * 100000.0) - 1.0);
				if (vSystemData.vActualEncoderRate == 0)
					vSystemData.vActualEncoderRate = 50;
			}
			if (Temp100KCounts)
				TempTurnedEncoderOn = true;
			BYTE TempUpperByte = (BYTE)(Temp100KCounts >> 8);
			tSerialCommand TempCommand;
			TempCommand[0] = 0x23;
			TempCommand[1] = 0xBA;
			TempCommand[2] = TempUpperByte;
			TempCommand[3] = (BYTE)Temp100KCounts;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);
			ReportErrorMessage("2. Set Simulated Encoder to: " + dtoa(vConfigurationData->vContinuousFeedEncoderRate,0),cAction,0);
		}

		//if (vConfigurationData->vSimulateLightControlBoard)
		//if (vSystemData.vFPGASimulateEncoderRate)
		//	vGlobaluCSerialPort->SetSimulatedEncoderRate(vSystemData.vFPGASimulateEncoderRate);
		//else
		//if (vConfigurationData->vContinuousFeedEncoderRate)
		//	vGlobaluCSerialPort->SetSimulatedEncoderRate(vConfigurationData->vContinuousFeedEncoderRate);
		//else
		//		SetFastestSimulatedEncoder(1);
	}
	else
	{  //uses codes for simulated encoder
		//this code is for simulated encoder off. vSystemData.vFPGASimulateEncoderRate == 255

		if (vSystemData.vFPGASimulateEncoderRate)
		{
			WORD TempSimulatedEncoderCode = 0xFF00;  //code 255 for turn off simulated encoder
			if (vSystemData.vFPGASimulateEncoderRate)
			{
				if (vSystemData.vFPGASimulateEncoderRate <= 12)
					TempSimulatedEncoderCode = 240;  // 12Hz
				else
				if (vSystemData.vFPGASimulateEncoderRate <= 50)
					TempSimulatedEncoderCode = 60;  // 50Hz
				else
				if (vSystemData.vFPGASimulateEncoderRate <= 100)
					TempSimulatedEncoderCode = 30;  // 100Hz
				else
				if (vSystemData.vFPGASimulateEncoderRate <= 200)
					TempSimulatedEncoderCode = 15;  // 200Hz
				else
				if (vSystemData.vFPGASimulateEncoderRate <= 500)
					TempSimulatedEncoderCode = 6;  // 500Hz
				else
				if (vSystemData.vFPGASimulateEncoderRate <= 1000)
					TempSimulatedEncoderCode = 3;  // 1000Hz
				else
					TempSimulatedEncoderCode = 1;  // 2307Hz
				TempTurnedEncoderOn = true;
			}
			TempSimulatedEncoderCode = TempSimulatedEncoderCode << 8;  //must shift up to MSByte
			vGlobaluCSerialPort->SetSimulatedEncoderRate(TempSimulatedEncoderCode);
		}
		else
		{
			WORD TempSimulatedEncoderCode = 0xFF;  //code 255 for turn off simulated encoder
			if (vConfigurationData->vContinuousFeedEncoderRate > 1500)
				TempSimulatedEncoderCode = 1;  // 2307Hz
			else
			if (vConfigurationData->vContinuousFeedEncoderRate)
			{
				TempSimulatedEncoderCode = (WORD)
					(3000.0 / vConfigurationData->vContinuousFeedEncoderRate);
			}
			if (TempSimulatedEncoderCode != 255)
				TempTurnedEncoderOn = true;

			TempSimulatedEncoderCode = TempSimulatedEncoderCode << 8;  //must shift up to MSByte
			vGlobaluCSerialPort->SetSimulatedEncoderRate(TempSimulatedEncoderCode);
		}

		if (vConfigurationData->vSimulateLightControlBoard)
		if (!vSystemData.vFPGASimulateEncoderRate)
		if (!vConfigurationData->vContinuousFeedEncoderRate)
				SetFastestSimulatedEncoder(1);
	}
	//enable or disable the encoder in the FPGA
	if (TempTurnedEncoderOn)
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x01;//enable encoder for simulated encoder
	else
	if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && ((vConfigurationData->vScanTracType == cAtempoScanTrac) || (vConfigurationData->vScanTracType == cForteScanTrac)))
	{
		//does this when source has stabilized
		vSystemData.vSecondsMeasuringRealConveyorEncoder = 0;
		vSystemData.vRealConveyorEncoderPulsesCount = 0;
		if (!vConfigurationData->vUseRealEncoder)
		if ((!vSystemData.vFPGASimulateEncoderRate) && (!vConfigurationData->vContinuousFeedEncoderRate))
			vSystemData.vRealConveyorEncoderPulsesCount = 1;
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x01;//enable encoder for simulated encoder
	}
	else
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & 0xFFFE;//disable encoder for simulated encoder

	Send0x9ACommand();

	if ((vSystemData.vFPGASimulateEncoderRate) ||
		(vConfigurationData->vContinuousFeedEncoderRate))
	{
		KillTimer(vConveyorStartTimerHandle);
		int TempTimerResult = SetTimer(vConveyorStartTimerHandle,5000,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-vConveyorStart Timer Failed",cWriteToLog,32000);
	}
}

void CScanTracDlg::TurnSimulatedEncoderOff()
{
	if (vGlobaluCSerialPort)
	if (vSystemData.vFPGAVersion9Point0OrHigher)
	{  //uses micro-seconds for simulated encoder
		vGlobaluCSerialPort->SetSimulatedEncoderRate(0);
	}
	else
	{  //uses codes for simulated encoder
		//0xFF00 this code is for simulated encoder off. vSystemData.vFPGASimulateEncoderRate == 255
		vGlobaluCSerialPort->SetSimulatedEncoderRate(0xFF00);
	}
	vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & 0xFFFE;//disable encoder for simulated encoder

	Send0x9ACommand();

	//KJH Version 18 needs this
	tSerialCommand TempCommand;
	TempCommand[0] = 0x23;
	TempCommand[1] = 0xBA;
	TempCommand[2] = 0;
	TempCommand[3] = 0;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTime);
	ReportErrorMessage("3. Set Simulated Encoder to 0",cAction,0);

	vSystemData.vSimulatingFastestEncoder = false;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->ClearEncoderHistory();
}

void CScanTracDlg::CalibrateDetectorGain()
{
	if (vGlobalDXMXRayPort)
		vGlobalDXMXRayPort->EnableWatchDog(false);  //calculations can take a long time, so disable watch dog
	if (vSystemData.vSystemRunMode != cStoppedSystemMode)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nSystem must be stopped, operation aborted";
		TempNoticeDialog.vType = cNoticeMessage;
		TempNoticeDialog.DoModal();
	}
	else
	{
		KillTimer(vConveyorStartTimerHandle);
		vSystemData.vCalibrationImageNumber = 0;
		vSystemData.vDensityIndex = 0;
		vSystemData.vCheckConveyor = false;
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("CalibrateDetectorGain Counters and Queues",cDebugMessage);
		ResetFPGAABFrameCounters();

		if (vGlobalImageAquisitionThread)
		{
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Start Calibrate Gain Reset a/b frame Counters",cDebugMessage);
			vGlobalImageAquisitionThread->vAFrameCounter = 0;
			vGlobalImageAquisitionThread->vBFrameCounter = 0;
			vGlobalImageAquisitionThread->vPreviousHardwareFrameCount = -1;
		}
		Sleep(cSendCommandSleepTime + 10);

		//start enable body trigger to clear uController queues
		tSerialCommand TempCommand;
		TempCommand[0] = 0x1C;
		TempCommand[1] = 4;
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x01;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime + 10);
		//start enable body trigger to clear uController queues
		TempCommand[0] = 0x1C;
		TempCommand[1] = 4;
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x00;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime + 10);

		vSystemData.vSystemRunMode = cCalibratingDetectorGainMode;
		CString TempText = " ";
		TempText.LoadString(IDS_Abort);
		SetDlgItemText(IDC_SubFunction1Button,TempText);
		UpdateRunButton();

		CString TempText1 = " ";
		TempText.LoadString(IDS_Calibrating);
		SetDlgItemText(IDC_Calibrating,TempText);
		m_Calibrating.ShowWindow(SW_SHOW);
		
		//LoadCalibrateOffsetProduct();		
		BYTE TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfXRayDetectors - vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration;
		if (vConfigurationData->vNumberOfDetectorsToCalibrate)
			TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfDetectorsToCalibrate - vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; 

		if (vGlobalCurrentProduct)
		{
			
			//Send Container Trigger to Image Delay
			BYTE TempActiveHigh = 0;
			if ((vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBodyTrigger - 1].vActiveHigh) ||
					(vSystemData.vFPGAVersion10Point7OrHigher)) //always active high in FPGA 10.7 and above
				TempActiveHigh = 0x80;
			WORD TempBTToImagePosition = 10;
			tSerialCommand TempCommand;
			TempCommand[0] = 0x18;
			TempCommand[1] = (BYTE)(TempBTToImagePosition >> 8);
			TempCommand[2] = (BYTE)TempBTToImagePosition;
			TempCommand[3] = TempActiveHigh;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime + 10);

			TempText.LoadString(IDS_XRAY);
			vSystemData.vXRayState = 25;
			::PostThreadMessage(vGlobalCallingThreadID,cXRaysOnMessage,25,0); //turn on X-Rays
			ReportErrorMessage("X-Rays Starting Up Step: 25d", cWriteToLog, 0);
			m_Calibrating.ShowWindow(SW_SHOW);
			SendXRayPowerOnOffToUController(1);

			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("End CalibrateDetectorGain ScanTracDlg",cDebugMessage);
		}
		//vSystemData.vRampXRayStep = 0;
		vCalibrateCurrentStep = 0;

		double TempMaximumCurrent = vConfigurationData->vMaximumCurrent;
		double TempMaxValue = GetMaximumCurrentFromVoltage(vGlobalCurrentProduct->vXRaySourceVoltage * 6);
		if (TempMaximumCurrent > TempMaxValue)
			TempMaximumCurrent = TempMaxValue;

		TempMaxValue = GetMaximumCurrentFromPower(vGlobalCurrentProduct->vXRaySourceVoltage * 6, vConfigurationData->vMaximumPower);
		if (TempMaximumCurrent > TempMaxValue)
			TempMaximumCurrent = TempMaxValue;

		if (vGlobalCurrentProduct->vXRaySourceCurrent > TempMaximumCurrent)
			vGlobalCurrentProduct->vXRaySourceCurrent = (float)TempMaximumCurrent;

		vCalibrateCurrent = vGlobalCurrentProduct->vXRaySourceCurrent;
		vSystemData.vRampXRayCurrentAmount = vCalibrateCurrent;  //set product current to first step so will ramp to it
		////brh temp
		//		ReportErrorMessage("Calibrate Gain Set Current: " + dtoa(vCalibrateCurrent,4) + ", V: " + dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6, 4), cError, 0);
		//
		//vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;

		//SendSourceSettingsToUController(vGlobalCurrentProduct->vXRaySourceVoltage, vCalibrateCurrent);

		if (vGlobaluCSerialPort)
		if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
			vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterOpen);
		vSystemData.vShuttingDownXRays = false;

		vSystemData.vCalibrationSimulationStarted = false;
		
		ReportErrorMessage("Start Calibrate Detector Gain Pass: " + 
			dtoa(vSystemData.vCalibrateGainIterationNumber,0), cWriteToLog,0);
		ResetCounters();
		vSystemData.vCalibrationImageNumber = 0;
		if (vSystemData.vCalibrateGainIterationNumber)
			vSystemData.vCalibrationGainRange = 1;  //range is amount to add or subtract  
		else
			vSystemData.vCalibrationGainRange = 5;  //range is amount to add or subtract  

		CString TempCalibrationNumbersString = "";
			for (BYTE TempLoop = vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoop < TempNumberOfDetectorsToAdjustGain + vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoop++)
			TempCalibrationNumbersString = TempCalibrationNumbersString + 
				dtoa(vConfigurationData->vDetectorGain[TempLoop],2) + ", ";
		ReportErrorMessage("Find Gain Step:0: " + 
			TempCalibrationNumbersString, cWriteToLog,0);

		SendADCGainsAndOffsets(false);
	}
}

void CScanTracDlg::ProcessCalibrateDetectorGain()
{
	vSystemData.vCalibrationImageNumber++;
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("STD-ProcessDetectorGainFrame: " +
		dtoa(vSystemData.vCalibrationImageNumber,0),cDebugMessage);
	//take frame and output to a file
	CString TempText = "Calibrate Gain:" + dtoa(vSystemData.vCalibrationImageNumber,0);
	SetDlgItemText(IDC_Calibrating,TempText);

	BYTE TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfXRayDetectors;
	if (vConfigurationData->vNumberOfDetectorsToCalibrate)
		TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfDetectorsToCalibrate - vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; 

	if (vConfigurationData->vSimulateLightControlBoard)
		FillMemory(vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage, vSystemData.vITIPCDig->vOriginalBufferSize, 120);

	if (vSystemData.vCalibrationImageNumber == 1)
	{//if first time through find darkest array, set its value as the target
		//Create data structures for each detectors data
			for (WORD TempLoopDetector = vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector < TempNumberOfDetectorsToAdjustGain + vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector++)
		{
			if (vSystemData.vDetectorDensityData[TempLoopDetector])
			{
				free(vSystemData.vDetectorDensityData[TempLoopDetector]);
				vSystemData.vDetectorDensityData[TempLoopDetector] = NULL;
			}
			if (ThereIsEnoughMemory(cStandardDeviationSampleSize * sizeof(double),"Density Sample Array"))
			{
				vSystemData.vDetectorDensityData[TempLoopDetector] = (double*)malloc(cStandardDeviationSampleSize * sizeof(double));
			}
		}  
	}
	double TempDensityValue = 0;
	//do souce density average for each detector

	if ((vSystemData.vITIPCDig->vOriginalImage) && (vSystemData.vITIPCDig->vOriginalImage->vGreyImage))
	for (WORD TempLoopDetector = vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector < TempNumberOfDetectorsToAdjustGain + vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector++)
	if (vSystemData.vDetectorDensityData[TempLoopDetector])
	{
		float TempSum = 0;
		BYTE *TempPointer = NULL;

		//add up all the pixels in all the lines except the first 5 and last 5 pixels 
		//in each line
		if ((vSystemData.vITIPCDig->vNextImageToDisplay) && (vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage))
		if (vSystemData.vITIPCDig->vNextImageToDisplayLock.Lock())
		{
			CopyMemory(vSystemData.vITIPCDig->vOriginalImage->vGreyImage, vSystemData.vITIPCDig->vNextImageToDisplay->vGreyImage, vSystemData.vITIPCDig->vOriginalBufferSize);

			vSystemData.vITIPCDig->vNextImageToDisplayLock.Unlock();
		}
		DWORD TempCount = 0;
		for (WORD TempLoopY = 0; TempLoopY < vSystemData.vITIPCDig->vOriginalBufferSizeY; TempLoopY++)
		{
			WORD TempNumberOfPixelsOnBottomToIgnore = 0;
			if (((TempLoopDetector) * vConfigurationData->vPixelsPerDetector) < vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration)
			{
				TempNumberOfPixelsOnBottomToIgnore = vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration - (TempLoopDetector * vConfigurationData->vPixelsPerDetector);
			}
			TempPointer = vSystemData.vITIPCDig->vOriginalImage->vGreyImage + (TempLoopDetector * vConfigurationData->vPixelsPerDetector) +
				(TempLoopY * vSystemData.vITIPCDig->vOriginalBufferSizeX) + TempNumberOfPixelsOnBottomToIgnore;

			for (WORD TempLoopX = TempNumberOfPixelsOnBottomToIgnore; TempLoopX < vConfigurationData->vPixelsPerDetector - 5;	TempLoopX++)
			{
				if ((DWORD)((TempLoopDetector * vConfigurationData->vPixelsPerDetector) + TempLoopX + (TempLoopY  * vSystemData.vITIPCDig->vOriginalBufferSizeX)) < 
					vSystemData.vITIPCDig->vOriginalBufferSize)
				{
					TempSum = TempSum + *TempPointer++;
					TempCount++;
				}
			}
		}
		//calculate the density of this detector
		if (TempCount)
			TempDensityValue = TempSum / TempCount;
		else
			TempDensityValue = 0;
		double *TempDataPointer = vSystemData.vDetectorDensityData[TempLoopDetector] + vSystemData.vDensityIndex;

		//crashed here vDensityIndex corrupted by going beyond vDetectorDensityData
		*TempDataPointer = TempDensityValue;
		
		//ReportErrorMessage("Find Gain Loop: " + dtoa(vSystemData.vCalibrationImageNumber,0) +
		//	" Detector: " + dtoa(TempLoopDetector,0) + " Density: " +
		//	dtoa(*TempDataPointer,2),cWriteToLog,0);
	}
	bool TempImageBrightnessOK = true;

	if (vSystemData.vCalibrationImageNumber == 1)
	{//if first time through find darkest array, set its value as the target
		vSystemData.vTargetDetectorGainValue = 255;
			for (WORD TempLoopDetector = vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector < TempNumberOfDetectorsToAdjustGain + vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector++)
		if (((TempLoopDetector + 1) * vConfigurationData->vPixelsPerDetector) > vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration + 5)
		{
			double *TempDataPointer = vSystemData.vDetectorDensityData[TempLoopDetector] + vSystemData.vDensityIndex;
			if (*TempDataPointer < vSystemData.vTargetDetectorGainValue)
				vSystemData.vTargetDetectorGainValue = *TempDataPointer;
		}
		//reduce target value by 5 on first pass so highest gain is about 9.5 instead of 10
		if (vSystemData.vCalibrateGainIterationNumber == 0)
			vSystemData.vTargetDetectorGainValue = vSystemData.vTargetDetectorGainValue;

		ReportErrorMessage("Process Gain Image Density: " + 
			dtoa(TempDensityValue,2),cWriteToLog,0);

		if (vSystemData.vTargetDetectorGainValue > 150)
		{
			TempImageBrightnessOK = false;
			if (vGlobalCurrentProduct->vXRaySourceVoltage * 6 > 15)
			{
				vSystemData.vCalibrationImageNumber = 0;

				vGlobalCurrentProduct->vXRaySourceVoltage = 
					(float)(vGlobalCurrentProduct->vXRaySourceVoltage - .1);

				vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;
				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

				ReportErrorMessage("Process Gain Too Bright (" +  
					dtoa(vSystemData.vTargetDetectorGainValue,2) + ") Droped Voltage to:" + 
					dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cWriteToLog,0);
			}
			else
			if (vGlobalCurrentProduct->vXRaySourceCurrent > .5) //was .149)
			{
				vSystemData.vCalibrationImageNumber = 0;

				vGlobalCurrentProduct->vXRaySourceCurrent = 
					(float)(vGlobalCurrentProduct->vXRaySourceCurrent - .05);

				vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;

				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

				ReportErrorMessage("Process Gain Too Bright (" +  
					dtoa(vSystemData.vTargetDetectorGainValue,2) + ") Droped Current to:" + 
					dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1),cWriteToLog,0);
			}
			else
			{
				ReportErrorMessage("Process Gain Too Bright Max Voltage and Current:" + 
					dtoa(vSystemData.vTargetDetectorGainValue,2),cWriteToLog,0);

				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = 
					"\n\n~Calibrate Gain Product too Bright (" + 
					dtoa(vSystemData.vTargetDetectorGainValue,2) +
					")\nIf results are not good, Decrease Brightness, Calibrate Gain Again";
				TempNoticeDialog.vType = cNoticeMessage;
				TempNoticeDialog.DoModal();

				TempImageBrightnessOK = true;
			}
		}
		else
		if (vSystemData.vTargetDetectorGainValue < 100)
		{
			TempImageBrightnessOK = false;

			double TempMaximumCurrent = vConfigurationData->vMaximumCurrent;
			double TempMaxValue = GetMaximumCurrentFromVoltage(vGlobalCurrentProduct->vXRaySourceVoltage * 6);
			if (TempMaximumCurrent > TempMaxValue)
				TempMaximumCurrent = TempMaxValue;

			TempMaxValue = GetMaximumCurrentFromPower(vGlobalCurrentProduct->vXRaySourceVoltage * 6, vConfigurationData->vMaximumPower);
			if (TempMaximumCurrent > TempMaxValue)
				TempMaximumCurrent = TempMaxValue;

			if (vGlobalCurrentProduct->vXRaySourceVoltage * 6.0 < vConfigurationData->vMaximumVoltage)
			{
				vSystemData.vCalibrationImageNumber = 0;
				vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vGlobalCurrentProduct->vXRaySourceVoltage + .1);

				if (vGlobalCurrentProduct->vXRaySourceVoltage > vConfigurationData->vMaximumVoltage / 6.0)
					vGlobalCurrentProduct->vXRaySourceVoltage = (float)(vConfigurationData->vMaximumVoltage / 6.0);
				vSystemData.vRampXRayVoltageAmount = vGlobalCurrentProduct->vXRaySourceVoltage;

				double TempMaximumCurrent = vConfigurationData->vMaximumCurrent;
				double TempMaxValue = GetMaximumCurrentFromVoltage(vGlobalCurrentProduct->vXRaySourceVoltage * 6);
				if (TempMaximumCurrent > TempMaxValue)
					TempMaximumCurrent = TempMaxValue;

				TempMaxValue = GetMaximumCurrentFromPower(vGlobalCurrentProduct->vXRaySourceVoltage * 6, vConfigurationData->vMaximumPower);
				if (TempMaximumCurrent > TempMaxValue)
					TempMaximumCurrent = TempMaxValue;

				if (vGlobalCurrentProduct->vXRaySourceCurrent > TempMaximumCurrent)
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)TempMaximumCurrent;
				vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;

				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

				ReportErrorMessage("Process Gain Too Dark (" + dtoa(vSystemData.vTargetDetectorGainValue,2) + ") Increased Voltage to: " + 
					dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6,1),cWriteToLog,0);
			}
			else
			if (vGlobalCurrentProduct->vXRaySourceCurrent + .05 < TempMaximumCurrent)
			{
				vSystemData.vCalibrationImageNumber = 0;

				vGlobalCurrentProduct->vXRaySourceCurrent = (float)(vGlobalCurrentProduct->vXRaySourceCurrent + .05);

				if (vGlobalCurrentProduct->vXRaySourceCurrent > TempMaximumCurrent)
					vGlobalCurrentProduct->vXRaySourceCurrent = (float)TempMaximumCurrent;

				vSystemData.vRampXRayCurrentAmount = vGlobalCurrentProduct->vXRaySourceCurrent;
				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,vSystemData.vRampXRayCurrentAmount);

				ReportErrorMessage("Process Gain Too Dark (" + dtoa(vSystemData.vTargetDetectorGainValue,2) + ") Increased Current to:" + 
					dtoa(vGlobalCurrentProduct->vXRaySourceCurrent,1),cWriteToLog,0);
			}
			else
			{
				ReportErrorMessage("Process Gain Too Dark Maxed Voltage and Current:" + dtoa(vSystemData.vTargetDetectorGainValue,2),cWriteToLog,0);

				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\n~Calibrate Gain Product too Dark (" + dtoa(vSystemData.vTargetDetectorGainValue,2) +
					")\nIf results are not good, Increase Brightness, Calibrate Gain Again";
				TempNoticeDialog.vType = cNoticeMessage;
				TempNoticeDialog.DoModal();

				TempImageBrightnessOK = true;
			}
		}
		else
		{
			ReportErrorMessage("Find Gain Target Value: " + dtoa(vSystemData.vTargetDetectorGainValue,0),cWriteToLog,0);
		}
	}
	if (TempImageBrightnessOK)
	{

		if ((vSystemData.vCalibrationImageNumber < 16) && (vSystemData.vCalibrationImageNumber > 1))
			vSystemData.vCalibrationGainRange = vSystemData.vCalibrationGainRange / 2;

		for (BYTE TempLoopDetector = 0; TempLoopDetector < TempNumberOfDetectorsToAdjustGain; TempLoopDetector++)
		for (WORD TempLoopDetector = vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector < TempNumberOfDetectorsToAdjustGain + vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector++)
		{
			double *TempDataPointer = vSystemData.vDetectorDensityData[TempLoopDetector] + vSystemData.vDensityIndex;
			if (*TempDataPointer > vSystemData.vTargetDetectorGainValue)
			{
				vConfigurationData->vDetectorGain[TempLoopDetector] = vConfigurationData->vDetectorGain[TempLoopDetector] - vSystemData.vCalibrationGainRange;

				if (vConfigurationData->vDetectorGain[TempLoopDetector] < 2)
					vConfigurationData->vDetectorGain[TempLoopDetector] = 2;

				//ReportErrorMessage("Gain Loop: " + dtoa(vSystemData.vCalibrationImageNumber,0) + " Detector: " + dtoa(TempLoopDetector,0) + " Too High, Lowered to: " +
				//	dtoa(vConfigurationData->vDetectorGain[TempLoopDetector],4),cWriteToLog,0);
				if (vSystemData.vLogFile.vLogSerialData)
				{
					vSystemData.vLogFile.WriteToLogFile( "Gain Loop: " + dtoa(vSystemData.vCalibrationImageNumber,0) +
						" Detector: " + dtoa(TempLoopDetector,0) + " Too High, Lowered to: " + dtoa(vConfigurationData->vDetectorGain[TempLoopDetector],4),cDebugMessage);
				}
			}
			else
			if (*TempDataPointer < vSystemData.vTargetDetectorGainValue)
			{
				vConfigurationData->vDetectorGain[TempLoopDetector] = vConfigurationData->vDetectorGain[TempLoopDetector] + vSystemData.vCalibrationGainRange;

				if (vConfigurationData->vDetectorGain[TempLoopDetector] > 10)
					vConfigurationData->vDetectorGain[TempLoopDetector] = 10;

				if (vSystemData.vLogFile.vLogSerialData)
					vSystemData.vLogFile.WriteToLogFile("Gain Loop: " + dtoa(vSystemData.vCalibrationImageNumber,0) +
						" Detector: " + dtoa(TempLoopDetector,0) + " Too Low, Raised to: " + dtoa(vConfigurationData->vDetectorGain[TempLoopDetector],4),cDebugMessage);
			}
			else
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Gain Loop: " + dtoa(vSystemData.vCalibrationImageNumber,0) + " Detector: " + dtoa(TempLoopDetector,0) + " Gain Close Enough",cDebugMessage);
		}
		SendADCGainsAndOffsets(false);

		if (vSystemData.vDensityIndex < (cStandardDeviationSampleSize - 1))
			vSystemData.vDensityIndex++;

		CString TempCalibrationNumbersString = "";
		for (BYTE TempLoop = vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoop < TempNumberOfDetectorsToAdjustGain + vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoop++)
			TempCalibrationNumbersString = TempCalibrationNumbersString + dtoa(vConfigurationData->vDetectorGain[TempLoop],2) + ", ";

		ReportErrorMessage("Find Gain Step:" + dtoa(vSystemData.vCalibrationImageNumber,0) + ": " + TempCalibrationNumbersString, cWriteToLog,0);
	}

	if (vSystemData.vCalibrationImageNumber >= 14)
	{ //have taken the cNumberOfCalibrationImages (10) images, so stop calibration mode
		EndCalibrateDetectorGain(false);
	}
	else
	{ 
		int TimerResult = SetTimer(vSimulateOneContainerTimer,500,NULL);
		if (!TimerResult)
			ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx, 32000);
	}
}

void CScanTracDlg::EndCalibrateDetectorGain(bool TempAbort)
{
	if (vAbortCalibration)
		TempAbort = true;

	KillTimer(vConveyorStartTimerHandle);
	if (TempAbort)
		ReportErrorMessage("Abort CalibrateDetectorGain",cUserChanges,0);
	else
		ReportErrorMessage("EndCalibrateDetectorGain",cAction,0);

	m_SubFunction1Button.ShowWindow(SW_HIDE);
	this->InvalidateRect(&m_SubFunction1Button.GetRectToInvalidateArrow());
	m_Calibrating.ShowWindow(SW_HIDE);

	KillTimer(vSourceStabilizeTimerHandle);

	SendXRayPowerOnOffToUController(0);
	vSystemData.vSourceRampedUp = false;
	StopImageAcquisition();
	vSystemData.vDigitalInputLine3Mask = 0x00;
	vSystemData.vCurrentBodyTriggerMask = 0;

	SendConveyorOnOffToUController(0);

	FinishStopRunning(true);

	ReportErrorMessage("End Calibrate Detector Gain", cWriteToLog,0);
	UpdateRunButton();

	vSystemData.vCalibrateGainIterationNumber++;
	if (TempAbort)
		RestoreOriginalProduct();
	//if just calibrating gains, and done with last pass, restore product, else reset counts
	if ((!vSystemData.vFullDetectorCalibration) && 
		(vSystemData.vCalibrateGainIterationNumber == cNumberOfTimesToCalibrateGain))
		RestoreOriginalProduct(); 
	else
		ResetCounters();

	WriteConfigurationDataToFile(false); //write to main config file

	//test for calibration
	CString TempDirectoryString = vConfigurationData->vScanTracCalibrationImagesDirectory;
	CString TempString = TempDirectoryString + "EqualizeDetectorGains.csv";

	TempString.Insert(TempString.GetLength() - 4, dtoa(vSystemData.vCalibrateGainIterationNumber,0) + "-" + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3) + "mSec" + 
		dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6.0, 1) + "kV");

	LPCTSTR TempFileName = TempString;
	CFileException TempFileException;
	if (ThereIsEnoughMemory(sizeof(CFile), "Equalize Detector Gains Data File"))
	{
		vCalibrationDataFile = new CFile;
		if (vCalibrationDataFile)
		{
			int TempFileOpened = vCalibrationDataFile->Open(TempFileName, (CFile::modeCreate | CFile::modeReadWrite), &TempFileException);
			if (TempFileOpened == 0)
			{
				//could not open serial log file
				ReportErrorMessage("Error-Open File Failed: " + TempString, cEMailInspx,32000);// + TempFileException.m_cause); 
				#ifdef _DEBUG
					afxDump << "Could Not Calibration Data File"  << "\n";
				#endif
			}
			else
			{
				//write the image data to the file
				TRY
				{
					CString TempString = "D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12\n";
					CW2A TempStringToWrite(TempString);
					vCalibrationDataFile->Write(TempStringToWrite, TempString.GetLength());

					BYTE TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfXRayDetectors;
					if (vConfigurationData->vNumberOfDetectorsToCalibrate)
						TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfDetectorsToCalibrate; 

					for (BYTE TempLoopDetector = 0; TempLoopDetector < TempNumberOfDetectorsToAdjustGain; TempLoopDetector++)
					{
						TempString = dtoa(vConfigurationData->vDetectorGain[TempLoopDetector], 2) + ", ";
						CW2A TempStringToWrite(TempString);
						vCalibrationDataFile->Write(TempStringToWrite, TempString.GetLength() );
					}
					TempString = "\n";
					CW2A TempStringToWrite1(TempString);
					vCalibrationDataFile->Write(TempStringToWrite1, TempString.GetLength());
				}
				CATCH_ALL(TempFileException)
				{
					ReportErrorMessage("Error Writing to CSV File",cEMailInspx,32000);
					//#ifdef _DEBUG
					//	afxDump << "Could Not Write Calibration File"  << "\n";
					//#endif
				}
				END_CATCH_ALL
				TRY
				{
					vCalibrationDataFile->Close();
				}
				CATCH_ALL(TempFileException)
				{
					ReportErrorMessage("Error Closing CSV File",cEMailInspx,32000);
				 #ifdef _DEBUG
						afxDump << "Could Not Close Calibration Image File"  << "\n";
				 #endif
				}
				END_CATCH_ALL
			}
			delete vCalibrationDataFile;
			vCalibrationDataFile = NULL;
		}
	}
	//end calibration testing

	if (!TempAbort)		//calibrate detector edges now that you have calibrated detector gains
	if (vSystemData.vCalibrateGainIterationNumber < cNumberOfTimesToCalibrateGain)
	{
		//calibrate the gain a second time
		if (InterlocksOK())
		{
			vSystemData.vModeToRunAfterCalibrateOffset = cCalibratingDetectorGainMode;
			//this will calibrate detectors, then do gain adjustments
			vSystemData.vCalibrateErrorCount = 0;
			vSystemData.vHadErrorTryRestart = 0;
			//calibrate offsets, then it will calibrate gain
			ReportErrorMessage("Detector Gain Calibration Started Pass: " + dtoa(vSystemData.vCalibrateGainIterationNumber,0), cWriteToLog,0);
			vSystemData.vCalibrateADCAfterDAC = true;
			vSystemData.vAutoCalibrate = true;
			vSystemData.vAutoCalibrateWhileRunning = false;
			if (vConfigurationData->vUseDACAndADCinDensityCompensation)
				CalibrateDACDetectorOffset();
			else
				CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
		}
		else
		{
			CNoticeDialog TempNoticeDialog;
			CString TempText = "\n\n\nX-Rays not on, Check Key Switch, E-Stop, Interlocks";
			if (PasswordOK(cSuperInspxPassword,false))
				TempText = TempText + "\nInterlocks State: " + WordToHex(vSystemData.vSourceInterLocks);
			TempNoticeDialog.vNoticeText = TempText;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
	}
	else
	{
		BYTE TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfXRayDetectors - vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration;
		if (vConfigurationData->vNumberOfDetectorsToCalibrate)
			TempNumberOfDetectorsToAdjustGain = vConfigurationData->vNumberOfDetectorsToCalibrate - vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; 

		double TempHighestGain = 0;
		for (BYTE TempLoopDetector = 0; TempLoopDetector < TempNumberOfDetectorsToAdjustGain; TempLoopDetector++)
		if (TempHighestGain < vConfigurationData->vDetectorGain[TempLoopDetector])
			TempHighestGain = vConfigurationData->vDetectorGain[TempLoopDetector];
		if (TempHighestGain < 10)
		{
			double TempGainToAdd = 10 - TempHighestGain;
			for (BYTE TempLoopDetector = vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector < TempNumberOfDetectorsToAdjustGain + vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration; TempLoopDetector++)
					vConfigurationData->vDetectorGain[TempLoopDetector] = TempGainToAdd + vConfigurationData->vDetectorGain[TempLoopDetector];
		}

		//test calibration
		CString TempDirectoryString = vConfigurationData->vScanTracCalibrationImagesDirectory;
		CString TempString = TempDirectoryString + "EqualizeDetectorGains.csv";

		TempString.Insert(TempString.GetLength() - 4, dtoa(vSystemData.vCalibrateGainIterationNumber,0) + "F-" + dtoa((vGlobalCurrentProduct->vXRayIntegrationTime * .0004),3) + "mSec" + 
			dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6.0, 1) + "kV");

		LPCTSTR TempFileName = TempString;
		CFileException TempFileException;
		if (ThereIsEnoughMemory(sizeof(CFile), "Equalize Detector Gains Data File"))
		{
			vCalibrationDataFile = new CFile;
			if (vCalibrationDataFile)
			{
				int TempFileOpened = vCalibrationDataFile->Open(TempFileName, (CFile::modeCreate | CFile::modeReadWrite), &TempFileException);
				if (TempFileOpened == 0)
				{
					//could not open serial log file
					ReportErrorMessage("Error-Open File Failed: " + TempString, cEMailInspx,32000);// + TempFileException.m_cause); 
					#ifdef _DEBUG
						afxDump << "Could Not Calibration Data File"  << "\n";
					#endif
				}
				else
				{
					//write the image data to the file
					TRY
					{
						CString TempString = "D1,D2,D3,D4,D5,D6,D7,D8,D9,D10,D11,D12\n";
						CW2A TempStringToWrite(TempString);
						vCalibrationDataFile->Write(TempStringToWrite, TempString.GetLength());

						for (BYTE TempLoopDetector = 0; TempLoopDetector < TempNumberOfDetectorsToAdjustGain; TempLoopDetector++)
						{
							TempString = dtoa(vConfigurationData->vDetectorGain[TempLoopDetector], 2) + ", ";
							CW2A TempStringToWrite(TempString);
							vCalibrationDataFile->Write(TempStringToWrite, TempString.GetLength() );
						}
						TempString = "\n";
						CW2A TempStringToWrite2(TempString);
						vCalibrationDataFile->Write(TempStringToWrite2, TempString.GetLength() );
					}
					CATCH_ALL(TempFileException)
					{
						ReportErrorMessage("Error Writing to CSV File",cEMailInspx,32000);
						//#ifdef _DEBUG
						//	afxDump << "Could Not Write Calibration File"  << "\n";
						//#endif
					}
					END_CATCH_ALL
					TRY
					{
						vCalibrationDataFile->Close();
					}
					CATCH_ALL(TempFileException)
					{
						ReportErrorMessage("Error Closing CSV File",cEMailInspx,32000);
					 #ifdef _DEBUG
							afxDump << "Could Not Close Calibration Image File"  << "\n";
					 #endif
					}
					END_CATCH_ALL
				}
				delete vCalibrationDataFile;
				vCalibrationDataFile = NULL;
			}
		}
		//end calibration testing

		SendADCGainsAndOffsets(false);
		if (vSystemData.vFullDetectorCalibration)
		if (InterlocksOK())  //do pixel calibrate since just finished gain calibrate
		{
			Sleep(2000);
			LoadCalibrateEdgesProduct();
			Sleep(2000);
			vSystemData.vModeToRunAfterCalibrateOffset = cCalibratingDetectorEdgesMode;
			vSystemData.vCalibrateGainIterationNumber = 0;
			vSystemData.vCalibrateErrorCount = 0;
			vSystemData.vHadErrorTryRestart = 0;
			vSystemData.vCalibrateADCAfterDAC = true;
			vSystemData.vAutoCalibrate = true;
			vSystemData.vAutoCalibrateWhileRunning = false;
			vSystemData.vApplyGainAndOffsetDuringCalibration = false;
			if (vConfigurationData->vUseDACAndADCinDensityCompensation)
				CalibrateDACDetectorOffset();
			else
				CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
		}
		else
		{
			CNoticeDialog TempNoticeDialog;
			CString TempText = "\n\n\nX-Rays not on, Check Key Switch, E-Stop, Interlocks";
			if (PasswordOK(cSuperInspxPassword,false))
				TempText = TempText + "\nInterlocks State: " + WordToHex(vSystemData.vSourceInterLocks);
			TempNoticeDialog.vNoticeText = TempText;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
	}
	if (TempAbort)
	{
		RestoreBackupGainAndPixelAdjustments();
		RestoreOriginalProduct();
	}
}

void CScanTracDlg::LoadCalibrateOffsetProduct()
{
	ResetCounters();
	vSystemData.vDensityIndex = 0;
	//look for product "~Calibrate Offset"
	//if ((!TempAutoCalibrate) && (!TempCalibrateWhileRunning) || (!vGlobalCurrentProduct))
	CProduct *TempProduct = GetProductByName("~Calibrate Offset");
	if (TempProduct)
		TempProduct->SetProductName("~Calibrate Gain");
	else
		TempProduct = GetProductByName("~Calibrate Gain");
	//if don't find a calibrate product, create and save it, then use it
	if (!TempProduct)
	if (ThereIsEnoughMemory(sizeof(CProduct), "New Calibrate Product "))
	{
		TempProduct = new CProduct;
		if (TempProduct)
		{
			TempProduct->SetProductName("~Calibrate Gain");

			TempProduct->vProductImageHeightTop = (float)(vConfigurationData->vDetectorLength * vConfigurationData->vNumberOfXRayDetectors);
			//if (vConfigurationData->vUseMetric)
			//	TempProduct->vProductImageHeightTop = (WORD)(TempProduct->vProductImageHeightTop * 25.4);
			//TempProduct->vProductImageWidth  = (float)(cNumberOfCalibrationOffsetImages / 
			//	vGlobalPixelsPerUnit);  //take 100 lines

			double TempDelay = 2;
			//if (vConfigurationData->vUseMetric)
			//	TempDelay = TempDelay * 25.4;
			TempProduct->SetProductBodyTriggerToImageBeltPositionOffset((float)TempDelay);
			TempProduct->SetProductImageWidth((float)TempDelay * 2);
			TempProduct->SetProductLockOutWidth((float)TempDelay);

			//if (vConfigurationData->vUseMetric)
			//	TempProduct->SetEndOfLineTimeOut((float)(50 * 25.4 * vGlobalPixelsPerUnit));
			//else
				TempProduct->SetEndOfLineTimeOut((float)(50 * vGlobalPixelsPerUnit) + vGlobalEndOfLineTimeOutMargin);

			for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
			{
				//if (vConfigurationData->vUseMetric)
				//	TempProduct->SetEjectorBeltPositionOffset(TempLoop,(float)(43 * 25.4));
				//else
					TempProduct->SetEjectorBeltPositionOffset(TempLoop,(float)(43));
			}

			TempProduct->vEdgeLocationBottom = (float)(.5);
			TempProduct->SetEdgeLocationBottom(TempProduct->vEdgeLocationBottom);
			TempProduct->vEdgeLocationHeight = (float)(1);
			TempProduct->SetEdgeLocationHeight(TempProduct->vEdgeLocationHeight);

			TempProduct->vBodyTrigger = 1;
			TempProduct->CalculateEndOfLineTimeOut();
			AddProduct(((CProduct *)TempProduct));
		}
	}
	if (TempProduct)
	{
		TempProduct->vUsingXScanPoint4mmDetectors = vSystemData.vCalibratingXScanPoint4mmDetectors;
		if ((vGlobalScanTracType == cForteScanTrac) || (vGlobalScanTracType == cCaseInspectorScanTrac))
			TempProduct->vUsingXScanPoint4mmDetectors = 0;

		if (vGlobalPixelsPerUnit)
		if (TempProduct->vImageWidthPosition < vConfigurationData->vNumberOfXRayDetectors * 11 / vGlobalPixelsPerUnit)
		{
			TempProduct->vProductImageWidth  = (float)(vConfigurationData->vNumberOfXRayDetectors * 11 / vGlobalPixelsPerUnit);
			TempProduct->SetProductImageWidth(TempProduct->vProductImageWidth);
		}

		if ((TempProduct->vXRaySourceVoltage == 0) || (TempProduct->vXRaySourceCurrent == 0))
		{
			TempProduct->vXRaySourceVoltage = 40 / 6;  //40 KV
			TempProduct->vXRaySourceCurrent = (float)(vConfigurationData->vMaximumCurrent / 2); //3 mAmp

			if (vConfigurationData->vHVPSType == cCheyneyMonoBlock)
			{
				if (TempProduct->vXRaySourceCurrent > vGlobalDXMXRayPort->vCurrentMaximumScale)
					TempProduct->vXRaySourceCurrent = (float)vGlobalDXMXRayPort->vCurrentMaximumScale;
				if (TempProduct->vXRaySourceCurrent > 20)
					TempProduct->vXRaySourceCurrent = 20;
			}

			if ((vGlobalDXMXRayPort) && ((vConfigurationData->vHVPSType == c100WMonoBlockHVPS) || (vConfigurationData->vHVPSType == cCheyneyMonoBlock)))
			if (TempProduct->vXRaySourceCurrent > 2)
				TempProduct->vXRaySourceCurrent = 2;

			if (vConfigurationData->vHVPSType == c210WMonoBlockHVPS)
			if (TempProduct->vXRaySourceCurrent > 3)
				TempProduct->vXRaySourceCurrent = 3;
			if (vConfigurationData->vHVPSType == cMNXHVPS)
			if (TempProduct->vXRaySourceCurrent > 1)
				TempProduct->vXRaySourceCurrent = 1;

			TempProduct->vXRayIntegrationTime = 750; //750 = .3 mSec
			//TempProduct->vXRayIntegrationTimeAtEdge = TempProduct->vXRayIntegrationTime;
		}
		vCalibrateCurrentStep = (double)TempProduct->vXRaySourceCurrent;

		TempProduct->vProductImageHeightTop = (float)(vConfigurationData->vDetectorLength * vConfigurationData->vNumberOfXRayDetectors);
		//if (vConfigurationData->vUseMetric)
		//	TempProduct->vProductImageHeightTop = (WORD)(TempProduct->vProductImageHeightTop * 25.4);
		//vCalibrateHoldCurrentProduct = vGlobalCurrentProduct;
		SetupProduct(TempProduct, false);
	}
}

void CScanTracDlg::LoadCalibrateEdgesProduct()
{
	CProduct *TempProduct = GetProductByName("~Calibrate Pixels");
	if ((vConfigurationData->vUseXScanDetectors) && (vConfigurationData->vScanTracType != cForteScanTrac) && (vConfigurationData->vScanTracType != cCaseInspectorScanTrac))
	{
		if (vSystemData.vCalibratingXScanPoint4mmDetectors)
			TempProduct = GetProductByName("~Calibrate Pixels .4mm");
		else
			TempProduct = GetProductByName("~Calibrate Pixels .8mm");
	}

	if (!TempProduct)
	{
		TempProduct = GetProductByName("~Calibrate");
		if (TempProduct)
			TempProduct->SetProductName("~Calibrate Pixels");
	}

	if ((vConfigurationData->vUseXScanDetectors) && (vConfigurationData->vScanTracType != cForteScanTrac) && (vConfigurationData->vScanTracType != cCaseInspectorScanTrac))
	if (TempProduct)
	{
		if (vSystemData.vCalibratingXScanPoint4mmDetectors)
			TempProduct->SetProductName("~Calibrate Pixels .4mm");
		else
			TempProduct->SetProductName("~Calibrate Pixels .8mm");
	}

	//if don't find a calibrate product, create and save it, then use it
	if (!TempProduct)
	if (ThereIsEnoughMemory(sizeof(CProduct), "New Calibrate Product "))
	{
		TempProduct = new CProduct;
		if (TempProduct)
		{
			TempProduct->SetProductName("~Calibrate Pixels");
			if ((vConfigurationData->vUseXScanDetectors) && (vConfigurationData->vScanTracType != cForteScanTrac) && (vConfigurationData->vScanTracType != cCaseInspectorScanTrac))
			{
				if (vSystemData.vCalibratingXScanPoint4mmDetectors)
					TempProduct->SetProductName("~Calibrate Pixels .4mm");
				else
					TempProduct->SetProductName("~Calibrate Pixels .8mm");
			}

			TempProduct->vProductImageHeightTop = (float)(vConfigurationData->vDetectorLength * vConfigurationData->vNumberOfXRayDetectors);
			//if (vConfigurationData->vUseMetric)
			//	TempProduct->vProductImageHeightTop = (WORD)(TempProduct->vProductImageHeightTop * 25.4);
			if (vGlobalPixelsPerUnit)
				TempProduct->vProductImageWidth  = (float)(cCalibrationImageWidth * 2 / vGlobalPixelsPerUnit);

			double TempDelay = 2;
			//if (vConfigurationData->vUseMetric)
			//	TempDelay = TempDelay * 25.4;
			TempProduct->SetProductBodyTriggerToImageBeltPositionOffset((float)TempDelay);
			TempProduct->SetProductImageWidth((float)TempDelay * 2);
			TempProduct->SetProductLockOutWidth((float)TempDelay);

			//if (vConfigurationData->vUseMetric)
			//	TempProduct->SetEndOfLineTimeOut((float)(50 * 25.4 * vGlobalPixelsPerUnit));
			//else
				TempProduct->SetEndOfLineTimeOut((float)(50 * vGlobalPixelsPerUnit + vGlobalEndOfLineTimeOutMargin));

			for (BYTE TempLoop = 0; TempLoop < cNumberOfEjectors; TempLoop++)
			{
				//if (vConfigurationData->vUseMetric)
				//	TempProduct->SetEjectorBeltPositionOffset(TempLoop,(float)(43 * 25.4));
				//else
					TempProduct->SetEjectorBeltPositionOffset(TempLoop,(float)(43));
			}

			TempProduct->vEdgeLocationBottom = (float)(.5);
			TempProduct->SetEdgeLocationBottom(TempProduct->vEdgeLocationBottom);
			TempProduct->vEdgeLocationHeight = (float)(1);
			TempProduct->SetEdgeLocationHeight(TempProduct->vEdgeLocationHeight);

			//TempProduct->vXRayIntegrationTimeAtEdge = TempProduct->vXRayIntegrationTime;
			TempProduct->vBodyTrigger = 1;
			TempProduct->CalculateEndOfLineTimeOut();
			AddProduct(((CProduct *)TempProduct));
		}
	}
	if (TempProduct)
	{
		TempProduct->vUsingXScanPoint4mmDetectors = vSystemData.vCalibratingXScanPoint4mmDetectors;
		if ((vGlobalScanTracType == cForteScanTrac) || (vGlobalScanTracType == cCaseInspectorScanTrac))
			TempProduct->vUsingXScanPoint4mmDetectors = 0;
		if (TempProduct->vImageWidthPosition < cCalibrationImageWidth)
		{
			if (vGlobalPixelsPerUnit)
				TempProduct->vProductImageWidth  = (float)(cCalibrationImageWidth * 2 / vGlobalPixelsPerUnit);
			TempProduct->SetProductImageWidth(TempProduct->vProductImageWidth);
		}

		double TempMaximumCurrent = vConfigurationData->vMaximumCurrent;
		double TempMaxValue = GetMaximumCurrentFromVoltage(TempProduct->vXRaySourceVoltage * 6) * 0.99;
		if (TempMaximumCurrent > TempMaxValue)
			TempMaximumCurrent = TempMaxValue;

		TempMaxValue = GetMaximumCurrentFromPower(vGlobalCurrentProduct->vXRaySourceVoltage * 6, vConfigurationData->vMaximumPower) * 0.99;
		if (TempMaximumCurrent > TempMaxValue)
			TempMaximumCurrent = TempMaxValue;

		//TempProduct->vXRaySourceCurrent = (float)(TempMaximumCurrent * 0.8); //80% of maximum current
		if (TempProduct->vXRaySourceCurrent > TempMaximumCurrent)
			TempProduct->vXRaySourceCurrent = (float)(TempMaximumCurrent);

		//TempProduct->vXRayIntegrationTime = 1000;  //.4 ms

		if ((TempProduct->vXRaySourceVoltage == 0) || (TempProduct->vXRaySourceCurrent == 0))
		{
			TempProduct->vXRaySourceVoltage = 33 / 6;  //33 KV
			TempProduct->vXRaySourceCurrent = (float)(vConfigurationData->vMaximumCurrent / 2); //half of full current
			TempProduct->vXRayIntegrationTime = 750; //750 = .3 mSec
			//TempProduct->vXRayIntegrationTimeAtEdge = TempProduct->vXRayIntegrationTime;
		}

		if (vConfigurationData->vMaximumCurrent < TempProduct->vXRaySourceCurrent)
			TempProduct->vXRaySourceCurrent = (float)vConfigurationData->vMaximumCurrent;

		if (vConfigurationData->vMaximumVoltage < TempProduct->vXRaySourceVoltage)
			TempProduct->vXRaySourceVoltage = (float)vConfigurationData->vMaximumVoltage;

		TempProduct->vProductImageHeightTop = (float)(vConfigurationData->vDetectorLength * vConfigurationData->vNumberOfXRayDetectors);
		//if (vConfigurationData->vUseMetric)
		//	TempProduct->vProductImageHeightTop = (WORD)(TempProduct->vProductImageHeightTop * 25.4);

		//if doing full calibration, saved current product before calibrated gain
		SetupProduct(TempProduct, false);
		Sleep(cSendCommandSleepTime);
	}
}

void CScanTracDlg::CheckHVPSVoltageSoon()
{
	int TimerResult = SetTimer(vCheckHVPSVoltageSoonTimerHandle,20000,NULL); //was 5000, changed to 20000
}

void CScanTracDlg::RestoreOriginalProduct()
{
	if (vCalibrateHoldCurrentProduct)
	{
		vGlobalCurrentProduct = vCalibrateHoldCurrentProduct;
		vSystemData.vModeToRunAfterCalibrateOffset = cStoppedSystemMode;

		if (vGlobalCurrentProduct)
		{
			int TempTimerResult = SetTimer(vSetupProductTimerHandle,1000,NULL);
			if (!TempTimerResult)
				ReportErrorMessage("Error-Display Timer Failed",cEMailInspx,32000);
		}
		else
		{
			//SendSourceSettingsToUController(0,0);	
			vSystemData.vCurrentProductName.LoadString(IDS_NoCurrentProduct);
			CString vTempString3 = " ";
			vTempString3 = vTempString3 + vSystemData.vCurrentProductName + vTempString3;
			SetDlgItemText(IDC_ProductLabel,vTempString3);
		}
		ReportErrorMessage("Restore Original Product after calibration complete: " + *vCalibrateHoldCurrentProduct->GetProductName(), cWriteToLog, 0);
		ResetCounters();
		vCalibrateHoldCurrentProduct = NULL;
	}
}

BOOL CALLBACK UpdateAllOpenMenuTitleBarColors(HWND hwnd, LPARAM lParam)
{

//	char class_name[80];
//	char title[80];
//	GetClassName(hwnd,(LPWSTR)class_name, sizeof(class_name));
//	GetWindowText(hwnd,(LPWSTR)title,sizeof(title));
  //  cout <<"Window title: "<<title<<endl;
  //  cout <<"Class name: "<<class_name<<endl<<endl;

	CWnd* pWnd = CWnd::FromHandle(hwnd); 
		CWnd *TempWindow = pWnd->GetDlgItem(IDC_DialogTitleStaticText1);
	if (TempWindow)
		TempWindow->Invalidate(false);
	
	TempWindow = pWnd->GetDlgItem(IDC_DialogTitleStaticText);
	if (TempWindow)
		TempWindow->Invalidate(false);
	
	TempWindow = pWnd->GetDlgItem(IDC_DialogTitleStaticText2);
	if (TempWindow)
		TempWindow->Invalidate(false);
	
	return TRUE;
}

void CScanTracDlg::UpdateTitleBar()
{
	EnumWindows(UpdateAllOpenMenuTitleBarColors, NULL); //EnumWindows is a C function that will do this procedure on all open windows
	CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
	if (TempWindow)
		TempWindow->Invalidate(false);
}

bool CScanTracDlg::CurrentProductIsInspxProduct()
{
	bool TempInspxProduct = false;
	if (vGlobalCurrentProduct)
	{
		CString TempCurrentProductName = *vGlobalCurrentProduct->GetProductName();
		if (TempCurrentProductName.GetAt(0) == '~')
			TempInspxProduct = true;
	}
	return TempInspxProduct;
}

void CScanTracDlg::SendXRayPowerOnOffToUController(BYTE TempOn)
{
	if (TempOn)
	if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
	if (vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode)
	if (vSystemData.vSystemRunMode != cCalibratingDetectorGainMode)
	if (vSystemData.vSystemRunMode != cCalibratingDetectorEdgesMode)
	if (vSystemData.vSystemRunMode != cMeasureSourceStrengthMode)
	if (vSystemData.vSystemRunMode != cAlignTubeMode)
	if (vSystemData.vSystemRunMode != cTestShutterMode)
	if (!vSystemData.vSimulateContainersRate)
	if (!vConfigurationData->vContinuousFeedContainerRate)
	{
		//leave door open if simulating body trigger or measure source strength
		if (vGlobaluCSerialPort)
		if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
			vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterAutoControl);
	}

	if (TempOn)
		ReportErrorMessage("Turn ON X-RAYS", cWriteToLog,0); 
	else
		ReportErrorMessage("Turn OFF X-RAYS", cWriteToLog,0); 

	vSystemData.vSourceRampedUp = false;
	vSystemData.vSourceErrorReported = false;

	//don't do this as will not start when press run
	//if ((vSystemData.vFPGAGeneratingSimulatedData) && (TempOn))
	//{  //if simulating data with FPGA, do not turn on x-ray source
	//	vSystemData.vSourceRampedUp = true;
	//}
	//else
	{
		if (TempOn)
		{
			if (vGlobalCurrentProduct)
			{
				//no ramp up, so send current and voltage settings
				vSystemData.vRampXRayWaitTime = 500;  
				vSystemData.vRampXRayStep = 11;

				SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount, vSystemData.vRampXRayCurrentAmount);
				::PostThreadMessage(vGlobalCallingThreadID, cNextSourceRampStepMessage,0,0);
				vConfigurationData->vTimeXRaysWereOnLast = CTime::GetCurrentTime();
			}
			if ((!vConfigurationData->vDemoMode) && (!vConfigurationData->vSimulateLightControlBoard))//must comment out to test monoblock in the office
			{
				if (vGlobalDXMXRayPort)
					vGlobalDXMXRayPort->TurnOnOffXRays(TempOn);
				else
				if (vGlobalMonoBlockXRayPort)
					vGlobalMonoBlockXRayPort->TurnOnOffXRays(TempOn);
				else
				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->SendXRayPowerOnOffToUController(TempOn);
			}
			KillTimer(vXRayTubeHasCooledTimerHandle);
			vConfigurationData->vXRayTubeHasCooled = false;
			WriteConfigurationDataToFile(false); //write to main config file
		}
		else
		{  //turning off supply, so turn off first, then set voltage and current to zero
			if (vSystemData.vLastXRayCommandOn) //if was on and now turning off, save time last run
				vConfigurationData->vTimeXRaysWereOnLast = CTime::GetCurrentTime();

			if (vGlobalDXMXRayPort)
				vGlobalDXMXRayPort->TurnOnOffXRays(TempOn);
			else
			if (vGlobalMonoBlockXRayPort)
				vGlobalMonoBlockXRayPort->TurnOnOffXRays(TempOn);
			else
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendXRayPowerOnOffToUController(TempOn);
			//set timer to vConfigurationData->vXRayTubeHasCooled = true;
			KillTimer(vXRayTubeHasCooledTimerHandle);
			int TempTimerResult = SetTimer(vXRayTubeHasCooledTimerHandle,30000,NULL);  //in 30 seconds mark X-Ray tube cooled
			//SendSourceSettingsToUController(0,0);	
		}
	}
	vSystemData.vLastXRayCommandOn = TempOn;
	if ((vConfigurationData->vDemoMode) || (vConfigurationData->vSimulateLightControlBoard))
	{
		if (vSystemData.vLastXRayCommandOn)
		{
			vSystemData.vSourceVoltage = vSystemData.vRampXRayVoltageAmount;
			vSystemData.vSourceCurrent = vSystemData.vRampXRayCurrentAmount;
		}
		else
		{
			vSystemData.vSourceVoltage = 0;
			vSystemData.vSourceCurrent = 0;
		}
	}
	if (vSystemData.vLastXRayCommandOn)
		vSystemData.vXRayOnNotice = true;
	else
		vSystemData.vXRayOnNotice = false;
	//comment out temp for testing 
	if (vConfigurationData->vSimulateLightControlBoard)
	{
		if (vSystemData.vXRayOnNotice)
			vSystemData.vRawInterlockInput = 0xFF7F;
		else
			vSystemData.vRawInterlockInput = 0xFF77;
		vSystemData.vSourceInterLocks = vSystemData.vRawInterlockInput;
	}

	if (!TempOn)
	if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
	if (vSystemData.vSystemRunMode != cCalibratingDetectorOffsetMode)
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterOpen);
}

void CScanTracDlg::SendSourceSettingsToUController(double TempVoltage, double TempCurrent)
{
	//if (vGlobalDXMXRayPort)
	//if ((TempVoltage > 10 / 6) && (TempCurrent < vGlobalDXMXRayPort->vMinimumCurrent * 0.9))
	//{
	//	TempVoltage = 0;
	//	TempCurrent = 0;
	//}
		
	ReportErrorMessage("Set X-Ray Voltage to: " + dtoa(TempVoltage * 6,2) + ", Set X-Ray Current to: " + dtoa(TempCurrent,4), cAction,0);

	vSystemData.vLastXRayCurrentSetTime = CIFCOS::GetSystimeMillisecs();
	//Send X-Ray Voltage
	if ((TempVoltage) || (TempCurrent))
	{
		vSystemData.vSourceVoltageMin = 254;
		vSystemData.vSourceVoltageMax = 0;
		vSystemData.vSourceCurrentMin = 254;
		vSystemData.vSourceCurrentMax = 0;
	}
	if (vGlobalDXMXRayPort)
	{
		vGlobalDXMXRayPort->vFilamentCurrentMin = 9999999;
		vGlobalDXMXRayPort->vFilamentCurrentMax = 0;
	}
	//if (!vConfigurationData->vVoltageControlAdjustGain)
	//	vConfigurationData->vVoltageControlAdjustGain = 1;
	double TempDouble = TempVoltage;
	//double TempDouble = (((TempVoltage * vConfigurationData->vVoltageControlAdjustGain) + 
	//	vConfigurationData->vVoltageControlAdjustOffset));
	//if (TempDouble < 0)
	//	TempDouble = 0;//10 is 60 KV

	if (vGlobalDXMXRayPort)
	{
		vGlobalDXMXRayPort->SetXRayVoltage(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempVoltage == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayVoltage(TempDouble);
	}
	else
	if (vGlobalMonoBlockXRayPort)
	{
		vGlobalMonoBlockXRayPort->SetXRayVoltage(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempVoltage == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayVoltage(TempDouble);
	}
	else
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->SetXRayVoltage(TempDouble);
	}

	//Send X-Ray Current
	//if (!vConfigurationData->vCurrentControlAdjustGain)
	//	vConfigurationData->vCurrentControlAdjustGain = 1;
	//vSystemData.vSourceCurrentSetting = TempCurrent;
	TempDouble = TempCurrent;
	//TempDouble = (((TempCurrent * vConfigurationData->vCurrentControlAdjustGain) + 
	//	vConfigurationData->vCurrentControlAdjustOffset));
	//if (TempDouble < 0)
	//	TempDouble = 0;

	double TempMaxValue = GetMaximumCurrentFromVoltage(TempVoltage * 6);
	if (TempMaxValue > vConfigurationData->vMaximumCurrent)
		TempMaxValue = vConfigurationData->vMaximumCurrent;

	double TempMaxCurrentFromPower = GetMaximumCurrentFromPower(TempVoltage * 6, vConfigurationData->vMaximumPower);
	if (TempMaxValue > TempMaxCurrentFromPower)
		TempMaxValue = TempMaxCurrentFromPower;

	if (TempDouble > TempMaxValue)
		TempDouble = TempMaxValue;

	if (vGlobalDXMXRayPort)
	{
		vGlobalDXMXRayPort->SetXRayCurrent(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempCurrent == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayCurrent(TempDouble);
	}
	else
	if (vGlobalMonoBlockXRayPort)
	{
		vGlobalMonoBlockXRayPort->SetXRayCurrent(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempCurrent == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayCurrent(TempDouble);
	}
	else
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->SetXRayCurrent(TempDouble);
	}

	if ((TempVoltage) || (TempCurrent))
	{
		vSystemData.vRampXRayCurrentAmount = TempCurrent;
		vSystemData.vRampXRayVoltageAmount = TempVoltage;

		double TempSourceVoltageTolerance = .1 * vSystemData.vRampXRayVoltageAmount;
		double TempSourceCurrentTolerance = .1 * vSystemData.vRampXRayCurrentAmount;

		if (TempSourceVoltageTolerance < 3)
			TempSourceVoltageTolerance = 3;

		if (TempSourceCurrentTolerance < .5)
			TempSourceCurrentTolerance = .5;

		vSystemData.vSourceVoltageMinRedLine = vSystemData.vRampXRayVoltageAmount - TempSourceVoltageTolerance;
		vSystemData.vSourceVoltageMaxRedLine = vSystemData.vRampXRayVoltageAmount + TempSourceVoltageTolerance;

		vSystemData.vSourceCurrentMinRedLine = vSystemData.vRampXRayCurrentAmount - TempSourceCurrentTolerance;
		vSystemData.vSourceCurrentMaxRedLine = vSystemData.vRampXRayCurrentAmount + TempSourceCurrentTolerance;

		if (vSystemData.vSourceVoltageMinRedLine < 0)
			vSystemData.vSourceVoltageMinRedLine = 0;
		if (vSystemData.vSourceCurrentMinRedLine < 0)
			vSystemData.vSourceCurrentMinRedLine = 0;
		if (vSystemData.vSourceVoltageMaxRedLine > 90 / 6)
			vSystemData.vSourceVoltageMaxRedLine = 90 / 6;
		if (vSystemData.vSourceCurrentMaxRedLine > 10)
			vSystemData.vSourceCurrentMaxRedLine = 10;

		vSystemData.vSourceRampedUp = false;
		if ((TempVoltage) || (TempCurrent))
		if (vSystemData.vXRayOnNotice)
			::PostThreadMessage(vGlobalCallingThreadID,cRampingSourceMessage,0,0);
	}
}

void CScanTracDlg::SendSourceCurrentToUController(double TempCurrent)
{
	//Send X-Ray Current
	ReportErrorMessage("Set X-Ray Current to: " + dtoa(TempCurrent,2), cAction,0);

	vSystemData.vLastXRayCurrentSetTime = CIFCOS::GetSystimeMillisecs();

	vSystemData.vSourceCurrentMin = 11;
	vSystemData.vSourceCurrentMax = 0;

	if (vGlobalDXMXRayPort)
	{
		vGlobalDXMXRayPort->vFilamentCurrentMin = 9999999;
		vGlobalDXMXRayPort->vFilamentCurrentMax = 0;
	}

	//vSystemData.vSourceCurrentSetting = TempCurrent;

	double TempDouble = TempCurrent;
	if (TempDouble < 0)
		TempDouble = 0;

	double TempMaxValue = GetMaximumCurrentFromVoltage(vSystemData.vRampXRayVoltageAmount * 6);
	if (TempMaxValue > vConfigurationData->vMaximumCurrent)
		TempMaxValue = vConfigurationData->vMaximumCurrent;

	double TempMaxCurrentFromPower = GetMaximumCurrentFromPower(vSystemData.vRampXRayVoltageAmount * 6, vConfigurationData->vMaximumPower);
	if (TempMaxValue > TempMaxCurrentFromPower)
		TempMaxValue = TempMaxCurrentFromPower;

	if (TempDouble > TempMaxValue)
		TempDouble = TempMaxValue;

	if (vGlobalDXMXRayPort)
	{
		vGlobalDXMXRayPort->SetXRayCurrent(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempDouble == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayCurrent(TempDouble);
	}
	else
	if (vGlobalMonoBlockXRayPort)
	{
		vGlobalMonoBlockXRayPort->SetXRayCurrent(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempCurrent == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayCurrent(TempDouble);
	}
	else
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->SetXRayCurrent(TempDouble);
	}

	vSystemData.vRampXRayCurrentAmount = TempDouble;

	double TempSourceCurrentTolerance = .1 * vSystemData.vRampXRayCurrentAmount;
	if (TempSourceCurrentTolerance < .25)
		TempSourceCurrentTolerance = .25;

	vSystemData.vSourceCurrentMinRedLine = vSystemData.vRampXRayCurrentAmount -
			TempSourceCurrentTolerance;
	vSystemData.vSourceCurrentMaxRedLine = vSystemData.vRampXRayCurrentAmount +
			TempSourceCurrentTolerance;

	if (vSystemData.vSourceCurrentMinRedLine < 0)
		vSystemData.vSourceCurrentMinRedLine = 0;
	if (vSystemData.vSourceCurrentMaxRedLine > 10.5)
		vSystemData.vSourceCurrentMaxRedLine = 10.5;

	vSystemData.vSourceRampedUp = false;
	if (TempDouble)
	if (vSystemData.vXRayOnNotice)
	::PostThreadMessage(vGlobalCallingThreadID,cRampingSourceMessage,0,0);
}

void CScanTracDlg::InitializeDXM()
{
	if (vGlobalDXMXRayPort)
	{
		ReportErrorMessage("Initialize: " + vGlobalDXMXRayPort->vHVPSType, cWriteToLog,0); 
		vGlobalDXMXRayPort->GetModelNumber();
				

		SendXRayPowerOnOffToUController(0);
		//SendSourceSettingsToUController(0,0);  //set voltage and current
		if (vGlobalCurrentProduct)
			SendSourceSettingsToUController(vGlobalCurrentProduct->vXRaySourceVoltage, vGlobalCurrentProduct->vXRaySourceCurrent);

		vGlobalDXMXRayPort->GetCurrentScale();
		vGlobalDXMXRayPort->GetVoltageScale();
	}
}

void CScanTracDlg::CheckACIn3SecondsBeforeYellowMessage(long TempMessageCode)
{
	int TimerResult = SetTimer(vCheckACBeforeThisYellowMessageTimerHandle,3000,NULL);
	if (!TimerResult)
		ReportErrorMessage("Error-vCheckACBeforeThisYellowMessage Timer Failed",cEMailInspx,32000);
}
	
void CScanTracDlg::KillCheckACBeforeYellowMessage(long TempMessageCode)
{
	KillTimer(vCheckACBeforeThisYellowMessageTimerHandle);
}

void CScanTracDlg::EmergencyShutXRaysDown(long TempSafetyViolation)
{
	//if (!vConfigurationData->vSimulateLightControlBoard)
	if (!vSystemData.vShuttingDownXRays)
	//if (vSystemData.vXRayOnNotice)
	{
		if (!TempSafetyViolation)
		{
			int TimerResult = SetTimer(vFlashYellowLightTimerHandle,500,NULL);
			vSystemData.vCantInspectError = true; // flash blue + yellow
		}


		SendXRayPowerOnOffToUController(0);

		//vSystemData.vShuttingDownXRays = true;
		vSystemData.vConveyorIsOn = false;
		//turn red lamp off
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->TurnOnOffRedLamp(false);

		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Emergency Stop Turned off Conveyor",cDebugMessage);

		::PostThreadMessage(vGlobalCallingThreadID, cuControllerStopRunningMessage,99,99);

		if (TempSafetyViolation)
		{
			int TimerResult = SetTimer(vShowSafetyViolationMessageTimer,5000,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx,32000);
		}
	}
	SetInterlockStatus();
	UpdateRunButton();
}

void CScanTracDlg::ShowSafetyViolationMessage()
{
	CNoticeDialog TempNoticeDialog;
	CString TempText = " ";
	TempText.LoadString(IDS_ForYourSafety);
	//TempNoticeDialog.vNoticeText = "\nFor Your Safety\nAlways press the red 'STOP' button\nbefore opening a door or conveyor cover.";
	TempNoticeDialog.vNoticeText = TempText;
	TempNoticeDialog.vType = cSafetyMessage;
	TempNoticeDialog.DoModal();
}

void CScanTracDlg::CreateBackupGainAndPixelAdjustments()
{
	for (BYTE TempLoop = 0; TempLoop < vConfigurationData->vNumberOfXRayDetectors; TempLoop++)
		vBackupDetectorGain[TempLoop] = vConfigurationData->vDetectorGain[TempLoop];

	for (WORD TempLoop = 0; TempLoop < cNumberOfPixelsToAdjustAllPixels1152; TempLoop++)
	{
		vBackupDetectorEdgeAdjustGain[TempLoop] = vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors];
		vBackupDetectorEdgeAdjustOffset[TempLoop] = vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors];
	}
}

void CScanTracDlg::RestoreBackupGainAndPixelAdjustments()
{
	for (BYTE TempLoop = 0; TempLoop < vConfigurationData->vNumberOfXRayDetectors; TempLoop++)
		vConfigurationData->vDetectorGain[TempLoop] = vBackupDetectorGain[TempLoop];

	for (WORD TempLoop = 0; TempLoop < cNumberOfPixelsToAdjustAllPixels1152; TempLoop++)
	{
		vConfigurationData->vDetectorEdgeAdjustGain[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = vBackupDetectorEdgeAdjustGain[TempLoop];
		vConfigurationData->vDetectorEdgeAdjustOffset[TempLoop][vSystemData.vCalibratingXScanPoint4mmDetectors] = vBackupDetectorEdgeAdjustOffset[TempLoop];
	}
		
	SendADCGainsAndOffsets(false);
}

BYTE CScanTracDlg::GetImproveLearnInspectionNumber()
{
	BYTE TempReturn = vGlobalCurrentProduct->vNumberOfInspections;
	if (TempReturn)
	{
		if (vGlobalCurrentProduct->vInspection[TempReturn - 1])
		{
			CString TempText = " ";
			TempText.LoadString(IDS_ImproveLearn);
			if (vGlobalCurrentProduct->vInspection[TempReturn - 1]->vName != TempText)
				TempReturn = 0;
		}
		else
			vGlobalCurrentProduct->vNumberOfInspections--;
	}
	return TempReturn;
}

void CScanTracDlg::TestShutter()
{
	if (vSystemData.vSystemRunMode != cStoppedSystemMode)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nSystem must be stopped, operation aborted";
		TempNoticeDialog.vType = cNoticeMessage;
		TempNoticeDialog.DoModal();
	}
	else
	if (InterlocksOK())
	{
		vSystemData.vCalibrationSimulationStarted = false;
		vShutterFailedLastTest = 0;
		//vSystemData.vHVPSInterlockDelay = 0;
		ReportErrorMessage("Start Test Shutter", cWriteToLog,0);
		KillTimer(vStopRunningTimerHandle);
		vStopRunningTimerActive = false;
		KillTimer(vConveyorStartTimerHandle);
		vSystemData.vShuttingDownXRays = false;
		SetFastestSimulatedEncoder(0.35);  //slow down the simulated encoder so will have more time for the shutter to move.

		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendContainerTriggerToImageDelay(vGlobalCurrentProduct);

		vSystemData.vCalibrationImageNumber = 0;
		vSystemData.vSystemRunMode = cTestShutterMode;
		CString TempText = " ";
		TempText.LoadString(IDS_Abort);
		SetDlgItemText(IDC_SubFunction1Button,TempText);
		UpdateRunButton();

		//start the X-Rays
		SendSourceSettingsToUController(vSystemData.vRampXRayVoltageAmount,
			vSystemData.vRampXRayCurrentAmount);		
		SendXRayPowerOnOffToUController(1);
		Sleep(cSendCommandSleepTime);

		if (vGlobaluCSerialPort)
		if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
			vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterOpen);
	}
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("End of Start Shutter Test",cDebugMessage);
}

void CScanTracDlg::ProcessTestShutter()
{
	if ((vSystemData.vITIPCDig->vOriginalImage) && (vSystemData.vITIPCDig->vOriginalImage->vGreyImage))
	{
		vSystemData.vCalibrationImageNumber++;
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("STD-ProcessTestShutter: " + dtoa(vSystemData.vCalibrationImageNumber,0),cDebugMessage);
		//take frame and output to a file
		CString TempString = " ";
		TempString = "";
		TempString.LoadString(IDS_XRaysWait);
		TempString = TempString + " " + dtoa(vSystemData.vCalibrationImageNumber, 0);
		SetDlgItemText(IDC_Calibrating,TempString);


		//do souce density average here
		float TempSum = 0;
		BYTE *TempPointer = NULL;
		DWORD TempCount = 0;

		//add up all the pixels in all the lines except the first 10 and last 10 pixels 
		//in each line
		for (WORD TempLoopY = 0;
			TempLoopY < vSystemData.vITIPCDig->vOriginalBufferSizeY; TempLoopY++)
		{
			TempPointer = vSystemData.vITIPCDig->vOriginalImage->vGreyImage + 10 + 
				(TempLoopY * vSystemData.vITIPCDig->vOriginalBufferSizeX);
			for (WORD TempLoopX = 0;
				TempLoopX < vSystemData.vITIPCDig->vOriginalBufferSizeX - 20; TempLoopX++)
			{
				TempSum = TempSum + *TempPointer++;
				TempCount++;
			}
		}

		CString TempStringName = "TestShutter";
		TempStringName = TempStringName + dtoa(vSystemData.vCalibrationImageNumber,0);
		TempStringName = TempStringName + ".BMP";
		TempStringName = vConfigurationData->vScanTracCalibrationImagesDirectory + TempStringName;
		int TempLength = TempStringName.GetLength();
		//if (PasswordOK(cTemporaryInspxPassword,false))// && (vSystemData.vWriteCalibrationImages))
		if (TempLength > MAX_PATH)
		{
			CNoticeDialog TempNoticeDialog;
			CString TempString = "\n\n\nSetup Name more the MAX_PATH characters, Offset Image save aborted";
			TempNoticeDialog.vNoticeText = TempString;
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
			TempLength = MAX_PATH;
		}
		else
		{
			CW2A TempFileNameString(TempStringName);			
			CImgFile *TempImageFile=IfxCreateImgFile(TempFileNameString);
			if (TempImageFile) 
			{
				if (!TempImageFile->WriteFile(vSystemData.vITIPCDig->vOriginalImage->vGreyImage,
					vSystemData.vITIPCDig->vOriginalBufferSizeX,
					vSystemData.vITIPCDig->vOriginalBufferSizeY,
					(WORD)vSystemData.vITIPCDig->vBitsPerPixel))
				{
					ReportErrorMessage("Failed to Write Test Shutter Image to File", cEMailInspx, 32000);
				}
				delete TempImageFile;
			}
		}

		double TempDensityValue = 0;
		if (TempCount)
			TempDensityValue = TempSum / TempCount;
		if (TempDensityValue > 255)
			TempDensityValue = 255;

		//first and third images should be white as shutter open
		if ((vSystemData.vCalibrationImageNumber == 1) || (vSystemData.vCalibrationImageNumber == 3))
		{
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Test Shutter: " + dtoa(vSystemData.vCalibrationImageNumber,0) + ", Should be Open, Brightness: " + dtoa(TempDensityValue, 0), cDebugMessage);

			if (TempDensityValue < 30)
			{
				if (vSystemData.vRampXRayVoltageAmount)
				if (vSystemData.vRampXRayCurrentAmount > .4)
				if (vSystemData.vITIPCDig->vShowOnlyRealImages)
				{
					if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterClose)
					{
						CString TempText = " ";
						TempText.LoadString(IDS_ShutterManuallyClosedCanNotTestOpenedShutter);
						ReportErrorMessage(TempText + " " +
							dtoa(vSystemData.vCalibrationImageNumber,0), cEMailInspx, 32000);
					}
					else
					if (vSystemData.vSourceCurrent > .3)
					{
						vShutterFailedLastTest++;
						CString TempText = " ";
						if (vSystemData.vCalibrationImageNumber == 3)
							TempText.LoadString(IDS_ShutterNeedsMaintenance);
						else
							TempText.LoadString(IDS_ShutterFailureDarkImageWhenOpen);

						ReportErrorMessage(TempText + " test " + dtoa(vSystemData.vCalibrationImageNumber,26) + " Failed to Open", cEMailMaintenance,0);

						CString TempNumberString = "1";
						if (vSystemData.vCalibrationImageNumber == 3)
							TempNumberString = "2";

						ReportErrorMessage("Shutter failed to open, test " + TempNumberString + " of 2", cEMailInspx,32000); //+ dtoa(TempDensityValue,1)
					}
					else
					{
						CString TempText = " ";
						TempText.LoadString(IDS_BlackImageCheckXRayCurrent);
						ReportErrorMessage(TempText + " " + dtoa(vSystemData.vCalibrationImageNumber,27), cError,0);

						ReportErrorMessage(TempText + " " + dtoa(vSystemData.vCalibrationImageNumber,0) + " = " + dtoa(TempDensityValue,1), cEMailInspx,32000);
					}
				}
			}
		}

		//second and fourth images should be black as shutter closed
		if ((vSystemData.vCalibrationImageNumber == 2) || (vSystemData.vCalibrationImageNumber == 4))
		{
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Test Shutter: " + dtoa(vSystemData.vCalibrationImageNumber,0) + ", Should be Closed, Brightness: " + dtoa(TempDensityValue, 0), cDebugMessage);


			if (TempDensityValue > 80)
			{
				if (vSystemData.vRampXRayVoltageAmount)
				if (vSystemData.vRampXRayCurrentAmount > .4)
				if (vSystemData.vITIPCDig->vShowOnlyRealImages)
				{
					if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterOpen)
					{
						CString TempText = " ";
						TempText.LoadString(IDS_ShutterManuallyOpenedCanNotTestClosedShutter);
						ReportErrorMessage(TempText + " " +
							dtoa(vSystemData.vCalibrationImageNumber,0) + " = " + 
							dtoa(TempDensityValue,1), cEMailInspx, 32000);
					}
					else
					{
						vShutterFailedLastTest++;
						CString TempText = " ";
						if (vSystemData.vCalibrationImageNumber == 4)
							TempText.LoadString(IDS_ShutterNeedsMaintenance);
						else
							TempText.LoadString(IDS_ShutterFailureBrightImageWhenClosed);

						ReportErrorMessage(TempText + " test " + dtoa(vSystemData.vCalibrationImageNumber,0) + " Failed to Open", cEMailMaintenance,26);

						CString TempNumberString = "1";
						if (vSystemData.vCalibrationImageNumber == 4)
							TempNumberString = "2";

						ReportErrorMessage("Shutter failed to close, test " + TempNumberString + " of 2", cEMailInspx,32000);
					}
				}
			}
		}

		if ((vSystemData.vCalibrationImageNumber == 1) || (vSystemData.vCalibrationImageNumber == 3))
		if (vGlobaluCSerialPort)
		//if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
			vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterClose);

		if (vSystemData.vCalibrationImageNumber == 2)
		if (vGlobaluCSerialPort)
		//if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
			vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterOpen);

		if (vSystemData.vCalibrationImageNumber == 4)
		{ //have taken the cNumberOfCalibrationImages (20) images, so stop calibration mode
			if (vShutterFailedLastTest > 1)
				vSystemData.vShutterFailedLastTest = true;
			else
				vSystemData.vShutterFailedLastTest = false;

			EndTestShutter(false);

			if (vGlobaluCSerialPort)
			if (vSystemData.vRadiationDoorManualControlRegister == cRadiationShutterAutoControl)
				vGlobaluCSerialPort->SetRadiationDoorManualControl(cRadiationShutterAutoControl);

			//if (vSystemData.vFullDetectorCalibration)
			//{
				//ReportErrorMessage("Full Detector Calibration Completed", cEMailInspx,32001);
				//vSystemData.vFullDetectorCalibration = false;
			//}

		}
		else
		{ 
			WORD TempShutterDelayTime = 300; // 60;
			if (vSystemData.vCalibrationImageNumber == 1)
				TempShutterDelayTime = 300; // 120;

			int TimerResult = SetTimer(vSimulateOneContainerTimer,TempShutterDelayTime,NULL);
			if (!TimerResult)
				ReportErrorMessage("Error-Simulate Cont Timer Failed",cEMailInspx,32000);
		}
	}
}

void CScanTracDlg::EndTestShutter(bool TempAbort)
{
	if (vAbortCalibration)
		TempAbort = true;

	KillTimer(vConveyorStartTimerHandle);
	KillTimer(vConveyorStartTimerHandle);
	KillTimer(vSourceStabilizeTimerHandle);
	if ((vSystemData.vModeToRunAfterCalibrateOffset == 0) || (TempAbort))
	{
		SendXRayPowerOnOffToUController(0);
		Sleep(cSendCommandSleepTime);
		vSystemData.vSystemRunMode = cStoppedSystemMode;
		//Sleep(1000);  //allow time for last frame to be processed
	}

	if (TempAbort)
	{
		m_SubFunction1Button.ShowWindow(SW_HIDE);
		this->InvalidateRect(&m_SubFunction1Button.GetRectToInvalidateArrow());
		m_Calibrating.ShowWindow(SW_HIDE);
	}

	if (TempAbort)
	{
		vSystemData.vSourceRampedUp = false;
		StopImageAcquisition();
		vSystemData.vDigitalInputLine3Mask = 0x00;
		vSystemData.vCurrentBodyTriggerMask = 0;
		vSystemData.vSystemRunMode = cStoppedSystemMode;

		if ((!vSystemData.vAutoCalibrate) || (TempAbort))
			SendConveyorOnOffToUController(0);

		FinishStopRunning(true);

	}
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter EndTestShutter ScanTracDlg",cDebugMessage);
	//Send Container Trigger to Image Delay
	if (vGlobalCurrentProduct)
	{

		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendContainerTriggerToImageDelay(vGlobalCurrentProduct);
	}
	//turn simulated encoder on if configured, otherwise will turn it off
	//must do when start to select real encoder
	TurnSimulatedEncoderOn();

	vTurnOffSourceWhenStopRunning = TempAbort;
	//if (vSystemData.vModeToRunAfterCalibrateOffset == cStoppedSystemMode)
	//	FinishCalibrateADCDetectorOffset(TempAbort);


	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SetRadiationDoorManualControl(
		vSystemData.vRadiationDoorManualControlRegister);

	if ((TempAbort) && (CurrentProductIsInspxProduct()))
		RestoreOriginalProduct();

	if (TempAbort)
		vSystemData.vSystemRunMode = cStoppedSystemMode;

	if (vGlobalCurrentProduct)
	{
		SendRetriggerLockout(vGlobalCurrentProduct->vLockoutPosition);
	}

	if (!TempAbort)
	if (vGlobalImageAquisitionThread)
	{
		if (vSystemData.vModeToRunAfterCalibrateOffset == cRunningSystemMode)
		{
			if (!InterlocksOK())
			{
				CString TempString1 = " ";
				CString TempString = " ";
				TempString1.LoadString(IDS_XRaysShutDown);
				TempString.LoadString(IDS_InterlockOpen);
				ReportErrorMessage(TempString + ", " + TempString1,cError,9);
				vSystemData.vSystemRunMode = cStoppedSystemMode;
				StopRunning(true);
			}
			else
			{//normal run or auto setup
				//if interlocks were OK and it ran set mode to correct run mode
				//StartRunning(false,true);
				//vSystemData.vCurrentBodyTriggerMask

				//set these counters the same since calibration added extra counts to some of them
				vSystemData.vImageCounter = vSystemData.vBodyTriggersCount;
				vSystemData.vFrameCount = vSystemData.vBodyTriggersCount;
				vSystemData.vProcessImageCounter = vSystemData.vBodyTriggersCount;
				vSystemData.vTriggerEndCounter = vSystemData.vBodyTriggersCount;

				vSystemData.vSystemRunMode = vSystemData.vModeToRunAfterCalibrateOffset;
				StartImageAcquisition();
				SetInterlockStatus();
				ShowOrHideProductDensityCompensation();
			}
		}
	}
	if (!TempAbort)
	{
		if (vSystemData.vTotalContainers == 0)
		{
			vSystemData.vITIPCDig->vMainDisplayIsDefaultImage = true;
			vSystemData.vITIPCDig->FillMainDisplayBuffer();
			if ((!vDisplayingVersion))//&& (!vShowingProductSetupWaitBox))		
			if (!vWaitForScreenUpdate)
			{
				int TimerResult = SetTimer(vWaitForScreenUpdateTimerHandle,10,NULL);
				if (!TimerResult)
					ReportErrorMessage("Error-Screen Timer Failed",cEMailInspx,32000);
				vWaitForScreenUpdate = true;
			}
			//ReportErrorMessage("End Shutter Test Displayed Pattern",cError,9);
		}
		//else
			//ReportErrorMessage("End Shutter Test Total Counters Not Zero",cError,9);
	}
	UpdateRunButton();

	CString TempText = " ";
	TempText.LoadString(IDS_XRAYSON);
	SetDlgItemText(IDC_Calibrating,TempText);
	m_Calibrating.ShowWindow(SW_SHOW);
	TempText.LoadString(IDS_Stop);
	SetDlgItemText(IDC_SubFunction1Button,TempText);

	vSystemData.vBodyTriggerLines = 0;
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("EndTestShutter vBodyTriggerLines = 0",cDebugMessage);
}

bool CScanTracDlg::PrepareToRun()
{
	ClearValveMonitoringFIFO();
	vSystemData.vOperationsGuardianError = 0;
	vGlobalGaveHardDriveLowOnMemoryWarning = false;
	vSystemData.vEject4InARowCount = 0;  //clear out any test ejects that never had a container do them
	vSystemData.vTestEjectNextContainer = 0;

	vSystemData.vTimeSinceLastStop = 0;
	vSystemData.vSecondsSinceLastContainer = 0;
	vSystemData.vHadABrownOut = false;
	if (vSystemData.vNeedToDisableEjectorsAfterSampleAll) //if aborted run during sample, don't leave ejectors on if they were off
	{
		EnableDisableEjectors(false);
		vSystemData.vNeedToDisableEjectorsAfterSampleAll = false;
		ReportErrorMessage("Disable Ejectors after Sampling containers and aborted now Starting Run", cWriteToLog,0);
	}

	for (BYTE TempLoop = 0; TempLoop < 3; TempLoop++)
		vSystemData.vRecievedFirstIndexPulse[TempLoop] = false;
	vSystemData.vSmallestDifferenceBetweenAverageAndMinimum = 255;
	vSystemData.vPipeBrightnessCount = 0;
	vSystemData.vSmallestDifferenceBetweenAverageAndMinimum;
	vSystemData.vCurrentPipeStatus = cNoPipeStatus;
	vSystemData.vAirBubblesInPipe = 0;
	vSystemData.vOldAirBubblesInPipe = 0;
	vSystemData.vPipeIsEmpty = 0;
	
	//set coolant flow OK since 50 watt and TDs have no coolant 
	if ((vConfigurationData->vScanTracType == cBriosoScanTrac) || (vConfigurationData->vScanTracType == cAtempoScanTrac) || 
		(vConfigurationData->vScanTracType == cForteScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || (vConfigurationData->vScanTracType == cCaseInspectorScanTrac) ||
		(vConfigurationData->vScanTracType == cPiccoloScanTrac) || (vConfigurationData->vScanTracType == cLegatoScanTrac))
	if (!vConfigurationData->vUseExternalInterlock)
		vSystemData.vSourceInterLocks = vSystemData.vSourceInterLocks | 0x0400;

	vSystemData.vOldDriftCompensationImageBrightnessDelta = 99999;
	vSystemData.vOldDriftCompensationADCOffset = 99999;
	vSystemData.vOldDriftCompensationDACOffset = 99999;
	vAbortCalibration = false;
	vSystemData.vLVDSErrorCount = 0;
	vSystemData.vGaveConveyorTooFastWarning = 0;
	if (!vConfigurationData->vDemoMode)
	if (!vSystemData.vITIPCDig->vCamera)
	{
		ReportErrorMessage("Error-No Frame Grabber",cEMailInspx,32000);
		ReportErrorMessage("Frame Grabber not connected, Call Service",cError,0);

		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\nError-No Frame Grabber detected in the computer.\nTurn off power and re-seat, or replace Frame Grabber";
		TempNoticeDialog.vType = cErrorMessage;
		//TempNoticeDialog.vAutoClose = 0xFFFF;  //force customer to shut down by not closing message
		TempNoticeDialog.DoModal();
	}

	vGlobalFlagSendOnceThreadError = true;
	vOldAverageEnabled = false;
	vOldStructureEnabled = false;
	vOldCalibrateBodyTriggerReferenceEnabled = false;
	if (!vConfigurationData->vSimulateLightControlBoard)
	if (!vSystemData.vOldNoCommunicationsWithUController)
	if (vGlobalFPGAVersion10Point0OrHigher)
	{
		if (vConfigurationData->vDetectorClockDivider != 8)
		{
			ReportErrorMessage("Pixel Clock Divider Wrong for FPGA Version 10+,\nCall Service", cCritical, 0); 
			ReportErrorMessage("Pixel Clock Divider Wrong for FPGA Version 10+,\nCall Service", cError, 0); 
		}
		//if (vConfigurationData->vPreAmplifierGain != 1)  //must be a gain of 2, which is code 1 in the software
		//	ReportErrorMessage("Preamp Gain Wrong for FPGA Version 10+, Call Service", cCritical,32000); 
	}
	else  //version 8 or 9 FPGA in uController board
	{
		if (vConfigurationData->vDetectorClockDivider != 20)
		{
			ReportErrorMessage("Pixel Clock Divider Wrong for FPGA Version less than 10,\nCall Service",cCritical, 0); 
			ReportErrorMessage("Pixel Clock Divider Wrong for FPGA Version less than 10,\nCall Service", cError, 0); 
		}
		//if (vConfigurationData->vPreAmplifierGain != 2)	//must be a gain of 4, which is code 2 in the software
		//	ReportErrorMessage("Preamp Gain Wrong for FPGA Version  less than 10, Call Service", cCritical,32000); 
	}
	if ((vConfigurationData->vPixelsPerDetector != 64) && (vConfigurationData->vPixelsPerDetector != 128))
	{
		ReportErrorMessage("Pixels Per Detector Wrong, Call Service", cCritical, 0); 
		ReportErrorMessage("Pixels Per Detector Wrong, Call Service", cError, 0); 
	}

	vSystemData.vInterlock200mSecChangeCount = 0;
	vSystemData.vDriftCompensationImageBrightnessDelta = 0;
	vSystemData.vCurrentBrightnessAdjustment = 0;
	vSystemData.vDriftCompensationADCOffset = 0;
	vSystemData.vDriftCompensationDACOffset = 0;
	SetProductDensityDisplay();

	vSystemData.vBodyTriggerLines = 0;
	vBodyTriggerActiveTimer = 0;
	vGaveBodyTriggerJammedMessage = false;
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("PrepareToRun vBodyTriggerLines = 0",cDebugMessage);

	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->vGaveEncoderWarning = false;
	if(vGlobalACPowerMoniter)
	{
		vGlobalACPowerMoniter->vGaveACVoltageWarning = false;
		vGlobalACPowerMoniter->IErrorACPowerMoniterLogFile.vGaveInspxMessageOverflowWarning = false;
	}
	bool TempReturn = false;
	//vSystemData.vHVPSInterlockDelay = 0;
	KillTimer(vStopRunningTimerHandle);
	vStopRunningTimerActive = false;
	vSystemData.vInspectionNameChanged = false;
	vSystemData.vInspectionNameMoved = false;

	//set these counters the same since calibration added extra counts to some of them
	vSystemData.vImageCounter = vSystemData.vBodyTriggersCount;
	vSystemData.vFrameCount = vSystemData.vBodyTriggersCount;
	vSystemData.vProcessImageCounter = vSystemData.vBodyTriggersCount;
	vSystemData.vTriggerEndCounter = vSystemData.vBodyTriggersCount;

	if (vSystemData.vReCalibrationTimerRunning)
	if (!vSystemData.vAutoCalibrateWhileRunning)
	{
		KillTimer(vReCalibrateOffsetTimerHandle);
		vSystemData.vReCalibrationTimerRunning = false;
	}
	KillTimer(vConveyorStartTimerHandle);
	//vSystemData.vGaveBodyTriggerWarning = 0;
	vSystemData.vCheckConveyor = false;
	vSystemData.vITIPCDig->vPreviousContainerEjected = 0;
	vSystemData.vIndexForDriftDensityOfLastNImages = 0;
	for (WORD TempLoop = 0; TempLoop < cMaximumNumberOfImagesForDriftDensity; TempLoop++)
		vSystemData.DensityOfLastNImages[TempLoop] = 0;
	if (vGlobalImageAquisitionThread)
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Stop Running Reset a/b frame Counters",cDebugMessage);
		vGlobalImageAquisitionThread->vAFrameCounter = 0;
		vGlobalImageAquisitionThread->vBFrameCounter = 0;
		vGlobalImageAquisitionThread->vPreviousHardwareFrameCount = -1;
	}
	vSystemData.vWaitingForImage = 0;
	vSystemData.vTimesRetried = 0;
	vSystemData.vSecondsSinceLastContainer = 60;
	vSystemData.vShuttingDownXRays = false;
	vSystemData.vBodyTriggerWidthSamples = 0;
	vSystemData.vBodyTriggerWidthIndex = 0;
	vSystemData.vBodyTriggerWidthAverage = 0;
	vSystemData.vBodyTriggerWidthStandardDeviation = 0;

	vSystemData.vCPMDataIndex = 0;
	vSystemData.vHaveAllCPMData = false;
	for (WORD TempLoop = 0; TempLoop < cMaxCPMTimePeriod; TempLoop++)
		vSystemData.vCPMData[TempLoop] = 0;

	if ((vConfigurationData->vDriftCompensationEnabled) && (vGlobalCurrentProduct) &&
		(vGlobalCurrentProduct->vSetupHistoryAverageDensity) &&
		(!vSystemData.vInAutoSetup))// && (vConfigurationData->vEnableEjectors))
	{
		vSystemData.vKeepDensityFeedbackLoopLocked = true;
		vSystemData.vDriftCompensationThresholdReductionAmount = 
			vConfigurationData->vDriftCompensationThresholdReductionMaximum;
		vSystemData.vDriftCompensationThresholdIncreaseAmount = 
			vConfigurationData->vDriftCompensationThresholdReductionMaximum;
			vSystemData.vITIPCDig->vDriftCompensationLocked = false;
	}
	else
	{
		vSystemData.vKeepDensityFeedbackLoopLocked = false;
		vSystemData.vDriftCompensationThresholdReductionAmount = 0;
		vSystemData.vDriftCompensationThresholdIncreaseAmount = 0;
		vSystemData.vITIPCDig->vDriftCompensationLocked = true;
	}

	vSystemData.vGaveNoXRayMessage = false;
	vSystemData.vTooManyRejectsIndex[0] = 0;
	vSystemData.vTooManyRejectsIndex[1] = 0;
	for (WORD TempLoop = 0; TempLoop < cMaximumEjectDataSize; TempLoop++)
	{
		vSystemData.vContainerEjectData[TempLoop][0] = 0;
		vSystemData.vContainerEjectData[TempLoop][1] = 0;
	}
	vSystemData.vPostedNewMainImageReadyToDisplayMessage = false;

	if ((!InterlocksOK()) || (!vSystemData.vMemoryOK))
	{
		vSystemData.vSystemRunMode = cStoppedSystemMode;
		m_Calibrating.ShowWindow(SW_HIDE);
		UpdateRunButton();
	}
	else
	{
		//try to reset a & b frame counters in FPGA
		//Send Number of Lines Per Frame to uController divided by 4 to make FEN Start Pulse
		//SendLinesPerFrame();
		WORD TempImageWidthPosition = vGlobalCurrentProduct->vImageWidthPosition;

		//Send Number of Lines Per Frame to FPGA
		//if stopped in middle of frame, this will reset the FPGA Frame enable
		tSerialCommand TempCommand;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xCE;
		TempCommand[2] = (BYTE)(TempImageWidthPosition >> 8);
		TempCommand[3] = (BYTE)TempImageWidthPosition;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

		//if (TempTurnOnSource)
		//if (!vSystemData.vITIPCDig->vShowOnlyRealImages)  //turn on simulator if testing
		//if ((!vSystemData.vFPGASimulateEncoderRate) && 
		//	(!vConfigurationData->vContinuousFeedEncoderRate)) //not simulating encoder
		//if (vSystemData.vActualEncoderRate == 0)
		//{
		//	SetFastestSimulatedEncoder(1);
		//}

		vSystemData.vGivenTemperatureWarning = false;
		vSystemData.vGivenFilterCloggedWarning = false;
		//if ((!vSystemData.vUControllerReady) && (!vConfigurationData->vDemoMode) && (!vConfigurationData->vSimulateLightControlBoard))
		//{
		//	ReportErrorMessage("Error-uController initializing - clear message to abort, or wait",
		//		cEMailInspx,32000);
		//	vSystemData.vWaitingForUControllerReady = true;
		//}
		//else
		{
			KillTimer(vStopRunningTimerHandle);
			vStopRunningTimerActive = false;

			ReportErrorMessage("Begin Inspecting: " + vSystemData.vFrameCountString, cAction,0);
			if (vConfigurationData->vDriftCompensationEnabled)
			if (vGlobalCurrentProduct->vSetupHistoryAverageDensity)
			{
				m_DensityNotLockedIndicator.ShowWindow(SW_SHOW);
			}

			SetupExternalDetectors();
			// temp comment out for speed test only
			//if ((!vSystemData.vITIPCDig->vShowOnlyRealImages) && (!(vConfigurationData->vContinuousFeedContainerRate)))
			//	if (vSystemData.vSimulateContainersRate == 0)
			//		vSystemData.vSimulateContainersRate = 30;

			vReportedBeltSpeedTooFast = false;
			CString TempText = " ";
			TempText.LoadString(IDS_Stop);
			SetDlgItemText(IDC_SubFunction1Button,TempText);
			UpdateRunButton();

			KillTimer(vTriggerIndicatorTimerHandle);
			SetDlgItemText(IDC_TriggerIndicator, _T(""));
			m_TriggerIndicator.ShowWindow(SW_HIDE);
		//	vOldTriggerIndicatorValue = 0;
			vTriggerIndicatorCount = 0;
			vCPMNotRunning = 0;

			//vOldTriggerIndicatorValue = false;
			TempReturn = true;

			if (vSystemData.vITIPCDig->vMainDisplayIsDefaultImage)
			if ((vSystemData.vTotalContainers == 0) || (PasswordOK(cTemporaryInspxPassword,false)))
			{
				if (vSystemData.vSystemRunMode == cRunningSystemMode)
				{
					vSystemData.vITIPCDig->vMainDisplayIsDefaultImage = true;
					vSystemData.vITIPCDig->FillMainDisplayBuffer();

					if (vSystemData.vLogFile.vLogSerialData)
						vSystemData.vLogFile.WriteToLogFile("StartRunning Filled Main Buffer",cDebugMessage);
					if ((!vDisplayingVersion))//&& (!vShowingProductSetupWaitBox))		
					if (!vWaitForScreenUpdate)
					{
						int TimerResult = SetTimer(vWaitForScreenUpdateTimerHandle,10,NULL);
						if (!TimerResult)
							ReportErrorMessage("Error-Screen Timer Failed",cEMailInspx,32000);
						vWaitForScreenUpdate = true;
					}
				}
			}
		}
	}
	if (TempReturn)//check conveyor not running too Fast
	if (!vSystemData.vInAutoSetup)
	if (!vSystemData.vInExpressSetup) //don't give warning in Express Setup as it will adjust the integration time to match the conveyor speed
	{
		if ((vSystemData.vPercentBeltSpeed > 120) && (vSystemData.vSystemRunMode == cRunningSystemMode))
		{
			if ((vSystemData.vFPGASimulateEncoderRate) || (vConfigurationData->vContinuousFeedEncoderRate) || (vConfigurationData->vScanTracType == cFermataScanTrac))
				ReportErrorMessage("Encoder input too fast to take images.\nSlow down encoder input,\nor shorten Integration Time.  Rate (Hz): " + dtoa(vSystemData.vActualEncoderRate,2) + ", Limit: " + dtoa(vSystemData.vMaximumEncoderRate,2), cCritical, 0);
			else
				ReportErrorMessage("Conveyor too fast to take images.\nSlow down conveyor,\nor shorten Integration Time.  Rate (Hz): " + dtoa(vSystemData.vActualEncoderRate,2) + ", Limit: " + dtoa(vSystemData.vMaximumEncoderRate,2), cCritical, 0);
		}
		else
		if (vSystemData.vPercentBeltSpeed > 106)
		{
			if (!vSystemData.vInAutoSetup)
				TempReturn = false;
			if ((vSystemData.vFPGASimulateEncoderRate) || (vConfigurationData->vContinuousFeedEncoderRate) || (vConfigurationData->vScanTracType == cFermataScanTrac))
				ReportErrorMessage("Encoder input too fast to inspect-Speed at " + dtoa(vSystemData.vPercentBeltSpeed,0) + "%",cEMailMaintenance,0);
			else
				ReportErrorMessage("Conveyor too fast to inspect-Speed at " + dtoa(vSystemData.vPercentBeltSpeed,0) + "%",cEMailMaintenance,0);
		}
	}
	return TempReturn;
}

void CScanTracDlg::ReadLifeTimeCounter()
{
	CArchive *PCounterArchive = NULL; 
	CFile *PTempCounterFile = NULL;
	WIN32_FIND_DATA FindFileData;
	CFileException TempFileException;

	//Rename C:\\3_LTC_bh folder to C:\\ScanTrac LTC
	CFileStatus TempFileStatus;
	CString TempSourceFolderName = "C:\\3_LTC_bh";
	if (CFile::GetStatus(TempSourceFolderName, TempFileStatus))
	{
		CFile TempFile;
		CString TempNewFolderName = "C:\\ScanTrac LTC";
		if (!CFile::GetStatus(TempNewFolderName, TempFileStatus))
			TempFile.Rename(TempSourceFolderName,TempNewFolderName);
	}

	//see if a LifeTime Counters file exists, if it does, use it and notify user, otherwise use common
	CString TempFileNameString = "C:\\ScanTrac LTC\\4_LTC_yada75";
	LPTSTR TempFileName = TempFileNameString.GetBuffer(TempFileNameString.GetLength());
	HANDLE hFind = FindFirstFile(TempFileName, &FindFileData);
	if (hFind == INVALID_HANDLE_VALUE) 
	{			//did not find c:\ScanTracHLTC\ScanTrac.LTC, 
	}
	else
	{ 
		TRY
		{
			CFile TempProductFile(TempFileName,CFile::modeRead | CFile::typeBinary | CFile::shareDenyNone);
			TRY
			{
				PTempCounterFile = &TempProductFile;
				if (ThereIsEnoughMemory(sizeof(CArchive), "Archive 6"))
				{
					PCounterArchive = new CArchive(PTempCounterFile,CArchive::load);
					if (PCounterArchive)
					if (ThereIsEnoughMemory(sizeof(CLifeTimeCounters), "New object for Read Config"))
					{
						CFile *TempArchiveFilePointer = PCounterArchive->GetFile();

						//get counter data class type to read in data
						if (ThereIsEnoughMemory(sizeof(CLifeTimeCounters), "Configuration Data"))
						{
							CLifeTimeCounters *TempLifeTimeCounters = new (CLifeTimeCounters);
							if (TempLifeTimeCounters)
							{
								CRuntimeClass *TempConfigDataRunTimeClass = TempLifeTimeCounters->GetRuntimeClass();

								//Read in system configuration data
								vReadInLifeTimeCounterDataPointer = PCounterArchive->ReadObject(TempConfigDataRunTimeClass);
								delete TempLifeTimeCounters;
								PCounterArchive->Close();

								//set our configuration data pointer to configuration data just read
								vGlobalLifeTimeCounters = (CLifeTimeCounters*)vReadInLifeTimeCounterDataPointer;
							}
						}
					}
					if (PCounterArchive)
						delete PCounterArchive;
				}
				TempProductFile.Close();
			}
			CATCH(CFileException, TempFileException)
			{
				if (TempFileException->m_cause == 2)
				{
				}
				else
				{
				}
			 #ifdef _DEBUG
					afxDump << "No Counters File Found " << TempFileException->m_cause << "\n";
			 #endif
			}
			END_CATCH
		}
		CATCH_ALL(TempException)
		{
		}
		END_CATCH_ALL
	}
	FindClose(hFind);
	if (!vGlobalLifeTimeCounters)//if did not have life time counter file, use from Products.STR file
	{
		if (ThereIsEnoughMemory(sizeof(CLifeTimeCounters), "LTC"))
		{
			vGlobalLifeTimeCounters = new (CLifeTimeCounters);
		}

		if (vGlobalLifeTimeCounters)
		if (vConfigurationData)
		{
			//vConfigurationData->vInspxMessageCount = 0;

			vGlobalLifeTimeCounters->vXRaySourceRunDuration = vConfigurationData->vXRaySourceRunDuration;
			vGlobalLifeTimeCounters->vDetectorsRunDuration = vConfigurationData->vDetectorsRunDuration;
			vGlobalLifeTimeCounters->vScanTracRunDuration = vConfigurationData->vScanTracRunDuration;
			
			vGlobalLifeTimeCounters->vXRaySourceWarrantyDuration = vConfigurationData->vXRaySourceRunDuration;
			vGlobalLifeTimeCounters->vDetectorsWarrantyDuration = vConfigurationData->vDetectorsRunDuration;
		}
	}
	if (vGlobalLifeTimeCounters)
	if (vGlobalLifeTimeCounters->vCommisionDate.GetYear() > 1999)
		vSystemData.vNotCommissioned = false;
}

void CScanTracDlg::WriteLifeTimeCounter()
{
	//check counters directory exists, if not, create it
	CString TempStringSSD = "C:\\ScanTrac LTC";
	LPTSTR TempStringSSDP = TempStringSSD.GetBuffer(TempStringSSD.GetLength());
	CFileStatus TempFileStatus;
	bool TempDirectoryExists = true;
	if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
	if (!CreateDirectory(TempStringSSD,NULL))
		ReportErrorMessage("Failed to Create Hard Drive Directory: " + TempStringSSD, cEMailInspx, 32000);
	else
	{
		if (CFile::GetStatus(TempStringSSDP, TempFileStatus))
		{
			TempFileStatus.m_attribute = FILE_ATTRIBUTE_HIDDEN;
			TempFileStatus.m_mtime = 0;
			CFile::SetStatus(TempStringSSDP, TempFileStatus);
		}
	}
	else
		TempDirectoryExists = false;

	CFileException TempFileException;

	TRY
	{
		CString TempCounterFileNameString = "C:\\ScanTrac LTC\\4_LTC_yada75";

		LPTSTR TempCounterFileName = TempCounterFileNameString.
			GetBuffer(TempCounterFileNameString.GetLength());

		if (CFile::GetStatus(TempCounterFileName, TempFileStatus))
		{
			TempFileStatus.m_attribute = TempFileStatus.m_attribute & (!FILE_ATTRIBUTE_HIDDEN);
			TempFileStatus.m_mtime = 0;
			CFile::SetStatus(TempCounterFileName, TempFileStatus);
		}
				

		CFile TempCounterFile(TempCounterFileName,CFile::modeCreate | CFile::modeWrite);
		CFile *PTempCounterFile = &TempCounterFile;
		if (ThereIsEnoughMemory(sizeof(CArchive), "Archive"))
		{
			CArchive *PCounterArchive = new CArchive(PTempCounterFile,CArchive::store);
			if (PCounterArchive)
			if (ThereIsEnoughMemory(sizeof(CLifeTimeCounters), "New Product for Write Config"))
			{
				CFile *TempArchiveFilePointer = PCounterArchive->GetFile();
				int TempSize = sizeof(CLifeTimeCounters);

				//Write the configuration data to the file
				CObject *TempObjectDataPointer = vGlobalLifeTimeCounters;

				PCounterArchive->WriteObject(TempObjectDataPointer);
				PCounterArchive->Close(); 

				
				if (CFile::GetStatus(TempCounterFileName, TempFileStatus))
				{
					TempFileStatus.m_attribute = TempFileStatus.m_attribute + FILE_ATTRIBUTE_HIDDEN;
					TempFileStatus.m_mtime = 0;
					CFile::SetStatus(TempCounterFileName, TempFileStatus);
				}
			}
			if (PCounterArchive)
				delete PCounterArchive;
		}
	}
	CATCH(CFileException, TempFileException)
	{
		ReportErrorMessage("System could not write Counter data to file",cEMailInspx,32000);
		//CNoticeDialog TempNoticeDialog;
		//TempNoticeDialog.vNoticeText = "\n\n\nSystem could not write Counter data to file";
		//TempNoticeDialog.vType = cErrorMessage;
		//TempNoticeDialog.DoModal();
		//#ifdef _DEBUG
		//	afxDump << "Counter data could not be written " << TempFileException->m_cause << "\n";
		//#endif
	}
	END_CATCH
	//int TempNumberOfFilesFlushed;
	//TempNumberOfFilesFlushed = _flushall();
}

bool DisposablePasswordOK(CString TempPasswordString, BYTE TempPasswordType )
{
	bool TempPasswordOK = false;
	if (TempPasswordString.GetLength() == 10)
	{
		CString TempStrippedPasswordString = TempPasswordString.GetAt(1);
		TempStrippedPasswordString = TempStrippedPasswordString + 
			TempPasswordString.GetAt(3) + TempPasswordString.GetAt(5) + TempPasswordString.GetAt(7) + 
			TempPasswordString.GetAt(9);

		CString TempPassword = TempPasswordString;

		CTime TempTime;
		TempTime = CTime::GetCurrentTime();

		DWORD TempDay = TempTime.GetDay();
		DWORD TempMonth = TempTime.GetMonth();
		DWORD TempYear = TempTime.GetYear();
		CString TempTodaysDateString = dtoa(TempMonth,0) + dtoa(TempDay,0) + dtoa(TempYear,0);

		CString TempTodaysCodeString = GetPasswordCodeFromDate(TempTime, TempPasswordType);

		CTimeSpan TempADay(1,0,0,0);
		CTime TempTomorrowsTime;
		TempTomorrowsTime = TempTime + TempADay;
		CString TempTomorrowsCodeString = GetPasswordCodeFromDate(TempTomorrowsTime, TempPasswordType);

		CTime TempYesterdaysTime;
		TempYesterdaysTime = TempTime - TempADay;
		CString TempYesterdaysCodeString = GetPasswordCodeFromDate(TempYesterdaysTime, TempPasswordType);

		CTime TempDayBeforeYesterdaysTime;
		TempDayBeforeYesterdaysTime = TempYesterdaysTime - TempADay;
		CString TempDayBeforeYesterdaysCodeString = GetPasswordCodeFromDate(TempDayBeforeYesterdaysTime, TempPasswordType);

		//int TempDR = rand();
		//CString TempRandomString = dtoa(TempDR,0); 

		if ((TempStrippedPasswordString == TempTodaysCodeString) || 
			(TempStrippedPasswordString == TempTomorrowsCodeString) || 
			(TempStrippedPasswordString == TempYesterdaysCodeString) || 
			(TempStrippedPasswordString == TempDayBeforeYesterdaysCodeString))
		{
			TempPasswordOK = true; //password is good

			//check to see if this password has been used before
			DWORD TempPlace = 
				vGlobalLifeTimeCounters->vUsedDisposablePasswords.Find(TempStrippedPasswordString,0);
			if (TempPlace < 65000)
			{
				DWORD TempPlace2 = 
					vGlobalLifeTimeCounters->vUsedDisposablePasswords.Find(_T("-"),TempPlace + 2);
				if (TempPlace2 < 65000)
				{
					DWORD TempPlace3 = 
						vGlobalLifeTimeCounters->vUsedDisposablePasswords.Find(_T(","),TempPlace + 2);
					if (TempPlace3 > 65000)
						TempPlace3 = vGlobalLifeTimeCounters->vUsedDisposablePasswords.GetLength();
					CString TempRunTimeString = 
						vGlobalLifeTimeCounters->vUsedDisposablePasswords.GetAt(TempPlace2 + 1);
					for (DWORD TempLoop = TempPlace2 + 2; TempLoop < TempPlace3; TempLoop++)
						TempRunTimeString = TempRunTimeString +
						vGlobalLifeTimeCounters->vUsedDisposablePasswords.GetAt(TempLoop);
					unsigned long TempRunTimeCounterWhenUsed = _wtoi(TempRunTimeString);
					if (vGlobalLifeTimeCounters->vScanTracRunDuration >
						TempRunTimeCounterWhenUsed + 43200) //if 12 hours run time since used password
						//br htest TempRunTimeCounterWhenUsed + 200) //if 10 minutes run time since used password
							TempPasswordOK = false;
					if (vGlobalLifeTimeCounters->vScanTracRunDuration <
						TempRunTimeCounterWhenUsed) //if counter has been reset since used password
							TempPasswordOK = false;
				}

				/*
				CString TempDateFindString = "-" + TempTodaysDateString;
				//if password was used before, but not on this date, then do not accept
				DWORD TempPlaceDate = 
					vGlobalLifeTimeCounters->vUsedDisposablePasswords.Find(TempTodaysDateString,TempPlace);
				if (TempPlaceDate - TempPlace != 6)
					TempPasswordOK = false;
					*/
			}

			if (TempPasswordOK)
			if (TempPlace > 65000)  //if password was not in used list already, then add it
			{
				vGlobalLifeTimeCounters->vUsedDisposablePasswords = 
					vGlobalLifeTimeCounters->vUsedDisposablePasswords + "," + 
					TempStrippedPasswordString + "-" + 
					dtoa(vGlobalLifeTimeCounters->vScanTracRunDuration,0);
			}
		}
	}
	return TempPasswordOK;
}

CString GetPasswordCodeFromDate(CTime TempDate, BYTE TempPasswordType)
{
	DWORD TempDay = TempDate.GetDay();
	DWORD TempMonth = TempDate.GetMonth();
	if (TempPasswordType == cTemporaryAdvancedPassword)
	{
		TempDay = TempDay * 1649;
		TempMonth = TempMonth * 246;
	}
	else
	// if (TempPasswordType == cTemporaryInspxPassword)
	{
		TempDay = TempDay * 1637;		//values to work with algorithm: 3000 - 1000
		TempMonth = TempMonth * 137;	//values to work with algorithm: 580 - 0
	}

	DWORD TempCode = TempMonth + TempDay;
	CString TempCodeString = dtoa(TempCode,0);
	while (TempCodeString.GetLength() < 5)
		TempCodeString = "0" + TempCodeString;
	return TempCodeString;
}

CString FormatRunTimeCounterString(unsigned long int TempCounter)
{
	int TempSeconds = TempCounter % 60;
	CString vTempSString = dtoa(TempSeconds,0);
	if (TempSeconds < 10)
		vTempSString = "0" + vTempSString;

	int TempMinutes = (TempCounter / 60) % 60;
	CString vTempMString = dtoa(TempMinutes,0);
	if (TempMinutes < 10)
		vTempMString = "0" + vTempMString;

	int TempHours = (TempCounter / 3600);
	CString vTempHString = dtoa(TempHours,0);
	if (TempHours < 10)
		vTempHString = "0" + vTempHString;

	CString TempTimeString = vTempHString + ":" + vTempMString + ":" + vTempSString;
	return TempTimeString;
}

void WriteStringToFile(CString TempNameForFile, CString TempStringToWrite) 
{
	TempNameForFile.Remove('"'); //can't have double quotes in file name
	CString TempFileNameString(cLogDirectory);
	TempFileNameString = TempFileNameString + TempNameForFile + ".txt";
	LPCTSTR TempFileName = TempFileNameString;
	CFileException TempFileException;
	if (ThereIsEnoughMemory(sizeof(CFile), "String to File"))
	{
		CFile *TempReportFile = new CFile;
		if (TempReportFile)
		{
			if (TempReportFile->Open(TempFileName, (CFile::modeCreate | CFile::modeReadWrite), &TempFileException))
			{
				WORD TempLength = TempStringToWrite.GetLength();
				if (TempLength)
				{
					CW2A TempStringToWrite2(TempStringToWrite);
					TempReportFile->Write(TempStringToWrite2, TempLength);
				}
				TempReportFile->Close();

				int TempPosition = TempNameForFile.Find(_T("ProductSummary"),0);
				if ((TempPosition > 255) || (TempPosition < 0))
					TempPosition = TempNameForFile.Find(_T("Source Strength"),0);
				if ((TempPosition > 255) || (TempPosition < 0))
					TempPosition = TempNameForFile.Find(_T("ProductThresholds"),0);
				if ((TempPosition > 255) || (TempPosition < 0))
				if (TempNameForFile != "SystemSummary")
				if (TempNameForFile != "SourceStrength")
				{
					CNoticeDialog TempNoticeDialog;
					CString TempText = TempNameForFile;
					TempText = "\n\n\n" + TempText + " written to file";
					TempNoticeDialog.vNoticeText = TempText;
					TempNoticeDialog.vType = cInformationMessage;
					TempNoticeDialog.vAutoClose = 1000;
					TempNoticeDialog.DoModal();
				}
			}
			else
			{
				//could not open serial log file
				#ifdef _DEBUG
					afxDump << "Could Not Open Report File"  << "\n";
				#endif
			}
			delete TempReportFile;
		}
	}
}

void CScanTracDlg::UpdateCustomerNameLine()
{
	CString TempString = vConfigurationData->vScanTracCustomerName;

	if (vSystemData.vNotCommissioned)
		TempString = TempString + "-Not Commissioned";

	if (vConfigurationData->vNeedToCalibrateEncoder)
	{
		if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
			TempString = TempString + "-ScanTrac Type Required";
		else
			TempString = TempString + "-Encoder Calibration Required";
	}

	SetDlgItemText(IDC_Shift,TempString);
}

void CScanTracDlg::SendProductIntegrationTime(WORD TempIntegrationTime)//, WORD TempIntegrationTimeAtEdge)
{
	//integration time code for old style
	//0 = .3 ms
	//1 = .4 ms
	//2 = .5 ms ..

	//integration time code for new style
	//750  = .3 ms
	//1000 = .4 ms
	//1250 = .5 ms ..

 	tSerialCommand TempCommand;
	if (vGlobalFPGAVersion10Point0OrHigher == 1)
	{
		if (TempIntegrationTime < 205)
			TempIntegrationTime = 750;

		BYTE TempUpperByte = (BYTE)(TempIntegrationTime >> 8);
		BYTE TempLowerByte = (BYTE)(TempIntegrationTime);
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xAE;
		{ //only fixed integration time
			TempCommand[2] = TempUpperByte;
			TempCommand[3] = TempLowerByte;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);
		}
	}
	else  //FPGA version below 10
	{
		WORD TempTime = ((WORD)(TempIntegrationTime * .004)) - 3;  //convert new style code to old style code

		TempCommand[0] = 0x1B;
		TempCommand[1] = (BYTE)TempTime;
		TempCommand[2] = 0;
		TempCommand[3] = 0;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);

	}
	WORD TempWord = 0;
	vSystemData.vMaximumEncoderRate = CalculateMaximumEncoderRate(TempIntegrationTime);
}

void CScanTracDlg::InitializeADCs()
{
	//New ADC XRD9814
	tSerialCommand TempCommand;
	if (vGlobaluCSerialPort)
	if (vGlobalFPGAVersion10Point0OrHigher)
	{//new way have 6 chips, one for each detector
		BYTE TempLoopCount = vConfigurationData->vNumberOfXRayDetectors;

		for (BYTE TempLoop = 0; TempLoop < TempLoopCount; TempLoop++)
		{ 
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Initialize ADC: 000C, 4000 Detector: " + dtoa(TempLoop,0),cDebugMessage);

			//Send Register 1 value to ADCs
			TempCommand[0] = 0x23;
			if (vConfigurationData->vScanTracType == cCaseInspectorScanTrac)
			{
				switch (TempLoop)
				{
					case 2: TempCommand[1] = 0xBC; break;  //front detector on 36 inch is center beam from trio
					case 1: TempCommand[1] = 0xD6; break;
					case 0: vGlobaluCSerialPort->StartMiddleBeamControl();  TempCommand[1] = 0xDE; break;
					case 5: TempCommand[1] = 0xBC; break; //middle detector daughter card is right beam from trio
					case 4: TempCommand[1] = 0xD6; break;
					case 3: TempCommand[1] = 0xDE; break;  
					case 8: TempCommand[1] = 0xB2; break; //back detector, uc
					case 7: TempCommand[1] = 0xB4; break;
					case 6: TempCommand[1] = 0xB6; break;


						//PROGRAM OTHER 3 CHANNELS OF EACH BOARD AS TEST IN CASE GOT WRONG ONES
					//case 17: TempCommand[1] = 0xF2; break; //back detector, uc
					//case 16: TempCommand[1] = 0xF4; break;
					//case 15: TempCommand[1] = 0xF6; break;
					//case 14: TempCommand[1] = 0xE4; break; //middle detector daughter card is right beam from trio
					//case 13: TempCommand[1] = 0xE6; break;
					//case 12: TempCommand[1] = 0xEA; break;  
					//case 11: TempCommand[1] = 0xE4; break;  //front detector on 36 inch is center beam from trio
					//case 10: TempCommand[1] = 0xE6; break;
					//case 9: vGlobaluCSerialPort->StartMiddleBeamControl(); TempCommand[1] = 0xEA; break;
				}
			}
			else
			if (vConfigurationData->vNumberOfXRayDetectors == 6)
			{
				switch (TempLoop)
				{
					case 5: TempCommand[1] = 0xB2; break; 
					case 4: TempCommand[1] = 0xB4; break;
					case 3: TempCommand[1] = 0xB6; break;
					case 2: TempCommand[1] = 0xF2; break;
					case 1: TempCommand[1] = 0xF4; break;
					case 0: TempCommand[1] = 0xF6; break;  
				}
			}
			else
			if (vConfigurationData->vScanTracType == cSoloPlusScanTrac)
			{
				switch (TempLoop)
				{
					case 8: TempCommand[1] = 0xDE; break;//top detector on 6 inch //daughter board T2
					case 7: TempCommand[1] = 0xD6; break;
					case 6: TempCommand[1] = 0xBC; break;  //6" daughter board
					case 5: TempCommand[1] = 0xF6; break;  //top detector on 12 inch //uC Board
					case 4: TempCommand[1] = 0xF4; break;
					case 3: TempCommand[1] = 0xF2; break;
					case 2: TempCommand[1] = 0xB6; break;
					case 1: TempCommand[1] = 0xB4; break;
					case 0: TempCommand[1] = 0xB2; break; //bottom detector//uC Board
				}
			}
			else
			if (vConfigurationData->vScanTracType == cAllegroScanTrac) //Allegro
			{
				switch (TempLoop)
				{
					case 0: TempCommand[1] = 0xB2; break; //back detector//uC Board
					case 1: TempCommand[1] = 0xB4; break;
					case 2: TempCommand[1] = 0xB6; break;
					case 3: TempCommand[1] = 0xF2; break;
					case 4: TempCommand[1] = 0xF4; break;
					case 5: TempCommand[1] = 0xF6; break;  //front detector on 12 inch //uC Board
					case 6: TempCommand[1] = 0xBC; break;  //6" daughter board
					case 7: TempCommand[1] = 0xD6; break;
					case 8: TempCommand[1] = 0xDE; break;//front detector on 6 inch //daughter board
				}
			}
			else
			{ //forte
				switch (TempLoop)
				{
					case 0: TempCommand[1] = 0xB2; break; //back detector
					case 1: TempCommand[1] = 0xB4; break;
					case 2: TempCommand[1] = 0xB6; break;
					case 3: TempCommand[1] = 0xF2; break;
					case 4: TempCommand[1] = 0xF4; break;
					case 5: TempCommand[1] = 0xF6; break;  //front detector on 12 inch
					case 6: TempCommand[1] = 0xBC; break;  
					case 7: TempCommand[1] = 0xD6; break;
					case 8: TempCommand[1] = 0xDE; break;
					case 9: TempCommand[1] = 0xE4; break;
					case 10: TempCommand[1] = 0xE6; break;
					case 11: TempCommand[1] = 0xEA; break;//front detector on 24 inch
				}
			}
			if (vGlobalFPGAVersion18point0orAbove)
			{
				TempCommand[2] = 0x00; //msb data
				TempCommand[3] = 0xC9;  //lsb of data to configure the version 18 ADCs  //original value 4 volt range on ADC input
				//TempCommand[3] = 0xD9;  //lsb of data to configure the version 18 ADCs  //original value 4 volt range on ADC input
				//TempCommand[3] = 0x59;  //lsb of data to configure the version 18 ADCs //tried this value for 2 volt range on ADC input instead on 9/12/2016 put back on 10/5/2015
			}
			else
			{
				TempCommand[2] = 0x00; //address of register 1
				TempCommand[3] = 0x0C;  //data of register 1
			}
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);

				//Send Register 2 value to ADCs
			if (vGlobalFPGAVersion18point0orAbove)  //version 18 only has one register that needs configuring, lower versions have 2 registers that need configuring
			{
				TempCommand[2] = 0x10; //address of register 2
				TempCommand[3] = 0xC0;  //data for register 2
			}
			else
			{
				TempCommand[2] = 0x04; //address of register 2
				TempCommand[3] = 0x00;  //data for register 2
			}
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);

			if ((vConfigurationData->vScanTracType == cCaseInspectorScanTrac) && (TempLoop == 2))
				vGlobaluCSerialPort->EndMiddleBeamControl();
		}
	}
	else
	{//old way had 2 - 3 channel a/d chips
		//Send A/D voltage range (0-2) and not invert
		for (BYTE TempLoop = 0; TempLoop < 3; TempLoop++)
		{
			TempCommand[0] = 0x4C;
			TempCommand[1] = TempLoop + 1; //which ADC Chip
			TempCommand[2] = 0; //control register 0 on the chip
			TempCommand[3] = 0x04;
			//0x14 not inverted 1-3 volts //0x04 not inverted, range 0 to 2 volts
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);
		}

		for (BYTE TempLoop = 0; TempLoop < 3; TempLoop++)
		{
			//Send Register 1 value to ADCs
			TempCommand[0] = 0x4C;
			TempCommand[1] = TempLoop + 1; //which ADC Chip
			TempCommand[2] = 4; //control register 1 on the chip
			TempCommand[3] = 0x00;
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTimeSetup);
		}
	}
	SendADCGainsAndOffsets(false);
}

void CScanTracDlg::SendADCGainsAndOffsets(bool TempSetAllGainsToTen)
{
	//New ADC XRD9814
	//hardware, top detector is # 1, software top detector is #5
	tSerialCommand TempCommand;
	if (vGlobalFPGAVersion10Point0OrHigher)
	{  //new way have 6 chips, one for each detector
		BYTE TempLoopCount = vConfigurationData->vNumberOfXRayDetectors;
		//if (vConfigurationData->vScanTracType == cCaseInspectorScanTrac)
		//	TempLoopCount = 18;

		for (BYTE TempLoop = 0; TempLoop < TempLoopCount; TempLoop++)
		{  
			//send a/d gain
			TempCommand[0] = 0x23;
			if (vConfigurationData->vScanTracType == cCaseInspectorScanTrac)
			{
				switch (TempLoop)
				{
					case 2: TempCommand[1] = 0xBC; break;  //front detector on 36 inch is center beam from trio
					case 1: TempCommand[1] = 0xD6; break;
					case 0: vGlobaluCSerialPort->StartMiddleBeamControl();  TempCommand[1] = 0xDE; break;
					case 5: TempCommand[1] = 0xBC; break; //middle detector daughter card is right beam from trio
					case 4: TempCommand[1] = 0xD6; break;
					case 3: TempCommand[1] = 0xDE; break;  
					case 8: TempCommand[1] = 0xB2; break; //back detector, uc
					case 7: TempCommand[1] = 0xB4; break;
					case 6: TempCommand[1] = 0xB6; break;

						//PROGRAM OTHER 3 CHANNELS OF EACH BOARD AS TEST IN CASE GOT WRONG ONES
					//case 17: TempCommand[1] = 0xF2; break; //back detector, uc
					//case 16: TempCommand[1] = 0xF4; break;
					//case 15: TempCommand[1] = 0xF6; break;
					//case 14: TempCommand[1] = 0xE4; break; //middle detector daughter card is right beam from trio
					//case 13: TempCommand[1] = 0xE6; break;
					//case 12: TempCommand[1] = 0xEA; break;  
					//case 11: TempCommand[1] = 0xE4; break;  //front detector on 36 inch is center beam from trio
					//case 10: TempCommand[1] = 0xE6; break;
					//case 9: vGlobaluCSerialPort->StartMiddleBeamControl(); TempCommand[1] = 0xEA; break;
				}
			}
			else
			if (vConfigurationData->vNumberOfXRayDetectors == 6)
			{
				switch (TempLoop)
				{
					case 5: TempCommand[1] = 0xB2; break; 
					case 4: TempCommand[1] = 0xB4; break;
					case 3: TempCommand[1] = 0xB6; break;
					case 2: TempCommand[1] = 0xF2; break;
					case 1: TempCommand[1] = 0xF4; break;
					case 0: TempCommand[1] = 0xF6; break;  
				}
			}
			else
			if (vConfigurationData->vScanTracType == cSoloPlusScanTrac)
			{
				switch (TempLoop)
				{
					case 8: TempCommand[1] = 0xDE; break;//top detector on 6 inch //daughter board T2
					case 7: TempCommand[1] = 0xD6; break;
					case 6: TempCommand[1] = 0xBC; break;  //6" daughter board
					case 5: TempCommand[1] = 0xF6; break;  //top detector on 12 inch //uC Board
					case 4: TempCommand[1] = 0xF4; break;
					case 3: TempCommand[1] = 0xF2; break;
					case 2: TempCommand[1] = 0xB6; break;
					case 1: TempCommand[1] = 0xB4; break;
					case 0: TempCommand[1] = 0xB2; break; //bottom detector//uC Board
				}
			}
			else
			if (vConfigurationData->vScanTracType == cAllegroScanTrac) //Allegro
			{
				switch (TempLoop)
				{
					case 8: TempCommand[1] = 0xB2; break; //back detector//uC Board
					case 7: TempCommand[1] = 0xB4; break;
					case 6: TempCommand[1] = 0xB6; break;
					case 5: TempCommand[1] = 0xF2; break;
					case 4: TempCommand[1] = 0xF4; break;
					case 3: TempCommand[1] = 0xF6; break;  //front detector on 12 inch //uC Board
					case 2: TempCommand[1] = 0xBC; break;  //6" daughter board
					case 1: TempCommand[1] = 0xD6; break;
					case 0: TempCommand[1] = 0xDE; break;//front detector on 6 inch //daughter board
				}
			}
			else
			{ //forte
				switch (TempLoop)
				{
					case 11: TempCommand[1] = 0xB2; break; 
					case 10: TempCommand[1] = 0xB4; break;
					case 9: TempCommand[1] = 0xB6; break;
					case 8: TempCommand[1] = 0xF2; break;
					case 7: TempCommand[1] = 0xF4; break;
					case 6: TempCommand[1] = 0xF6; break;  
					case 5: TempCommand[1] = 0xBC; break;  
					case 4: TempCommand[1] = 0xD6; break;
					case 3: TempCommand[1] = 0xDE; break;
					case 2: TempCommand[1] = 0xE4; break;
					case 1: TempCommand[1] = 0xE6; break;
					case 0: TempCommand[1] = 0xEA; break;
				}
			}

			BYTE TempDetector = TempLoop;
			if (vConfigurationData->vScanTracType == cCaseInspectorScanTrac)
				TempDetector = TempDetector % 9;

			double TempDouble = 0;
			BYTE TempMiddle = 0;
			WORD TempCodeToSend = 0;
			if (vGlobalFPGAVersion18point0orAbove)
			{ //new adc has a max gain of 6, old adc had a max gain of 10, so rescale gain of 10 into a gain of 6.
				double TempEffectiveGain = (vConfigurationData->vDetectorGain[TempDetector]) * 6.0 / 10.0; //gain is 6 bits or maximum of 63

				//new adc has a non linear gain for the codes, so apply this formula to get the code to send for the effective gain that we want
				TempCodeToSend = (BYTE)(63 - (((6 / TempEffectiveGain) - 1) * 63 / 5));

				if (TempCodeToSend > 63)
					TempCodeToSend = 63;

				if (TempSetAllGainsToTen)
					TempCodeToSend = 63;

				TempCodeToSend = (BYTE)TempCodeToSend;
				TempMiddle = 0x20;//address for red gain
			}
			else
			{
				TempDouble = (vConfigurationData->vDetectorGain[TempDetector] - 1) * 1023 / 9;
				if (TempSetAllGainsToTen)
					TempDouble = (10 - 1) * 1023 / 9;
				TempMiddle = 0x08;//address for red gain
				TempCodeToSend = WORD(TempDouble);
				TempMiddle = (TempMiddle | (TempCodeToSend >> 8));
			}

			if (vSystemData.vLogFile.vLogSerialData)
			if (TempSetAllGainsToTen)
				vSystemData.vLogFile.WriteToLogFile("Send ADC Gain: " + dtoa(TempLoop + 1, 0) + " = 10",cDebugMessage);
			else
				vSystemData.vLogFile.WriteToLogFile("Send ADC Gain: " + dtoa(TempLoop + 1, 0) + " = " + dtoa(vConfigurationData->vDetectorGain[TempDetector], 2),cDebugMessage);

			TempCommand[2] = TempMiddle; 
			TempCommand[3] = (BYTE)TempCodeToSend;  //gain value
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);

			if ((vConfigurationData->vScanTracType == cCaseInspectorScanTrac) && (TempLoop == 2))
				vGlobaluCSerialPort->EndMiddleBeamControl();
		}
	}
	else
	{  //old way had 2 - 3 channel a/d chips
		BYTE TempMiddle = 0;
		for (BYTE TempLoop = 0; TempLoop < vConfigurationData->vNumberOfXRayDetectors; TempLoop++)
		{  
			//send a/d gain
			//BYTE TempDetector = vConfigurationData->vNumberOfXRayDetectors - TempLoop - 1;
			BYTE TempDetector = vConfigurationData->vNumberOfXRayDetectors - TempLoop - 1;
			double TempDouble = (vConfigurationData->vDetectorGain[TempDetector] - 1) * 1023 / 9;
			if (TempSetAllGainsToTen)
				TempDouble = (10 - 1) * 1023 / 9;

			if (vSystemData.vLogFile.vLogSerialData)
			if (TempSetAllGainsToTen)
				vSystemData.vLogFile.WriteToLogFile("Send ADC Gain: " + dtoa(TempDetector + 1, 2) + " = 10",cDebugMessage);
			else
				vSystemData.vLogFile.WriteToLogFile("Send ADC Gain: " + dtoa(TempDetector + 1, 2) + " = " +
					dtoa(vConfigurationData->vDetectorGain[TempDetector],0),cDebugMessage);

			WORD TempCode = WORD(TempDouble);
			TempMiddle = ((TempLoop % 3) + 2) << 2;
			TempMiddle = (TempMiddle | (TempCode >> 8));
			TempCommand[0] = 0x4C;
			TempCommand[1] = ((TempLoop) / 3) + 1; //which ADC Chip
			TempCommand[2] = TempMiddle;//(TempLoop % 3) + 2; //which A/D Channel on the Chip
			TempCommand[3] = (BYTE)TempCode;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);

			/*
			//send a/d offset
			int TempOffset = vSystemData.vADCDetectorOffset[TempLoop] + 
				(int)vSystemData.vDriftCompensationADCOffset;
			if (TempOffset < -700)
				TempOffset = -700;
			if (TempOffset > 500)
				TempOffset = 500;

			BYTE TempGrossOffset = 0;
			if (TempOffset <= -400)
			{
				TempGrossOffset = 3;
				TempOffset = TempOffset + 400;
			}
			else
			if (TempOffset <= -200)
			{
				TempGrossOffset = 2;
				TempOffset = TempOffset + 200;
			}
			else
			if (TempOffset >= 200)
			{
				TempGrossOffset = 1;
				TempOffset = TempOffset + -200;
			}

			BYTE TempSign = 0;
			if (TempOffset < 0)
			{
				TempSign = 0x80;
				TempOffset = -TempOffset;
			}

			BYTE TempOffsetCode = (BYTE)((DWORD)TempOffset * (DWORD)127 / (DWORD)300);
			TempOffsetCode = TempOffsetCode | TempSign;
			BYTE TempOffsetAddress = 0x14 + ((TempDetector % 3) << 2);

			TempCommand[0] = 0x4C;
			TempCommand[1] = ((TempDetector) / 3) + 1; //which ADC Chip
			TempCommand[2] = TempOffsetAddress + TempGrossOffset; //address for adc offset
			TempCommand[3] = TempOffsetCode; //offset value
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);
			*/
		}
	}
	SendAllADCOffsets();
}

void CScanTracDlg::CreateProcessQuickLearnImagesThread()
{
	vOldProcessingQuickLearn = true;
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Create Quick Learn Images Thread",cDebugMessage);
	//thread lowest priority
	if (vSystemData.vMemoryOK)
	{
		vGlobalProcessQuickLearnImagesThread = (CProcessQuickLearnImagesThread *)AfxBeginThread(
			RUNTIME_CLASS(CProcessQuickLearnImagesThread), THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
			//THREAD_PRIORITY_LOWEST  // dont use lowest, makes it too slow
			//THREAD_PRIORITY_BELOW_NORMAL
	}
	if (!vGlobalProcessQuickLearnImagesThread)
	{
		ReportErrorMessage("Error-Could Not Create Process Quick Learn Thread", cEMailInspx,32000); 
	}
	else
	{
		if (vSystemData.vInExpressSetup)
			ReportErrorMessage("Started Processing Quick Learn in Express Setup 1: " + dtoa(vConfigurationData->vNumberOfQuickLearnImagesToTake,0), cAction,0);
		else
			ReportErrorMessage("Started Processing Quick Learn 1: " + dtoa(vConfigurationData->vNumberOfQuickLearnImagesToTake,0), cAction,0);

		vGlobalProcessQuickLearnImagesThread->vLocalSystemData = &vSystemData;
		vGlobalProcessQuickLearnImagesThread->vLocalConfigurationData = vConfigurationData;
		vGlobalProcessQuickLearnImagesThread->vMainWindowPointer = this;

		TempAfinity = (AFFINITYMASK_QUICK_LEARN & vGlobalSystemAffinityMask);
		/*
		if ((TempAfinity != 0)&&(vGlobalSystemAffinityMask >= 0x0F))
		{
			if (vGlobalSystemAffinityMask == 0xFF)
				DWORD TempOriginalAffinityMask = ::SetThreadAffinityMask(vGlobalProcessQuickLearnImagesThread->m_hThread, 0x04);
			else
			if (::SetThreadAffinityMask(vGlobalProcessQuickLearnImagesThread->m_hThread,TempAfinity))
			{
				vReplyOK |= 0x08;
			}
		}
		*/
		vGlobalProcessQuickLearnImagesThread->ResumeThread();
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Created Quick Learn Images Thread",cDebugMessage);

		if (vSystemData.vInAutoSetup)
		if (!vSystemData.vImprovingLearn)
		if (!vSystemData.vInExpressSetup)
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\nQuick Learn Complete:\n" + dtoa(vSystemData.vWrongWidthsDuringLearn,0) + " Wrong Widths during learn (excluded)\n" +
				dtoa(vSystemData.vWrongBrightnessDuringLearn,0) + " Wrong Brightness during Learn (excluded)\n";
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Closed Quick Learn Complete Dialog",cDebugMessage);
		}
	}
}

void CScanTracDlg::CheckForIFC59()
{
	if (!vGlobalDemoMode)
	{
		CString TempRegistryValue;
		CRegKey TempRegistryKey;
		bool TempGiveRebootNotice = false;

		LONG TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\IFC 5.9.0.0"));

		if (TempErrorCode != ERROR_SUCCESS)
		{
			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services"));

			TempErrorCode = TempRegistryKey.SetKeyValue(_T("CORLOG"), _T("system32\\drivers\\CORLOG.sys"), _T("ImagePath"));
			TempErrorCode = TempRegistryKey.SetKeyValue(_T("CORLOG"), _T("CORLOG"), _T("DisplayName"));
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\CORLOG"));
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("Start"), (DWORD)0);
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\CORLOG"));
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("Type"), (DWORD)1);
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\CORLOG"));
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ErrorControl"),(DWORD)1);
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services"));
			TempErrorCode = TempRegistryKey.SetKeyValue(_T("CORPCI"), _T("CORPCI"), _T("DisplayName"));
			TempErrorCode = TempRegistryKey.SetKeyValue(_T("CORPCI"), _T("system32\\drivers\\CORPCI.sys"), _T("ImagePath"));
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\CORPCI"));
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("Start"), (DWORD)0);
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\CORPCI"));
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("Type"), (DWORD)1);
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\CORPCI"));
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ErrorControl"), (DWORD)1);
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services"));

			TempErrorCode = TempRegistryKey.SetKeyValue(_T("CORSERIAL"), _T("CORSERIAL"), _T("DisplayName"));
			TempErrorCode = TempRegistryKey.SetKeyValue(_T("CORSERIAL"), _T("system32\\drivers\\CORSERIAL.sys"), _T("ImagePath"));
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\CORSERIAL"));
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("Start"), (DWORD)1);
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\CORSERIAL"));
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("Type"), (DWORD)1);
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Services\\CORSERIAL"));
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ErrorControl"), (DWORD)1);
			TempErrorCode = TempRegistryKey.Close();

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths"));

			if (TempErrorCode == ERROR_SUCCESS)
			{
				TempErrorCode = TempRegistryKey.SetKeyValue(_T("IFC 5.9.0.0"), _T("C:\\IFC59"), _T("Path"));
				TempErrorCode = TempRegistryKey.SetKeyValue(_T("IFC 5.9.0.0"), _T("C:\\IFC59\\IFC 5.9.0.0"), _T("Default"));
			}

			TempErrorCode = TempRegistryKey.Open(HKEY_CURRENT_USER, _T("Environment"));

			if (TempErrorCode == ERROR_SUCCESS)
			{
				//TempErrorCode = TempRegistryKey.SetKeyValue("Environment","C:\\IFC59\\Config","IFCCNF");
				TempErrorCode = TempRegistryKey.SetStringValue(_T("IFCCNF"), _T("C:\\IFC59\\Config"));
			}

			TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE,_T("System\\CurrentControlSet\\Control\\Session Manager\\Environment"));

			if (TempErrorCode == ERROR_SUCCESS)
			{
				//TempErrorCode = TempRegistryKey.SetKeyValue("Environment","C:\\IFC59\\Config","IFCCNF");
				TempErrorCode = TempRegistryKey.SetStringValue(_T("IFCCNF"), _T("C:\\IFC59\\Config"));
			}

			TempErrorCode = TempRegistryKey.Close();
			TempGiveRebootNotice = true;
		}

		CString TempBootMessageText = " ";
		if (TempGiveRebootNotice)
			TempBootMessageText =
				"\nRecent memory change, or software upgrade requires reboot to finish installation.\nIf upgrade to IFC software you must also run the Upgrade IFC Batch Files.\nAutomatically Rebooting in 10 seconds";

		TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\mvcntp\\Parameters"));

		if ((TempErrorCode == ERROR_SUCCESS) && (vGlobalPCRunningWindowsXP >= cWindows7))  //windows 7 does not use, so delete the key
		{
			DWORD TempWord = 0;
			TempRegistryKey.QueryDWORDValue(_T("ITEX Pool PhysAddr"), TempWord);
			
			if (TempWord > 0)
			{
			
				LPTSTR TempKeyString = _T("ITEX Pool PhysAddr");
				long TempSuccess = RegDeleteValue(TempRegistryKey.m_hKey, TempKeyString);

				if (!TempGiveRebootNotice)
				{
					TempBootMessageText = "\n\nHad to remove setting for Windows 7\n\nComputer will automatically reboot 10 Seconds.";
					TempGiveRebootNotice = true;
				}
			}
		}
		else
		if (vGlobalPCRunningWindowsXP <= cWindowsXP)
		{
			DWORD TempWord = 0;
			TempRegistryKey.QueryDWORDValue(_T("ITEX Pool PhysAddr"), TempWord);

		if (!TempWord) //if value was zero, set it
		{
			if (!TempGiveRebootNotice)
				TempBootMessageText = "\n\nRecent Memory Change Requires Reboot\nto finish setting parameters.\nComputer will automatically reboot 10 Seconds.";
			TempGiveRebootNotice = true;

			//reserve 16 megabytes at the top of memory for the frame grabber to use
			MEMORYSTATUS memstat;
			GlobalMemoryStatus(&memstat);
			DWORD TempAmountOfMemory = memstat.dwTotalPhys;
			TempAmountOfMemory = TempAmountOfMemory / 1000000;
			CString TempBootIniStringToAdd = " /MAXMEM=240";
/*
			if (TempAmountOfMemory > 4000) //set for 4 gigabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0xff000000);
				TempBootIniStringToAdd = " /MAXMEM=4080";
			}
			else //set for 3.5 gig RAM
			if (TempAmountOfMemory > 3500) //set for 3.5 gigabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0xdf000000);
				TempBootIniStringToAdd = " /MAXMEM=3568";
			}
			else //set for 3 gig RAM
			if (TempAmountOfMemory > 3000) //set for 3 gigabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0xbf000000);
				TempBootIniStringToAdd = " /MAXMEM=3056";
			}
			else //set for 2.5 gig RAM
			if (TempAmountOfMemory > 3000) //set for 2.5 gigabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0x9f000000);
				TempBootIniStringToAdd = " /MAXMEM=2544";
			}
			else //set for 2 gig RAM
			if (TempAmountOfMemory > 2000) //set for 2 gigabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0x7f000000);
				TempBootIniStringToAdd = " /MAXMEM=2032";
			}
			else //set for 1.5 gig RAM
			*/
			if (TempAmountOfMemory > 1500) //set for 1.5 gigabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"), 0x5f000000);
				TempBootIniStringToAdd = " /MAXMEM=1520";
			}
			else //set for 1 gig RAM
			if (TempAmountOfMemory > 1000) //set for 1 gigabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"), 0x3f000000);
				TempBootIniStringToAdd = " /MAXMEM=1008";
			}
			else
			if (TempAmountOfMemory > 490) //set for 512 Megabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"), 0x1f000000);
				TempBootIniStringToAdd = " /MAXMEM=496";
			}
			else
			if (TempAmountOfMemory > 235) //set for 256 Megabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"),0xf000000);
				TempBootIniStringToAdd = " /MAXMEM=240";
			}
			else //set for 128 Megabytes RAM
			{
				TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"),0x7000000);
				TempBootIniStringToAdd = " /MAXMEM=112";
			}
			TempErrorCode = TempRegistryKey.SetDWORDValue(_T("Max Buffer Size (bytes)"),0x1000000);

			TRY
			{
				CFile TempBootIniFile;
				CFileStatus TempFileStatus; 
				CFile::GetStatus(_T("C:\\Boot.Ini"),TempFileStatus);

				if (TempFileStatus.m_attribute & CFile::readOnly)
				{
					TempFileStatus.m_attribute = TempFileStatus.m_attribute & 0xFFFE;
					TempFileStatus.m_mtime = 0; 
					CFile::SetStatus(_T("C:\\Boot.Ini"),TempFileStatus);
					CFile::GetStatus(_T("C:\\Boot.Ini"),TempFileStatus);
				}

				if (TempBootIniFile.Open(_T("C:\\Boot.Ini"), (CFile::modeReadWrite | CFile::shareDenyNone),NULL))
				{
					if ((TempBootIniFile.m_hFile) && (TempBootIniFile.m_hFile != INVALID_HANDLE_VALUE))
					{
						char TempChars[1000];
						UINT TempLength = TempBootIniFile.Read(TempChars,1000);
						CString TempString = TempChars;
						UINT TempStringLength = TempString.GetLength();
						if (TempStringLength > TempLength)
							TempString.Delete(TempLength,TempStringLength - TempLength);

						WORD TempPosition = 0;
						TempPosition = TempString.Find(_T("MAXMEM"),0);
						if (TempPosition < 1000)
							ReportErrorMessage("Check Boot.Ini for MaxMem 16Meg less than PC Memory",cEMailInspx,32000);
						else
						{
							TempPosition = TempString.Find(_T("WINNT="),0);
							if (TempPosition > 1000)
								TempPosition = TempString.Find(_T("winnt ="),0);
							if (TempPosition > 1000)
								TempPosition = TempString.Find(_T("Windows XP"),0);
							if (TempPosition > 1000)
								TempPosition = TempString.Find(_T("XP"),0);
							if (TempPosition > 1000)
								TempPosition = TempString.Find(_T("xp"),0);

							while (TempPosition < 1000)
							{
								TempPosition = TempString.Find(_T("\n"),TempPosition);
								if (TempPosition > 1000)
								{
									TempString = TempString + TempBootIniStringToAdd;
								}
								else
								{
									TempString.Insert(TempPosition - 1,TempBootIniStringToAdd);
									TempPosition = TempString.Find(_T("WINNT="),TempPosition);
									if (TempPosition > 1000)
										TempPosition = TempString.Find(_T("winnt ="),TempPosition);
								}
							}

							TRY
							{
								TempBootIniFile.SeekToBegin();
							}
							CATCH_ALL(TempFileException)
							{
								ReportErrorMessage("Failed SeekToBegin of INI file", cEMailInspx, 32000);
							}
							END_CATCH_ALL

							CW2A TempStringToWrite(TempString);

							TempBootIniFile.Write(TempStringToWrite, TempString.GetLength());
							TempBootIniFile.Flush();
						}
						TempBootIniFile.Close();
					}
					else
						ReportErrorMessage("Could not open Boot.Ini to update Memory Maximum",cEMailInspx,32000);
				}
				else
					ReportErrorMessage("Could not open Boot.Ini to update Memory Maximum",cEMailInspx,32000);
			}
			CATCH_ALL(TempException)
			{
				ReportErrorMessage("Could not access Boot.Ini to update Memory Maximum",cEMailInspx,32000);
			}
			END_CATCH_ALL
			//must write /MAXMEM=240 or 16 meg less then there is into Boot.Ini
			//winnt = "Windows NT Embedded Version 4.00" /NODEBUG /NoSerialMice:COM2
			}
		}
		if (TempGiveRebootNotice)
		{
#ifdef _DEBUG
			CYesNoDialog TempYesNoDialog;
			TempYesNoDialog.vNoticeText = _T("nRelease Version would Reboot now,\nThis is a development version,\nDo you want to Reboot Now?");
			TempYesNoDialog.vYesButtonText = "Reboot Now!";
			TempYesNoDialog.vNoButtonText = "Reboot Later";
			TempYesNoDialog.vQuestionType = cConfirmQuestion;
			int TempResult = TempYesNoDialog.DoModal();
			if (TempResult == IDOK)
				SystemShutDown(cReboot);
#else
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = TempBootMessageText;
			TempNoticeDialog.vType = cInformationMessage;
			TempNoticeDialog.vAutoClose = 30000;
			TempNoticeDialog.DoModal();
			SystemShutDown(cReboot);
#endif
		}
	}
}

void CScanTracDlg::ClearDesignatedFrameGrabberMemorySettings(bool TempAskIfShouldRebootNow)
{
	CRegKey TempRegistryKey;
	LONG TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\mvcntp\\Parameters"));
	TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"), (WORD)0x0);
	TempErrorCode = TempRegistryKey.SetDWORDValue(_T("Max Buffer Size (bytes)"), (WORD)0x0);

	TRY
	{
		CFile TempBootIniFile;
		CFileStatus TempFileStatus; 
		CFile::GetStatus(_T("C:\\Boot.Ini"),TempFileStatus);

		if (TempFileStatus.m_attribute & CFile::readOnly)
		{
			TempFileStatus.m_attribute = TempFileStatus.m_attribute & 0xFFFE;
			TempFileStatus.m_mtime = 0; 
			CFile::SetStatus(_T("C:\\Boot.Ini"),TempFileStatus);
			CFile::GetStatus(_T("C:\\Boot.Ini"),TempFileStatus);
		}

		if (TempBootIniFile.Open(_T("C:\\Boot.Ini"), (CFile::modeReadWrite | CFile::shareDenyNone), NULL))
		{
			char TempChars[1000];
			UINT TempLength = TempBootIniFile.Read(TempChars,1000);
			CString TempString = TempChars;
			UINT TempStringLength = TempString.GetLength();
			if (TempStringLength > TempLength)
				TempString.Delete(TempLength,TempStringLength - TempLength);

			//remove any old MaxMem statements
			WORD TempPositionMaxMem = TempString.Find(_T("MAXMEM"),0);
			while (TempPositionMaxMem < 5000)
			{
				WORD TempPositionMaxMemEnd = TempString.Find(_T("\n"),TempPositionMaxMem);
				if (TempPositionMaxMemEnd < 5000)
				{
					TempString.Delete(TempPositionMaxMem - 2, 1 + TempPositionMaxMemEnd - TempPositionMaxMem);
					TempPositionMaxMem = TempString.Find(_T("MAXMEM"),TempPositionMaxMem);
				}
				else
				{
					TempString.Delete(TempPositionMaxMem - 2,
						1 + TempPositionMaxMemEnd - TempString.GetLength());
					TempPositionMaxMem = 10000;
				}
			}

			TRY
			{
				TempBootIniFile.SeekToBegin();
			}
			CATCH_ALL(TempFileException)
			{
				ReportErrorMessage("Failed SeekToBegin of INI file", cEMailInspx, 32000);
			}
			END_CATCH_ALL

			CW2A TempStringToWrite(TempString);

			TempBootIniFile.Write(TempStringToWrite, TempString.GetLength());
			TempBootIniFile.SetLength(TempString.GetLength());
			TempBootIniFile.Flush();
			TempBootIniFile.Close();
		}
		else
			ReportErrorMessage("Could not open Boot.Ini to update Memory Maximum",cEMailInspx,32000);
	}
	CATCH_ALL(TempException)
	{
		ReportErrorMessage("Could not access Boot.Ini to update Memory Maximum",cEMailInspx,32000);
	}
	END_CATCH_ALL
/*
	CNoticeDialog TempNoticeDialog;
	TempNoticeDialog.vNoticeText = "\nReboot now,\nafter boot up when it runs, ScanTrac.Exe will\nreset the Memory Setup,\nthen have you reboot again.";
	TempNoticeDialog.vType = cInformationMessage;
	//TempNoticeDialog.vAutoClose = 0xFFFF;  //force customer to shut down by not closing message
	TempNoticeDialog.DoModal();
*/
	if (TempAskIfShouldRebootNow)
	{
		CYesNoDialog TempYesNoDialog;
		TempYesNoDialog.vNoticeText = _T("nReboot now,\nafter boot up when it runs, ScanTrac.Exe will\nreset the Memory Setup,\nthen have you reboot again.\nReboot Now?");
		TempYesNoDialog.vYesButtonText = "Reboot Now!";
		TempYesNoDialog.vNoButtonText = "Reboot Later";
		TempYesNoDialog.vQuestionType = cConfirmQuestion;
		int TempResult = TempYesNoDialog.DoModal();
		if (TempResult == IDOK)
			SystemShutDown(cReboot);
	}
	else
			SystemShutDown(cReboot);
}

void CScanTracDlg::UpdateCurrentProductNameDisplay()
{
	CString TempText = " ";
	TempText.LoadString(IDS_CurrentProduct);

	//chinese test only
	//TempText.LoadString(IDS_RenSymbol);
	//TempText.LoadString(IDS_YenSymbol);
	
	SetDlgItemText(IDC_CurrentProductLabel,TempText + ":");
	if (vGlobalCurrentProduct == NULL)
	{
		TempText.LoadString(IDS_NoCurrentProduct);
		vSystemData.vCurrentProductName = " " + TempText + " ";
		SetDlgItemText(IDC_ProductLabel,vSystemData.vCurrentProductName);
	}
	else
	{
		CString TempString3 = " ";
		TempString3 = TempString3 + vSystemData.vCurrentProductName + TempString3;
		if (vConfigurationData->vAskForProductionReportProductCode)
			TempString3 = TempString3 + "(" + vSystemData.vShiftProductCode + ") ";
		SetDlgItemText(IDC_ProductLabel,TempString3);
	}
}

//void CScanTracDlg::OnMouseMove(UINT nFlags, CPoint point) 
//{
//	// TODO: Add your message handler code here and/or call default
//	vGlobalMouseMoveCounter++;
//	if (vGlobalMouseMoveCounter > 5)
//	{
//		vGlobalMouseMoveCounter = 0;
//		if (vGlobalUnderRemoteControl)
//			vGlobalUnderRemoteControl = 600;
//	}
//	CDialog::OnMouseMove(nFlags, point);
//}

void CScanTracDlg::SetInterlockStatus()
{
	CString TempText = " ";
	CString TempTextT1;
	if (vSystemData.vOpenInterlock.GetLength())
	{
		TempTextT1.LoadString(IDS_PoorLearn);
		if (vSystemData.vOpenInterlock == TempTextT1)
			vSystemData.vOpenInterlock = "";

		if (vSystemData.vOpenInterlock.GetLength())
		{
			TempTextT1.LoadString(IDS_ACFailed);
			if (vSystemData.vOpenInterlock == TempTextT1)
				vSystemData.vOpenInterlock = "";
		}

		if (vSystemData.vOpenInterlock.GetLength())
		{
			TempTextT1.LoadString(IDS_WeightTrend);
			if (vSystemData.vOpenInterlock == TempTextT1)
				vSystemData.vOpenInterlock = "";
		}

		if (vSystemData.vOpenInterlock.GetLength())
		{
			TempTextT1 = "Temp Sensor";
			if (vSystemData.vOpenInterlock == TempTextT1)
				vSystemData.vOpenInterlock = "";
		}

		if (vSystemData.vOpenInterlock.GetLength())
		{
			TempTextT1.LoadString(IDS_LateEject);
			if (vSystemData.vOpenInterlock == TempTextT1)
				vSystemData.vOpenInterlock = "";
		}

		if (vSystemData.vOpenInterlock.GetLength())
		{
			TempTextT1.LoadString(IDS_OldInspection);
			if (vSystemData.vOpenInterlock == TempTextT1)
				vSystemData.vOpenInterlock = "";
		}

		if (vSystemData.vOpenInterlock.GetLength())
		{
			TempTextT1.LoadString(IDS_BrownOut);
			if (vSystemData.vOpenInterlock == TempTextT1)
				vSystemData.vOpenInterlock = "";
		}

		if (vSystemData.vOpenInterlock.GetLength())
		{
			TempTextT1.LoadString(IDS_GuardianServer);
			if (vSystemData.vOpenInterlock == TempTextT1)
				vSystemData.vOpenInterlock = "";
		}
		if (vSystemData.vOpenInterlock.GetLength())
		{
			TempTextT1.LoadString(IDS_DetectorCalibrationNeeded);
			if (vSystemData.vOpenInterlock == TempTextT1)
				vSystemData.vOpenInterlock = "";
		}
		if (vSystemData.vOpenInterlock.GetLength())
		{
			TempTextT1.LoadString(IDS_CalibrateWeight);
			if (vSystemData.vOpenInterlock == TempTextT1)
				vSystemData.vOpenInterlock = "";
		}
	}

	vShowuControllerStatusInRed = false;
	if (!vSystemData.vACPowerOn)
	{
		TempText.LoadString(IDS_ShuttingDown);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vACPowerMonitorTroubleCount >= 2)
	{
		TempText = "Lost A/C Power";
			if (vACPowerMonitorTroubleCount >= 10)
				TempText.LoadString(IDS_ShuttingDown);
		vShowuControllerStatusInRed = true;
	}
	else
	if ((!vConfigurationData->vSimulateLightControlBoard) && (vSystemData.vOldNoCommunicationsWithUController) && ((vGlobalFirstMicroControllerCommCheck == cFinishedSearchForNextSerialPort) || (vGlobalFirstMicroControllerCommCheck == cNoCommPortSettings)))
	{
		TempText.LoadString(IDS_NouC);
		vShowuControllerStatusInRed = true;
	}
	else
	if ((vGlobalDXMXRayPort) && (!vConfigurationData->vSimulateLightControlBoard) && (vOldNoCommunicationsWithDXM) && (vGlobalXrayNoCommMessageRcvdEver == cYesCommSeen))
	{
		TempText.LoadString(IDS_NoXRayComm);
		vShowuControllerStatusInRed = true;
	}
	else
	if ((vGlobalGuardMaster) && (vGlobalGuardMaster->vDetectedValidGuardMasterDevice) && (vGlobalGuardMaster->vNoCommunications))
	{
		TempText.LoadString(IDS_NoInterlockComm);
		vShowuControllerStatusInRed = true;
	}
	else
	//if ((vGlobalPowerFlex40) && (vGlobalPowerFlex40->vDetectedValidPowerFlex40Device) && (vGlobalPowerFlex40->vNoCommunications))
	//{
	//	TempText.LoadString(IDS_NoConveyorComm);
	//	vShowuControllerStatusInRed = true;
	//}
	//else
	if ((vGlobalMonoBlockXRayPort) && (!vConfigurationData->vSimulateLightControlBoard) && (vGlobalMonoBlockXRayPort->vOldNoCommunications))
	{
		TempText.LoadString(IDS_NoXRayComm);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vOpenInterlock.GetLength())
	{
		TempText = 	vSystemData.vOpenInterlock;
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vEjectTooLateMessageGivenThisRun)
	{
		TempText.LoadString(IDS_LateEject);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vPosteduCVoltageProblemMessage)
	{
		TempText.LoadString(IDS_PowerSupplyProblem);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vAirConditionerFailed)
	{
		TempText.LoadString(IDS_ACFailed);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vWeightTrendingAlarm)
	{
		TempText.LoadString(IDS_WeightTrend);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vCheckWeighOffsetCalibrationNeeded)
	{
		TempText.LoadString(IDS_CalibrateWeight);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vMissingRAM)
	{
		TempText.LoadString(IDS_MissingRAM);
		vShowuControllerStatusInRed = true;
	}
	else
	if ((vConfigurationData->vEnableOperationsGuardian) && (vSystemData.vOperationsGuardianError))
	{
		TempText.LoadString(IDS_GuardianServer);
		vShowuControllerStatusInRed = true;
	}
	else
	//have a backup hard drive, but no primary hard drive in the system
	if ((!vSystemData.vPrimaryDrive.GetLength()) && (vSystemData.vBackupDrive.GetLength()))
	{
		TempText.LoadString(IDS_NoPrimaryDrive);
		vShowuControllerStatusInRed = true;
	}
	else
	if ((vSystemData.vPrimaryDrive.GetLength()) && (!vSystemData.vBackupDrive.GetLength()))
	{
		TempText.LoadString(IDS_NoBackupDrive);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vProductHasAPoorLearn)
	{
		TempText.LoadString(IDS_PoorLearn);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vProductHasAnOldInspection)
	{
		TempText.LoadString(IDS_OldInspection);
		vShowuControllerStatusInRed = true;
	}
	else
	if ((vGlobalCurrentProduct) && (!vGlobalCurrentProduct->ProductHasImageFiles(vGlobalCurrentDirectory)) && (!vSystemData.vITIPCDig->vProductContaminant2StructureImage) &&
		(vGlobalCurrentProduct->vProductName.Find(_T("~"),0) == -1) &&//if not a system setup product
		(vConfigurationData->vScanTracType != cAtempoScanTrac) && (vConfigurationData->vScanTracType != cForteScanTrac) && (vGlobalScanTracType != cAllegroScanTrac) && (vConfigurationData->vScanTracType != cCaseInspectorScanTrac))  //don't give learn incomplete on TDs
	{
		TempText.LoadString(IDS_LearnIncomplete);
		vShowuControllerStatusInRed = true;
	}
	else
	//if (vSystemData.vHadABrownOut)
	//{
	//	TempText.LoadString(IDS_BrownOut);
	//	vShowuControllerStatusInRed = true;
	//}
	//else
		/*
	if (vSystemData.vHadAPowerMoniterMessageError % 16)	//if flags 1, 2, 4, 8 are on
	{
		//vSystemData.vOpenInterlock.LoadString(IDS_ACPowerCriticalError);
		vShowuControllerStatusInRed = true;
	}
	else
	*/
	//if (vSystemData.vHadAnACPowerDropOut)
	//{
	//	TempText.LoadString(IDS_ACDropOut);
	//	vShowuControllerStatusInRed = true;
	//}
	//else
	//if (vSystemData.vDetectorCalibrationNeeded)
	//{
	//	TempText.LoadString(IDS_DetectorCalibrationNeeded);
	//	vShowuControllerStatusInRed = true;
	//}
	//else//downstream
	if ((!vSystemData.vDownStreamSignalSaysConveyorOn) && (vConfigurationData->vUseDownStreamSignalThatStopsConveyor == cUseDownStream))
	{
		TempText.LoadString(IDS_DownStream);
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vGivenTemperatureSensorWarning == cTemperatureSensorWarningRedBoxSent)
	{
		TempText = "Temp Sensor";
		vShowuControllerStatusInRed = true;
	}
	else //faulty encoder
	if (vSystemData.vDisplayingAnEncoderError)
	{
		TempText = "Encoder Faulty";
		vShowuControllerStatusInRed = true;
	}
	else
	if (vSystemData.vOperationsGuardianError)
	{
		CString TempText1;
		TempText1.LoadString(IDS_GuardianServer);
		vSystemData.vOpenInterlock = TempText1;
		vShowuControllerStatusInRed = true;
	}
	if (vSystemData.vOldOpenInterlock != TempText)
	{
		vSystemData.vOldOpenInterlock = TempText;
		if (!vConfigurationData->vDemoMode)
			SetDlgItemText(IDC_uControllerStatus,TempText);
	}
}

void CScanTracDlg::QuickLearnFinished()
{
	SetInterlockStatus();
	SetLearnState();
}

bool CScanTracDlg::ChangeFilter() 
{
	CSelectItemDialog ISelectItemDialog;  
	
	CProduct *TempProduct = GetProductByName("~SourceStrength");
	bool TempSourceStrengthIsCurrentProduct = false;
	if (TempProduct == vGlobalCurrentProduct)
		TempSourceStrengthIsCurrentProduct = true;

	if (TempProduct)
	{
		//Set dialog box data titles and number value
		ISelectItemDialog.vTitleString = "Source Strength Settings Non-Standard";
		//ISelectItemDialog.vBackgroundColor = cGreen;

		ISelectItemDialog.vItems[0] = "Keep Existing Settings";
		if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cUpSideDownSoloScanTrac))
		{
			ISelectItemDialog.vNumberOfItems = 3;
			ISelectItemDialog.vItems[1] = "Use Standard Settings for Aluminum Filter";
			ISelectItemDialog.vItems[2] = "Use Standard Settings for No Aluminum Filter";
		}
		else
		{
			ISelectItemDialog.vNumberOfItems = 2;
			ISelectItemDialog.vItems[1] = "Use Standard Settings";
		}
		//ISelectItemDialog.m_DialogTitleStaticText2 = "";
		//ISelectItemDialog.m_DialogTitleStaticText3 = "";
		//Pass control to dialog box and display
		int nResponse = ISelectItemDialog.DoModal();
		//dialog box is now closed, if user pressed select do this
		//if user pressed cancel, do nothing
		if (nResponse == IDOK)
		{
			if ((ISelectItemDialog.vItemNumberSelected == 2) || (ISelectItemDialog.vItemNumberSelected == 3))
			{
				if (ISelectItemDialog.vItemNumberSelected == 2)
					vConfigurationData->vXRaySourceFilter = true;
				else
					vConfigurationData->vXRaySourceFilter = false;

				if ((TempProduct->vXRaySourceVoltage * 6.0 > (float)(GetDefaultMeasureSourceStrengthVoltage() + 1)) || 
					(TempProduct->vXRaySourceVoltage * 6.0 < (float)(GetDefaultMeasureSourceStrengthVoltage() - 1)))
					TempProduct->vXRaySourceVoltage = (float)(GetDefaultMeasureSourceStrengthVoltage() / 6.0);

				if ((TempProduct->vXRaySourceCurrent > (float)(GetDefaultMeasureSourceStrengthCurrent(vConfigurationData->vXRaySourceFilter) + 0.5)) || 
					(TempProduct->vXRaySourceCurrent < (float)(GetDefaultMeasureSourceStrengthCurrent(vConfigurationData->vXRaySourceFilter) - 0.5)))
					TempProduct->vXRaySourceCurrent = (float)GetDefaultMeasureSourceStrengthCurrent(vConfigurationData->vXRaySourceFilter);
					TempProduct->vXRayIntegrationTime = 750; //750 = .3 mSec

					if (vConfigurationData->vMaximumCurrent < TempProduct->vXRaySourceCurrent)
						TempProduct->vXRaySourceCurrent = (float)vConfigurationData->vMaximumCurrent;

					if (vConfigurationData->vMaximumVoltage < TempProduct->vXRaySourceVoltage)
						TempProduct->vXRaySourceVoltage = (float)vConfigurationData->vMaximumVoltage;
			}
			return true;
		}
		else 
		if (nResponse == 10)
		{
			return false;
		}
		else
			return false;
	}
	else
		return false;
}

void CScanTracDlg::SendBodyTriggerInverterControl()
{
	if (vSystemData.vFPGAVersion10Point7OrHigher)
	if (vGlobalCurrentProduct)
	{  
		//Send Inverter setting for body trigger
		//Don't enable encoder interrupt
		//figure out if should invert any of the body trigger bits
		WORD TempMask = vConfigurationData->vBodyTrigger[0].vLineBitMask << 5;
		if (vConfigurationData->vBodyTrigger[0].vActiveHigh)
		{
			TempMask = ~TempMask;
			vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & TempMask;  //clear bit 6 to not invert it if trigger 2 used
		}
		else
			vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | TempMask;  //clear bit 5 to not invert it if trigger 1 used

		TempMask = vConfigurationData->vBodyTrigger[1].vLineBitMask << 5;  //shift over 5 bits
		if (vConfigurationData->vBodyTrigger[1].vActiveHigh)
		{
			TempMask = ~TempMask; //invert the bits
			vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & TempMask;  //clear bit 6 to not invert it if trigger 2 used
		}
		else
			vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | TempMask;  //clear bit 5 to not invert it if trigger 1 used

		Send0x9ACommand();

		if (vGlobalCurrentProduct->vBackupBodyTrigger)
		{
			//Send Inverter setting for Backup body trigger
			//Don't enable encoder interrupt
			if (!vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBackupBodyTrigger - 1].vActiveHigh)
			{  //if the signal is active low, invert it in the FPGA if FPGA version 10.7 or higher
				if (vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBackupBodyTrigger - 1].vLineBitMask == 2)
					vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x40;  //set bit 6 to invert it if trigger 2 used
				else
					vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x20;  //set bit 5 to invert it if trigger 1 used
			}
			else
			{  //if the signal is active high, make sure FPGA does not invert it in FPGA version 10.7 or higher
				if (vConfigurationData->vBodyTrigger[vGlobalCurrentProduct->vBackupBodyTrigger - 1].vLineBitMask == 2)
					vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & 0xFFBF;  //set bit 6 to invert it if trigger 2 used
				else
					vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & 0xFFDF;  //set bit 5 to invert it if trigger 1 used
			}
			Send0x9ACommand();
		}
	}
}

void CScanTracDlg::StartLearning()
{
	CString TempText = " ";
	CString TempText1 = " ";
	//if quick learn is setup 
	if (vGlobalCurrentProduct)
	if ((vConfigurationData->vQuickLearnNumberOfStructureDeltas) &&
		(vConfigurationData->vNumberOfQuickLearnImagesToTake))
	{
		if (vGlobalProcessQuickLearnImagesThread)
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\nSaving Last Quick Learn\nTry again in a few seconds";
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
		else
		{ //do quick learn
			if (ThereIsEnoughMemory(10000000 + vSystemData.vITIPCDig->vOriginalBufferSize * ((vConfigurationData->vNumberOfQuickLearnImagesToTake * 2) + 
				vConfigurationData->vNumberOfLastRejectImages), "Quick Learn Images"))
			{
				vSystemData.vIncludeRejectsInAverageAndStructure = false;
				if (vSystemData.vManualReLearnWhileInspecting)
				{
					CYesNoDialog TempYesNoDialog;
					TempText.LoadString(IDS_IncludeRejectsinLearnedImage);//"\n\n\nInclude Rejects in Learned Image?"
					TempYesNoDialog.vNoticeText = TempText;
					TempYesNoDialog.vQuestionType = cConfirmQuestion;
					TempText1.LoadString(IDS_IncludeRejects);
					TempYesNoDialog.vYesButtonText = TempText1;
					TempText1.LoadString(IDS_ExcludeRejects);
					TempYesNoDialog.vNoButtonText = TempText1;
					int TempResult = TempYesNoDialog.DoModal();
					if (TempResult == IDOK)
						vSystemData.vIncludeRejectsInAverageAndStructure = true;
				}
				vSystemData.FreeQuickLearnImages();
				vSystemData.vWrongWidthsDuringLearn = 0;
				vSystemData.vRejectsDuringLearn = 0;
				vSystemData.vWrongBrightnessDuringLearn = 0;

				//clear the reference if you are in auto setup so can learn the new width
				if (vSystemData.vInAutoSetup)
				{
					vGlobalCurrentProduct->vReferenceTop = 0;
					vGlobalCurrentProduct->vReferenceBottom = 0;
					vGlobalCurrentProduct->vReferenceLeft = 0;
					vGlobalCurrentProduct->vReferenceRight = 0;
					vGlobalCurrentProduct->vReferenceWidth = 0;
					ReportErrorMessage("Delete Reference Data", cAction, 0);
				}

				ReportErrorMessage("Start Quick Learn", cAction,0);
				vSystemData.vTakingQuickLearnImages = true;
				ReportErrorMessage("Start Quick Learn: " + dtoa(vConfigurationData->vNumberOfQuickLearnImagesToTake,0), cAction,0);
			}
			else
			{
				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\nNot Enough Memory Available for Quick Learn\nTry Normal Learn";
				TempNoticeDialog.vType = cErrorMessage;
				TempNoticeDialog.DoModal();
			}
		}
	}
	else
	//start normal learn
	{
		vSystemData.vIncludeRejectsInAverageAndStructure = false;
		if (vSystemData.vManualReLearnWhileInspecting)
		{
			CYesNoDialog TempYesNoDialog;
			TempText.LoadString(IDS_IncludeRejectsinLearnedImage);//"\n\n\nInclude Rejects in Learned Image?"
			TempYesNoDialog.vNoticeText = TempText;
			TempYesNoDialog.vQuestionType = cConfirmQuestion;
			TempText1.LoadString(IDS_IncludeRejects);
			TempYesNoDialog.vYesButtonText = TempText1;
			TempText1.LoadString(IDS_ExcludeRejects);
			TempYesNoDialog.vNoButtonText = TempText1;
			int TempResult = TempYesNoDialog.DoModal();
			if (TempResult == IDOK)
				vSystemData.vIncludeRejectsInAverageAndStructure = true;
		}
		//don't find new reference location if you have one and are inspecting
		if ((vConfigurationData->vCalibrateBodyTriggerReferenceDisableCount) && ((vSystemData.vInAutoSetup) ||
			(!vSystemData.vITIPCDig->HaveLearnImageFile("=Process 2")) || (!vGlobalCurrentProduct->vReferenceRight) || (!vGlobalCurrentProduct->vReferenceTop)))
		{
			vSystemData.vITIPCDig->vReferenceRightStandardDeviation = 0;
			vSystemData.vITIPCDig->vReferenceRightAverage = 0;
			vSystemData.vITIPCDig->vReferenceLeftStandardDeviation = 0;
			vSystemData.vITIPCDig->vReferenceLeftAverage = 0;
			vSystemData.vITIPCDig->vReferenceTopStandardDeviation = 0;
			vSystemData.vITIPCDig->vReferenceTopAverage = 0;
			vSystemData.vITIPCDig->vReferenceBottomStandardDeviation = 0;
			vSystemData.vITIPCDig->vReferenceBottomAverage = 0;

			vSystemData.vFrameCount = 0;
			vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceCount = 0;
			vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled = true;
			ReportErrorMessage("Start Standard Learn", cAction,0);
			vOldCalibrateBodyTriggerReferenceEnabled = true;
		}
		else
		if (vConfigurationData->vAverageDisableCount)
		{
			vSystemData.vITIPCDig->MakeAverageImageBuffer();
			vSystemData.vWrongWidthsDuringLearn = 0;
			vSystemData.vWrongBrightnessDuringLearn = 0;
			vSystemData.vRejectsDuringLearn = 0;
			vSystemData.vITIPCDig->vAverageEnabled = true;
			vOldAverageEnabled = true;
		}
		else
		{
			CNoticeDialog TempNoticeDialog;
			CString TempText = " ";
			TempText.LoadString(IDS_AutoSetupNotConfigured);
			TempNoticeDialog.vNoticeText = TempText;
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
	}
}

void CScanTracDlg::QuickSetupStartAutoReLearnIfNeeded(int TempLogStatistics)
{
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("STD-Check Auto Improve State",cDebugMessage);

	if ((vSystemData.vITIPCDig->vAverageEnabled != vOldAverageEnabled) || //if not learning now
		(vSystemData.vITIPCDig->vStructureEnabled != vOldStructureEnabled))
		CheckLearningStatus();

	bool TempInspxProduct = false;
	if (vGlobalCurrentProduct)
	{
		CString *TempProductName = vGlobalCurrentProduct->GetProductName();
		if (TempProductName->GetAt(0) == '~')
			TempInspxProduct = true;
	}

	if (vConfigurationData->vAutoImproveEnabled)
	if (!TempInspxProduct)
	if (vSystemData.vSystemRunMode == cRunningSystemMode)
	if ((!vSystemData.vTakingQuickLearnImages) && (!vSystemData.vITIPCDig->vAverageEnabled) && //if not learning now
		(!vSystemData.vITIPCDig->vStructureEnabled) && (!vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled) && 
		(!vOldAverageEnabled) && (!vOldStructureEnabled))
	if (!vGlobalProcessQuickLearnImagesThread)
	if ((vSystemData.vITIPCDig->vDriftCompensationLocked) || (!vGlobalCurrentProduct->vSetupHistoryStructureCount))
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("STD-Check Auto Improve State-Check",cDebugMessage);

		if (vConfigurationData->vStructureDisableCount < 500)
			vConfigurationData->vStructureDisableCount = 2000;

		if ((vGlobalCurrentProduct->vSetupHistoryStructureCount < vConfigurationData->vStructureDisableCount) || (vGlobalCurrentProduct->vNeedToRelearn)) //if have not done a full learn
		{
			if (vGlobalCurrentProduct->vNeedToRelearn)
				ReportErrorMessage("Product needed to be re-learned--Starting Automatically", cUserChanges,0);

			if (vGlobalCurrentProduct->vSetupHistoryStructureCount >= 100) //do a full learn
			{
				if (vConfigurationData->vStructureDisableCount < 500)
					vConfigurationData->vStructureDisableCount = 2000;

				if (vConfigurationData->vAverageDisableCount < 50)
					vConfigurationData->vAverageDisableCount = 200;

				if (vConfigurationData->vCalibrateBodyTriggerReferenceDisableCount < 5)
					vConfigurationData->vCalibrateBodyTriggerReferenceDisableCount = 20;

				vConfigurationData->vNumberOfQuickLearnImagesToTake = 0; //Turn off quick learn
				vSystemData.vIncludeRejectsInAverageAndStructure = false;
				StartAutoReLearn();
			}
			else
			if (vGlobalCurrentProduct->vSetupHistoryStructureCount >= 10) //do a Quick Learn 100
			{
				vConfigurationData->vNumberOfQuickLearnImagesToTake = 100;
				if (!vConfigurationData->vQuickLearnNumberOfStructureDeltas)
					vConfigurationData->vQuickLearnNumberOfStructureDeltas = 3.0;
				vSystemData.vIncludeRejectsInAverageAndStructure = false;
				StartAutoReLearn();
			}
			else //do a quick learn 10
			{
				vConfigurationData->vNumberOfQuickLearnImagesToTake = 10;
				if (!vConfigurationData->vQuickLearnNumberOfStructureDeltas)
					vConfigurationData->vQuickLearnNumberOfStructureDeltas = 3.0;
				vSystemData.vIncludeRejectsInAverageAndStructure = false;
				StartAutoReLearn();
			}
		}
		else //see if can add improve learn
		if (vSystemData.vITIPCDig->vImproveLearnCount)
		if (vConfigurationData->vAutoImproveNumberToAddToLearn)
		if (vGlobalCurrentProduct->vAddToLearnCount <= vConfigurationData->vAutoImproveNumberToAddToLearn)
		{
			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("STD-Check Auto Improve State-Check Improve Learn",cDebugMessage);

			//8/28/2009 don't make an undo as Auto Improve will wipe out a manual improve undo
			//vSystemData.vITIPCDig->MakeUndoBackupOfLearnStructureFiles(vGlobalCurrentProduct);

			if (vSystemData.vITIPCDig->vProductStructureImage)
			if (vSystemData.vITIPCDig->vProductStructureImage->vGreyImage)
			if (vSystemData.vITIPCDig->vImproveLearnStructureImage)
			if (vSystemData.vITIPCDig->vImproveLearnStructureImage->vGreyImage)
			if (vSystemData.vITIPCDig->vProductContaminant2StructureImage)
			if (vSystemData.vITIPCDig->vProductContaminant2StructureImage->vGreyImage)
			{
				CopyMemory(vSystemData.vITIPCDig->vProductStructureImage->vGreyImage, vSystemData.vITIPCDig->vImproveLearnStructureImage->vGreyImage, vSystemData.vITIPCDig->vOriginalBufferSize);

				vSystemData.vITIPCDig->SaveStructureImageToFile(vGlobalCurrentProduct, false);

				CopyMemory(vSystemData.vITIPCDig->vProductContaminant2StructureImage->vGreyImage,
					vSystemData.vITIPCDig->vImproveLearnContaminant2StructureImage->vGreyImage, vSystemData.vITIPCDig->vOriginalBufferSize);

				if ((vSystemData.vITIPCDig->vProductContaminant2StructureImageWithNoDilation) && (vSystemData.vITIPCDig->vProductContaminant2StructureImageWithNoDilation->vGreyImage))
				{ //current one has dilations in it, so must add to undilated one, then write to file as we only dilate when read from file which is undilated
					CopyMemory(vSystemData.vITIPCDig->vProductContaminant2StructureImageWithNoDilation->vGreyImage, vSystemData.vITIPCDig->vImproveLearnContaminant2StructureImage->vGreyImage,
						vSystemData.vITIPCDig->vOriginalBufferSize);
				}

				vSystemData.vITIPCDig->SaveContaminant2StructureImageToFile(vGlobalCurrentProduct, vSystemData.vITIPCDig->vImproveLearnContaminant2StructureImage, false);
				WORD TempWord = vSystemData.vITIPCDig->vImproveLearnCount + vGlobalCurrentProduct->vAddToLearnCount;

				if ((vSystemData.vITIPCDig->vProductContaminant2StructureImageWithNoDilation) && (vSystemData.vITIPCDig->vProductContaminant2StructureImageWithNoDilation->vGreyImage)) //must read back in to get dilated version
				if ((vGlobalLearnState) && (((vGlobalNormalLearnDilateTimes) && (vGlobalCurrentProduct->vSetupHistoryStructureCount > 19) &&
					(vGlobalCurrentProduct->vSetupHistoryStructureCount != vGlobalCurrentProduct->vSetupHistoryAverageCount)) || 
					((vGlobalQuickLearnDilateTimes) && (vGlobalCurrentProduct->vSetupHistoryStructureCount > 1) &&
					(vGlobalCurrentProduct->vSetupHistoryStructureCount == vGlobalCurrentProduct->vSetupHistoryAverageCount)))) //if the last learn was a normal learn, and not a quick learn
				if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
				{  //end of collecting structure, Save structure image
					vSystemData.vITIPCDig->LoadStructureImagesFromFiles(true, false);
					vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();	
				}

				vSystemData.vITIPCDig->vNumberOfImagesInLastAddToLearn = vSystemData.vITIPCDig->vImproveLearnCount;
				if (TempWord > 65535)
					TempWord = 65535;
				vGlobalCurrentProduct->vAddToLearnCount = (WORD)TempWord;

				ReportErrorMessage("Auto Improve Added To Learn: " + dtoa(vGlobalCurrentProduct->vAddToLearnCount, 0) + ", Product: " + vSystemData.vCurrentProductName, cUserChanges,0);

				SetLearnState();
				vSystemData.vITIPCDig->vImproveLearnCount = 0;
				vSystemData.vImproveLearnTotalContainers = 0;

				WriteConfigurationDataToFile(false); //write to main config file
			}
		}
	}

	if (TempLogStatistics)
	{
		CFileException TempFileException;
		CString TempFilePath = cLogDirectory;
		TempFilePath += "AutoImproveStatistics.CSV";
		LPCTSTR TempFileName = TempFilePath;

		if (ThereIsEnoughMemory(sizeof(CFile), "Auto Improve Statistics"))
		{
			CFile TempStatisticsFile;
			if (TempStatisticsFile)
			if (TempStatisticsFile.Open(TempFileName, (CFile::modeCreate | CFile::modeNoTruncate | CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException))
			if ((TempStatisticsFile.m_hFile) && (TempStatisticsFile.m_hFile != INVALID_HANDLE_VALUE))
			{
				CTime TempTime;
				TempTime = CTime::GetCurrentTime();
				CString TempTimeString = " ";
				TempTimeString = TempTime.Format("%Y-%m-%d %#I:%M:%S%p");//Year, Month, day 12 hour time format with am pm

				CString TempNewString = *vGlobalCurrentProduct->GetProductName();
				double TempPercentAddedToLearn = 0;
				if (vSystemData.vITIPCDig->vAutoImproveStatisticsCountTo100 - vSystemData.vITIPCDig->vAutoImproveStatisticsCountEjectedIn100 > 0)
					TempPercentAddedToLearn = ((double)vSystemData.vITIPCDig->vAutoImproveStatisticsAddedToLearnCount / (double)(vSystemData.vITIPCDig->vAutoImproveStatisticsCountTo100 - vSystemData.vITIPCDig->vAutoImproveStatisticsCountEjectedIn100)) * 100.0;

				TempNewString = TempNewString + "," + TempTimeString + "," + dtoa(vSystemData.vITIPCDig->vAutoImproveStatisticsCount, 0) + ", " + dtoa(TempPercentAddedToLearn, 4) + ", " + 
					dtoa(vSystemData.vITIPCDig->vAutoImproveStatisticsCountTo100, 0) + ", " + 
					dtoa(vSystemData.vITIPCDig->vAutoImproveStatisticsCountEjectedIn100, 0) + ", " + dtoa(vSystemData.vITIPCDig->vAutoImproveStatisticsAddedToLearnCount, 0);

				ULONGLONG TempFileSize = TempStatisticsFile.GetLength();

				vSystemData.vITIPCDig->vAutoImproveStatisticsCountTo100 = 0;
				vSystemData.vITIPCDig->vAutoImproveStatisticsCountEjectedIn100 = 0;
				vSystemData.vITIPCDig->vAutoImproveStatisticsAddedToLearnCount = 0;

				if (TempFileSize < 20)
				{
					CString TempHeaderString = "Inspx Inspx , Product Name, Date/Time, Total Containers, Percent Added To Learn, Counts in Group, Ejected in Group, Added To Learn In Group" + (char)13;
					WORD TempLength = TempHeaderString.GetLength();
					if (TempLength)
					{
						CW2A TempStringToWrite(TempHeaderString);
						TempStatisticsFile.Write(TempStringToWrite, (UINT)TempLength);
					}
				}
				else
				{
					TRY
					{
						TempStatisticsFile.SeekToEnd();
					}
					CATCH_ALL(TempFileException)
					{
						ReportErrorMessage("Failed SeekToEnd of Auto Improve Statistics File", cEMailInspx, 32000);
					}
					END_CATCH_ALL
				}
									
				TempNewString = (char)0x0D + TempNewString;

				WORD TempLength = TempNewString.GetLength();
				if (TempLength)
				{
					CW2A TempStringToWrite(TempNewString);
					TempStatisticsFile.Write(TempStringToWrite, (UINT)TempLength);
				}

				TempStatisticsFile.Close();
			}
		}
	}
}

void CScanTracDlg::StartAutoReLearn()
{
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Enter Start Auto Relearn",cDebugMessage);

	vSystemData.vManualReLearnWhileInspecting = false;

	if ((vConfigurationData->vQuickLearnNumberOfStructureDeltas) &&
		(vConfigurationData->vNumberOfQuickLearnImagesToTake))
	{
		//do quick learn
		if (ThereIsEnoughMemory(10000000 + vSystemData.vITIPCDig->vOriginalBufferSize *
			((vConfigurationData->vNumberOfQuickLearnImagesToTake * 2) + vConfigurationData->vNumberOfLastRejectImages), 
			"Quick Learn Images"))
		{
			vSystemData.vIncludeRejectsInAverageAndStructure = false;
			if (!vConfigurationData->vEnableEjectors)
			if (vSystemData.vPercentRejected > 20)
				vSystemData.vIncludeRejectsInAverageAndStructure = true;

			vSystemData.FreeQuickLearnImages();
			vSystemData.vWrongWidthsDuringLearn = 0;
			vSystemData.vRejectsDuringLearn = 0;
			vSystemData.vWrongBrightnessDuringLearn = 0;
			vSystemData.vImprovingLearn = true;

			vSystemData.vTakingQuickLearnImages = true;
			ReportErrorMessage("Auto Start Quick Learn: " + dtoa(vConfigurationData->vNumberOfQuickLearnImagesToTake,0) + ", Product: " + vSystemData.vCurrentProductName, cUserChanges,0);
		}
		else
			ReportErrorMessage("Not Enough Memory Available for Auto Quick Learn: " + 
				dtoa(vConfigurationData->vNumberOfQuickLearnImagesToTake,0), cEMailInspx,32000);
	}
	else
	//start normal learn
	{
		vSystemData.vIncludeRejectsInAverageAndStructure = false;
		if (!vConfigurationData->vEnableEjectors)
		if (vSystemData.vPercentRejected > 20)
			vSystemData.vIncludeRejectsInAverageAndStructure = true;
		//find reference location if you have one
		if ((!vSystemData.vITIPCDig->HaveLearnImageFile("=Process 2")) || (!vGlobalCurrentProduct->vReferenceRight) || (!vGlobalCurrentProduct->vReferenceTop))
		{
			vSystemData.vITIPCDig->vReferenceRightStandardDeviation = 0;
			vSystemData.vITIPCDig->vReferenceRightAverage = 0;
			vSystemData.vITIPCDig->vReferenceLeftStandardDeviation = 0;
			vSystemData.vITIPCDig->vReferenceLeftAverage = 0;
			vSystemData.vITIPCDig->vReferenceTopStandardDeviation = 0;
			vSystemData.vITIPCDig->vReferenceTopAverage = 0;
			vSystemData.vITIPCDig->vReferenceBottomStandardDeviation = 0;
			vSystemData.vITIPCDig->vReferenceBottomAverage = 0;

			vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceCount = 0;
			vSystemData.vITIPCDig->vCalibrateBodyTriggerReferenceEnabled = true;
			ReportErrorMessage("Start Standard Learn Auto Improve", cAction,0);
			vSystemData.vImprovingLearn = true;
			vOldCalibrateBodyTriggerReferenceEnabled = true;
		}
		else //start learning average
		if (vConfigurationData->vAverageDisableCount)
		{
			vSystemData.vITIPCDig->MakeAverageImageBuffer();
			vSystemData.vWrongWidthsDuringLearn = 0;
			vSystemData.vWrongBrightnessDuringLearn = 0;
			vSystemData.vRejectsDuringLearn = 0;
			vSystemData.vAdjustingBrightnessBeforeLearning = false;
			//if (((vSystemData.vCurrentBrightnessAdjustment > 15) || (vSystemData.vCurrentBrightnessAdjustment < -15)) && (vConfigurationData->vDriftCompensationEnabled))
			//{
			//	ReportErrorMessage("Adjust Brightness Before Re-Learn",cUserChanges,0);
			//	vSystemData.vAdjustingBrightnessBeforeLearning = true;
			//}
			//else
			{
				vSystemData.vITIPCDig->vAverageEnabled = true;
				vOldAverageEnabled = true;
			}
			vSystemData.vImprovingLearn = true;
			ReportErrorMessage("Start Standard Learn Auto ImproveA", cAction,0);
			ReportErrorMessage("Auto Start Standard Learn: " + dtoa(vConfigurationData->vAverageDisableCount + vConfigurationData->vStructureDisableCount,0) + ", Product: " + vSystemData.vCurrentProductName, cUserChanges,0);
		}
	}
}

void CScanTracDlg::SetLearnState()
{
	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Set Learn State",cDebugMessage);
	//reduce learned threshold by 10 X vGlobalLearnState for contaminant bottom
	//zero threshold on Contaminant Top
	//erode histogram by 1 X vGlobalLearnState for contaminant bottom

	//don't check any other settings if it is an Inspx setup product
	bool TempInspxProduct = false;
	if (vGlobalCurrentProduct)
	{
		CString *TempProductName = vGlobalCurrentProduct->GetProductName();
		if (TempProductName->GetAt(0) == '~')
			TempInspxProduct = true;
	}

	if ((!vGlobalCurrentProduct) || (!vConfigurationData->vAutoImproveEnabled) || (TempInspxProduct))
	{
		vGlobalLearnState = 0;  //No Learn desensitization

		if (PasswordOK(cInspxPassword,false))
		if (!vConfigurationData->vAutoImproveEnabled)
			SetDlgItemText(IDC_LearnState, _T("Auto Improve Disabled"));
		else
			SetDlgItemText(IDC_LearnState, _T("Auto Improve: N/A"));

		m_AutoImproving.ShowWindow(SW_HIDE);
		if (!vSystemData.vYellowMessageButtonYellow) //not showing yellow message, so SHOW auto improve message
			SetDlgItemText(IDC_StatusLine, _T(""));
	}
	else
	{
		BYTE TempPreviousLearnState = vGlobalLearnState;
		vGlobalLearnState = 10;  //No Learn
		if (vGlobalCurrentProduct) //if have a current product
		{
			//if (vSystemData.vITIPCDig->vProductContaminant2StructureImage)  //if have learned the product
			if (vSystemData.vITIPCDig->HaveLearnImageFile("=Process 2T"))
			{
				if (vConfigurationData->vStructureDisableCount < 500)
					vConfigurationData->vStructureDisableCount = 2000;

				if ((vConfigurationData->vAutoImproveNumberToAddToLearn) && 
					(vGlobalCurrentProduct->vAddToLearnCount > vConfigurationData->vAutoImproveNumberToAddToLearn / 40) &&
					(vGlobalCurrentProduct->vSetupHistoryStructureCount >= vConfigurationData->vStructureDisableCount))
				{
					if (vGlobalCurrentProduct->vAddToLearnCount > vConfigurationData->vAutoImproveNumberToAddToLearn)
						vGlobalLearnState = 0;  //Learn Complete  Added enough Add to Learns that can run at full sensitivity default 4000
					else
					if (vGlobalCurrentProduct->vAddToLearnCount > vConfigurationData->vAutoImproveNumberToAddToLearn / 2)
						vGlobalLearnState = 1;  //default 2000 add to learns
					else
					if (vGlobalCurrentProduct->vAddToLearnCount > vConfigurationData->vAutoImproveNumberToAddToLearn / 4)
						vGlobalLearnState = 2;  //default 1000 add to learns
					else
					if (vGlobalCurrentProduct->vAddToLearnCount > vConfigurationData->vAutoImproveNumberToAddToLearn / 8)
						vGlobalLearnState = 3;  //default 500 add to learns
					else
					if (vGlobalCurrentProduct->vAddToLearnCount > vConfigurationData->vAutoImproveNumberToAddToLearn / 12)
						vGlobalLearnState = 4;  //default 333 add to learns
					else
					if (vGlobalCurrentProduct->vAddToLearnCount > vConfigurationData->vAutoImproveNumberToAddToLearn / 20)
						vGlobalLearnState = 5;  //default 200 add to learns
					else
					//if (vGlobalCurrentProduct->vAddToLearnCount > vConfigurationData->vAutoImproveNumberToAddToLearn / 40)
						vGlobalLearnState = 6; //default 100 add to learns
				}
				else
				if (vGlobalCurrentProduct->vSetupHistoryAverageCount == vGlobalCurrentProduct->vSetupHistoryStructureCount)//setup with quick learn
				{
					if (vGlobalCurrentProduct->vSetupHistoryStructureCount >= vConfigurationData->vStructureDisableCount)
						vGlobalLearnState = 7;  
					else
					if (vGlobalCurrentProduct->vSetupHistoryStructureCount >= 100)
						vGlobalLearnState = 8;  
					else
					if (vGlobalCurrentProduct->vSetupHistoryStructureCount >= 10)
						vGlobalLearnState = 9;  
				}
				else//setup with standard learn
				{
					if (vGlobalCurrentProduct->vSetupHistoryStructureCount >= vConfigurationData->vStructureDisableCount)
						vGlobalLearnState = 7;  
					else
					if (vGlobalCurrentProduct->vSetupHistoryStructureCount >= 100)
						vGlobalLearnState = 8;  
					else
					if (vGlobalCurrentProduct->vSetupHistoryStructureCount >= 10)
						vGlobalLearnState = 9;  
				}
			}
			if (vGlobalLearnState)
			if (vSystemData.vITIPCDig->vProductHistogramImage)  //if have learned the product
				//need to erode the histogram to reduce inspection area
			{
				BYTE TempHistogramThreshold = vGlobalCurrentProduct->vHistogramThreshold;
				BYTE TempHistogramLowerThreshold = vGlobalCurrentProduct->vHistogramLowerThreshold;
				if (!TempHistogramLowerThreshold)
					TempHistogramLowerThreshold = vGlobalLearnState * 5;

				BYTE TempHistogramDilateTimes = vGlobalCurrentProduct->vHistogramDilateTimes;

				//erode the mask the approprate extra number of times for the Improve state
				if (TempHistogramDilateTimes < 6)
					TempHistogramDilateTimes = TempHistogramDilateTimes + vGlobalLearnState;  //if small or no erode do double
				else
					TempHistogramDilateTimes = TempHistogramDilateTimes + (vGlobalLearnState / 2);//if large erode only do single

				if ((vSystemData.vITIPCDig->vProductAverageImage) && (vSystemData.vITIPCDig->vProductAverageImage->vGreyImage))
				{
					vSystemData.vITIPCDig->SaveThresholdImageInHistogram(vGlobalCurrentProduct, TempHistogramThreshold,
						vSystemData.vITIPCDig->vProductAverageImage->vGreyImage, TempHistogramDilateTimes, TempHistogramLowerThreshold);
				}
			}
			CString TempText = " ";
			if (vGlobalCurrentProduct->vAddToLearnCount)
				TempText = " (" + dtoa(vGlobalCurrentProduct->vAddToLearnCount,0) + ")";
			if (PasswordOK(cInspxPassword,false))
				SetDlgItemText(IDC_LearnState,"Improve State: " + dtoa((10 - vGlobalLearnState) * 10,0) + "%" + TempText);
		}
		else
			SetDlgItemText(IDC_LearnState, _T(""));

		if (vLastLearnState != vGlobalLearnState)
		{
			vLastLearnState = vGlobalLearnState;
			if ((vLastLearnState) && (vLastLearnState != 255)) //colors for Improving Learn - Do not test contaminants indicator
			{
				ReportErrorMessage("Auto Improve State " + dtoa((10 - vLastLearnState) * 10,0) + "% done, product: " + vSystemData.vCurrentProductName,cUserChanges,0);
				m_AutoImproving.ShowWindow(SW_SHOW);
				if (!vSystemData.vYellowMessageButtonYellow) //not showing yellow message, so SHOW auto improve message
				{
					CString TempText = "-";
					TempText.LoadString(IDS_ImprovingLearnDonottestsmallcontaminants);
					SetDlgItemText(IDC_StatusLine, TempText);
				}
			}
			else
			{
				ReportErrorMessage("Auto Improve complete for product: " + vSystemData.vCurrentProductName,cUserChanges,0);
				m_AutoImproving.ShowWindow(SW_HIDE);
				if (!vSystemData.vYellowMessageButtonYellow) //not showing yellow message, so make sure auto improve message is cleared
					SetDlgItemText(IDC_StatusLine, _T(""));

				//must reload the structure image to remove dilations if doing dilations
				if (vGlobalNormalLearnDilateTimes)
				if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
				{  //end of collecting structure, Save structure image
					vSystemData.vITIPCDig->LoadStructureImagesFromFiles(false, false);
					vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();	
				}
			}
		}
	}
}

void CScanTracDlg::CheckForCorrectMemorySize()
{
	if (!vGlobalDemoMode)
	if (vGlobalPCRunningWindowsXP <= cWindowsXP)
	{
		//only 3 gig allowed in 32 bit Windows XP
		//if (vGlobalPCRunningWindowsXP == cWindowsXP)
		//MEMORYSTATUSEX statex;
		//statex.dwLength = sizeof (statex);
		//bool TempReadOK = GlobalMemoryStatusEx(&statex);
		//if (!TempReadOK)
		//	ReportErrorMessage("Failed to Read amount of RAM usage", cEMailInspx, 32000);

		//reserve 16 megabytes at the top of memory for the frame grabber to use
		MEMORYSTATUS memstat;
		memstat.dwLength = sizeof (memstat);
		GlobalMemoryStatus(&memstat);

		DWORD TempAmountOfMemory = memstat.dwTotalPhys;
		TempAmountOfMemory = TempAmountOfMemory / 1000000;
		CString TempBootIniStringToAdd(" /MAXMEM=240");
/*
		if (TempAmountOfMemory > 4000) //set for 4 gigabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=4080";
		else//set for 3.5 gig RAM
		if (TempAmountOfMemory > 3500) //set for 3.5 gigabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=3568";
		else //set for 3 gig RAM
		if (TempAmountOfMemory > 3000) //set for 3 gigabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=3056";
		else //set for 2.5 gig RAM
		if (TempAmountOfMemory > 2500) //set for 2.5 gigabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=2544";
		else //set for 2 gig RAM
		if (TempAmountOfMemory > 2000) //set for 2 gigabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=2032";
		else //set for 1.5 gig RAM
		*/
		if (TempAmountOfMemory > 1500) //set for 1.5 gigabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=1520";
		else //set for 1 gig RAM
		if (TempAmountOfMemory > 1000) //set for 1 gigabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=1008";
		else
		if (TempAmountOfMemory > 490) //set for 512 Megabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=496";
		else
		if (TempAmountOfMemory > 235) //set for 256 Megabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=240";
		else//set for 128 Megabytes RAM
			TempBootIniStringToAdd = " /MAXMEM=112";

		TRY
		{
			CFile TempBootIniFile;
			CFileStatus TempFileStatus; 
			CFile::GetStatus(_T("C:\\Boot.Ini"),TempFileStatus);

			if (TempFileStatus.m_attribute & CFile::readOnly)
			{
				TempFileStatus.m_attribute = TempFileStatus.m_attribute & 0xFFFE;
				TempFileStatus.m_mtime = 0; 
				CFile::SetStatus(_T("C:\\Boot.Ini"),TempFileStatus);
			}

			if (TempBootIniFile.Open(_T("C:\\Boot.Ini"), (CFile::modeReadWrite | CFile::shareDenyNone), NULL))
			{
				if ((TempBootIniFile.m_hFile) && (TempBootIniFile.m_hFile != INVALID_HANDLE_VALUE))
				{
					char TempChars[1000];
					UINT TempLength = TempBootIniFile.Read(TempChars,1000);
					CString TempString = TempChars;
					UINT TempStringLength = TempString.GetLength();
					WORD TempPosition = TempString.Find(TempBootIniStringToAdd,0);

					if (TempPosition > 5000) //did not find correct string, maybe memory size is smaller, so change it
					{
						//remove any old MaxMem statements
						WORD TempPositionMaxMem = TempString.Find(_T("MAXMEM"),0);
						while (TempPositionMaxMem < 5000)
						{
							WORD TempPositionMaxMemEnd = TempString.Find(_T("\n"),TempPositionMaxMem);
							if (TempPositionMaxMemEnd < 5000)
							{
								TempString.Delete(TempPositionMaxMem - 2, 1 + TempPositionMaxMemEnd - TempPositionMaxMem);
								TempPositionMaxMem = TempString.Find(_T("MAXMEM"),TempPositionMaxMem);
							}
							else
							{
								TempString.Delete(TempPositionMaxMem - 2,
									1 + TempPositionMaxMemEnd - TempString.GetLength());
								TempPositionMaxMem = 10000;
							}
						}
						//set new max mem statements
						TempPosition = TempString.Find(_T("WINNT="),0);
						if (TempPosition > 1000)
							TempPosition = TempString.Find(_T("winnt ="),0);
						if (TempPosition > 1000)
							TempPosition = TempString.Find(_T("Windows XP"),0);
						if (TempPosition > 1000)
							TempPosition = TempString.Find(_T("XP"),0);
						if (TempPosition > 1000)
							TempPosition = TempString.Find(_T("xp"),0);

						while (TempPosition < 1000)
						{
							TempPosition = TempString.Find(_T("\n"),TempPosition);
							if (TempPosition > 1000)
							{
								TempString = TempString + TempBootIniStringToAdd;
							}
							else
							{
								TempString.Insert(TempPosition - 1,TempBootIniStringToAdd);
								TempPosition = TempString.Find(_T("WINNT="),TempPosition);
								if (TempPosition > 1000)
									TempPosition = TempString.Find(_T("winnt ="),TempPosition);
							}
						}

						TRY
						{
							TempBootIniFile.SeekToBegin();
						}
						CATCH_ALL(TempFileException)
						{
							ReportErrorMessage("Failed SeekToEnd of INI file", cEMailInspx, 32000);
						}
						END_CATCH_ALL

						CW2A TempStringToWrite(TempString);
						TempBootIniFile.Write(TempStringToWrite, TempString.GetLength());
						TempBootIniFile.Flush();

						//changed registry keys
						CRegKey TempRegistryKey;
						LONG TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\mvcntp\\Parameters"));

						DWORD TempWord = 0;
						TempRegistryKey.QueryDWORDValue(_T("ITEX Pool PhysAddr"),TempWord);

						if (TempAmountOfMemory < 132) //set for 128 Megabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"), 0x7000000);
						else
						if (TempAmountOfMemory < 270) //set for 256 Megabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"), 0xf000000);
						else
						if (TempAmountOfMemory < 550) //set for 512 Megabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"), 0x1f000000);
						else //set for 1 gig RAM
						if (TempAmountOfMemory < 1100) //set for 1 gigabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"), 0x3f000000);
						else //set for 1.5 gig RAM
						//if (TempAmountOfMemory < 1650) //set for 1.5 gigabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue(_T("ITEX Pool PhysAddr"), 0x5f000000);
						/*
						else //set for 2 gig RAM
						if (TempAmountOfMemory < 2200) //set for 2 gigabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0x7f000000);
						else //set for 2.5 gig RAM
						if (TempAmountOfMemory < 2700) //set for 2.5 gigabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0x9f000000);
						else //set for 3 gig RAM
						if (TempAmountOfMemory < 3200) //set for 3 gigabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0xbf000000);
						else //set for 3.5 gig RAM
						if (TempAmountOfMemory < 3700) //set for 3 gigabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0xdf000000);
						else //set for 4 gig RAM
						//if (TempAmountOfMemory < 4200) //set for 3 gigabytes RAM
							TempErrorCode = TempRegistryKey.SetDWORDValue("ITEX Pool PhysAddr", 0xff000000);
							*/

						TempErrorCode = TempRegistryKey.SetDWORDValue(_T("Max Buffer Size (bytes)"), 0x1000000);
						TempBootIniFile.Close();

#ifdef _DEBUG
						CYesNoDialog TempYesNoDialog;
						TempYesNoDialog.vNoticeText = "Amount of Memory Changed. Has: " + dtoa(TempAmountOfMemory,0) + 
							"\nRelease Version would Reboot now,\nThis is a development version,\nDo you want to Reboot Now?";
						TempYesNoDialog.vYesButtonText = "Reboot Now!";
						TempYesNoDialog.vNoButtonText = "Reboot Later";
						TempYesNoDialog.vQuestionType = cConfirmQuestion;
						int TempResult = TempYesNoDialog.DoModal();
						if (TempResult == IDOK)
							SystemShutDown(cReboot);
#else
						if (vGlobalFBWFEnable == 1)
						{
							CNoticeDialog TempNoticeDialog;
							CString TempText = "Warning-Memory has gone down since previous boot.\nHard Drive Protection is Enabled.\nShut Down Computer and install 1 Gig of RAM\nor call Inspx.\nNew Amount of Memory: " +
								dtoa(TempAmountOfMemory,0);
							TempNoticeDialog.vNoticeText = TempText;
							TempNoticeDialog.vType = cInformationMessage;
							//TempNoticeDialog.vAutoClose = 30000;
							TempNoticeDialog.DoModal();
						}
						else
						{
							CNoticeDialog TempNoticeDialog;
							CString TempText = "Warning-Memory has gone down since previous boot.\nCall for Service.\nThe Computer will reboot automatically\nif you close this window\nto update memory settings.\nNew Amount of Memory: " +
								dtoa(TempAmountOfMemory,0);
							TempNoticeDialog.vNoticeText = TempText;
							TempNoticeDialog.vType = cInformationMessage;
							//TempNoticeDialog.vAutoClose = 30000;
							TempNoticeDialog.DoModal();
							SystemShutDown(cReboot);
						}
#endif
					}  //end of memory amount changed
					TempBootIniFile.Close();
				}
				else
					ReportErrorMessage("Could not open Boot.Ini to update Memory Maximum",cEMailInspx,32000);
			}
			else
				ReportErrorMessage("Could not open Boot.Ini to update Memory Maximum",cEMailInspx,32000);
		}
		CATCH_ALL(TempException)
		{
			ReportErrorMessage("Could not access Boot.Ini to update Memory Maximum",cEMailInspx,32000);
		}
		END_CATCH_ALL
		//must write /MAXMEM=240 or 16 meg less then there is into Boot.Ini
		//winnt = "Windows NT Embedded Version 4.00" /NODEBUG /NoSerialMice:COM2
	}
}

//enum {FileNameNotFound,FileNameFoundOnce,FileNameFoundTwice};
void CScanTracDlg::CheckHardDrives()
{
	vSystemData.vPrimaryDrive = "";
	vSystemData.vBackupDrive = "";
	unsigned int TempFoundNamePri = FileNameNotFound;
	unsigned int TempFoundNameBackup = FileNameNotFound;
	BOOL FlagMessageNoBackup = false;
	BOOL FlagMessageNoPrimary = false;

	CFileStatus TempFileStatus;
	CString TempPrimaryDriveString = "0_Primary_Hard_Drive";
	LPTSTR TempPrimaryDriveBuffer = TempPrimaryDriveString.GetBuffer(TempPrimaryDriveString.GetLength());

	for (BYTE TempDriveLoop = 0; TempDriveLoop < 10; TempDriveLoop++)
	{
		TempPrimaryDriveString = ":\\0_Primary_Hard_Drive";
		TempPrimaryDriveString = char(67 + TempDriveLoop) + TempPrimaryDriveString;
		TempPrimaryDriveBuffer = TempPrimaryDriveString.GetBuffer(TempPrimaryDriveString.GetLength());
		if ((CFile::GetStatus(TempPrimaryDriveBuffer, TempFileStatus)))
		{
			// looking for a primary drive
			if (TempFoundNamePri == FileNameNotFound)
			{
				TempFoundNamePri = FileNameFoundOnce;		// set true first time find primary drive
				vSystemData.vPrimaryDrive = char(67 + TempDriveLoop);	// save first primary drive found letter
			}
			else
			{	// if second primary drive found, flag, drop out of loop
				TempFoundNamePri = FileNameFoundTwice;
				vSystemData.vBackupDrive = char(67 + TempDriveLoop);
				TempDriveLoop = 20;
			}
		}
	}

	if ((TempFoundNamePri == FileNameNotFound) || (TempFoundNamePri == FileNameFoundOnce))	//TempFoundNamePri != FileNameFoundTwice
	{
		CString TempBackupDriveString = "0_Backup_Hard_Drive";
		LPTSTR TempBackupDriveBuffer = TempBackupDriveString.GetBuffer(TempBackupDriveString.GetLength());
		for (BYTE TempDriveLoop = 0; TempDriveLoop < 10; TempDriveLoop++)
		{
			TempBackupDriveString = ":\\0_Backup_Hard_Drive";
			TempBackupDriveString = char(67 + TempDriveLoop) + TempBackupDriveString;
			TempBackupDriveBuffer = TempBackupDriveString.GetBuffer(TempBackupDriveString.GetLength());
			if ((CFile::GetStatus(TempBackupDriveBuffer, TempFileStatus)))
			{
				if (TempFoundNameBackup == FileNameNotFound)
				{
					vSystemData.vBackupDrive = char(67 + TempDriveLoop);
					TempFoundNameBackup = FileNameFoundOnce;
				}
				else
				{
					TempFoundNameBackup = FileNameFoundTwice;
					vSystemData.vPrimaryDrive = vSystemData.vBackupDrive;
					vSystemData.vBackupDrive = char(67 + TempDriveLoop);
					TempDriveLoop = 20;
				}
			}
		}
	}

	// look for two pris or two secs.  If have two backups or two primarys, send yellow message and change file name correctly
	if (TempFoundNamePri == FileNameFoundTwice) 
	{
		if (IfSameScanTracDirectories(vSystemData.vPrimaryDrive,vSystemData.vBackupDrive))	//kjh only do if scantrac directories are identical	
		{
			ReportErrorMessage("Both Drives Named Primary, Renaming second drive to Backup",cEMailInspx,32000);

			CString TempFolderName = vSystemData.vBackupDrive + ":\\0_Primary_Hard_Drive";
			if (!RemoveDirectory(TempFolderName))
			{
				ReportErrorMessage("Error-Removal of Backup Drive Folder, 0_Primary_Hard_Drive ,Failed",cEMailInspx,32000);
				ReportErrorMessage("Error-Removal of Backup Drive Folder, 0_Primary_Hard_Drive ,Failed",cEMailMaintenance,0);
			}
			else	// create primary name only if delete of backup name succeeded
			{
				TempFolderName = vSystemData.vBackupDrive + ":\\0_Backup_Hard_Drive";
				if (!CreateDirectory(TempFolderName,NULL))
				{
					ReportErrorMessage("Error-Creating Backup Drive Folder, 0_Backup_Hard_Drive, Failed",cEMailInspx,32000);
					ReportErrorMessage("Error-Creating Backup Drive Folder, 0_Backup_Hard_Drive, Failed",cEMailMaintenance,32000);
				}
				else
				{
					ReportErrorMessage("Both Drives Named Primary, Changed second drive to Backup",cEMailInspx,32000);
					ReportErrorMessage("Both Drives Named Primary, Changed second drive to Backup",cEMailMaintenance,0);
				}
			}
		}
		else
		{
			ReportErrorMessage("Both Drives Named Primary, Drives not Identical",cEMailInspx,32000);
			ReportErrorMessage("Both Drives Named Primary, Drives not Identical",cEMailMaintenance,0);
			FlagMessageNoBackup = true;
			vSystemData.vBackupDrive = "";
		}
	}
	else	
	if (TempFoundNameBackup == FileNameFoundTwice)  
	{ // rename first drive which is currently  ":\\0_Backup_Hard_Drive"  to ":\\0_Primary_Hard_Drive" 
			// vSystemData.vPrimaryDrive	
		if (IfSameScanTracDirectories(vSystemData.vPrimaryDrive,vSystemData.vBackupDrive)) //kjh only do if scantrac directories are identical
		{
			ReportErrorMessage("Both Drives Named Backup, Renaming first drive to Primary",cEMailInspx,32000);

			CString TempFolderName = vSystemData.vPrimaryDrive + ":\\0_Backup_Hard_Drive";
			if (!RemoveDirectory(TempFolderName))
			{
				ReportErrorMessage("Error-Removal of Primary Drive Folder,0_Backup_Hard_Drive ,Failed",cEMailInspx,32000);
				ReportErrorMessage("Error-Removal of Primary Drive Folder,0_Backup_Hard_Drive ,Failed",cEMailMaintenance,0);
			}
			else	// create primary name only if delete of backup name succeeded
			{
				TempFolderName = vSystemData.vPrimaryDrive + ":\\0_Primary_Hard_Drive";
				if (!CreateDirectory(TempFolderName,NULL))
				{
					ReportErrorMessage("Error-Creating Primary Drive Folder, 0_Primary_Hard_Drive, Failed",cEMailInspx,32000);
					ReportErrorMessage("Error-Creating Primary Drive Folder, 0_Primary_Hard_Drive, Failed", cEMailMaintenance,0);
				}
				else
				{
					ReportErrorMessage("Both Drives Named Backup, Changed first drive to Primary",cEMailInspx,32000);
					ReportErrorMessage("Both Drives Named Backup, Changed first drive to Primary",cEMailMaintenance,0);
				}
			}
		}
		else
		{
			ReportErrorMessage("Both Drives Named Backup, Drives not Identical",cEMailInspx,32000);
			ReportErrorMessage("Both Drives Named Backup, Drives not Identical",cEMailMaintenance,0);
			FlagMessageNoPrimary = true;
			vSystemData.vBackupDrive = vSystemData.vPrimaryDrive;
			vSystemData.vPrimaryDrive = "";
		}
	}
	else
	//if (!vSystemData.vPrimaryDrive.GetLength())
	//if (vSystemData.vBackupDrive.GetLength())
	if (((vSystemData.vPrimaryDrive == "") && (vSystemData.vBackupDrive == "C")) || FlagMessageNoPrimary)
	{
		if (!vGaveHardDriveFailedMessageToday)
		{
			vGaveHardDriveFailedMessageToday = true;
			ReportErrorMessage("Replace Primary Hard Drive ASAP, Running on Backup",cEMailInspx,32000);
			ReportErrorMessage("Replace Primary Hard Drive ASAP, Running on Backup",cEMailMaintenance,0);

			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\nReplace Primary Hard Drive ASAP\n\nRunning on Backup Hard Drive";
			//TempNoticeDialog.vNoticeText = TempNoticeDialog.vNoticeText + "\n Primary Hard Drive: None";
			//TempNoticeDialog.vNoticeText = TempNoticeDialog.vNoticeText + "\n Backup Hard Drive: C";
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}
		SetInterlockStatus();
	}
	else
	//if (vSystemData.vPrimaryDrive.GetLength())
	//if (!vSystemData.vBackupDrive.GetLength())
	if (((vSystemData.vPrimaryDrive == "C") && (vSystemData.vBackupDrive == "")) || FlagMessageNoBackup)
	{
		if (!vGaveHardDriveFailedMessageToday)
		{
			vGaveHardDriveFailedMessageToday = true;
			ReportErrorMessage("No Backup Hard Drive in ScanTrac, Replace ASAP",cEMailInspx,32000);
			ReportErrorMessage("No Backup Hard Drive in ScanTrac, Replace ASAP",cEMailMaintenance,0);

			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\nNo Backup Hard Drive in ScanTrac\n\nReplace ASAP";
			//TempNoticeDialog.vNoticeText = TempNoticeDialog.vNoticeText + "\n Primary Hard Drive: C";
			//TempNoticeDialog.vNoticeText = TempNoticeDialog.vNoticeText + "\n Backup Hard Drive: None";
			TempNoticeDialog.vType = cErrorMessage;
			TempNoticeDialog.DoModal();
		}

		SetInterlockStatus();
	}
	else
		//if you have a drive marked primary or backup, but not the other, make label problem message
	if (((vSystemData.vPrimaryDrive.GetLength()) || (vSystemData.vBackupDrive.GetLength())) &&
		//((vSystemData.vPrimaryDrive != "C") || (!vSystemData.vBackupDrive.GetLength())))
		(vSystemData.vPrimaryDrive != "C"))
	{
		ReportErrorMessage("Primary/Backup Hard Drive Label Problem",cEMailInspx,32000);
		ReportErrorMessage("Primary/Backup Hard Drive Label Problem",cEMailMaintenance,0);
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\nPrimary/Backup Hard Drive Label Problem\nCheck Hard Drive Labels";
		TempNoticeDialog.vNoticeText = TempNoticeDialog.vNoticeText + "\n Primary Drive: " + vSystemData.vPrimaryDrive;
		TempNoticeDialog.vNoticeText = TempNoticeDialog.vNoticeText + "\n Backup Drive: " + vSystemData.vBackupDrive;
		TempNoticeDialog.vType = cErrorMessage;
		TempNoticeDialog.DoModal();
		SetInterlockStatus();
	}
	else
		SetInterlockStatus();
}

//kjh compare c: and d: drives, are the scantrac directories identical ?
BOOL CScanTracDlg::IfSameScanTracDirectories(CString cDirectory1Check,CString cDirectory2Check)
{
	BOOL Answer = false;
	CString cCompareDirectory1 = " ";
	CString cCompareDirectory2 = " ";
	CString cCompareDirectory3 = " ";
	CString cCompareDirectory4 = " ";
	CString cCompareDirectory5 = " ";
	CString cCompareDirectory6 = " ";
	CString AllFilesCheck = "\\ScanTrac*.*";
	CString vOutputTextString = " ";
	CString TempString = " ";
	WIN32_FIND_DATA CheckFileData1;
	WIN32_FIND_DATA CheckFileData2;
	WIN32_FIND_DATA CheckFileData3;
	WIN32_FIND_DATA CheckFileData4;
	WIN32_FIND_DATA CheckFileData5;
	WIN32_FIND_DATA CheckFileData6;
	CString TempCString1 = " ";
	CString TempCString2 = " ";
	CString TempCString3 = " ";
	CString TempCString4 = " ";
	CString TempCString5 = " ";
	CString TempCString6 = " ";

//	vSystemData.vPrimaryDrive;
//	vSystemData.vBackupDrive;
	cCompareDirectory1 = cDirectory1Check + ":" + AllFilesCheck ;
	cCompareDirectory2 = cDirectory2Check + ":" + AllFilesCheck ;

//		vOutputTextString = "Compare Directory - " + cCompareDirectory1 + " and Directory - " + cCompareDirectory2 + "\n" ;

	LPTSTR DirectoryName1 = cCompareDirectory1.GetBuffer(cCompareDirectory1.GetLength());
	LPTSTR DirectoryName2 = cCompareDirectory2.GetBuffer(cCompareDirectory2.GetLength());

	HANDLE hFind1 = FindFirstFile(DirectoryName1, &CheckFileData1);
	HANDLE hFind2 = FindFirstFile(DirectoryName2, &CheckFileData2);

	if ((hFind1 == INVALID_HANDLE_VALUE) || (hFind2 == INVALID_HANDLE_VALUE)) // No files in directory
	{
		ReportErrorMessage("Error-Compare Failed, No Files in Directory",cEMailInspx,32000);
//			vOutputTextString += "Compare Failed, No Files in Directory" ;
	}
	else 
	{
		BOOL ContinueCheck = true ;
		do
		{
			TempCString1 = CheckFileData1.cFileName;
			TempCString2 = CheckFileData2.cFileName;
//#ifdef debugDirectoryCompare
//				vOutputTextString += "\n";
//				vOutputTextString += TempCString1;
//				vOutputTextString += "\t";
//				vOutputTextString += TempCString2;
//#endif
			// if file exists, compare file // note want to compare directories.
			if ((!TempCString1.IsEmpty()) /*&& (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))*/
						&& (TempCString1.GetAt(0)!='.') && (TempCString1.GetAt(0)!='~'))
			{
				// compare filename and directory
				if (TempCString1 != TempCString2)
				{
					ReportErrorMessage(TempCString1 + " not equal to: " + TempCString2, cEMailInspx,32000); 
					ContinueCheck = false ;
				}
				// if a scantrac directory check two levels down
				else if ((CheckFileData1.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
								 (CheckFileData2.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (TempCString1.Find(_T("ScanTrac"))>=0) )
				{
					cCompareDirectory3 = cDirectory1Check + ":\\" + TempCString1 + AllFilesCheck ;
					cCompareDirectory4 = cDirectory2Check  + ":\\" + TempCString2 + AllFilesCheck ;

			//		vOutputTextString = "Compare Directory - " + cCompareDirectory1 + " and Directory - " + cCompareDirectory2 + "\n" ;

					LPTSTR DirectoryName3 = cCompareDirectory3.GetBuffer(cCompareDirectory3.GetLength());
					LPTSTR DirectoryName4 = cCompareDirectory4.GetBuffer(cCompareDirectory4.GetLength());

					HANDLE hFind3 = FindFirstFile(DirectoryName3, &CheckFileData3);
					HANDLE hFind4 = FindFirstFile(DirectoryName4, &CheckFileData4);

					if (DirectoryName3 != _T("ScanTracACPowerMonitor"))
					if ((hFind3 == INVALID_HANDLE_VALUE) || (hFind4 == INVALID_HANDLE_VALUE)) 
					{
							// No files in directory, done
					}
					else 
					{
						// ContinueCheckLevel = true ;	set above
						do
						{
							TempCString3 = CheckFileData3.cFileName;
							TempCString4 = CheckFileData4.cFileName;
//#ifdef debugDirectoryCompare
//								vOutputTextString += "\n";
//								vOutputTextString += TempCString3;
//								vOutputTextString += "\t";
//								vOutputTextString += TempCString4;
//#endif
							// if file exists, compare file // note want to compare directories.
							if ((!TempCString3.IsEmpty()) /*&& (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))*/
										&& (TempCString3.GetAt(0)!='.') && (TempCString3.GetAt(0)!='~'))
							{
								// compare filename and directory
								if (TempCString3 != TempCString4)
								{
									ReportErrorMessage(TempCString3 + " not equal to: " + TempCString4, cEMailInspx,32000); 
									ContinueCheck = false ;
								}
								else if ((CheckFileData3.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && 
												 (CheckFileData4.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) && (TempCString3.Find(_T("ScanTrac"))>=0) )	
								{
									cCompareDirectory5 = cDirectory1Check + ":\\" + TempCString1 + "\\" + TempCString3 + AllFilesCheck ;
									cCompareDirectory6 = cDirectory2Check +  ":\\" + TempCString2 + "\\" + TempCString4 + AllFilesCheck ;
									
									LPTSTR DirectoryName5 = cCompareDirectory5.GetBuffer(cCompareDirectory5.GetLength());
									LPTSTR DirectoryName6 = cCompareDirectory6.GetBuffer(cCompareDirectory6.GetLength());

									HANDLE hFind5 = FindFirstFile(DirectoryName5, &CheckFileData5);
									HANDLE hFind6 = FindFirstFile(DirectoryName6, &CheckFileData6);

									if ((hFind5 == INVALID_HANDLE_VALUE) || (hFind6 == INVALID_HANDLE_VALUE)) 
									{
											// No files in directory, done
									}

									else 
									{
										// ContinueCheckLevel = true ;	set above
										do
										{
											TempCString5 = CheckFileData5.cFileName;
											TempCString6 = CheckFileData6.cFileName;
//#ifdef debugDirectoryCompare
//													vOutputTextString += "\n";
//													vOutputTextString += TempCString5;
//													vOutputTextString += "\t";
//													vOutputTextString += TempCString6;
//#endif
											if ((!TempCString5.IsEmpty()) /*&& (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))*/
														&& (TempCString5.GetAt(0)!='.') && (TempCString5.GetAt(0)!='~'))
											{
												// compare filename and directory
												if (TempCString5 != TempCString6)
												{
													ReportErrorMessage(TempCString5 + " not equal to: " + TempCString6, cEMailInspx,32000); 
													ContinueCheck = false;
												}
											}
										}
										while (ContinueCheck && (FindNextFile(hFind5,&CheckFileData5)) && (FindNextFile(hFind6,&CheckFileData6))) ;
									}
									FindClose(hFind5);
									FindClose(hFind6);
								}
							}
						}
						while (ContinueCheck && (FindNextFile(hFind3,&CheckFileData3)) && (FindNextFile(hFind4,&CheckFileData4))) ;
					}
					FindClose(hFind3);
					FindClose(hFind4);
				}
			}
		}
		while (ContinueCheck && (FindNextFile(hFind1,&CheckFileData1)) && (FindNextFile(hFind2,&CheckFileData2))) ;
		Answer = ContinueCheck;
	}
	FindClose(hFind1);
	FindClose(hFind2);

/*
#ifdef debugDirectoryCompare
//			output results to a help screen
	CHelpDialog * IHelpDialog;
	IHelpDialog = new(CHelpDialog);
	IHelpDialog->vHelpContext = 16;
	IHelpDialog->vHelpType = 0;
	IHelpDialog->vWindowType = cTextWindow;
	IHelpDialog->vLocalSystemData = &vSystemData;
	IHelpDialog->vMainWindowPointer = this;
	IHelpDialog->vLocalConfigurationData = vConfigurationData;
	IHelpDialog->vProductPointer = vGlobalCurrentProduct;

	IHelpDialog->vTitleString = "Compare Directories Information";
	IHelpDialog->vTextString = vOutputTextString;
	int TempResult = IHelpDialog->DoModal();
	delete IHelpDialog;
	if (TempResult == 10)
	{
		//Main Menu button pressed
		Sleep(1); //is the equivelent of a yeild statement;
		CDialog::EndDialog(TempResult);
	}
#endif		
*/
	return (Answer);
}


void CScanTracDlg::StartCopyAllScanTracFoldersToBackupHardDrive()
{
	vBackupHardDisk = false;

	if (vSystemData.vPrimaryDrive == "C")
	if (vSystemData.vBackupDrive.GetLength())
	if (vSystemData.vACPowerOn)
	if (!vGlobalBackupHardDriveThread)  //not already backing up
	{
		//start the Backup Hard Drive Thread
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Backup Hard Drive Thread",cDebugMessage);
		//thread lowest priority
		if (vSystemData.vMemoryOK)
		{
			vGlobalBackupHardDriveThread = (CBackupHardDriveThread *)AfxBeginThread(RUNTIME_CLASS(CBackupHardDriveThread), THREAD_PRIORITY_IDLE, 0, CREATE_SUSPENDED);
				//THREAD_PRIORITY_LOWEST
				//THREAD_PRIORITY_BELOW_NORMAL
				//THREAD_PRIORITY_NORMAL
		}
		if (!vGlobalBackupHardDriveThread)
		{
			ReportErrorMessage("Error-Could Not Create Process Quick Learn Thread A", cEMailInspx,32000); 
		}
		else
		{
			ReportErrorMessage("--Info Only, Start Backup Hard Drive", cAction,0);
			ReportErrorMessage("Started Backup Hard Drive Thread", cWriteToLog,0);
			vGlobalBackupHardDriveThread->vLocalSystemData = &vSystemData;
			vGlobalBackupHardDriveThread->vLocalConfigurationData = vConfigurationData;
			vGlobalBackupHardDriveThread->vMainWindowPointer = this;
			m_DoNotShutOffPower.ShowWindow(SW_SHOW);

			//kjh priority
			/*
			TempAfinity = (AFFINITYMASK_BACKUP_HARDDRIVE & vGlobalSystemAffinityMask);
			if ((TempAfinity != 0) && (vGlobalSystemAffinityMask >= 0x0F))
			{
				if (vGlobalSystemAffinityMask == 0xFF)
					DWORD TempOriginalAffinityMask = ::SetThreadAffinityMask(vGlobalProcessQuickLearnImagesThread->m_hThread, 0x04);
				else
				if (::SetThreadAffinityMask(vGlobalBackupHardDriveThread->m_hThread,TempAfinity))
				{
					vReplyOK |= 0x08;
				}
			}
			*/
			vGlobalBackupHardDriveThread->ResumeThread();

			//m_TriggerIndicator.ShowWindow(SW_SHOW);
			//SetDlgItemText(IDC_TriggerIndicator,"Backup HD");
		}
	}
}

void CScanTracDlg::EndCopyAllScanTracFoldersToBackupHardDrive()
{ 
	vGlobalBackupHardDriveThread = NULL;

	int TimerResult = SetTimer(vClearSlippedTimerHandle, 10,NULL); //clear Backup HD Indicator
	if (!TimerResult)
		ReportErrorMessage("Error-Slipped Timer Failed",cEMailInspx,32000);

	ReportErrorMessage("End Backup Hard Drive", cWriteToLog,0);
	ReportErrorMessage("--Info Only, Finish Backup Hard Drive", cAction,0);

	RECT TempRect;
	m_DoNotShutOffPower.GetWindowRect(&TempRect);
	m_DoNotShutOffPower.ShowWindow(SW_HIDE);
	this->InvalidateRect(&TempRect);
}

/*
void CScanTracDlg::BackupRegistryToBackupHardDrive()
{  //backup setup files and registry to backup hard drive
	//backup Registry
	CFileStatus TempFileStatus;
	CString TempRegistryFolderName = "C:\\WinNT\\System32\\Config";
	if (CFile::GetStatus(TempRegistryFolderName, TempFileStatus))
	{
		CString TempFolderName = vSystemData.vBackupDrive + ":\\WinNT";
		CreateDirectory(TempFolderName, NULL);
		TempFolderName = TempFolderName + ":\\System32";
		CreateDirectory(TempFolderName, NULL);
		CopyFolderToBackupHardDrive("WinNT\\System32\\Config");
	}
	else
	{  //maybe running XP
		TempRegistryFolderName = "C:\\Windows\\System32\\Config";
		if (CFile::GetStatus(TempRegistryFolderName, TempFileStatus))
		{
			CString TempFolderName = vSystemData.vBackupDrive + ":\\Windows";
			CreateDirectory(TempFolderName, NULL);
			TempFolderName = TempFolderName + "\\System32";
			CreateDirectory(TempFolderName, NULL);
			CopyFolderToBackupHardDrive("Windows\\System32\\Config");
		}
	}
}
*/
void CScanTracDlg::MoveFoldersToNewFormatIfNeeded()
{
	CString TempFolderName = "C:\\Images";
	DeleteFilesInDirectory(TempFolderName);
	RemoveDirectory(TempFolderName);

	TempFolderName = "C:\\America Online 5.0b";
	DeleteFilesInDirectory(TempFolderName);
	RemoveDirectory(TempFolderName);

	if (vGlobalPCRunningWindowsXP == cWindowsNT)
	{
		TempFolderName = "C:\\InetPub";
		DeleteFilesInDirectory(TempFolderName);
		RemoveDirectory(TempFolderName);
	}

	CFileStatus TempFileStatus;
	CString TempSourceFolderName = "C:\\ATI";
	if (CFile::GetStatus(TempSourceFolderName, TempFileStatus))
	{
		CFile TempFile;
		CString TempNewFolderName = "C:\\ATI Installer for MSI Motherboard";
		if (!CFile::GetStatus(TempNewFolderName, TempFileStatus))
			TempFile.Rename(TempSourceFolderName,TempNewFolderName);

		CString TempNewName = "C:\\Install Files\\ATI Installer for MSI Motherboard";
		if (!MoveFile(TempNewFolderName, TempNewName))
			ReportErrorMessage("Failed to Move Folder: " + TempNewFolderName + " to " + TempNewName, cEMailInspx, 32000);
	}

	TempFolderName = "C:\\ScanTrac Automatic Backups";
	if (!CFile::GetStatus(TempFolderName, TempFileStatus))
	{
		if (!CreateDirectory(TempFolderName,NULL))
			ReportErrorMessage("Failed to Create Directory: " + TempFolderName, cEMailInspx, 32000);
		else
		{
			CString TempFolderToMoveName = "C:\\ScanTracSetupBackup*.*";
			
			if (CFile::GetStatus(TempFolderName, TempFileStatus))
			{
				WIN32_FIND_DATA FindFileData;
				HANDLE hFind;
				hFind = FindFirstFile(TempFolderToMoveName, &FindFileData);

				if (hFind != INVALID_HANDLE_VALUE) 
				{
					CString TempSourceFileOrFolderName = "C:\\";
					TempSourceFileOrFolderName = TempSourceFileOrFolderName + FindFileData.cFileName;
					CString TempDestinationFileOrFolderName = TempFolderName + "\\" + FindFileData.cFileName;
					if (TempSourceFileOrFolderName.GetAt(TempSourceFileOrFolderName.GetLength() - 1) != '.')
					{
						if (!MoveFile(TempSourceFileOrFolderName, TempDestinationFileOrFolderName))
							ReportErrorMessage("Failed to Move Folder: " + TempSourceFileOrFolderName + " to " + TempDestinationFileOrFolderName, cEMailInspx, 32000);

  //LPCTSTR lpExistingFileName, // file name
  //LPCTSTR lpNewFileName       // new file name
					}
					while (FindNextFile(hFind,&FindFileData))
					{
						TempSourceFileOrFolderName = "C:\\";
						TempSourceFileOrFolderName = TempSourceFileOrFolderName + FindFileData.cFileName;
						TempDestinationFileOrFolderName = TempFolderName + "\\" + FindFileData.cFileName;
						if (!MoveFile(TempSourceFileOrFolderName, TempDestinationFileOrFolderName))
							ReportErrorMessage("Failed to Move Folder: " + TempSourceFileOrFolderName + " to " + TempDestinationFileOrFolderName, cEMailInspx, 32000);
					}
					FindClose(hFind);
				}
			}
		}
	}

	CString TempDestinationFileName = "C:\\ScanTrac Software Updates";
	CreateDirectory(TempDestinationFileName,NULL);

	CString TempDestinationFolderName = "C:\\ScanTrac Manual Backups";
	CreateDirectory(TempDestinationFolderName,NULL);

	CString TempSourceFolder = "C:\\ScanTrac\\Backup";
	if (CFile::GetStatus(TempSourceFolder, TempFileStatus))
	{
		CFileStatus TempFileStatus;
		CString TempFolderToMoveName = "C:\\ScanTrac\\Backup\\*.*";
		
		WIN32_FIND_DATA FindFileData;
		HANDLE hFind;
		hFind = FindFirstFile(TempFolderToMoveName, &FindFileData);

		if (hFind != INVALID_HANDLE_VALUE) 
		{
			CString TempSourceFileOrFolderName = TempSourceFolder + "\\" + FindFileData.cFileName;
			CString TempNewDestinationFileName = TempDestinationFileName + "\\" + FindFileData.cFileName;
			CString TempNewDestinationFolderName = TempDestinationFolderName + "\\" + FindFileData.cFileName;
			if (TempSourceFileOrFolderName.GetAt(TempSourceFileOrFolderName.GetLength() - 1) != '.')
			{  //if a folder move to ScanTrac Manual Backups
				if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					if (!MoveFile(TempSourceFileOrFolderName, TempNewDestinationFolderName))
						ReportErrorMessage("Failed to Move Folder: " + TempSourceFileOrFolderName + " to " + TempNewDestinationFolderName, cEMailInspx, 32000);
				}
				else
				{  //if a file, move to ScanTrac Software Updates
					if (!MoveFile(TempSourceFileOrFolderName, TempNewDestinationFileName))
						ReportErrorMessage("Failed to Move File: " + TempSourceFileOrFolderName + " to " + TempNewDestinationFileName, cEMailInspx, 32000);
				}
			}
			while (FindNextFile(hFind,&FindFileData))
			{
				TempSourceFileOrFolderName = TempSourceFolder + "\\" + FindFileData.cFileName;
				TempNewDestinationFileName = TempDestinationFileName + "\\" + FindFileData.cFileName;
				TempNewDestinationFolderName = TempDestinationFolderName + "\\" + FindFileData.cFileName;
				if (TempSourceFileOrFolderName.GetAt(TempSourceFileOrFolderName.GetLength() - 1) != '.')
				{  //if a folder move to ScanTrac Manual Backups
					if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
					{
						if (!MoveFile(TempSourceFileOrFolderName, TempNewDestinationFolderName))
							ReportErrorMessage("Failed to Move Folder: " + TempSourceFileOrFolderName + " to " + TempNewDestinationFolderName, cEMailInspx, 32000);
					}
					else
					{  //if a file, move to ScanTrac Software Updates
						if (!MoveFile(TempSourceFileOrFolderName, TempNewDestinationFileName))
							ReportErrorMessage("Failed to Move File: " + TempSourceFileOrFolderName + " to " + TempNewDestinationFileName, cEMailInspx, 32000);
					}
				}
			}
			FindClose(hFind);
		}
		RemoveDirectory(TempSourceFolder);
	}
	CString TempTestString = vConfigurationData->vScanTracRejectedImagesDirectory;
	if (TempTestString.MakeUpper() == "D:\\SCANTRACREJECTEDIMAGES\\")
	{
		CString TempFolder = "C:\\ScanTracRejectedImages";  //if saving rejects to D drive, can't have folder on C drive, or nightly backup will delete all the files
		RemoveDirectory(TempFolder);
	}
}

void CScanTracDlg::CheckInterlocksIn200MS()
{
	if ((vGlobalMonoBlockXRayPort) && ((vGlobalMonoBlockXRayPort->vHadLowCurrent) || (vGlobalMonoBlockXRayPort->vHadLowVoltage)))
		SetTimer(vCheckInterlocksIn200MSTimerHandle,2000,NULL);
	else
		SetTimer(vCheckInterlocksIn200MSTimerHandle,200,NULL);
}

void CScanTracDlg::ConvertImagesTo16Bit()
{
	CString TempImageDirectory = "C:\\ScanTrac Test Images\\";
	CYesNoDialog TempYesNoDialog;
	CString TempDirectory = vConfigurationData->vScanTracImagesDirectory;
	TempDirectory = "\n\nConvert all images from 8 to 16 bit\nin the " + 
		TempImageDirectory + " directory?";
	TempYesNoDialog.vNoticeText = TempDirectory;
	TempYesNoDialog.vQuestionType = cConfirmQuestion;
	int TempResult = TempYesNoDialog.DoModal();
	//if user said OK delete files in log directory 
	if (TempResult == IDOK)
	{
		CString TempFileType = "*.*";
		WIN32_FIND_DATA FindFileData;
		HANDLE hFind;

		CString TempString = TempImageDirectory + TempFileType;
		LPTSTR TempDirectoryName = TempString.GetBuffer(TempString.GetLength());

		hFind = FindFirstFile(TempDirectoryName, &FindFileData);

		if (hFind == INVALID_HANDLE_VALUE) 
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nNo files in image directory to convert";
			TempNoticeDialog.vType = cInformationMessage;
			TempNoticeDialog.DoModal();
		} 
		else 
		{
			CString TempString = " ";
			CString TempDirectory = TempImageDirectory;
			TempString = TempDirectory + FindFileData.cFileName;
			CString TempFileNameString = TempDirectory + FindFileData.cFileName;
			if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
			//if (TempFileNameString.GetAt(TempString.GetLength() - 1) != '.')
			{
				ConvertImageFrom8to16bit(TempFileNameString);
			}
			while (FindNextFile(hFind,&FindFileData))
			{
				TempString = TempDirectory + FindFileData.cFileName;
				CString TempFileNameString = TempDirectory + FindFileData.cFileName;
				if (!(FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
					ConvertImageFrom8to16bit(TempFileNameString);
			}
		}
		FindClose(hFind);
	}
}

void CScanTracDlg::ConvertImageFrom8to16bit(CString TempFileNameString)
{

	LPTSTR TempString = TempFileNameString.GetBuffer(TempFileNameString.GetLength());
	int TempHeight = 0;
	int TempWidth = 0;
	int TempBitsPerPixel = 0;
	int TempType = 0;

	//read in 8 bit per pixel image file
	CFileStatus TempFileStatus;
	if (CFile::GetStatus(TempFileNameString, TempFileStatus))
	{
		CW2A TempFileNameString2(TempString);		
		Erflag TempError = im_file_get_size(TempFileNameString2, IM_BMP_FILE, &TempHeight, &TempWidth, &TempBitsPerPixel, &TempType);
		if (TempError == IM_OK)
		if (TempBitsPerPixel == 8)
		{
			DWORD TempImageSize = TempHeight * TempWidth;
			if (ThereIsEnoughMemory(TempImageSize + sizeof(Image), "Temp Convert Image"))
			{
				Image *TempInputImage;
				TempInputImage = im_create(IM_BYTE, TempHeight, TempWidth);

				if (TempInputImage)
				if (TempInputImage->pix)
				{
					FillMemory(TempInputImage->pix, TempImageSize, 255);
					TempError = im_file_read(TempInputImage, TempFileNameString2, IM_AUTO_FILE);
					if (TempError == IM_OK)
					{
						//convert 8 bit image to 16 bit image
						if (ThereIsEnoughMemory(TempImageSize * 2 + sizeof(Image), "Temp Convert Image"))
						{
							Image *TempOutputImage;
							TempOutputImage = im_create(IM_WORD, TempHeight, TempWidth);

							if (TempOutputImage)
							if (TempOutputImage->pix)
							{
								FillMemory(TempOutputImage->pix, TempImageSize, 0xFFFF);

								BYTE *TempBytePointer = TempInputImage->pix;
								WORD *TempWordPointer = (WORD *)TempOutputImage->pix;

								for (DWORD TempLoop = 0; TempLoop < TempImageSize; TempLoop++)
								{
									if (*TempBytePointer == 255)
										*TempWordPointer = 0xFFF0;
									else
										*TempWordPointer = (*TempBytePointer << 8) + ((rand() % 16) << 4);
									TempWordPointer++;
									TempBytePointer++;
								}

								//write 16 bit image to file

								TempFileNameString.Delete(TempFileNameString.GetLength() - 4,4);
								TempFileNameString.Insert(TempFileNameString.GetLength(), _T("b.RAW"));
								LPTSTR TempString1 = TempFileNameString.GetBuffer(MAX_PATH); //TempString.GetLength());

								CW2A TempFileNameString2(TempString1);
								CImgFile *TempImageFile=IfxCreateImgFile(TempFileNameString2);
								if (TempImageFile) 
								if ((TempOutputImage) && (TempOutputImage->pix))
								{
									if (!TempImageFile->WriteFile(TempOutputImage->pix, TempHeight, TempWidth, 16))
									{
										ReportErrorMessage("Failed to Write Converted Image to File: " + TempFileNameString, cEMailMaintenance,0);
									}
								}
								if (TempImageFile) 
									delete TempImageFile;
							}
							if (TempOutputImage)
								im_delete(TempOutputImage);
						}
					}
				}
				if (TempInputImage)
					im_delete(TempInputImage);
			}
		}
	}
}

void CScanTracDlg::CalculatePipelineEncoderAndTrigger()
{
	if (vGlobalCurrentProduct)
	if (((vConfigurationData->vScanTracType == cLegatoScanTrac) || (vConfigurationData->vScanTracType == cFermataScanTrac)) ||//pipeline ScanTrac
		((vConfigurationData->vContinuousFeedEncoderRate) && (vConfigurationData->vContinuousFeedContainerRate) && (vSystemData.vInAutoSetup))) //continuous feed and setting up the product
	{
		if ((vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
		{
			vConfigurationData->vContinuousFeedEncoderRate = 0;  //in bulk mode must use real encoder
			vConfigurationData->vContinuousFeedContainerRate = 0;
			ReportErrorMessage("Bulk Mode-Disable Continuous Feed Encoder and Trigger", cAction,0);
		}
		else
		{
			vConfigurationData->vContinuousFeedEncoderRate = CalculateMaximumEncoderRate(vGlobalCurrentProduct->vXRayIntegrationTime);

			//vConfigurationData->vContinuousFeedEncoderRate = (WORD)(vConfigurationData->vContinuousFeedEncoderRate * 0.85);

			WORD TempTargetEncoderRate = vConfigurationData->vContinuousFeedEncoderRate;

			ReportErrorMessage("Original Calculate Continuous Feed Encoder Rate: " + dtoa(vConfigurationData->vContinuousFeedEncoderRate,0), cAction,0);

			WORD Temp100KCounts = (WORD)(((1.0/(double)vConfigurationData->vContinuousFeedEncoderRate) * 100000.0) - 1.0);

			if (Temp100KCounts)
			{
				WORD TempEncoderValueWillGet = 100000 / Temp100KCounts;

				while (TempEncoderValueWillGet > TempTargetEncoderRate)
				{
					vConfigurationData->vContinuousFeedEncoderRate = vConfigurationData->vContinuousFeedEncoderRate - 2;

					if (!vConfigurationData->vContinuousFeedEncoderRate)
						ReportErrorMessage("Error-Pipe Calc-vContinuousFeedEncoderRate = 0, would cause crash", cEMailInspx, 32000);
					else
						Temp100KCounts = (WORD)(((1.0 / (double)vConfigurationData->vContinuousFeedEncoderRate) * 100000.0) - 1.0);

					if (!Temp100KCounts)
						ReportErrorMessage("Error-Pipe Calc-Temp100KCounts = 0, would cause crash", cEMailInspx, 32000);
					else
						TempEncoderValueWillGet = 100000 / Temp100KCounts;
				}
			}
			ReportErrorMessage("Set Continuous Feed Encoder Rate: " + dtoa(vConfigurationData->vContinuousFeedEncoderRate,0), cAction,0);

			if (!vGlobalPixelsPerUnit)
				ReportErrorMessage("Error-Pipe Calc-vGlobalPixelsPerUnit = 0, would cause crash", cEMailInspx, 32000);
			else
			if (!vGlobalCurrentProduct->vProductImageWidth)
				ReportErrorMessage("Error-Pipe Calc-vGlobalCurrentProduct->vProductImageWidth = 0, would cause crash", cEMailInspx, 32000);
			else
				vConfigurationData->vContinuousFeedContainerRate = (WORD)(1.1 * (60.0 * vConfigurationData->vContinuousFeedEncoderRate / (vGlobalCurrentProduct->vProductImageWidth * vGlobalPixelsPerUnit)));
		}

		if (vSystemData.vInAutoSetup)//change rates if in setup
		{
			SendConveyorOnOffToUController(1);
			TurnSimulatedEncoderOn();
			Sleep(500);
			TurnSimulatedContainersOn();
		}
	}
}

void CScanTracDlg::CheckInspectionNamesForOldInspections(bool TempGiveWarning)
{
	vSystemData.vProductHasAnOldInspection = false;
	if ((vGlobalCurrentProduct) && (!CurrentProductIsInspxProduct()))
	//if (vSystemData.vITIPCDig->vShowOnlyRealImages)
	{
		BYTE TempNumberOfOldContaminantInspections = 0;
		BYTE TempNumberOfOldGlassInspections = 0;
		BYTE TempNumberOfOldJarBottomInspections = 0;

		for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
		if (vGlobalCurrentProduct->vInspection[TempLoop])
		if (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType != cVoidInspection)
		{
			CString TempName = vGlobalCurrentProduct->vInspection[TempLoop]->vName;
			BYTE TempLength = TempName.GetLength();
			if (TempLength)
			{
				BYTE TempPosition = TempName.Find(_T("Contaminant Top"), 0);

				if ((vGlobalCurrentProduct->vInspection[TempLoop]->vAddStructure) && (vGlobalCurrentProduct->vInspection[TempLoop]->vSubtractAverage))
				{
					TempNumberOfOldContaminantInspections++;
					vSystemData.vProductHasAnOldInspection = true;
				}
				//else
				//{
				//	if (TempPosition < 255)
				//	{
				//		TempNumberOfOldContaminantInspections++;
				//		vSystemData.vProductHasAnOldInspection = true;
				//	}

				//	TempPosition = TempName.Find("Contaminant", 0);
				//	if ((TempPosition < 255) && (TempPosition == TempLength - 11))
				//	{
				//		TempNumberOfOldContaminantInspections++;
				//		vSystemData.vProductHasAnOldInspection = true;
				//	}
				//}

				TempPosition = TempName.Find(_T("Glass"), 0);
				if ((TempPosition < 255) && (TempPosition == TempLength - 5))
				{
					TempNumberOfOldGlassInspections++;
					vSystemData.vProductHasAnOldInspection = true;
				}

				TempLength = TempName.GetLength();
				TempPosition = TempName.Find(_T("Jar Bottom"), 0);
				if (TempPosition < 255)
				{
					TempNumberOfOldJarBottomInspections++;
					vSystemData.vProductHasAnOldInspection = true;
				}
			}
		}
		if (TempGiveWarning)
		{
			if (TempNumberOfOldContaminantInspections)
			{
				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\nThis product has " + dtoa(TempNumberOfOldContaminantInspections,0) + 
					" old style Contaminant inspection(s).\nPlease replace with better Foreign Material inspection(s).";
				TempNoticeDialog.vType = cInformationMessage;
				TempNoticeDialog.DoModal();
				ReportErrorMessage("Product: " + *vGlobalCurrentProduct->GetProductName() + " has " + 
					dtoa(TempNumberOfOldContaminantInspections,0) + " old style Contaminant inspection(s)", cAction,0);
			}
			if (TempNumberOfOldGlassInspections)
			{
				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\nThis product has " + dtoa(TempNumberOfOldGlassInspections,0) + 
					" old style Glass inspection(s).\nPlease replace with better Glass In Body inspection(s).";
				TempNoticeDialog.vType = cInformationMessage;
				TempNoticeDialog.DoModal();
				
				ReportErrorMessage("Product: " + *vGlobalCurrentProduct->GetProductName() + " has " + 
					dtoa(TempNumberOfOldGlassInspections,0) + " old style Glass inspection(s)", cAction,0);
			}
			if (TempNumberOfOldJarBottomInspections)
			{
				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\nThis product has " + dtoa(TempNumberOfOldJarBottomInspections,0) + 
					" old style Jar Bottom inspection(s).\nPlease replace with better Glass on Bottom inspection(s).";
				TempNoticeDialog.vType = cInformationMessage;
				TempNoticeDialog.DoModal();
				
				ReportErrorMessage("Product: " + *vGlobalCurrentProduct->GetProductName() + " has " + 
					dtoa(TempNumberOfOldJarBottomInspections,0) + " old style Jar Bottom inspection(s)", cAction,0);
			}
		}
		SetInterlockStatus();
		UpdateClearYellowMessageButton();
	}
}

void CScanTracDlg::WriteARejectToTheHardDrive()
{
	BOOL TempShadowWriteCheck;
	CString TempShadowCurrentFileName;
	CString TempShadowFolderName;
	CImgFile *TempImageFile;
	Image *TempImage;
	BOOL CreatedFileForvRejectedImageDirectory;
	CString TempFileName;
	CString TempCurrentFileTime;
	BYTE *TempPointer;

	TempShadowCurrentFileName = "";
	TempShadowFolderName = "";
	TempShadowWriteCheck = false;		// if actually write a file for reject images, and file is not to c: or d:, write backup to c: or d:
	CreatedFileForvRejectedImageDirectory = false;

	CString TempDriveName = vConfigurationData->vScanTracRejectedImagesDirectory.GetAt(0);
	if ((TempDriveName != "C") && (TempDriveName != "D"))	// added to see if using C or D local drives
	{
		TempShadowWriteCheck = true;
	}

	TRY
	{
		if (vConfigurationData->vWriteRejectsToFiles)
		if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vLogThisReject)
		{
			if (vConfigurationData->vScanTracRejectedImagesDirectory.GetLength() > 5)
			if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage)
			{
				TempCurrentFileTime = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vTime.Format("%Y-%m-%d-%H-%M-%S");
				TempFileName = vSystemData.vCurrentProductName;
				TempFileName.Replace(_T("-"), _T(" "));
				TempFileName = TempFileName + "-" + TempCurrentFileTime;
				TempShadowCurrentFileName = TempFileName;

				CString TempFolderName = vConfigurationData->vScanTracRejectedImagesDirectory + vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vTime.Format("%Y-%m-%d");
				LPTSTR TempStringSSDP = TempFolderName.GetBuffer(TempFolderName.GetLength());
				if (vGlobalHaveDDrive)
					TempShadowFolderName =  cRejectedImagesDirectoryDDrive + vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vTime.Format("%Y-%m-%d");
				else
					TempShadowFolderName =  cRejectedImagesDirectoryCDrive + vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vTime.Format("%Y-%m-%d");
				CFileStatus TempFileStatus;
				if (TempFolderName.GetLength() > 4)
				if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
					CreateDirectory(TempFolderName,NULL);

				if (TempCurrentFileTime == WriteARejectToTheHardDriveLastTimeString)
					WriteARejectToTheHardDriveLastMultipleSecondFileCount++;
				else
					WriteARejectToTheHardDriveLastMultipleSecondFileCount = 1;

				TempFileName = TempFileName + "-" + dtoa(WriteARejectToTheHardDriveLastMultipleSecondFileCount,0);
				TempShadowCurrentFileName = TempShadowCurrentFileName + "-" + dtoa(WriteARejectToTheHardDriveLastMultipleSecondFileCount,0);

				WriteARejectToTheHardDriveLastTimeString = TempCurrentFileTime;

				if ((vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection < vGlobalCurrentProduct->vNumberOfInspections) &&
					(vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection >= 0) &&
					(vGlobalCurrentProduct->vInspection[vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection]))
				{
					CString TempInspectionName = vGlobalCurrentProduct->vInspection[vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection]->vName;
					TempInspectionName.Replace(_T("-"), _T(" "));
					TempFileName = TempFileName + "-" + TempInspectionName;
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-" + TempInspectionName;
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cEjectSlippedContainer)
				{
					TempFileName = TempFileName + "-Ejected Slipped";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Ejected Slipped";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cPassSlippedContainer)
				{
					TempFileName = TempFileName + "-Passed Slipped";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Passed Slipped";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cEjectContainerWrongWidth)
				{
					TempFileName = TempFileName + "-Ejected Wrong Width";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Ejected Wrong Width";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cPassContainerWrongWidth)
				{
					TempFileName = TempFileName + "-Passed Wrong Width";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Passed Wrong Width";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cEjectContainerOnTop)
				{
					TempFileName = TempFileName + "-Ejected Wrong Height";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Ejected Wrong Height";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cPassContainerOnTop)
				{
					TempFileName = TempFileName + "-Passed Wrong Height";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Passed Wrong Height";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cEjectContainerWrongHeight)
				{
					TempFileName = TempFileName + "-Ejected Wrong Height";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Ejected Wrong Height";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cEjectContainerOnConveyorStop)
				{
					TempFileName = TempFileName + "-Ejected Conveyor Stop";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Ejected Conveyor Stop";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cPassContainerOnConveyorStop)
				{
					TempFileName = TempFileName + "-Passed Conveyor Stop";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Passed Conveyor Stop";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cEjectEmptySlippedContainer)
				{
					TempFileName = TempFileName + "-Ejected Empty Slipped";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Ejected Empty Slipped";
				}
				else
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset == cTestEject)
				{
					TempFileName = TempFileName + "-Ejected Test Eject";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Ejected Test Eject";
				}
				else
				if ((vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset >= cEjectAuxilaryDetectorOffset) &&
					(vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection + cEjectInspectionOffset <= cMaximumRejectReason))
				{
					CString TempNumber = dtoa(vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vContainerEjectInspection - cEjectAuxilaryDetectorOffset + 1,0);
					TempFileName = TempFileName + "-Ejected Auxiliary Detector " + TempNumber;
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Ejected Auxiliary Detector " + TempNumber;
				}
				else
				{
					TempFileName = TempFileName + "-Good";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Good";
				}

				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vEjectorsDisabled)
				{
					TempFileName = TempFileName + "-Disabled";
					TempShadowCurrentFileName = TempShadowCurrentFileName + "-Disabled";
				}

				TempFileName = TempFolderName + "\\" + TempFileName + ".BMP";
				TempShadowCurrentFileName = TempShadowFolderName + "\\" + TempShadowCurrentFileName + ".BMP";

				BYTE TempLength = TempFileName.GetLength();
				LPTSTR TempString1 = TempFileName.GetBuffer(TempLength);

				CW2A TempFileNameString(TempString1);
				TempImageFile = IfxCreateImgFile(TempFileNameString);
				if (TempImageFile) 
				{
					//find the amount of free space
					CString TempDriveName = vConfigurationData->vScanTracRejectedImagesDirectory.GetAt(0);
					TempDriveName = TempDriveName + ":";

					double TempTotalBytesAvailable = CheckDiskSpaceFree(TempDriveName);

					TempTotalBytesAvailable = TempTotalBytesAvailable / 1000000;  //convert to mega bytes

					if ((TempTotalBytesAvailable == 0) && (vGlobalCountErrorMsgPossibleDirectoryNotAvailableSent == 0))
					{
						ReportErrorMessage("Error-Could Not Write Image, Server Not Available: " + TempFileName, cEMailMaintenance, 0);
						vGlobalCountErrorMsgPossibleDirectoryNotAvailableSent++;
					}
					else if ((TempTotalBytesAvailable != 0) && (TempTotalBytesAvailable < 10))  //if have more than 10 megabytes free space
					{
						ReportErrorMessage("Error-Could Not Write Reject Image to File: " + TempFileName, cEMailMaintenance, 0);
					}
					else if (TempTotalBytesAvailable > 10)//if have more than 10 megabytes free space
					{
						//need to rotate the image and copy it to save in file and save in file with red box
						//Image *TempImage = NULL;
						TempImage = NULL;
						if (ThereIsEnoughMemory(vSystemData.vITIPCDig->vOriginalBufferSize * 2, "Image to Write To Disk Buffer"))
						{
							TempImage = im_create(IM_BYTE, vSystemData.vITIPCDig->vOriginalBufferSizeX, 
								vSystemData.vITIPCDig->vOriginalBufferSizeY * 2);
						}

						if ((TempImage) && (TempImage->pix))
						{
							BYTE *TempPointer = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage;
							for (DWORD TempLoop = 0; TempLoop < vSystemData.vITIPCDig->vOriginalBufferSize; TempLoop++)
							{
								if (*TempPointer == 0)
									*TempPointer = 1;
								TempPointer++;
							}

							CopyMemory(TempImage->pix, vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage, 
								vSystemData.vITIPCDig->vOriginalBufferSize);

							CopyMemory(TempImage->pix + vSystemData.vITIPCDig->vOriginalBufferSize, 
								vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage, 
								vSystemData.vITIPCDig->vOriginalBufferSize);


							if ((vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxWidth) &&
								(vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxHeight))
							{
								//TempScaleX = (double)vSystemData.vITIPCDig->vMainDisplayImageSizeX / (double)vSystemData.vITIPCDig->vAquisitionSizeY;
								//TempScaleY = (double)vSystemData.vITIPCDig->vMainDisplayImageSizeY / (double)vSystemData.vITIPCDig->vOriginalBufferSizeX;

								int TempCornerX = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxCornerX;

								int TempCornerY = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxCornerY;

								if (TempCornerY >= vSystemData.vITIPCDig->vOriginalBufferSizeY)
									TempCornerY = vSystemData.vITIPCDig->vOriginalBufferSizeY - 1;

								if (TempCornerX >= vSystemData.vITIPCDig->vOriginalBufferSizeX)
									TempCornerX = vSystemData.vITIPCDig->vOriginalBufferSizeX - 1;

								int TempHeight = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxHeight;
								int TempWidth = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxWidth;

								if (TempHeight >= vSystemData.vITIPCDig->vOriginalBufferSizeX)
									TempHeight = vSystemData.vITIPCDig->vOriginalBufferSizeX - 1;

								if (TempWidth + TempCornerY + 2 > vSystemData.vITIPCDig->vOriginalBufferSizeY)
									TempWidth = vSystemData.vITIPCDig->vOriginalBufferSizeY - TempCornerY - 2;

								BYTE *TempDestinationPointer = TempImage->pix + TempCornerX +
									(TempCornerY * vSystemData.vITIPCDig->vOriginalBufferSizeX);

								BYTE *TempMaxDestinationPointer = TempImage->pix - 1 + vSystemData.vITIPCDig->vOriginalBufferSize;

								if (TempDestinationPointer > TempMaxDestinationPointer)
									TempDestinationPointer = TempMaxDestinationPointer;

								//draw Bottom Horizontal line
								BYTE *TempPointer = TempDestinationPointer;
								for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
								if (TempPointer <= TempMaxDestinationPointer)
								{
									*TempPointer = 0; //set left pixel red
									TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
								}

								TempPointer = TempDestinationPointer + 1;
								for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
								if (TempPointer <= TempMaxDestinationPointer)
								{
									*TempPointer = 0; //set left pixel red
									TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
								}

								//draw Top horizontal line
								TempPointer = TempDestinationPointer + TempHeight;

								while (TempPointer < TempImage->pix + vSystemData.vITIPCDig->vOriginalBufferSizeX)
									TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

								for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
								if (TempPointer <= TempMaxDestinationPointer)
								{
									*TempPointer = 0; //set left pixel red
									TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
								}

								TempPointer = TempDestinationPointer - 1 + TempHeight;

								while (TempPointer < TempImage->pix)
									TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

								for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
								if (TempPointer <= TempMaxDestinationPointer)
								{
									*TempPointer = 0; //set left pixel red
									TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
								}

								//draw left vertical line
								TempPointer = TempDestinationPointer;
								for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
								if (TempPointer >= TempImage->pix)
									*TempPointer++ = 0; //set left pixel red

								TempPointer = TempDestinationPointer + 1;
								if (TempPointer > TempMaxDestinationPointer)
									TempPointer = TempMaxDestinationPointer;
								for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
								if (TempPointer >= TempImage->pix)
									*TempPointer++ = 0; //set left pixel red

								//draw Right vertical line
								TempPointer = TempDestinationPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX * TempWidth;
								if (TempPointer > TempMaxDestinationPointer)
									TempPointer = TempMaxDestinationPointer;
								for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
								if (TempPointer >= TempImage->pix)
									*TempPointer++ = 0; //set left pixel red

								TempPointer = TempDestinationPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX * TempWidth + 1;
								if (TempPointer > TempMaxDestinationPointer)
									TempPointer = TempMaxDestinationPointer;
								for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
								if (TempPointer >= TempImage->pix)
									*TempPointer++ = 0; //set left pixel red
							}

							RotateImage90Degrees(TempImage,1);

#ifdef IFC59Driver
							if (!TempImageFile->WriteFile(TempImage->pix,
								vSystemData.vITIPCDig->vOriginalBufferSizeY * 2, vSystemData.vITIPCDig->vOriginalBufferSizeX,
								(WORD)vSystemData.vITIPCDig->vBitsPerPixel, IFFCL_GRAY, IFFCOMP_DEFAULT, NULL))
							{
								ReportErrorMessage("Failed to Write Reject Image to File", cEMailMaintenance, 0);
							}
							else
							{
								CreatedFileForvRejectedImageDirectory = true;
							}
#else
							if (!TempImageFile->WriteFile(TempImage->pix,
								vSystemData.vITIPCDig->vOriginalBufferSizeY * 2, vSystemData.vITIPCDig->vOriginalBufferSizeX,
								(WORD)vSystemData.vITIPCDig->vBitsPerPixel, IFFCL_GRAY, IFFCOMP_DEFAULT))
							{
								ReportErrorMessage("Failed to Write Reject Image to File", cEMailMaintenance, 0);
							}
#endif
						}
						if (!((CompareBit(vGlobalShadowImages,cShadowRejectedImageBit)) && (TempShadowWriteCheck)))
						{
							if (TempImage)  // delete if dont need again
								im_delete(TempImage);
						}
					}

					// check after write to other drive ??, check now
						//check how much hard drive space is free,  keep atlease 100 meg, 400 meg if C:
					// if drive is not available (TempTotalBytesAvailable == 0)
					if ((TempTotalBytesAvailable > 0) && ((TempTotalBytesAvailable < 500) || ((TempTotalBytesAvailable < 1000) && (TempDriveName == "C:"))))
					{
						ReportErrorMessage("Hard Disk Space for Reject Images Getting Low-delete 2 files",cWriteToLog,0);

						//delete oldest two reject image files
						WIN32_FIND_DATA FindFileData;
						HANDLE hFind;

						CString TempString = vConfigurationData->vScanTracRejectedImagesDirectory;
						TempString = TempString + "*.*";
						LPTSTR TempDirectoryName = TempString.GetBuffer(TempString.GetLength());
						CString TempFolder = vConfigurationData->vScanTracRejectedImagesDirectory;
						CString TempOldestFolder = "99999999";

						hFind = FindFirstFile(TempDirectoryName, &FindFileData);

						bool TempLookingForOldestFolder = true;
						BYTE TempFilesDeleted = 0;
						while (TempFilesDeleted < 2)
						{
							//find the oldest folder name there is
							if (TempLookingForOldestFolder)
							{
								if (FindNextFile(hFind,&FindFileData))
								{
									CString TempFileNameString = TempFolder + FindFileData.cFileName;
									if (TempFileNameString.GetAt(TempFileNameString.GetLength() -1) != '.')
									if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
									{
										if (TempOldestFolder > FindFileData.cFileName)
											TempOldestFolder = FindFileData.cFileName;
									}
								}
								else
								{//no more folders, so found oldest folder name, so use it tp delete files from
									TempLookingForOldestFolder = false;
									if (TempOldestFolder.GetAt(0) == '9')
										TempFilesDeleted = 100;
									TempFolder = vConfigurationData->vScanTracRejectedImagesDirectory + TempOldestFolder + "\\";
									CString TempFileName1 = TempFolder + "*.*";
									FindClose(hFind);
									hFind = FindFirstFile(TempFileName1, &FindFileData);
								}
							}
							else
							{
								if (FindNextFile(hFind,&FindFileData))
								{
									CString TempFileNameString = TempFolder + FindFileData.cFileName;
									if (TempFileNameString.GetAt(TempFileNameString.GetLength() -1) != '.')
									if (hFind == INVALID_HANDLE_VALUE)
									{
										//did not find anymore files in this subfolder, so delete the folder and go up to the original folder level
										RemoveDirectory(TempFolder);
										TempFolder = vConfigurationData->vScanTracRejectedImagesDirectory;
										TempLookingForOldestFolder = true;
										TempOldestFolder = "99999999";
										FindClose(hFind);
										hFind = FindFirstFile(TempDirectoryName, &FindFileData);
									}
									else
									if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
									{
										TempFolder = FindFileData.cFileName;
										TempFolder = vConfigurationData->vScanTracRejectedImagesDirectory + TempFolder + "\\";
										CString TempFileName1 = TempFolder + "*.*";
										FindClose(hFind);
										hFind = FindFirstFile(TempFileName1, &FindFileData);
									}
									else
									{
										if (DeleteFile(TempFileNameString))
											TempFilesDeleted++;
										else
											ReportErrorMessage("Failed to Delete File: " + TempFileNameString, cEMailInspx, 32000);
									}
								}
								else
								{//no more files in the folder to delete
									//did not find anymore files in this subfolder, so delete the folder and go up to the original folder level
									wchar_t TempEndString = TempFolder.GetAt(TempFolder.GetLength() - 1);
									if (TempEndString == '\\')
										TempFolder.Delete(TempFolder.GetLength() - 1);
									CString TempHoldName = TempFolder;
									LPTSTR TempFolderName = TempHoldName.GetBuffer(TempFolder.GetLength());
									FindClose(hFind);

									if (!RemoveDirectory(TempFolderName))
									{
										TempFilesDeleted = 50;
										DWORD TempErrorCode = GetLastError();
										ReportErrorMessage("Error-Code: " + dtoa(TempErrorCode,0) + 
											" Failed to Delete Old Reject Image Folder: " + TempFolderName,cEMailInspx,32000);
									}

									TempFolder = vConfigurationData->vScanTracRejectedImagesDirectory;
									TempLookingForOldestFolder = true;
									TempOldestFolder = "99999999";
									hFind = FindFirstFile(TempDirectoryName, &FindFileData);
								}
							}
						}
						FindClose(hFind);
					}
					delete TempImageFile;
				}
			}
			if (!(CompareBit(vGlobalShadowImages,cShadowRejectedImageBit) && (TempShadowWriteCheck)))
			{
				if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage)
					free(vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage);

				vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage = NULL;
				vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vLogThisReject = false;
				vSystemData.vNextRejectToSave++;
				if (vSystemData.vNextRejectToSave >= cNumberOfRejectImageBuffers)
					vSystemData.vNextRejectToSave = 0;
			}

		}
	}
	CATCH(CFileException, TempFileException)
	{
		ReportErrorMessage("Write Reject To File Failed: " + dtoa(TempFileException->m_cause,0), cEMailMaintenance, 0);
	}
	CATCH_ALL(TempException)
	{
		ReportErrorMessage("Write Reject To File Failed 22", cEMailMaintenance, 0);
	}
	END_CATCH_ALL

	// if file not created above and writing to a shadow directory, create file here.
	if ((CompareBit(vGlobalShadowImages,cShadowRejectedImageBit)) && (TempShadowWriteCheck) && (!CreatedFileForvRejectedImageDirectory))
	{
		if (!CreatedFileForvRejectedImageDirectory)	// create file to write
		if (vConfigurationData->vWriteRejectsToFiles)
		if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vLogThisReject)
		{
//			LPTSTR TempStringSSDP = TempShadowFolderName.GetBuffer(TempShadowFolderName.GetLength());

//			CFileStatus TempFileStatus;
//			if (TempShadowFolderName.GetLength() > 4)
//			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
//				CreateDirectory(TempShadowFolderName,NULL);

//			BYTE TempLength = TempShadowCurrentFileName.GetLength();
//			LPTSTR TempString1 = TempShadowCurrentFileName.GetBuffer(TempLength);

			TempImage = NULL;
			if (ThereIsEnoughMemory(vSystemData.vITIPCDig->vOriginalBufferSize * 2, "Image to Write To Disk Buffer"))
			{
				TempImage = im_create(IM_BYTE, vSystemData.vITIPCDig->vOriginalBufferSizeX, 
					vSystemData.vITIPCDig->vOriginalBufferSizeY * 2);
			}

			if ((TempImage) && (TempImage->pix))
			{
				TempPointer = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage;
				for (DWORD TempLoop = 0; TempLoop < vSystemData.vITIPCDig->vOriginalBufferSize; TempLoop++)
				{
					if (*TempPointer == 0)
						*TempPointer = 1;
					TempPointer++;
				}

				CopyMemory(TempImage->pix, vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage, 
					vSystemData.vITIPCDig->vOriginalBufferSize);

				CopyMemory(TempImage->pix + vSystemData.vITIPCDig->vOriginalBufferSize, 
					vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage, 
					vSystemData.vITIPCDig->vOriginalBufferSize);


//							if ((vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxWidth) &&
//								(vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxHeight))
//							{
			//TempScaleX = (double)vSystemData.vITIPCDig->vMainDisplayImageSizeX / (double)vSystemData.vITIPCDig->vAquisitionSizeY;
			//TempScaleY = (double)vSystemData.vITIPCDig->vMainDisplayImageSizeY / (double)vSystemData.vITIPCDig->vOriginalBufferSizeX;

				int TempCornerX = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxCornerX;

				int TempCornerY = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxCornerY;

				if (TempCornerY >= vSystemData.vITIPCDig->vOriginalBufferSizeX)
					TempCornerY = vSystemData.vITIPCDig->vOriginalBufferSizeX - 1;

				if (TempCornerX >= vSystemData.vITIPCDig->vOriginalBufferSizeY)
					TempCornerX = vSystemData.vITIPCDig->vOriginalBufferSizeY - 1;

				int TempHeight = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxHeight;
				int TempWidth = vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vRedBoxWidth;

				if (TempHeight >= vSystemData.vITIPCDig->vOriginalBufferSizeX)
					TempHeight = vSystemData.vITIPCDig->vOriginalBufferSizeX - 1;

				if (TempWidth + TempCornerY + 2 > vSystemData.vITIPCDig->vOriginalBufferSizeY)
					TempWidth = vSystemData.vITIPCDig->vOriginalBufferSizeY - TempCornerY - 2;

				BYTE *TempDestinationPointer = TempImage->pix + TempCornerX +
					(TempCornerY * vSystemData.vITIPCDig->vOriginalBufferSizeX);

				BYTE *TempMaxDestinationPointer = TempImage->pix - 1 + vSystemData.vITIPCDig->vOriginalBufferSize;

				if (TempDestinationPointer > TempMaxDestinationPointer)
					TempDestinationPointer = TempMaxDestinationPointer;

				//draw Bottom Horizontal line
				TempPointer = TempDestinationPointer;
				for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
				if (TempPointer <= TempMaxDestinationPointer)
				{
					*TempPointer = 0; //set left pixel red
					TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				}

				TempPointer = TempDestinationPointer + 1;
				for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
				if (TempPointer <= TempMaxDestinationPointer)
				{
					*TempPointer = 0; //set left pixel red
					TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				}

				//draw Top horizontal line
				TempPointer = TempDestinationPointer + TempHeight;

				while (TempPointer < TempImage->pix + vSystemData.vITIPCDig->vOriginalBufferSizeX)
					TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
				if (TempPointer <= TempMaxDestinationPointer)
				{
					*TempPointer = 0; //set left pixel red
					TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				}

				TempPointer = TempDestinationPointer - 1 + TempHeight;

				while (TempPointer < TempImage->pix)
					TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;

				for (WORD TempLoop = 0; TempLoop < TempWidth; TempLoop++)
				if (TempPointer <= TempMaxDestinationPointer)
				{
					*TempPointer = 0; //set left pixel red
					TempPointer = TempPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX;
				}

				//draw left vertical line
				TempPointer = TempDestinationPointer;
				for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
				if (TempPointer >= TempImage->pix)
					*TempPointer++ = 0; //set left pixel red

				TempPointer = TempDestinationPointer + 1;
				if (TempPointer > TempMaxDestinationPointer)
					TempPointer = TempMaxDestinationPointer;
				for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
				if (TempPointer >= TempImage->pix)
					*TempPointer++ = 0; //set left pixel red

				//draw Right vertical line
				TempPointer = TempDestinationPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX * TempWidth;
				if (TempPointer > TempMaxDestinationPointer)
					TempPointer = TempMaxDestinationPointer;
				for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
				if (TempPointer >= TempImage->pix)
					*TempPointer++ = 0; //set left pixel red

				TempPointer = TempDestinationPointer + vSystemData.vITIPCDig->vOriginalBufferSizeX * TempWidth + 1;
				if (TempPointer > TempMaxDestinationPointer)
					TempPointer = TempMaxDestinationPointer;
				for (WORD TempLoop = 0; TempLoop < TempHeight; TempLoop++)
				if (TempPointer >= TempImage->pix)
					*TempPointer++ = 0; //set left pixel red
		//							}
				RotateImage90Degrees(TempImage,1);
			} // end if (TempImage->pix) file created

// review to here kjh
		}  // if write rejects okay & if primary reject file creation failed
	}  // if have a shadow rejects folder and it is okay to write to it, if ((CompareBit(vGlobalShadowImages,cShadowRejectedImageBit)) && (TempShadowWriteCheck == true) && (CreatedFileForvRejectedImageDirectory = false))

	if ((CompareBit(vGlobalShadowImages,cShadowRejectedImageBit)) && (TempShadowWriteCheck))
	{
		CString TempRejectedImageDirectoryDefault;
		// check, if d: write to d:reject images, if no d: write to C:reject images.
		if (vGlobalHaveDDrive)
			TempRejectedImageDirectoryDefault = cRejectedImagesDirectoryDDrive;
		else
			TempRejectedImageDirectoryDefault = cRejectedImagesDirectoryCDrive;
		TRY
		{
			LPTSTR TempStringSSDP = TempShadowFolderName.GetBuffer(TempShadowFolderName.GetLength());
			CFileStatus TempFileStatus;
			if (TempShadowFolderName.GetLength() > 4)
			if (!(CFile::GetStatus(TempStringSSDP, TempFileStatus)))
				CreateDirectory(TempShadowFolderName,NULL);


			CW2A TempFileNameString(TempShadowCurrentFileName);
			CImgFile *TempImageFile2=IfxCreateImgFile(TempFileNameString);

			TempImageFile2 = IfxCreateImgFile(TempFileNameString);
			if (TempImageFile2) 
			{
				//find the amount of free space
				CString TempDriveName = TempShadowFolderName.GetAt(0);
				TempDriveName = TempDriveName + ":";

				double TempTotalBytesAvailableB = CheckDiskSpaceFree(TempDriveName);

				TempTotalBytesAvailableB = TempTotalBytesAvailableB / 1000000;  //convert to mega bytes

				if (TempTotalBytesAvailableB < 10)  //if have more than 10 megabytes free space
					ReportErrorMessage("Error-Could Not Write Reject Image to File", cEMailMaintenance, 0);
				else
				{

#ifdef IFC59Driver
					if (!TempImageFile2->WriteFile(TempImage->pix,
						vSystemData.vITIPCDig->vOriginalBufferSizeY * 2, vSystemData.vITIPCDig->vOriginalBufferSizeX,
						(WORD)vSystemData.vITIPCDig->vBitsPerPixel, IFFCL_GRAY, IFFCOMP_DEFAULT, NULL))
					{
						ReportErrorMessage("Failed to Write Reject Image to File", cEMailMaintenance, 0);
					}
#else
						if (!TempImageFile->WriteFile(TempImage->pix,
							vSystemData.vITIPCDig->vOriginalBufferSizeY * 2, vSystemData.vITIPCDig->vOriginalBufferSizeX,
							(WORD)vSystemData.vITIPCDig->vBitsPerPixel, IFFCL_GRAY, IFFCOMP_DEFAULT))
						{
							ReportErrorMessage("Failed to Write Reject Image to File", cEMailMaintenance, 0);
						}
#endif
				}
				if (TempImage)
					im_delete(TempImage);
						
					//check how much hard drive space is free,  keep atlease 100 meg, 400 meg if C:
				if ((TempTotalBytesAvailableB > 0) && ((TempTotalBytesAvailableB < 500) || ((TempTotalBytesAvailableB < 1000) && (TempDriveName == "C:"))))
				{
					ReportErrorMessage("Hard Disk Space for Reject Images Getting Low-delete 2 files",cWriteToLog,0);

					//delete oldest two reject image files
					WIN32_FIND_DATA FindFileData;
					HANDLE hFind;

					CString TempString = TempRejectedImageDirectoryDefault;
					TempString = TempString + "*.*";
					LPTSTR TempDirectoryName = TempString.GetBuffer(TempString.GetLength());
					CString TempFolder = TempRejectedImageDirectoryDefault;
					CString TempOldestFolder = "99999999";

					hFind = FindFirstFile(TempDirectoryName, &FindFileData);

					bool TempLookingForOldestFolder = true;
					BYTE TempFilesDeleted = 0;
					while (TempFilesDeleted < 2)
					{
						//find the oldest folder name there is
						if (TempLookingForOldestFolder)
						{
							if (FindNextFile(hFind,&FindFileData))
							{
								CString TempFileNameString = TempFolder + FindFileData.cFileName;
								if (TempFileNameString.GetAt(TempFileNameString.GetLength() -1) != '.')
								if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
								{
									if (TempOldestFolder > FindFileData.cFileName)
										TempOldestFolder = FindFileData.cFileName;
								}
							}
							else
							{//no more folders, so found oldest folder name, so use it tp delete files from
								TempLookingForOldestFolder = false;
								if (TempOldestFolder.GetAt(0) == '9')
									TempFilesDeleted = 100;
								TempFolder = TempRejectedImageDirectoryDefault + TempOldestFolder + "\\";
								CString TempFileName1 = TempFolder + "*.*";
								FindClose(hFind);
								hFind = FindFirstFile(TempFileName1, &FindFileData);
							}
						}
						else
						{
							if (FindNextFile(hFind,&FindFileData))
							{
								CString TempFileNameString = TempFolder + FindFileData.cFileName;
								if (TempFileNameString.GetAt(TempFileNameString.GetLength() -1) != '.')
								if (hFind == INVALID_HANDLE_VALUE)
								{
									//did not find anymore files in this subfolder, so delete the folder and go up to the original folder level
									RemoveDirectory(TempFolder);
									TempFolder = TempRejectedImageDirectoryDefault;
									TempLookingForOldestFolder = true;
									TempOldestFolder = "99999999";
									FindClose(hFind);
									hFind = FindFirstFile(TempDirectoryName, &FindFileData);
								}
								else
								if (FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
								{
									TempFolder = FindFileData.cFileName;
									TempFolder = TempRejectedImageDirectoryDefault + TempFolder + "\\";
									CString TempFileName1 = TempFolder + "*.*";
									FindClose(hFind);
									hFind = FindFirstFile(TempFileName1, &FindFileData);
								}
								else
								{
									if (DeleteFile(TempFileNameString))
										TempFilesDeleted++;
									else
										ReportErrorMessage("Failed to Delete File: " + TempFileNameString, cEMailInspx, 32000);
								}
							}
							else
							{//no more files in the folder to delete
								//did not find anymore files in this subfolder, so delete the folder and go up to the original folder level
								wchar_t TempEndString = TempFolder.GetAt(TempFolder.GetLength() - 1);
								if (TempEndString == '\\')
									TempFolder.Delete(TempFolder.GetLength() - 1);
								CString TempHoldName = TempFolder;
								LPTSTR TempFolderName = TempHoldName.GetBuffer(TempFolder.GetLength());
								FindClose(hFind);

								if (!RemoveDirectory(TempFolderName))
								{
									TempFilesDeleted = 50;
									DWORD TempErrorCode = GetLastError();
									ReportErrorMessage("Error-Code: " + dtoa(TempErrorCode,0) + 
										" Failed to Delete Old Reject Image Folder: " + TempFolderName,cEMailInspx,32000);
								}

								TempFolder = TempRejectedImageDirectoryDefault;
								TempLookingForOldestFolder = true;
								TempOldestFolder = "99999999";
								hFind = FindFirstFile(TempDirectoryName, &FindFileData);
							}
						}
					}
					FindClose(hFind);
				}
			}
			delete TempImageFile2;
				
			if (vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage)
				free(vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage);

			vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vGreyImage = NULL;
			vSystemData.vRejectImageBuffer[vSystemData.vNextRejectToSave].vLogThisReject = false;

			vSystemData.vNextRejectToSave++;
			if (vSystemData.vNextRejectToSave >= cNumberOfRejectImageBuffers)
				vSystemData.vNextRejectToSave = 0;
		}
		CATCH(CFileException, TempFileException)
		{
			ReportErrorMessage("Write Reject To File Failed: " + dtoa(TempFileException->m_cause,0), cEMailMaintenance, 0);
		}
		CATCH_ALL(TempException)
		{
			ReportErrorMessage("Write Reject To File Failed 22", cEMailMaintenance, 0);
		}
		END_CATCH_ALL
	} // end shadow directory
}

/*
		for (BYTE TempLoopB = 0; TempLoopB < cMaximumRedBoxes; TempLoopB++)
		{
			vSystemData.vRejectImageBuffer[TempLoop].vRedBoxCornerX[TempLoopB] = 0;
			vSystemData.vRejectImageBuffer[TempLoop].vRedBoxCornerY[TempLoopB] = 0;
			vSystemData.vRejectImageBuffer[TempLoop].vRedBoxWidth[TempLoopB] = 0;
			vSystemData.vRejectImageBuffer[TempLoop].vRedBoxHeight[TempLoopB] = 0;
		}
	}
*/

void CScanTracDlg::SetUsePipeFlowInput(BYTE TempValue)
{
	if (TempValue)
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x80;  //set msbit to use pipe flow input
	else
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & 0xFF7F;  //clear msbit to use pipe flow input
}

void CScanTracDlg::ReadBIOSVersionFromRegistry()
{
	wchar_t TempRegistryValue[380];
	CRegKey TempRegistryKey;
	bool TempGiveRebootNotice = false;

	LONG TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("Hardware\\Description\\System"));

	if (TempErrorCode == ERROR_SUCCESS)
	{
		DWORD TempCount = 380;
		DWORD  CodeType;
//		TempErrorCode = TempRegistryKey.QueryStringValue("SystemBiosVersion", TempRegistryValue, &TempCount);
		TempErrorCode = RegQueryValueEx(TempRegistryKey.m_hKey, _T("SystemBiosVersion"), NULL, &CodeType, (LPBYTE)TempRegistryValue, &TempCount);
		if (TempCount > 380)
			TempCount = 380;
		if (TempErrorCode == ERROR_SUCCESS)
		{
			vSystemData.vBIOSVersion = "";
			for (DWORD TempLoop = 0; TempLoop < TempCount; TempLoop++)
			{
				//wchar_t a = TempRegistryValue[TempLoop];
				if (TempRegistryValue[TempLoop] == '\0')
					vSystemData.vBIOSVersion = vSystemData.vBIOSVersion + ' ';  //under XP Seavo Motherboard, get some null characters in the string
				else
				if ((TempRegistryValue[TempLoop] <= '~') && (TempRegistryValue[TempLoop] >= ' '))
					vSystemData.vBIOSVersion = vSystemData.vBIOSVersion + TempRegistryValue[TempLoop];
			}
			vSystemData.vBIOSVersion = vSystemData.vBIOSVersion + "\0\0";	// null at the end of a string
		}

		TempCount = 200;
		TempErrorCode = TempRegistryKey.QueryStringValue(_T("SystemBiosDate"), TempRegistryValue, &TempCount);
		if (TempErrorCode == ERROR_SUCCESS)
		{
			vSystemData.vBIOSDate = "";
			for (DWORD TempLoop = 0; TempLoop < TempCount; TempLoop++)
			{
				wchar_t a = TempRegistryValue[TempLoop];
				if (a == 0)
					break;
				//vSystemData.vBIOSDate = vSystemData.vBIOSDate + " ";
				//else
				vSystemData.vBIOSDate = vSystemData.vBIOSDate + TempRegistryValue[TempLoop];
			}
				vSystemData.vBIOSDate = vSystemData.vBIOSDate + "\0\0";
		}

		TempCount = 200;
		TempErrorCode = TempRegistryKey.QueryStringValue(_T("VideoBiosDate"), TempRegistryValue, &TempCount);
		if (TempErrorCode == ERROR_SUCCESS)
		{
			vSystemData.vVideoBIOSDate = "";
			for (DWORD TempLoop = 0; TempLoop < TempCount; TempLoop++)
			{
				wchar_t a = TempRegistryValue[TempLoop];
				if (a == 0)
					break;
				//vSystemData.vVideoBIOSDate = vSystemData.vVideoBIOSDate + " ";
				//else
				vSystemData.vVideoBIOSDate = vSystemData.vVideoBIOSDate + TempRegistryValue[TempLoop];
			}
			vSystemData.vVideoBIOSDate = vSystemData.vVideoBIOSDate + "\0\0";
		}

		TempCount = 200;
//		TempErrorCode = TempRegistryKey.QueryStringValue("VideoBiosVersion", TempRegistryValue, &TempCount);
		TempErrorCode = RegQueryValueEx(TempRegistryKey.m_hKey, _T("VideoBiosVersion"), NULL, &CodeType, (LPBYTE)TempRegistryValue, &TempCount);
		if (TempErrorCode == ERROR_SUCCESS)
		{
			if (TempCount > 200)
				TempCount = 200;
			vSystemData.vVideoBIOSVersion = "";
			for (DWORD TempLoop = 0; TempLoop < TempCount; TempLoop++)
			{
				wchar_t a = TempRegistryValue[TempLoop];
				if (a == 0)
					break;
				//vSystemData.vVideoBIOSVersion = vSystemData.vVideoBIOSVersion + " ";
				else
					vSystemData.vVideoBIOSVersion = vSystemData.vVideoBIOSVersion + TempRegistryValue[TempLoop];
			}
			vSystemData.vVideoBIOSVersion = vSystemData.vVideoBIOSVersion + "\0\0";
		}
	}
}

void CScanTracDlg::SetFirstTraceOfOscilloscopeToContainerTrigger()
{
	BYTE TempCurrentProductBodyTrigger = 33;  //33 is the first body trigger 
	if (vGlobalCurrentProduct)
		TempCurrentProductBodyTrigger = vGlobalCurrentProduct->vBodyTrigger + 32;

	if (vConfigurationData->vDiagnosticLineSelect[0] != TempCurrentProductBodyTrigger)
	{
		vConfigurationData->vDiagnosticLineSelect[0] = TempCurrentProductBodyTrigger;
		SendDiagnosticLineSelect();
	}
}

void CScanTracDlg::DownStreamSignalChanged(long TempDownStreamOn)
{
	if (vConfigurationData->vUseDownStreamSignalThatStopsConveyor == cUseDownStream)
	{
		if ((vSystemData.vSystemRunMode == cRunningSystemMode) && (vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
		{
			if (TempDownStreamOn) //conveyor started
			{
				if (vGlobaluCSerialPort)
				if ((vSystemData.vSystemRunMode == cRunningSystemMode) && (vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
				{
					if (((vConfigurationData->vScanTracType == cAtempoScanTrac) || (vConfigurationData->vScanTracType == cForteScanTrac)) && (!vConfigurationData->vUseRealEncoder)) //only use if using the motor signal
					{
						WORD TempRate = vConfigurationData->vLastSimulatedEncoderRateSet * 16;

						//if .4mm detectors, want to set to 32 times
						if (vConfigurationData->vPixelsPerDetector == 128)
						{
							TempRate = TempRate * 2;
							ReportErrorMessage("Down Stream Signal on, Set Encoder 32x to: " + dtoa(TempRate,0), cAction,0);
						}
						else
						{
							ReportErrorMessage("Down Stream Signal on, Set Encoder 16x to: " + dtoa(TempRate,0), cAction,0);
						}
						if (TempRate > vSystemData.vBeltRateMaximum)
							TempRate = (WORD)(vSystemData.vBeltRateMaximum * .95);


						SetMotorSignalSimulatedEncoderRate((WORD)TempRate);
					}
					else
					if (vSystemData.vFPGASimulateEncoderRate)
					{
						TurnSimulatedEncoderOn();
						ReportErrorMessage("Down Stream Signal on, Turn Encoder On: " + dtoa(vSystemData.vFPGASimulateEncoderRate,0), cAction,0);
					}
					else
					if (vConfigurationData->vContinuousFeedEncoderRate)
					{
						TurnSimulatedEncoderOn();
						ReportErrorMessage("Down Stream Signal on, Turn Encoder On: " + dtoa(vConfigurationData->vContinuousFeedEncoderRate,0), cAction,0);
					}

					//enable encoder in the FPGA
					vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x01;//enable encoder for simulated encoder

					Send0x9ACommand();

					KillTimer(vConveyorStartTimerHandle);
					int TempTimerResult = SetTimer(vConveyorStartTimerHandle,5000,NULL);
					if (!TempTimerResult)
						ReportErrorMessage("Error-vConveyorStart Timer Failed",cWriteToLog,32000);

					if (vConfigurationData->vEnableEjectors)
						vGlobaluCSerialPort->TurnAlarmOnOff(4,true);//turn on system inspecting bit if inspecting and ejectors enabled since conveyor started
				}
			}
			else//conveyor stopped
			{
				if (((vConfigurationData->vScanTracType == cAtempoScanTrac) || (vConfigurationData->vScanTracType == cForteScanTrac)) && (!vConfigurationData->vUseRealEncoder)) //only use if using the motor signal
				{
					if ((vSystemData.vSystemRunMode == cRunningSystemMode) && (vSystemData.vSystemRunMode == cAutoSetupRunningSystem))
					{
						TurnSimulatedEncoderOff();
						if (vConfigurationData->vPixelsPerDetector == 128)
							ReportErrorMessage("Down Stream Signal Off, Turn Off Encoder 32x", cAction,0);
						else
							ReportErrorMessage("Down Stream Signal Off, Turn Off Encoder 16x", cAction,0);
					}
				}
				else
				if ((vSystemData.vFPGASimulateEncoderRate) || (vConfigurationData->vContinuousFeedEncoderRate))
				{
					TurnSimulatedEncoderOff();
					ReportErrorMessage("Down Stream Signal Off, Turn Off Simulated Encoder", cAction,0);
				}

				if (vGlobaluCSerialPort)
					vGlobaluCSerialPort->TurnAlarmOnOff(4,false);//turn off system inspecting bit since conveyor stoped
			}
		}
	}
	/*else
	{
		if (TempDownStreamOn) //conveyor started
			ReportErrorMessage("Down Stream Signal on, ScanTrac not inspecting", cAction,0);
		else
			ReportErrorMessage("Down Stream Signal off, ScanTrac not inspecting", cAction,0);
	}
	*/
}

//9/4/2009
void SystemShutDown(SystemShutDownMode mode)
{
	HANDLE hToken;
	TOKEN_PRIVILEGES tkp;

	// Get a token for this process.
	if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken )) 
	{
		ReportErrorMessage("Shutdown OpenProcessToken failed", cEMailMaintenance, 0);
	}

	// Get the LUID for the shutdown privilege.
	LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);
	tkp.PrivilegeCount = 1; // one privilege to set
	tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

	// Get the shutdown privilege for this process.
	AdjustTokenPrivileges(hToken, false, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0);

	// Cannot test the return value of AdjustTokenPrivileges.
	if (GetLastError() != ERROR_SUCCESS) 
	{
		ReportErrorMessage("Shutdown AdjustTokenPrivileges failed", cEMailInspx, 32000);
	}

	switch(mode)
	{
		//Forcefully close apps, shutdown and leave system at shutoff point
		case cShutDown:
			if (!ExitWindowsEx(EWX_SHUTDOWN | EWX_FORCE, 0))
				ReportErrorMessage("Shutdown Failed", cEMailMaintenance, 0);
		break;

		// Forcefully close apps, shutdown and reboot
		case cReboot:
			if (!ExitWindowsEx(EWX_REBOOT | EWX_FORCE, 0)) 
				ReportErrorMessage("Reboot Failed", cEMailMaintenance, 0);
		break;

		// Forcefully close apps, shutdown and poweroff
		case cPowerOff:
			if (!ExitWindowsEx(EWX_POWEROFF | EWX_FORCE, 0))
				ReportErrorMessage("Power Off Failed", cEMailMaintenance, 0);
		break;

		// Forcefully close apps, and logoff
		case cLogOff:
			if (!ExitWindowsEx(EWX_LOGOFF | EWX_FORCE, 0))
				ReportErrorMessage("LogOff Failed", cEMailMaintenance, 0);
		break;
	}
	CNoticeDialog TempNoticeDialog;
	TempNoticeDialog.vNoticeText = "\n\n\nRebooting System";
	TempNoticeDialog.vType = cInformationMessage;
	TempNoticeDialog.vAutoClose = 0xFFFF;
	TempNoticeDialog.DoModal();
} 

//9/30/2009
void CScanTracDlg::CheckSystemSettingsAreStandard()
{
	vSystemData.vAllSystemSettingsAreStandard = true;
	vSystemData.vNonStandardSetting = "";

	if (vConfigurationData->vDetectorsAtBottomToIgnoreDuringCalibration)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tNot Calibrating All Detectors At Bottom";
	}

	if (vConfigurationData->vNumberOfDetectorsToCalibrate)
	if (vConfigurationData->vNumberOfDetectorsToCalibrate < vConfigurationData->vNumberOfXRayDetectors)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tNot Calibrating All Detectors At Top";
	}

	if (vConfigurationData->vRedIndicatorToShowOnMainMenu == cDefectsInNoColor)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tNo Reject Display Indicator";
	}

	if (vGlobalCurrentProduct)
	if (vConfigurationData->vOverWriteBadPixel[0][vGlobalCurrentProduct->vUsingXScanPoint4mmDetectors] == 0xAAAB)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tCopy Over Bad Pixels Enabled";
	}

	if ((vConfigurationData->vNumberOfDaysToKeepLogs > 100) || (vConfigurationData->vNumberOfDaysToKeepLogs < 5))
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tAuto Delete Log Files";
	}
	if ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes))
	if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cPiccoloScanTrac) || 
		(vConfigurationData->vScanTracType == cUpSideDownSoloScanTrac))//side view scantrac
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tMulti Lane Mode Enabled";
	}

	if ((vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode)))
	if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cPiccoloScanTrac) || 
		(vConfigurationData->vScanTracType == cUpSideDownSoloScanTrac))//side view scantrac
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tBulk Mode Enabled";
	}

	if (vConfigurationData->vPixelsPerDetector != 64)
	if (vConfigurationData->vPixelsPerDetector != 128)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tNumber of Pixels Per Detector";
	}

	if (vConfigurationData->vStopRunningOnUnConfirmedEject)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tStop Inspecting on Unconfirmed Eject";
	}

	if (vConfigurationData->vMaxImageIntensityAdjustBeforeLocked < 40)
	if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cPiccoloScanTrac) || 
		(vConfigurationData->vScanTracType == cFermataScanTrac))//side view scantrac
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tAdjusting Brightness Before Locked too low";
	}

	if (vConfigurationData->vMaxImageIntensityAdjust < 10)
	if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cPiccoloScanTrac) || 
		(vConfigurationData->vScanTracType == cFermataScanTrac))//side view scantrac
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tAdjusting Brightness After Locked too low";
	}

	if (vConfigurationData->vAdjustAllAreaOfHistogram)
	if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cPiccoloScanTrac) || 
		(vConfigurationData->vScanTracType == cFermataScanTrac))//side view scantrac
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tAdjusting Entire Area of Container for brightness";
	}

	if (vConfigurationData->vRadiationShutterInSystem)
	{
		if (!vConfigurationData->vRadiationDoorInvertDoorOutput)
		{
			vSystemData.vAllSystemSettingsAreStandard = false;
			vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tRadiation Shutter non standard activity level";
		}

		if (vConfigurationData->vRadiationDoorDistanceStayOpen < 40)
		{
			vSystemData.vAllSystemSettingsAreStandard = false;
			vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tRadiation Shutter Distance Open too short";
		}

		if (vConfigurationData->vRadiationDoorInDoorDistance)
		{
			vSystemData.vAllSystemSettingsAreStandard = false;
			vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tRadiation Shutter Delay not Zero";
		}
	}

	if (vConfigurationData->vStopInspectionIfConveyorStops)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tStop Inspection If Conveyor Stops";
	}

	if (vConfigurationData->vEjectContainersNotInspected)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tEject Containers Not Inspected";
	}

	if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cPiccoloScanTrac) || 
		(vConfigurationData->vScanTracType == cFermataScanTrac))//side view scantrac
	{
		if (!vConfigurationData->vAdjustImageIntensity)
		{
			vSystemData.vAllSystemSettingsAreStandard = false;
			vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tNot Adjusting Image Brightness";
		}

		if (!vConfigurationData->vDriftCompensationEnabled)
		{
			vSystemData.vAllSystemSettingsAreStandard = false;
			vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Not Enabled";
		}
		else
		{
			if (!vConfigurationData->vUseDACAndADCinDensityCompensation)
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Not Using DAC and ADC";
			}

			if (vConfigurationData->vDriftCompensationWaitTime != 100)
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Wait Time Non Standard";
			}

			if (vConfigurationData->vNumberOfImagesForDriftDensity != 10)
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Number of Images Non Standard";
			}

			if ((vConfigurationData->vDriftCompensationFastThreshold < 5) || (vConfigurationData->vDriftCompensationFastThreshold > 25))
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Fast Threshold Non Standard";
			}

			if ((vConfigurationData->vDriftCompensationVeryFastThreshold < 10) || (vConfigurationData->vDriftCompensationVeryFastThreshold > 50))
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Very Fast Threshold Non Standard";
			}

			if (vConfigurationData->vNumberOfImagesForDriftDensity != 10)
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Number of Images Non Standard";
			}

			if ((vConfigurationData->vDriftCompensationFastAdjust < 10) || (vConfigurationData->vDriftCompensationFastAdjust > 40))
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Fast Adjust Non Standard";
			}

			if ((vConfigurationData->vDriftCompensationVeryFastAdjust < 20) || (vConfigurationData->vDriftCompensationVeryFastAdjust > 70))
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Very Fast Adjust Non Standard";
			}

			if ((vConfigurationData->vDriftCompensationSlowThreshold < 3) || (vConfigurationData->vDriftCompensationSlowThreshold > 6))
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Slow Threshold Non Standard";
			}

			if (vConfigurationData->vDriftCompensationSlowAdjust != 1)
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Slow Adjust Non Standard";
			}

			if (vConfigurationData->vDriftCompensationMaximumAdjust != 500)
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Maximum Adjust Non Standard";
			}

			if ((vConfigurationData->vDriftCompensationThresholdReductionFactor < 1) || (vConfigurationData->vDriftCompensationFastThreshold > 10))
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Maximum Adjust Non Standard";
			}

			if (vConfigurationData->vDriftCompensationThresholdReductionMaximum != 0)
			{
				vSystemData.vAllSystemSettingsAreStandard = false;
				vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Maximum Adjust Non Standard";
			}
		}
	}
	else
	{
		if (vConfigurationData->vAdjustImageIntensity)
		{
			vSystemData.vAllSystemSettingsAreStandard = false;
			vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tAdjusting Image Brightness";
		}

		if (vConfigurationData->vDriftCompensationEnabled)
		{
			vSystemData.vAllSystemSettingsAreStandard = false;
			vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tProduct Density Compensation Enabled";
		}
	}

	if (((vGlobalFPGAVersion10Point0OrHigher) && (vConfigurationData->vPreAmplifierGain != 1)) || //gain of 2
		((!vGlobalFPGAVersion10Point0OrHigher) && (vConfigurationData->vPreAmplifierGain != 2))) //gain of 4
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tPre-Amp Gain Non Standard";
	}

	if ((vConfigurationData->vScanTracType == cSoloScanTrac) || (vGlobalScanTracType == cSoloPlusScanTrac) || (vConfigurationData->vScanTracType == cPiccoloScanTrac) || 
		(vConfigurationData->vScanTracType == cUpSideDownSoloScanTrac)) //Side View ScanTrac
	{
		if (vConfigurationData->vContinuousFeedEncoderRate != 0)
		{
			vSystemData.vAllSystemSettingsAreStandard = false;
			vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tContinuous Feed Encoder Enabled";
		}

		if (vConfigurationData->vContinuousFeedContainerRate != 0)
		{
			vSystemData.vAllSystemSettingsAreStandard = false;
			vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tContinuous Feed Containers Enabled";
		}
	}

	if (vConfigurationData->vAutoXRaySourceOffEnabled != 1)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tTurn off X-Rays on Brownout Disabled";
	}

	if (((vGlobalFPGAVersion10Point0OrHigher) && (vConfigurationData->vDetectorClockDivider != 8)) ||
		((!vGlobalFPGAVersion10Point0OrHigher) && (vConfigurationData->vDetectorClockDivider != 20)))
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tDetector Pixel Clock Divider Non Standard";
	}

	if (vConfigurationData->vNumberOfPixelAtBottomToIgnoreInCalibration > 10)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tNumber of Pixels at bottom to ignore during calibration non standard";
	}
	if (vConfigurationData->vUse101VACFor10SecondsShutDownLimit)
	{
		vSystemData.vAllSystemSettingsAreStandard = false;
		vSystemData.vNonStandardSetting = vSystemData.vNonStandardSetting + "\n\tShut Down X-Rays when below 101 VAC for 10 Seconds non standard";
	}
}
//9/30/2009
BYTE CScanTracDlg::TestModesAreActive()
{
	BYTE TempTestModesActive = ((!vSystemData.vITIPCDig->vShowOnlyRealImages) ||
		(vSystemData.vSimulating) ||
		(vSystemData.vFPGAGeneratingSimulatedData) ||
		(vConfigurationData->vSimulateLightControlBoard) ||
		((vSystemData.vFPGASimulateEncoderRate) && (!((vSystemData.vAutoCalibrate) ||
		(vSystemData.vAutoCalibrateWhileRunning)))) ||
		(vSystemData.vSimulateContainersRate) ||
		(vSystemData.vuControllerSendExtraDiagnosticMessages) ||
		(vSystemData.vuCOutputSerialDebugData) ||
		(vSystemData.vuCSimulate16Hz) ||
		(vSystemData.vTestingTrigger) ||
		(!vSystemData.vEnableduC16HzInterrupt) ||
		(vSystemData.vLogFile.vLogSerialData) ||
		(!vSystemData.vLogFile.vLogSyncData) ||
		(vConfigurationData->vDemoMode) ||
		(vSystemData.vTemporarilyChangeSource) ||
		(vSystemData.vSimulatingCamLinkImage) ||
		(vSystemData.vKeepExternalDetectorsEnabled) ||
		(vSystemData.vFPGADontCorrectForEncoderErrors));
	if (TempTestModesActive)
		TempTestModesActive = 8;

	if (vSystemData.vRadiationDoorManualControlRegister)
	if (vSystemData.vRadiationDoorManualControlRegister & 2)
		TempTestModesActive = 2;
	else
		TempTestModesActive = 4;

	return TempTestModesActive;
}

			//11/5/2009
void CScanTracDlg::CalculateIfRunningOutOfTime()
{
	if (vSystemData.vITIPCDig->vImageToDisplayOnMainMenu)
	if (vGlobalCurrentProduct)
	if (vSystemData.vActualEncoderRate)
	{
		//calculate the percent of all time to process images
		double TempTimeForCurrentImage = vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vProcessTime / 1000000;

		double TempWidthOfContainerInPulses = vGlobalCurrentProduct->vReferenceWidth;

		if (!TempWidthOfContainerInPulses)
			TempWidthOfContainerInPulses = vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vRight -
			vSystemData.vITIPCDig->vImageToDisplayOnMainMenu->vLeft;

		double TempMaximumTimeAllowed = 0;
		if (vSystemData.vActualEncoderRate)
			TempMaximumTimeAllowed = TempWidthOfContainerInPulses / vSystemData.vActualEncoderRate;

		if (TempMaximumTimeAllowed)
			vSystemData.vPercentOfTimeForProcessing = (WORD)((TempTimeForCurrentImage / TempMaximumTimeAllowed) * 100);
		else
			vSystemData.vPercentOfTimeForProcessing = 0;

		//ReportErrorMessage("Time For Current Image: " + dtoa(TempTimeForCurrentImage,4), cAction, 0);
		//ReportErrorMessage("Container Reference Width: " + dtoa(vGlobalCurrentProduct->vReferenceWidth,4), cAction, 0);
		//ReportErrorMessage("Width of container: " + dtoa(TempWidthOfContainerInPulses,4), cAction, 0);
		//ReportErrorMessage("Encoder Rate: " + dtoa(vSystemData.vActualEncoderRate,4), cAction, 0);
		//ReportErrorMessage("Time Allowed: " + dtoa(TempMaximumTimeAllowed,4), cAction, 0);
		//ReportErrorMessage("++Percent Of Time For Processing: " + dtoa(vSystemData.vPercentOfTimeForProcessing,4), cAction, 0);

		//calculate the percent of time used to get to the ejector
		//find encoder pulses from end of image to ejector
		double TempEncoderPulsesFromGettingImageToEjector = vGlobalCurrentProduct->vEjectorDelayBeltPosition[0] - vGlobalCurrentProduct->vImageWidthPosition - vGlobalCurrentProduct->vBTToImagePosition;

		if (TempEncoderPulsesFromGettingImageToEjector < 10) //if less than 10 encoder pulses to ejector, set to 10 encoder pulses to ejector
			TempEncoderPulsesFromGettingImageToEjector = 10;

		double TempMaximumTimeUntilEjector = 0; 
		if (vSystemData.vActualEncoderRate)
			TempMaximumTimeUntilEjector = TempEncoderPulsesFromGettingImageToEjector / vSystemData.vActualEncoderRate; 
		else
			TempMaximumTimeUntilEjector = 0;

		if (TempMaximumTimeUntilEjector)
			vSystemData.vPercentOfTimeBeforeEject = (WORD)(((TempTimeForCurrentImage + .01) / TempMaximumTimeUntilEjector) * 100);
		else
			vSystemData.vPercentOfTimeBeforeEject = 0;

		//ReportErrorMessage("Pulses Trigger to Image: " + dtoa(vGlobalCurrentProduct->vBTToImagePosition,4), cAction, 0);
		//ReportErrorMessage("Pulses Width of Image: " + dtoa(vGlobalCurrentProduct->vImageWidthPosition,4), cAction, 0);
		//ReportErrorMessage("Encoder Pulses to Ejector: " + dtoa(vGlobalCurrentProduct->vEjectorDelayBeltPosition[0],4), cAction, 0);
		//ReportErrorMessage("Encoder Pulses From Getting Image To Ejector: " + dtoa(TempEncoderPulsesFromGettingImageToEjector,4), cAction, 0);
		//ReportErrorMessage("Encoder Rate: " + dtoa(vSystemData.vActualEncoderRate,4), cAction, 0);
		//ReportErrorMessage("Time Allowed to Ejector: " + dtoa(TempMaximumTimeUntilEjector,4), cAction, 0);
		//ReportErrorMessage("++Percent Of Time Before Eject: " + dtoa(vSystemData.vPercentOfTimeBeforeEject,4), cAction, 0);
	}
}
// 10/29/09 kjh function to return cpu usage in percentage form
// get system times http://www.codeproject.com/KB/threads/Get_CPU_Usage.aspx
// initialize?? no just dont use first time through function
//	last_idleTime.dwHighDateTime = 0;
//	last_idleTime.dwLowDateTime = 0;
//	last_kernelTime.dwHighDateTime = 0;
//	last_kernelTime.dwLowDateTime = 0;
//	last_userTime.dwHighDateTime = 0;
//	last_userTime.dwLowDateTime = 0;
UINT CScanTracDlg::FindCPUUsage(void)
{
	UINT vResult = 0;
	static FILETIME last_idleTime, last_kernelTime, last_userTime;
	static ULONGLONG Last_ACQThreadKernelTime;
	static ULONGLONG Last_ACQThreadUserTime;
	static ULONGLONG Last_MyProcessKernelTime;
	static ULONGLONG Last_MyProcessUserTime;

//	typedef BOOL (*mytry) (LPFILETIME lpIdleTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);
	typedef BOOL (CALLBACK* mytry) (LPFILETIME, LPFILETIME, LPFILETIME);
	mytry NewGetSystemParams;    // Function pointer

	HMODULE hLibNetwork = LoadLibrary((_T("kernel32.dll"))); // file name of module

	if (vGlobalImageAquisitionThread)
	if (hLibNetwork != NULL)
	{
		FILETIME idleTime, kernelTime, userTime;
  
		ULONGLONG UserTimeSlice;
		ULONGLONG KernelTimeSlice;

		LPCSTR lpProcName = "GetSystemTimes";		// handle to DLL module // function name		 
//		mytry NewGetSystemParams = (mytry)GetProcAddress(hLibNetwork,lpProcName);   
		NewGetSystemParams = (mytry)GetProcAddress(hLibNetwork,lpProcName);   

		if (NewGetSystemParams != NULL)
		{
		  DWORD dwRetVal = NewGetSystemParams(&idleTime, &kernelTime, &userTime );

			// if the call to NewGetSystemParams is successful and it is not the first time through continue
			// Do not want to process first time through, that is why != 0 comparison
			// if the system call return value is non zero, the function succeeded http://msdn.microsoft.com/en-us/library/ms724400(VS.85).aspx
			if ((dwRetVal != 0) && (last_kernelTime.dwLowDateTime != 0))
			{
				FILETIME usr ; //= userTime - last_userTime;
				ULONGLONG Value1 = (((ULONGLONG) userTime.dwHighDateTime) << 32) + userTime.dwLowDateTime;
				ULONGLONG Value2 = (((ULONGLONG) last_userTime.dwHighDateTime) << 32) + last_userTime.dwLowDateTime;
				UserTimeSlice = (Value1 - Value2) ;
				usr.dwLowDateTime  = (DWORD) (UserTimeSlice & 0xFFFFFFFF );
				usr.dwHighDateTime = (DWORD) (UserTimeSlice >> 32 ); 

				FILETIME ker ; // = kernelTime - last_kernelTime;
				Value1 = (((ULONGLONG) kernelTime.dwHighDateTime) << 32) + kernelTime.dwLowDateTime;
				Value2 = (((ULONGLONG) last_kernelTime.dwHighDateTime) << 32) + last_kernelTime.dwLowDateTime;
				KernelTimeSlice = (Value1 - Value2) ;
				ker.dwLowDateTime  = (DWORD) (KernelTimeSlice & 0xFFFFFFFF );
				ker.dwHighDateTime = (DWORD) (KernelTimeSlice >> 32 ); 

				FILETIME idl ; //= idleTime - last_idleTime;      
				Value1 = (((ULONGLONG) idleTime.dwHighDateTime) << 32) + idleTime.dwLowDateTime;
				Value2 = (((ULONGLONG) last_idleTime.dwHighDateTime) << 32) + last_idleTime.dwLowDateTime;
				ULONGLONG qwResultIdl = Value1 - Value2 ;
				idl.dwLowDateTime  = (DWORD) (qwResultIdl & 0xFFFFFFFF );
				idl.dwHighDateTime = (DWORD) (qwResultIdl >> 32 ); 

				FILETIME sys ; // = kerl + usr;		//system time
				Value1 = (((ULONGLONG) ker.dwHighDateTime) << 32) + ker.dwLowDateTime;
				Value2 = (((ULONGLONG) usr.dwHighDateTime) << 32) + usr.dwLowDateTime;
				ULONGLONG qwResultSys = Value1 + Value2 ;
				sys.dwLowDateTime  = (DWORD) (qwResultSys & 0xFFFFFFFF );
				sys.dwHighDateTime = (DWORD) (qwResultSys >> 32 ); 

				UINT cpu = 0;

				if (((qwResultSys - qwResultIdl) > 0) && (qwResultSys))
				{
					cpu = UINT((((((qwResultSys - qwResultIdl) * 1000) + 5) / qwResultSys) / 10)); // +0.5 for rounding value
				}

				vResult = cpu;		//percentage of usage to return
				
				FILETIME MyProcessCreationTime;
				FILETIME MyProcessExitTime;
				FILETIME MyProcessKernelTime;
				FILETIME MyProcessUserTime;

				if (GetProcessTimes(vGlobalMyProcessHandle, &MyProcessCreationTime, &MyProcessExitTime, &MyProcessKernelTime, &MyProcessUserTime))
				{
					//FILETIME MyProcessKernelTime ;	//  kernelTime - last_kernelTime;
					ULONGLONG MyProcessKernel = (((ULONGLONG) MyProcessKernelTime.dwHighDateTime) << 32) + MyProcessKernelTime.dwLowDateTime;
					ULONGLONG MyProcessKernelTimeSlice = (MyProcessKernel - Last_MyProcessKernelTime) ;

					//FILETIME MyProcessUserTime ;	// userTime - last_userTime;
					ULONGLONG MyProcessUser  = (((ULONGLONG) MyProcessUserTime.dwHighDateTime) << 32) + MyProcessUserTime.dwLowDateTime;
					ULONGLONG MyProcessUserTimeSlice = (MyProcessUser - Last_MyProcessUserTime) ;
					
// below gives a percentage of kernel and user time relative to total time used.  Want % absolute
//					UINT vProcessKernelTimePercent;
//					UINT vProcessUserTimePercent;
//					if (KernelTimeSlice > 0)
//						vProcessKernelTimePercent = (UINT)((((MyProcessKernelTimeSlice*1000)/KernelTimeSlice)+5)/10);
//					else
//						vProcessKernelTimePercent = 0;
//
//					if (UserTimeSlice > 0)
//						vProcessUserTimePercent = (UINT)((((MyProcessUserTimeSlice*1000)/UserTimeSlice)+5)/10);
//					else
//						vProcessUserTimePercent = 0;

					//qwResultSys = system time slice reference +5 rounding caused value to be greater the total CPU time, eliminated
					if (qwResultSys)
						vGlobalProcessTimePercent = (UINT)(((((MyProcessKernelTimeSlice+MyProcessUserTimeSlice)*1000) / qwResultSys)) / 10);

					Last_MyProcessKernelTime = MyProcessKernel;
					Last_MyProcessUserTime = MyProcessUser;
				}	

				FILETIME ACQThreadCreationTime;
				FILETIME ACQThreadExitTime;
				FILETIME ACQThreadKernelTime;
				FILETIME ACQThreadUserTime;

				if (GetThreadTimes(vGlobalImageAquisitionThread->m_hThread,&ACQThreadCreationTime,&ACQThreadExitTime,&ACQThreadKernelTime,&ACQThreadUserTime))
				{

					ULONGLONG ACQUserValue = (((ULONGLONG) ACQThreadUserTime.dwHighDateTime) << 32) + ACQThreadUserTime.dwLowDateTime;
					ULONGLONG ACQThreadUserTimeSlice = (ACQUserValue - Last_ACQThreadUserTime) ;

					ULONGLONG ACQKernelValue = (((ULONGLONG) ACQThreadKernelTime.dwHighDateTime) << 32) + ACQThreadKernelTime.dwLowDateTime;
					ULONGLONG ACQThreadKernelTimeSlice = (ACQKernelValue - Last_ACQThreadKernelTime) ;

// below gives a percentage of kernel and user time relative to total time used.  Want % absolute
//					UINT vThreadKernelTimePercent;
//					UINT vThreadUserTimePercent;
//					if (KernelTimeSlice != 0)
//						vThreadKernelTimePercent = (UINT)((((ACQThreadKernelTimeSlice*1000)/KernelTimeSlice)+5)/10);
//					else
//						vThreadKernelTimePercent = 0;
//					
//					if (UserTimeSlice != 0)
//						vThreadUserTimePercent = (UINT)((((ACQThreadUserTimeSlice*1000)/UserTimeSlice)+5)/10);
//					else
//						vThreadUserTimePercent = 0;
					
					//qwResultSys = system time slice reference // +5 rounding caused value to be greater the total CPU time, eliminated
					if (qwResultSys)
						vGlobalThreadTimePercent = (UINT)(((((ACQThreadUserTimeSlice + ACQThreadKernelTimeSlice)*1000) / qwResultSys)) / 10);
//kjh here yellow message if vGlobalThreadTimePercent > 90%
					if (vGlobalThreadTimePercent > 90)
					if (vGlobalFlagSendOnceThreadError == true)
 					if (vSystemData.vSystemRunMode == cRunningSystemMode)
					{	// if true check for yellow message send
						ReportErrorMessage("Warning - CPU usage over 90%",cEMailInspx,32000);
						vGlobalFlagSendOnceThreadError = false;
					}
					Last_ACQThreadKernelTime = ACQKernelValue;
					Last_ACQThreadUserTime = ACQUserValue;
				}
				else
				{	// to see error messages
		//			DWORD TroubledInfo = GetLastError();
					LPVOID lpMsgBuf;
						FormatMessage( 
						FORMAT_MESSAGE_ALLOCATE_BUFFER | 
						FORMAT_MESSAGE_FROM_SYSTEM | 
						FORMAT_MESSAGE_IGNORE_INSERTS,
						NULL,
						GetLastError(),
						MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language
						(LPTSTR) &lpMsgBuf,
						0,
						NULL 
					);
					// ...
					// Display the string.
					CString TempNowString = (LPCTSTR)lpMsgBuf ;
					// Free the buffer.
					LocalFree( lpMsgBuf );
				}
			}
			// first time through function do not do, second time process values
			// save value for next time in this function
			last_idleTime.dwHighDateTime = idleTime.dwHighDateTime;
			last_idleTime.dwLowDateTime = idleTime.dwLowDateTime;
			last_kernelTime.dwHighDateTime = kernelTime.dwHighDateTime;
			last_kernelTime.dwLowDateTime = kernelTime.dwLowDateTime;
			last_userTime.dwHighDateTime = userTime.dwHighDateTime;
			last_userTime.dwLowDateTime = userTime.dwLowDateTime;
		}
		FreeLibrary(hLibNetwork);
	}		// call time function okay
	return(vResult);
// end kjh get system times call parameters, for future
}

//kjh for GetSystemTimes call 10/29/09 
//typedef struct _FILETIME { DWORD dwLowDateTime; DWORD dwHighDateTime; } FILETIME, *PFILETIME; 
//kjh end for GetSystemTimes call 10/29/09

void CScanTracDlg::Send0x9ACommand()
{
	tSerialCommand TempCommand;
	TempCommand[0] = 0x23;
	TempCommand[1] = 0x9A;
	TempCommand[2] = (BYTE)(vSystemData.vCurrentConveyorOutput >> 8);//0x00;
	TempCommand[3] = (BYTE)(vSystemData.vCurrentConveyorOutput);
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTime + 10);
}

void CScanTracDlg::ShowOrHideProductDensityCompensation()
{
	if ((PasswordOK(cTemporaryInspxPassword,false)) && (vSystemData.vMainDisplayMode == cMainDisplayImage))
		//m_LearnState.ShowWindow(SW_SHOW); 
		SetLearnState();
	else
	{
		//m_LearnState.ShowWindow(SW_HIDE);
		CalculateSensitivity();
		if (vSystemData.vNumberOfSensitivities)
			SetDlgItemText(IDC_LearnState, _T("Sensitivity"));
		else
			SetDlgItemText(IDC_LearnState, _T(" "));
	}

	int TempCurrentlyShowing = m_DensityCompensation.IsWindowVisible();

	if ((vConfigurationData->vDriftCompensationEnabled) && (PasswordOK(cTemporaryInspxPassword,false)) &&
		(vSystemData.vMainDisplayMode == cMainDisplayImage) &&
		((vSystemData.vSystemRunMode == cAutoSetupRunningSystem) || (vSystemData.vSystemRunMode == cRunningSystemMode)))
	{
		if (!TempCurrentlyShowing)
		{
			m_DensityCompensation.ShowWindow(SW_SHOW);
			//m_ThresholdReduction.ShowWindow(SW_SHOW);
			m_ThresholdIncrease.ShowWindow(SW_SHOW);
			vSystemData.vOldDriftCompensationThresholdReductionAmount = -1000;
		}
	}
	else
	{
		if (TempCurrentlyShowing)
		{
			m_DensityCompensation.ShowWindow(SW_HIDE);
			m_ThresholdReduction.ShowWindow(SW_HIDE);
			m_ThresholdIncrease.ShowWindow(SW_HIDE);
		}
	}
}

void CScanTracDlg::UpdateProductDensityCompensation()
{
	if (vConfigurationData->vDriftCompensationEnabled)
	{
		if ((vSystemData.vOldDriftCompensationADCOffset != vSystemData.vDriftCompensationADCOffset) ||
			(vSystemData.vOldDriftCompensationDACOffset != vSystemData.vDriftCompensationDACOffset))
		{
			vSystemData.vOldDriftCompensationADCOffset = vSystemData.vDriftCompensationADCOffset;
			vSystemData.vOldDriftCompensationDACOffset = vSystemData.vDriftCompensationDACOffset;
			if (vConfigurationData->vUseDACAndADCinDensityCompensation)
			{
				CString TempSign = "";
				if (vSystemData.vCurrentBrightnessAdjustment > 0)
					TempSign = "+";
				SetDlgItemText(IDC_DensityCompensation,"Corr: " + TempSign + dtoa(vSystemData.vCurrentBrightnessAdjustment,0));

				if ((vSystemData.vCurrentBrightnessAdjustment > 50.0) || (vSystemData.vCurrentBrightnessAdjustment < -50.0))
				{
					if (!m_DensityLockTooFarOff.IsWindowVisible())
					{
						m_DensityLockTooFarOff.ShowWindow(SW_SHOW);
					}
				}
				else
				{
					if (m_DensityLockTooFarOff.IsWindowVisible())
						m_DensityLockTooFarOff.ShowWindow(SW_HIDE);
				}
			}
			else
			{
				CString TempSign = "";
				if (vSystemData.vCurrentBrightnessAdjustment > 0)
					TempSign = "+";
				SetDlgItemText(IDC_DensityCompensation,"Corr: " + TempSign + dtoa(vSystemData.vCurrentBrightnessAdjustment,0));
			}
		}
		//if (vSystemData.vOldDriftCompensationThresholdReductionAmount != vSystemData.vDriftCompensationThresholdReductionAmount)
		//{
		//	vSystemData.vOldDriftCompensationThresholdReductionAmount = vSystemData.vDriftCompensationThresholdReductionAmount;
		//	CString TempString = dtoa(vSystemData.vOldDriftCompensationThresholdReductionAmount,0);
		//	if (vSystemData.vOldDriftCompensationThresholdReductionAmount)
		//		TempString = "Delta Thresh: -" + TempString;
		//	else
		//		TempString = "Delta Thresh: " + TempString;
		//	SetDlgItemText(IDC_ThresholdReduction,TempString);
		//}
		if (vSystemData.vOldDriftCompensationImageBrightnessDelta != vSystemData.vDriftCompensationImageBrightnessDelta)
		{
			vSystemData.vOldDriftCompensationImageBrightnessDelta = vSystemData.vDriftCompensationImageBrightnessDelta;
			CString TempString = dtoa(vSystemData.vOldDriftCompensationImageBrightnessDelta,0);
			TempString = "Delta Bright: " + TempString;
			SetDlgItemText(IDC_ThresholdIncrease,TempString);

			if (m_ThresholdIncrease.IsWindowVisible())
			if (vSystemData.vLastChatWindowText.GetLength() > 2)
				SetDlgItemText(IDC_ChatMessage, "Message: " + vSystemData.vLastChatWindowText);
		}
	}

	if (vSystemData.vITIPCDig->vDriftCompensationLocked)
	{
		if (m_DensityNotLockedIndicator.IsWindowVisible())
			m_DensityNotLockedIndicator.ShowWindow(SW_HIDE);
	}
	else //compensation not locked
	if (!m_DensityCompensation.IsWindowVisible())
	if ((vConfigurationData->vDriftCompensationEnabled) && (vSystemData.vMainDisplayMode == cMainDisplayImage) &&
		((vSystemData.vSystemRunMode == cAutoSetupRunningSystem) || (vSystemData.vSystemRunMode == cRunningSystemMode)) && (PasswordOK(cTemporaryInspxPassword,false)))
		{
			m_DensityNotLockedIndicator.ShowWindow(SW_SHOW);
		}
}

void CScanTracDlg::TurnOnOffCamLinkTestImages(bool TempTurnOn)
{
	if (vGlobalFrameGrabberType == cPC2CamLinkFrameGrabber)
	if (vSystemData.vITIPCDig->vCaptureModule)
	if (TempTurnOn)
	{
		vSystemData.vSimulatingCamLinkImage = true;
		ReportErrorMessage("Inspx Enabled CamLink Simulated Images", cWriteToLog, 32000);
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		for (BYTE TempLoop = 0; TempLoop < 5; TempLoop++)
		{
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFC, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
		}
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
	}
	else
	{
		if ((vSystemData.vFPGASimulateEncoderRate == 300) && (vSystemData.vSimulateContainersRate == 30))
		{
			//Turn Off simulated encoder
			vSystemData.vSimulateContainersRate = 0;
			vSystemData.vFPGASimulateEncoderRate = 0;
			TurnSimulatedEncoderOff();
			TurnSimulatedContainersOff();
		}
		vSystemData.vSimulatingCamLinkImage = false;
		ReportErrorMessage("Disabled CamLink Simulated Images", cWriteToLog, 32000);
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		for (BYTE TempLoop = 0; TempLoop < 5; TempLoop++)
		{
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFA, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
		}
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
		Sleep(10);

		if ((vSystemData.vPreviousProduct != "") && (vSystemData.vPreviousProduct != *vGlobalCurrentProduct->GetProductName()))
		{
			vSystemData.vCurrentProductName = vSystemData.vPreviousProduct;
			vGlobalCurrentProduct = GetProductByName(vSystemData.vPreviousProduct);

			if (vGlobalCurrentProduct)
			{
				if (CheckSystemFullyConfigured(vConfigurationData))
					CheckProductFullyConfigured(vGlobalCurrentProduct);

				SetupProduct(vGlobalCurrentProduct, false);
				vSystemData.vITIPCDig->DeleteUndoStructureLearnFiles(vGlobalCurrentProduct);
			}
		}
	}
}

void CScanTracDlg::SetSimulatedEncoderTo16TimesConveyor() //6/23/2011
{
	if ((vConfigurationData->vScanTracType == cAtempoScanTrac) || (vConfigurationData->vScanTracType == cForteScanTrac))
	if (!vConfigurationData->vUseRealEncoder)
	if ((!vSystemData.vFPGASimulateEncoderRate) && (!vConfigurationData->vContinuousFeedEncoderRate))
	//if (!vConfigurationData->vSimulateLightControlBoard)
	if (vSystemData.vSecondsMeasuringRealConveyorEncoder > 1)
	{
		//11/18/2009
		double TempCurrentConveyorRateDouble = vSystemData.vRealConveyorEncoderPulsesCount;
		
		if (vSystemData.vRealConveyorEncoderPulsesCount > 1)
			TempCurrentConveyorRateDouble = ((vSystemData.vRealConveyorEncoderPulsesCount - 1) / vSystemData.vSecondsMeasuringRealConveyorEncoder) + 0.5;

		ReportErrorMessage("Motor Signal Rate (Hertz): " + dtoa(TempCurrentConveyorRateDouble,2),cWriteToLog,0);


		WORD TempCurrentConveyorRate = (WORD)(TempCurrentConveyorRateDouble + .5);

		if (TempCurrentConveyorRate > 3)  //if only zero, one or two, use the previous value
		{
			//if you have a previous encoder rate, and it is different, set current to previous value if is within 2 of previous
			if (vConfigurationData->vLastSimulatedEncoderRateSet)  
			if (TempCurrentConveyorRate != vConfigurationData->vLastSimulatedEncoderRateSet)
			{
				if ((TempCurrentConveyorRate >= vConfigurationData->vLastSimulatedEncoderRateSet - 2) &&
					(TempCurrentConveyorRate <= vConfigurationData->vLastSimulatedEncoderRateSet + 2))
					TempCurrentConveyorRate = vConfigurationData->vLastSimulatedEncoderRateSet;
			}
			vConfigurationData->vLastSimulatedEncoderRateSet = TempCurrentConveyorRate;

			TempCurrentConveyorRate = TempCurrentConveyorRate * 16;

			//if .4mm detectors, want to set to 32 times
			if (vConfigurationData->vPixelsPerDetector == 128)
			{
				TempCurrentConveyorRate = TempCurrentConveyorRate * 2;
				ReportErrorMessage("Set Encoder to 32x, vSystemData.vRealConveyorEncoderPulsesCount: " + dtoa(vSystemData.vRealConveyorEncoderPulsesCount), cAction,0);
				ReportErrorMessage("Set Encoder to 32x, vSystemData.vSecondsMeasuringRealConveyorEncoder: " + dtoa(vSystemData.vSecondsMeasuringRealConveyorEncoder), cWriteToLog,0);
			}
			else
			{
				ReportErrorMessage("Set Encoder to 16x, vSystemData.vRealConveyorEncoderPulsesCount: " + dtoa(vSystemData.vRealConveyorEncoderPulsesCount), cAction,0);
				ReportErrorMessage("Set Encoder to 16x, vSystemData.vSecondsMeasuringRealConveyorEncoder: " + dtoa(vSystemData.vSecondsMeasuringRealConveyorEncoder), cWriteToLog,0);
			}

			vSystemData.vSimulatingFastestEncoder = false;
			SetMotorSignalSimulatedEncoderRate((WORD)TempCurrentConveyorRate);

			vSystemData.vRealConveyorEncoderPulsesCount = 0;
			vSystemData.vSecondsMeasuringRealConveyorEncoder = 0;
		}
		else
		{
			if (vConfigurationData->vPixelsPerDetector == 128)
				ReportErrorMessage("Conveyor Stopped so do not set Encoder to 32 Times Real",cWriteToLog,0);
			else
				ReportErrorMessage("Conveyor Stopped so do not set Encoder to 16 Times Real",cWriteToLog,0);
		}
	}
	else
	{
		if (vConfigurationData->vPixelsPerDetector == 128)
			ReportErrorMessage("Conveyor Stopped so do not set Encoder to 32 Times Real",cWriteToLog,0);
		else
			ReportErrorMessage("Conveyor Stopped so do not set Encoder to 16 Times Real",cWriteToLog,0);
	}
}

double CScanTracDlg::GetDefaultMeasureSourceStrengthVoltage()
{
	double TempVoltage = 35;
	switch (vConfigurationData->vScanTracType)
	{
		case cUpSideDownSoloScanTrac:
		case cSoloScanTrac:
			if (vConfigurationData->vXRaySourceFilter)//new source strength code
				TempVoltage = 39;
			else
				TempVoltage = 23;
		break;
		case cSoloPlusScanTrac:
			if (vConfigurationData->vXRaySourceFilter)//new source strength code
				TempVoltage = 52;
			else
				TempVoltage = 34;
		break;
		case cFermataScanTrac:
			if (vConfigurationData->vXRaySourceFilter)//new source strength code
				TempVoltage = 39;
			else
				TempVoltage = 23;
				//TempVoltage = 41;
		break;
		case cPiccoloScanTrac:
				TempVoltage = 22;
		break;
		case cLegatoScanTrac:
				TempVoltage = 22;
		break;
		case cAtempoScanTrac:
				TempVoltage = 45;
		break;
		case cAllegroScanTrac:
				TempVoltage = 60;
		break;
		case cForteScanTrac:
				TempVoltage = 45;
		break;
		case cCaseInspectorScanTrac:
				TempVoltage = 47;
		break;
		case cBriosoScanTrac:
				TempVoltage = 40;
		break;
	}
	if ((vGlobalPixelsPerUnitInHeight == 64) || (vConfigurationData->vUseXScanDetectors) || (vSystemData.vCalibratingXScanPoint4mmDetectors)) //if using .4mm detectors or X-Scan
		TempVoltage = TempVoltage + 5;
	return TempVoltage;
}

double CScanTracDlg::GetDefaultMeasureSourceStrengthCurrent(BYTE TempHasFilter)
{
	double TempCurrent = 1;
	switch (vConfigurationData->vScanTracType)
	{
		case cUpSideDownSoloScanTrac:
		case cSoloScanTrac:
			TempCurrent = 1; //new source strength code
			//if (TempHasFilter)
			//	TempCurrent = 1.2;
			//else
			//	TempCurrent = .8;
		break;
		case cSoloPlusScanTrac:
			TempCurrent = 2;
		break;
		case cFermataScanTrac:
			TempCurrent = 1; //new source strength code
			//if (TempHasFilter)
			//	TempCurrent = 1.2;
			//else
			//	TempCurrent = .4;
		break;
		case cPiccoloScanTrac:
			TempCurrent = 0.15;
		break;
		case cLegatoScanTrac:
			TempCurrent = 0.15;
		break;
		case cAtempoScanTrac:
			TempCurrent = 3;
		break;
		case cAllegroScanTrac:
			TempCurrent = .8;
		break;
		case cForteScanTrac:
			TempCurrent = 3;
		break;
		case cCaseInspectorScanTrac:
			TempCurrent = 1.6;
		break;
		case cBriosoScanTrac:
			TempCurrent = .5;
		break;
	}
	if ((!vConfigurationData->vUseXScanDetectors) && ((vGlobalPixelsPerUnitInHeight == 64) || (vSystemData.vCalibratingXScanPoint4mmDetectors))) //if using DT .4mm detectors 
		TempCurrent = TempCurrent * 2;
	return TempCurrent;
}

double CScanTracDlg::GetDefaultAlignTubeVoltage()
{
	double TempVoltage = 35;
	switch (vConfigurationData->vScanTracType)
	{
		case cUpSideDownSoloScanTrac:
		case cSoloScanTrac:
		case cSoloPlusScanTrac:
				TempVoltage = 31;
		break;
		case cFermataScanTrac:
				TempVoltage = 20;
		break;
		case cPiccoloScanTrac:
				TempVoltage = 22;
		break;
		case cLegatoScanTrac:
				TempVoltage = 22;
		break;
		case cAtempoScanTrac:
				TempVoltage = 36;
		break;
		case cAllegroScanTrac:
				TempVoltage = 40;
		break;
		case cForteScanTrac:
				TempVoltage = 36;
		break;
		case cCaseInspectorScanTrac:
				TempVoltage = 32;
		break;
		case cBriosoScanTrac:
				TempVoltage = 30;
		break;
	}
	return TempVoltage;
}

double CScanTracDlg::GetDefaultAlignTubeCurrent(BYTE TempHasFilter)
{
	double TempCurrent = 1;
	switch (vConfigurationData->vScanTracType)
	{
		case cUpSideDownSoloScanTrac:
		case cSoloScanTrac:
		case cSoloPlusScanTrac:
			if (TempHasFilter)
				TempCurrent = 1;
			else
				TempCurrent = 0.17;
		break;
		case cFermataScanTrac:
			TempCurrent = 0.5;
		break;
		case cPiccoloScanTrac:
			TempCurrent = 0.15;
		break;
		case cLegatoScanTrac:
			TempCurrent = 0.15;
		break;
		case cAtempoScanTrac:
			TempCurrent = 1.5;
		break;
		case cAllegroScanTrac:
			TempCurrent = 1.0;
		break;
		case cForteScanTrac:
			TempCurrent = 1.5;
		break;
		case cCaseInspectorScanTrac:
			TempCurrent = 1.5;
		break;
		case cBriosoScanTrac:
			TempCurrent = 1;
		break;
	}
	return TempCurrent;
}

void CScanTracDlg::SetMotorSignalSimulatedEncoderRate(WORD TempRate)
{
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->ClearEncoderHistory();
	bool TempTurnedEncoderOn = false;
	if (vGlobaluCSerialPort)
	if (vSystemData.vFPGAVersion9Point0OrHigher)
	{  //uses micro-seconds for simulated encoder
		if (TempRate > 50000)
			TempRate = 50000;

		if (TempRate)
			TempTurnedEncoderOn = true;
		//convert to counts then back to hertz so can see actual value obtained
		WORD Temp100KCounts = (WORD)(((1.0/(double)TempRate) * 100000.0) - 1.0);
		BYTE TempUpperByte = (BYTE)(Temp100KCounts >> 8);
		tSerialCommand TempCommand;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xBA;
		TempCommand[2] = TempUpperByte;
		TempCommand[3] = (BYTE)Temp100KCounts;
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendSerialCommand(TempCommand);

		ReportErrorMessage("3. Set Simulated Encoder to: " + dtoa(TempRate,0),cAction,0);
		Sleep(cSendCommandSleepTime);
	}
	else
	{  //uses codes for simulated encoder
		//this code is for simulated encoder off. TempRate == 255

			WORD TempSimulatedEncoderCode = 0xFF00;  //code 255 for turn off simulated encoder
			if (TempRate)
			{
				if (TempRate <= 12)
					TempSimulatedEncoderCode = 240;  // 12Hz
				else
				if (TempRate <= 50)
					TempSimulatedEncoderCode = 60;  // 50Hz
				else
				if (TempRate <= 100)
					TempSimulatedEncoderCode = 30;  // 100Hz
				else
				if (TempRate <= 200)
					TempSimulatedEncoderCode = 15;  // 200Hz
				else
				if (TempRate <= 500)
					TempSimulatedEncoderCode = 6;  // 500Hz
				else
				if (TempRate <= 1000)
					TempSimulatedEncoderCode = 3;  // 1000Hz
				else
					TempSimulatedEncoderCode = 1;  // 2307Hz
				TempTurnedEncoderOn = true;
			}
			TempSimulatedEncoderCode = TempSimulatedEncoderCode << 8;  //must shift up to MSByte
			vGlobaluCSerialPort->SetSimulatedEncoderRate(TempSimulatedEncoderCode);
	}
	//enable or disable the encoder in the FPGA
	if (TempTurnedEncoderOn)
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x01;//enable encoder for simulated encoder
	else
	if ((vSystemData.vSystemRunMode != cStoppedSystemMode) && ((vConfigurationData->vScanTracType == cAtempoScanTrac) || (vConfigurationData->vScanTracType == cForteScanTrac)))
	{
		//does this when source has stabilized
		vSystemData.vSecondsMeasuringRealConveyorEncoder = 0;
		vSystemData.vRealConveyorEncoderPulsesCount = 0;
		if (!vConfigurationData->vUseRealEncoder)
		if (!TempRate)
			vSystemData.vRealConveyorEncoderPulsesCount = 1;
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput | 0x01;//enable encoder for simulated encoder
	}
	else
		vSystemData.vCurrentConveyorOutput = vSystemData.vCurrentConveyorOutput & 0xFFFE;//disable encoder for simulated encoder

	Send0x9ACommand();

	if (TempRate)
	{
		KillTimer(vConveyorStartTimerHandle);
		int TempTimerResult = SetTimer(vConveyorStartTimerHandle,5000,NULL);
		if (!TempTimerResult)
			ReportErrorMessage("Error-vConveyorStart Timer Failed",cWriteToLog,32000);
	}
	vSystemData.vSimulatingFastestEncoder = false;
}
/*
HANDLE CScanTracDlg::ChangeBitmapFormat(HBITMAP hBitmap,WORD wBitCount,DWORD dwCompression,HPALETTE hPal,HWND hwnd) 
{ 
    HDC                hDC;          // Screen DC 
    HANDLE             hNewDIB=NULL; // Handle to new DIB 
    BITMAP             Bitmap;       // BITMAP data structure 
    BITMAPINFOHEADER   bi;           // Bitmap info. header 
    LPBITMAPINFOHEADER lpbi;         // Pointer to bitmap header 
    HPALETTE           hOldPal=NULL; // Handle to palette 
    WORD               NewBPP;       // New bits per pixel 
    DWORD              NewComp;      // New compression format 
 
    // Check for a valid bitmap handle 
 
    if (!hBitmap) 
        return NULL; 
 
    // Validate wBitCount and dwCompression 
    // They must match correctly (i.e., BI_RLE4 and 4 BPP or 
    // BI_RLE8 and 8BPP, etc.) or we return failure 
     
    if (wBitCount == 0) 
    { 
        NewComp = dwCompression; 
        if (NewComp == BI_RLE4) 
            NewBPP = 4; 
        else if (NewComp == BI_RLE8) 
            NewBPP = 8; 
        else // Not enough info  
            return NULL; 
    } 
    else if (wBitCount == 1 && dwCompression == BI_RGB) 
    { 
        NewBPP = wBitCount; 
        NewComp = BI_RGB; 
    } 
    else if (wBitCount == 4) 
    { 
        NewBPP = wBitCount; 
        if (dwCompression == BI_RGB || dwCompression == BI_RLE4) 
            NewComp = dwCompression; 
        else 
            return NULL; 
    } 
    else if (wBitCount == 8) 
    { 
        NewBPP = wBitCount; 
        if (dwCompression == BI_RGB || dwCompression == BI_RLE8) 
            NewComp = dwCompression; 
        else 
            return NULL; 
    } 
    else if (wBitCount == 24 && dwCompression == BI_RGB) 
    { 
        NewBPP = wBitCount; 
        NewComp = BI_RGB; 
    } 
    else 
        return NULL; 
 
    // Get info about the bitmap 
 
    GetObject(hBitmap, sizeof(BITMAP), (LPSTR)&Bitmap); 
 
    // Fill in the BITMAPINFOHEADER appropriately 
 
    bi.biSize               = sizeof(BITMAPINFOHEADER); 
    bi.biWidth              = Bitmap.bmWidth; 
    bi.biHeight             = Bitmap.bmHeight; 
    bi.biPlanes             = 1; 
    bi.biBitCount           = NewBPP; 
    bi.biCompression        = NewComp; 
    bi.biSizeImage          = 0; 
    bi.biXPelsPerMeter      = 0; 
    bi.biYPelsPerMeter      = 0; 
    bi.biClrUsed            = 0; 
    bi.biClrImportant       = 0; 
 
    // Go allocate room for the new DIB 
 
    hNewDIB = AllocRoomForDIB(bi, hBitmap , hwnd); 
    if (!hNewDIB) 
        return NULL; 
 
    // Get a pointer to the new DIB 
 
    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hNewDIB); 
 
    // If we have a palette, get a DC and select/realize it 
 
    if (hPal) 
    { 
 			hDC = CreateDC ( TEXT("DISPLAY"), NULL, NULL, NULL );
					hOldPal = SelectPalette(hDC, hPal, false); 
					RealizePalette(hDC); 
    } 
 
    // Call GetDIBits and get the new DIB bits 
 
    if (!GetDIBits(hDC, hBitmap, 0, (UINT) lpbi->biHeight, (LPSTR)lpbi + 
            (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi, 
            DIB_RGB_COLORS)) 
    { 
        GlobalUnlock(hNewDIB); 
        GlobalFree(hNewDIB); 
        hNewDIB = NULL; 
    } 
 
    // Clean up and return 
 
    if (hOldPal) 
    { 
        SelectPalette(hDC, hOldPal, true); 
        RealizePalette(hDC); 
		::ReleaseDC(hwnd, hDC);
     } 
 
    // Unlock the new DIB's memory block 
 
    if (hNewDIB) 
        GlobalUnlock(hNewDIB); 
 
    return hNewDIB; 
}
*/
WORD CScanTracDlg::PaletteSize (VOID FAR * pv) 
{     
	LPBITMAPINFOHEADER lpbi;     
	WORD NumColors;      
	lpbi      = (LPBITMAPINFOHEADER)pv;     
	NumColors = DibNumColors(lpbi);      
	if (lpbi->biSize == sizeof(BITMAPCOREHEADER))         
		return NumColors * sizeof(RGBTRIPLE);     
	else         
		return NumColors * sizeof(RGBQUAD); 
} 

WORD CScanTracDlg::SaveDIB(HANDLE hDib, LPWSTR lpFileName)
{
	BITMAPFILEHEADER    bmfHdr;     // Header for Bitmap file     
	LPBITMAPINFOHEADER  lpBI;       // Pointer to DIB info structure     
	HANDLE              fh;         // file handle for opened file     
	DWORD               dwDIBSize;     
	DWORD               dwWritten;      

	if (!hDib)         
		return ERR_INVALIDHANDLE;  
	
   fh = CreateFile(lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL);      
   
   if (fh == INVALID_HANDLE_VALUE)         
	 {
			ReportErrorMessage("Could not access Server to write Screen Shot File",cEMailMaintenance, 0);
		 return ERR_OPEN;      
	 }
   // Get a pointer to the DIB memory, the first of which contains     
   // a BITMAPINFO structure      
   lpBI = (LPBITMAPINFOHEADER)GlobalLock(hDib);     
   if (!lpBI)     
   {         
		 CloseHandle(fh);         
		 return ERR_LOCK;     
	 }     
	// Check to see if we're dealing with an OS/2 DIB.  If so, don't     
	// save it because our functions aren't written to deal with these     
	// DIBs.  
   if (lpBI->biSize != sizeof(BITMAPINFOHEADER))     
   {         
		 GlobalUnlock(hDib);         
		 CloseHandle(fh);         
		 return ERR_NOT_DIB;     
	 }      
	// Fill in the fields of the file header      
	// Fill in file type (first 2 bytes must be "BM" for a bitmap)      
	bmfHdr.bfType = DIB_HEADER_MARKER;  // "BM" 

  dwDIBSize = *(LPDWORD)lpBI + PaletteSize((LPSTR)lpBI);        
 // Now calculate the size of the image      
 // It's an RLE bitmap, we can't calculate size, so trust the biSizeImage     
 // field      
 
  if ((lpBI->biCompression == BI_RLE8) || (lpBI->biCompression == BI_RLE4))         
    dwDIBSize += lpBI->biSizeImage;     
   else     
	 {         
			DWORD dwBmBitsSize;  
			// Size of Bitmap Bits only          
			// It's not RLE, so size is Width (DWORD aligned) * Height          
			dwBmBitsSize = WIDTHBYTES((lpBI->biWidth)*((DWORD)lpBI->biBitCount)) * lpBI->biHeight;          
			dwDIBSize += dwBmBitsSize;          
			// Now, since we have calculated the correct size, why don't we         
			// fill in the biSizeImage field (this will fix any .BMP files which          
			// have this field incorrect).          
			lpBI->biSizeImage = dwBmBitsSize;     
	 }       
 
  // Calculate the file size by adding the DIB size to sizeof(BITMAPFILEHEADER)                         
  bmfHdr.bfSize = dwDIBSize + sizeof(BITMAPFILEHEADER);     
  bmfHdr.bfReserved1 = 0;     
  bmfHdr.bfReserved2 = 0;      
 
  // Now, calculate the offset the actual bitmap bits will be in     
  // the file -- It's the Bitmap file header plus the DIB header,     
  // plus the size of the color table.          
 
 bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + lpBI->biSize + PaletteSize((LPSTR)lpBI);      
 
 // Write the file header      
 
 WriteFile(fh, (LPSTR)&bmfHdr, sizeof(BITMAPFILEHEADER), &dwWritten, NULL);      
 
 // Write the DIB header and the bits -- use local version of     
  // MyWrite, so we can write more than 32767 bytes of data          
 
 WriteFile(fh, (LPSTR)lpBI, dwDIBSize, &dwWritten, NULL);      
 GlobalUnlock(hDib);     
 CloseHandle(fh);      
 
 if (dwWritten == 0)         
   return ERR_OPEN; 
 
 // oops, something happened in the write     
  else         
    return 0; // Success code  
}

WORD CScanTracDlg::DibNumColors (VOID FAR * pv)
{     
	int bits;     
	LPBITMAPINFOHEADER lpbi;     
	LPBITMAPCOREHEADER lpbc;      
	lpbi = ((LPBITMAPINFOHEADER)pv);     
	lpbc = ((LPBITMAPCOREHEADER)pv);      
	
	/*  With the BITMAPINFO format headers, the size of the palette      
	*  is in biClrUsed, whereas in the BITMAPCORE - style headers, it      
	*  is dependent on the bits per pixel ( = 2 raised to the power of      
	*  bits/pixel).      
	*/     
	
	if (lpbi->biSize != sizeof(BITMAPCOREHEADER))     
	{         
		if (lpbi->biClrUsed != 0)             
			return (WORD)lpbi->biClrUsed;         
	
		bits = lpbi->biBitCount;     
	}     
	else         
		bits = lpbc->bcBitCount;      
	
	switch (bits)     
	{     
		case 1:         
			return 2;     
		case 4:         

			return 16;     
		case 8:         
			return 256;     
		default:         
			//  A 24 bitcount DIB has no color table          
			return 0;     

	} 
}

/*
HANDLE CScanTracDlg::AllocRoomForDIB(BITMAPINFOHEADER bi, HBITMAP hBitmap , HWND hwnd) 
{ 
    DWORD               dwLen; 
    HANDLE              hDIB; 
    HDC                 hDC; 
    LPBITMAPINFOHEADER  lpbi; 
    HANDLE              hTemp; 
 
    // Figure out the size needed to hold the BITMAPINFO structure 
    // (which includes the BITMAPINFOHEADER and the color table). 
 
    dwLen = bi.biSize + PaletteSize((LPSTR) &bi); 
    hDIB  = GlobalAlloc(GHND,dwLen); 
 
    // Check that DIB handle is valid 
 
    if (!hDIB) 
        return NULL; 
 
    // Set up the BITMAPINFOHEADER in the newly allocated global memory, 
    // then call GetDIBits() with lpBits = NULL to have it fill in the 
    // biSizeImage field for us. 
 
    lpbi  = (LPBITMAPINFOHEADER)GlobalLock(hDIB); 
    *lpbi = bi; 
 
    hDC = CreateDC ( TEXT("DISPLAY"), NULL, NULL, NULL );
 
    GetDIBits(hDC, hBitmap, 0, (UINT) bi.biHeight, NULL, (LPBITMAPINFO)lpbi, 
            DIB_RGB_COLORS); 
 	::ReleaseDC(hwnd, hDC);
 
 
    // If the driver did not fill in the biSizeImage field, 
    // fill it in -- NOTE: this is a bug in the driver! 
     
    if (lpbi->biSizeImage == 0) 
        lpbi->biSizeImage = WIDTHBYTES((DWORD)lpbi->biWidth * 
                lpbi->biBitCount) * lpbi->biHeight; 
 
    // Get the size of the memory block we need 
 
    dwLen = lpbi->biSize + PaletteSize((LPSTR) &bi) + lpbi->biSizeImage; 
 
    // Unlock the memory block 
 
    GlobalUnlock(hDIB); 
 
    // ReAlloc the buffer big enough to hold all the bits  
 
    if (hTemp = GlobalReAlloc(hDIB,dwLen,0)) 
		{
        return hTemp; 
		}
    else 
    { 
        // Else free memory block and return failure 
 
        GlobalFree(hDIB); 
        return NULL; 
    } 
} 
*/


HPALETTE CScanTracDlg::GetSystemPalette(HWND hwnd) 
{ 
    HDC hDC;                // handle to a DC 
    static HPALETTE hPal = NULL;   // handle to a palette 
    HANDLE hLogPal;         // handle to a logical palette 
    LPLOGPALETTE lpLogPal;  // pointer to a logical palette 
    int nColors;            // number of colors 
 
    // Find out how many palette entries we want. 

    hDC = CreateDC ( TEXT("DISPLAY"), NULL, NULL, NULL );
 
    if (!hDC) 
        return NULL; 
	 
    nColors = 256; //PalEntriesOnDevice(hDC);   // Number of palette entries 
 
    // Allocate room for the palette and lock it. 
 
    hLogPal = GlobalAlloc(GHND, sizeof(LOGPALETTE) + nColors * 
            sizeof(PALETTEENTRY)); 
 
    // if we didn't get a logical palette, return NULL 
 
    if (!hLogPal) 
        return NULL; 
 
    // get a pointer to the logical palette 
 
    lpLogPal = (LPLOGPALETTE)GlobalLock(hLogPal); 
 
    // set some important fields 
 
    lpLogPal->palVersion = 0x300; //PALVERSION; 
    lpLogPal->palNumEntries = nColors; 
 
    // Copy the current system palette into our logical palette 
 
    GetSystemPaletteEntries(hDC, 0, nColors, 
            (LPPALETTEENTRY)(lpLogPal->palPalEntry)); 
 
    // Go ahead and create the palette.  Once it's created, 
    // we no longer need the LOGPALETTE, so free it.     
 
    hPal = CreatePalette(lpLogPal); 
 
    // clean up 
 
    GlobalUnlock(hLogPal); 
    GlobalFree(hLogPal); 
//	::ReleaseDC(hwnd, hDC);
		DeleteDC(hDC);		//kjh

    return hPal; 
} 

/*
void CScanTracDlg::WindowCapture(HWND wnd)
{

	HBITMAP hBitmap = CopyWindowToBitmap(this , wnd, 1);

    HPALETTE hPal = NULL;
    if (hBitmap) 
	{
//       hPal = GetSystemPalette(); 
	   ghBitmap = hBitmap;
     gbDrawImage = true;
	   gbIsCaptured = true;
	   CRect rect;
	   GetClientRect(&rect);
	   InvalidateRect(rect);
//	   CCapITDoc* pDoc = GetDocument();
	   DoSize(FromHandle(this->m_hWnd) ,hBitmap);

	   UpdateCaptureStatus(true);

    }
    else 
	{	
		gbIsCaptured = false;
		hPal = NULL; 

	   AfxMessageBox("Sorry !!!!");
	}
}
*/
/*
void CScanTracDlg::UpdateCaptureStatus(BOOL bCaptured)
{
//	CMainFrame* frame = (CMainFrame*)AfxGetMainWnd();
//	frame->g_mbImageCaptured = bCaptured;
}
*/

/*
void CScanTracDlg::DoSize(CWnd* wnd , HBITMAP ghBitmap)
{
    BITMAP      bm;                     // Bitmap info structure 
    int         cxBitmap=0, cyBitmap=0; // Bitmap width and height 
//    int         cxScroll, cyScroll;     // Scroll positions 
    RECT        rect;                   // Client rectangle 
 
    // repaint if displaying bitmap 
 
    if (ghBitmap) 
    { 
        // Get info about bitmap 
 
        GetObject(ghBitmap, sizeof(BITMAP), (LPSTR)&bm); 
 
        // Get the width and height of the bitmap 

//		CSize sizeTotal;
		// TODO: calculate the total size of this view
//		sizeTotal.cx = bm.bmWidth;
//		sizeTotal.cy = bm.bmHeight;
//		SetScrollSizes(MM_TEXT, sizeTotal);		

        cxBitmap = bm.bmWidth; 
        cyBitmap = bm.bmHeight; 
 
        // Find out the dimensions of the window, and the current thumb 
        // positions 
 
        wnd->GetClientRect(&rect); 
 
//        cxScroll = wnd->GetScrollPos (SB_HORZ); 
 //       cyScroll = wnd->GetScrollPos (SB_VERT); 
 
        // If current thumb positions would cause blank space 
        // at right or bottom of client area, repaint 
 
 //       if (cxScroll + rect.right > cxBitmap || 
 //               cyScroll + rect.bottom > cyBitmap) 
 //           wnd->InvalidateRect(NULL, false); 
 
        // Make sure scroll bars are updated 
 
//        SetupScrollBars(wnd , (WORD)cxBitmap, (WORD)cyBitmap); 
    } 
    else //if (bStartup) 
        wnd->InvalidateRect(NULL, true); 
}
*/

/*
HBITMAP CScanTracDlg::CopyWindowToBitmap(CWnd* wnd , HWND hWnd, WORD fPrintArea)
{
	HBITMAP     hBitmap = NULL;  // handle to device-dependent bitmap      
	// check for a valid window handle      
	if (!hWnd)         
	    return NULL; 

    RECT    rectWnd; 
  ::GetWindowRect(hWnd, &rectWnd);  
	

	switch (fPrintArea)     
	{         
		case 1: //PW_WINDOW: // copy entire window         
		{             
          // get the window rectangle              
          // get the bitmap of that window by calling             
		  // CopyScreenToBitmap and passing it the window rect                     
//		  GetWindowRect(&rectWnd);
          hBitmap = CopyScreenToBitmap(&rectWnd);             
		  break;         
		}   
//       case PW_CLIENT: // copy client area         
//	   {             
//	     RECT rectClient;             
//	     POINT pt1, pt2;              // get client dimensions              
//	     wnd->GetClientRect(&rectClient);              // convert client coords to screen coords              
//	     pt1.x = rectClient.left;             
//	     pt1.y = rectClient.top;             
//	     pt2.x = rectClient.right;             
//	     pt2.y = rectClient.bottom;             
//	     wnd->ClientToScreen(&pt1);             
//	     wnd->ClientToScreen(&pt2);             
//	     rectClient.left = pt1.x;             
//	     rectClient.top = pt1.y;             
//	     rectClient.right = pt2.x;             
//	     rectClient.bottom = pt2.y;  
//
//         // get the bitmap of the client area by calling             
//	     // CopyScreenToBitmap and passing it the client rect                          
//	     hBitmap = CopyScreenToBitmap(&rectClient);             
//	     break;         
//	   }               
	   default:    // invalid print area             
	        return NULL;     
	}      // return handle to the bitmap     
	
	return hBitmap; 
}
*/


/*
HBITMAP CScanTracDlg::CopyScreenToBitmap(LPRECT lpRect)
{
	HDC         hScrDC, hMemDC;         // screen DC and memory DC     
//	HBITMAP     hBitmap; //, 
//	HBITMAP     hBitmap;
//	HBITMAP     hOldBitmap;    // handles to deice-dependent bitmaps     
	int         nX, nY, nX2, nY2;       // coordinates of rectangle to grab     
	int         nWidth, nHeight;        // DIB width and height     
	int         xScrn, yScrn;           // screen resolution      

	HGDIOBJ     hOldBitmap , hBitmap;
		
		// check for an empty rectangle 
    if (IsRectEmpty(lpRect))       
	   return NULL;      
	   // create a DC for the screen and create     
	   // a memory DC compatible to screen DC          

   hScrDC = CreateDC("DISPLAY", NULL, NULL, NULL);     
   hMemDC = CreateCompatibleDC(hScrDC);      // get points of rectangle to grab  
   
   nX = lpRect->left;     
   nY = lpRect->top;     
   nX2 = lpRect->right;     
   nY2 = lpRect->bottom;      // get screen resolution      
   
   xScrn = GetDeviceCaps(hScrDC, HORZRES);     
   yScrn = GetDeviceCaps(hScrDC, VERTRES);      
   
   //make sure bitmap rectangle is visible      
   
   if (nX < 0)         
	  nX = 0;     
   
   if (nY < 0)         
      nY = 0;     
   
   if (nX2 > xScrn)         
      nX2 = xScrn;     
   
   if (nY2 > yScrn)         
      nY2 = yScrn;      

   nWidth = nX2 - nX;     
   nHeight = nY2 - nY;      
   
   // create a bitmap compatible with the screen DC     
   
   hBitmap = CreateCompatibleBitmap(hScrDC, nWidth, nHeight);      
   
   // select new bitmap into memory DC     
   
   hOldBitmap =   SelectObject (hMemDC, hBitmap);      
   
   // bitblt screen DC to memory DC     
   
   BitBlt(hMemDC, 0, 0, nWidth, nHeight, hScrDC, nX, nY, SRCCOPY);     
   
   // select old bitmap back into memory DC and get handle to     
   // bitmap of the screen          
   
   hBitmap = SelectObject(hMemDC, hOldBitmap);      
   
   // clean up      
   
   DeleteDC(hScrDC);     
   DeleteDC(hMemDC);      
   
   // return handle to the bitmap      
   
   return (HBITMAP)hBitmap; 

}
*/
//DRIVE_LAYOUT_INFORMATION
/*
BOOL DeviceIoControl(
  (HANDLE) hDevice,            // handle to device
  IOCTL_DISK_GET_DRIVE_LAYOUT, // dwIoControlCode operation
  NULL,                        // lpInBuffer; must be NULL
  0,                           // nInBufferSize; must be zero
  (LPVOID) lpOutBuffer,        // output buffer
  (DWORD) nOutBufferSize,      // size of output buffer
  (LPDWORD) lpBytesReturned,   // number of bytes returned
  (LPOVERLAPPED) lpOverlapped  // OVERLAPPED structure
);
*/

/* reference
http://us.generation-nt.com/answer/fail-get-drive-information-deviceiocontrol-help-24864692.html
*/	
double DetermineHardDiskSize(CString TempCheckDirectory)	// 
{
// below works with FBWF or normal mode
	double DiskSize = 0;		// return 0 if fail
// hard drive size
	HANDLE hdevice;

	if (TempCheckDirectory == "D:\\")
	{
		hdevice=CreateFile(_T("\\\\.\\D:"),												// handle to c: could use //	hdevice=CreateFile("\\\\.\\PhysicalDrive0",	
				GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ |
				FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	}
	else if (TempCheckDirectory == "E:\\")
	{
		hdevice=CreateFile(_T("\\\\.\\E:"),												// handle to c: could use //	hdevice=CreateFile("\\\\.\\PhysicalDrive0",	
				GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ |
				FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	}
	else if (TempCheckDirectory == "F:\\")
	{
		hdevice=CreateFile(_T("\\\\.\\F:"),												// handle to c: could use //	hdevice=CreateFile("\\\\.\\PhysicalDrive0",	
				GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ |
				FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	}
	else
	{
//	hdevice=CreateFile("\\\\.\\PhysicalDrive0",					// handle to first physical drive of the computer
//			GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ |
//			FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);

		hdevice=CreateFile(_T("\\\\.\\C:"),												// handle to c: could use //	hdevice=CreateFile("\\\\.\\PhysicalDrive0",	
				GENERIC_READ | GENERIC_WRITE, FILE_SHARE_READ |
				FILE_SHARE_WRITE, NULL, OPEN_EXISTING, 0, NULL);
	}

	DWORD buffersize = 128;
	DWORD bytesreturned;
	DWORD * ptrbytesreturned = &bytesreturned;

//	DRIVE_LAYOUT_INFORMATION	InfoLayout = malloc( buffersize );
	DRIVE_LAYOUT_INFORMATION *drivelayout = (DRIVE_LAYOUT_INFORMATION*) malloc( buffersize );

	BOOL LoopOK = true;
	int LoopCnt = 0;

	if (drivelayout)
	if ((hdevice != NULL) && (hdevice != INVALID_HANDLE_VALUE)) // ( && (hdevice != 0))
	{
//		BOOL bresult=DeviceIoControl(hdevice,IOCTL_DISK_GET_DRIVE_LAYOUT, NULL, 0, drivelayout, sizeof(drivelayout), &size, NULL);

		DWORD bytesreturned = 0;

		// loop til we get the buffer size right 
		while( (LoopOK) && (LoopCnt < 6) && (!DeviceIoControl( hdevice, IOCTL_DISK_GET_DRIVE_LAYOUT,NULL, 0, drivelayout, buffersize,	ptrbytesreturned, 0 )) )
		{
			if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
			{
			// uh-oh ... some other error 
				LoopOK = false;
// free below				free( drivelayout );
			}
			else
			{
				buffersize += 4*sizeof( PARTITION_INFORMATION );
				free( drivelayout );
				drivelayout = (DRIVE_LAYOUT_INFORMATION*) malloc( buffersize );
				LoopCnt++;
			}
		}
		if ((LoopOK) && (LoopCnt < 6))
		{
			LARGE_INTEGER PartLength;

			PartLength = drivelayout->PartitionEntry[0].PartitionLength;
			LONGLONG ValueDiskSize64 = 0;
			ValueDiskSize64 = (long)PartLength.HighPart;
			ValueDiskSize64 <<= 32;		//shift ms part over
			ValueDiskSize64 += PartLength.LowPart ;

			DiskSize = (double)ValueDiskSize64;
		}
	}

	if (drivelayout)
		free(drivelayout);
	CloseHandle(hdevice); 		// close file

	return (DiskSize);
}

WORD CScanTracDlg::CalculateMaximumEncoderRate(WORD TempProductIntegrationTime)
{
	double TempMaximumEncoderRate = 1000; 

	double TempReadoutOverhead = .00011; //overhead is time to read out the pixels.
	if (vConfigurationData->vPixelsPerDetector == 128) //if .4 mm mode, need twice as much time to read out the pixels
		TempReadoutOverhead = TempReadoutOverhead * 2;

	if (TempProductIntegrationTime)
		TempMaximumEncoderRate = TempMaximumEncoderRate = 1 / (((TempProductIntegrationTime * .0004) / 1000) + TempReadoutOverhead); 
	//convert Integration code to mSec then to Maximum Rate, readout is .11 mSec overhead to read out detectors over integration time

	if (TempMaximumEncoderRate > 50000)
		TempMaximumEncoderRate = 50000;

	return (WORD)TempMaximumEncoderRate;
}

// get network card and set nt/xp flag
bool GetNetworkCardName(void)
{
	LONG TempErrorCode;
	CRegKey TempRegistryKey;
	unsigned long int TempCount = 500;
	LPTSTR TempBuffer = _T("");
	BOOL RecordID = false;
	unsigned int i,j;

	const char SavedTcpipRegistryLocation[100] = "SYSTEM\\CurrentControlSet\\Services\\TCPIP\\Parameters\\Interfaces\\";
	unsigned int CharsInRegistryLocationString = 62;

// Key Bind = 	\Device\{2D4E55F0-2D5F-4E82-9715-15F0CB798A86}\Device\NdisWanIp
// Key Export = \Device\Tcpip_{2D4E55F0-2D5F-4E82-9715-15F0CB798A86}
//							\Device\Tcpip_{43A0D974-F014-4FFE-88FE-D7A4EED2BFFC}
//							\Device\Tcpip_{528D97D1-7DF6-474E-B50D-1CFBA8EDB946}
// Key Route =	"{2D4E55F0-2D5F-4E82-9715-15F0CB798A86}""NdisWanIp"

	vGlobalRegistryTCPIPKeyPath = "0";		// set network ID to null, if ID found set to actual value

	TempErrorCode = TempRegistryKey.Open(HKEY_LOCAL_MACHINE, _T("System\\CurrentControlSet\\Services\\Tcpip\\Linkage"),KEY_ALL_ACCESS );
	if (TempErrorCode == ERROR_SUCCESS)
	{
		TempErrorCode = TempRegistryKey.QueryStringValue(_T("Bind"), TempBuffer, &TempCount);
		if (TempErrorCode == ERROR_SUCCESS)
		{
			if (TempCount > 500)
				TempCount = 500;
			for (i = 0; i < TempCount; i++)
			{
				wchar_t a = TempBuffer[i];
				if (a == '{')
				{
					RecordID = true;
					j = CharsInRegistryLocationString;
				}
				if (RecordID)
				{
					vGlobalRegistryTCPIPKeyPath.SetAt(j, a);
					j++;
				}
				if (a == '}')
				{
					vGlobalRegistryTCPIPKeyPath.SetAt(j, '0');
					break;
				}
			}
			for (i = 0; i<CharsInRegistryLocationString; i++)
			{
				vGlobalRegistryTCPIPKeyPath.SetAt(i, SavedTcpipRegistryLocation[i]);
			}

		}
	}
	TempRegistryKey.Close();

	return((TempErrorCode == ERROR_SUCCESS) && RecordID);		//return if successful key open
}

void CScanTracDlg::SendPreAmpGain(BYTE TempPreAmplifierGain)
{
	tSerialCommand TempCommand;
	TempCommand[0] = 0x23;
	TempCommand[1] = 0xC6; //pre amplifier gain Right Image
	TempCommand[2] = 0; 
	TempCommand[3] = TempPreAmplifierGain;  
	vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);

	if (vConfigurationData->vNumberOfXRayDetectors > 6) //Forte = 12 and Case Inspector = 9
	{
		TempCommand[1] = 0xD0; //pre amplifier gain Left Image
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);
	}

	if (vConfigurationData->vScanTracType == cCaseInspectorScanTrac)
	{
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->StartMiddleBeamControl();

		tSerialCommand TempCommand;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xD0; //pre amplifier gain Middle Image
		TempCommand[2] = 0; 
		TempCommand[3] = TempPreAmplifierGain;  
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime);

		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->EndMiddleBeamControl();
	}
}

double CalculateStandardDeviation(double *TempDataArray, DWORD TempNumberOfElements, double *TempAverage)
{
	double TempSum = 0;
	double *TempPointer = TempDataArray;
	for (DWORD TempLoop = 0; TempLoop < TempNumberOfElements; TempLoop++)
	{
		TempSum = TempSum + *TempPointer;
		TempPointer++;
	}
	if (TempNumberOfElements)
		*TempAverage = TempSum / TempNumberOfElements;

	double TempTotalVariance = 0;
	double TempThisVariance = 0;
	TempPointer = TempDataArray;
	for (DWORD TempLoop = 0; TempLoop < TempNumberOfElements; TempLoop++)
	{
		TempThisVariance = *TempPointer - *TempAverage;
		TempTotalVariance = TempTotalVariance + (TempThisVariance * TempThisVariance);
		TempPointer++;
	}

	double TempVariance = 0;
	if (TempNumberOfElements > 1)
		TempVariance = TempTotalVariance / (TempNumberOfElements - 1);
	double TempStandardDeviation = sqrt(TempVariance);
	return TempStandardDeviation;
}

double CalculateStandardDeviation(BYTE *TempDataArray, DWORD TempNumberOfElements, double *TempAverage)
{
	double TempStandardDeviation = 0;
	*TempAverage = 0;

	if (TempNumberOfElements > 1)
	{
		double TempSum = 0;
		double TempTotalVariance = 0;
		double TempThisVariance = 0;
		BYTE *TempPointer = TempDataArray;
		for (DWORD TempLoop = 0; TempLoop < TempNumberOfElements; TempLoop++)
		{
			TempSum = TempSum + *TempPointer;
			TempPointer++;
		}
		*TempAverage = TempSum / TempNumberOfElements;

		TempPointer = TempDataArray;
		for (DWORD TempLoop = 0; TempLoop < TempNumberOfElements; TempLoop++)
		{
			TempThisVariance = *TempPointer - *TempAverage;
			TempTotalVariance = TempTotalVariance + (TempThisVariance * TempThisVariance);
			TempPointer++;
		}

		double TempVariance =  TempTotalVariance / (TempNumberOfElements - 1);
		TempStandardDeviation = sqrt(TempVariance);
	}
	return TempStandardDeviation;
}

// return call succeed or falled
ULONG MemoryUsageFBWFCheck(void)
{
	DWORD dwRetVal = 0;
	CString TempCString = "";

	ULONG vUsedSpace;
	ULONG vTotalSpace;
	ULONG vTotalNextSpace;
	ULONG vAvailableSpace;

	struct FbwfMemoryUsage
	{
		 ULONG currentCacheThreshold; // Cache threshold in bytes for the current session. 
		 ULONG nextCacheThreshold;		// Cache threshold in bytes for the next session
		 ULONG dirStructure;					// Memory in bytes used to store directory structure
		 ULONG fileData;							// Memory in bytes used to cache file data
	};

	//does FBWF manager exist on this system
	CString TempFileName = "\\WINDOWS\\system32\\fbwfmgr.exe";

	CFileStatus TempFileStatus;

	if ((CFile::GetStatus(TempFileName, TempFileStatus)) && vGlobalFBWFEnable)
	{

		FbwfMemoryUsage MemoryUsageStructure;
		FbwfMemoryUsage * ptrMemoryUsageStructure = &MemoryUsageStructure ;

			typedef ULONG (CALLBACK* mytry) (FbwfMemoryUsage * );
			mytry NewFbwfGetMemoryUsage;    // Function pointer

		// free Library is causing an MFC exception error.  Load Library once when start, make a global
		//	HMODULE hLibNetwork = LoadLibrary( ("fbwflib.dll")); // file name of module
		//	HINSTANCE hLibNetwork = LoadLibrary( ("fbwflib.dll")); // file name of module

			// if library not loaded try to load
			if (vGlobalhLibFBWFNetwork == NULL)
			{
				vGlobalhLibFBWFNetwork = LoadLibrary(_T("fbwflib.dll")); // file name of module
			}

			if (vGlobalhLibFBWFNetwork != NULL)
			{
				LPCSTR lpProcName = "FbwfGetMemoryUsage";		// handle to DLL module // function name		 
				NewFbwfGetMemoryUsage = (mytry)GetProcAddress(vGlobalhLibFBWFNetwork,lpProcName);   

				if (NewFbwfGetMemoryUsage != NULL)
				{
					dwRetVal = NewFbwfGetMemoryUsage(ptrMemoryUsageStructure);

					if (dwRetVal == NO_ERROR)
					{
						vTotalSpace = (MemoryUsageStructure.currentCacheThreshold)/(1024*1024);		//mbyte 
						vTotalNextSpace = (MemoryUsageStructure.nextCacheThreshold)/(1024*1024); //mbyte
						vUsedSpace = (MemoryUsageStructure.dirStructure + MemoryUsageStructure.fileData)/(1024*1024); //mbyte  
						vAvailableSpace = vTotalSpace - vUsedSpace ; // 

						if ((vTotalSpace == 0))
						{
							ReportErrorMessage("FBWF Overlay Size Total read fail",cEMailInspx,32000);
						}
						else if (((vAvailableSpace * 100)/vTotalSpace) <= 20)		// 20% of FBWF left
						{
							CString vNumberStrings = " ";
//debug							vNumberStrings.Format(_T(" %ld, %ld, %ld"),vUsedSpace, vAvailableSpace, vTotalSpace);
							vNumberStrings = " ";
							ReportErrorMessage("Protected Drive almost full, Call Service" + vNumberStrings,cEMailInspx,32000);
							ReportErrorMessage("FBWF almost full, Commit some files in FBWF " + vNumberStrings,cEMailInspx,32000);
						}
					}
					else
					{
						ReportErrorMessage("FBWF Overlay Size Read fail",cEMailInspx,32000);
					}
				}
			}		
	} //end FBWF exits on system

	return(dwRetVal);
}

bool CScanTracDlg::PowerWiringOK()
{
	bool TempOK = true;
	if ((vGlobalACPowerMoniter) && (!vGlobalACPowerMoniter->vNoCommunications) && (vSystemData.vHadAPowerMoniterMessageError & 0x2008))
	{
		TempOK = false;
		if (vSystemData.vHadAPowerMoniterMessageError & 0x2008)
		{
			ReportErrorMessage("A/C Power Wiring Hot/Neutral reversed, Can not run X-Rays", cCritical, 0);
			ReportErrorMessage("A/C Power Wiring Hot/Neutral reversed, Can not run X-Rays", cError, 0);
		}
		else
		{
			ReportErrorMessage("A/C Power Wiring Open Ground, Can not run X-Rays", cCritical, 0);
			ReportErrorMessage("A/C Power Wiring Open Ground, Can not run X-Rays", cError, 0);
		}
	}
	return TempOK;
}

void CScanTracDlg::OnNewImageKey()
{
	ShowSupportPhoneNumber();

}
/*
void CScanTracDlg::TestingOnlySendSourceCurrentToUController()
{
	//Send X-Ray Current
	double TempCurrent = 0;

	CNumericEntryDialog INumericEntryDialog;  
	
	INumericEntryDialog.vEditString = dtoa(vConfigurationData->vSystemBodyTriggerToXRayBeam, 2);

	//Set dialog box data titles and number value
	INumericEntryDialog.m_DialogTitleStaticText1 = "Enter Test Current ";
	INumericEntryDialog.m_DialogTitleStaticText2 = "Used to test error messages";
	INumericEntryDialog.m_UnitsString = "";

	INumericEntryDialog.m_DialogTitleStaticText3 = "";
	INumericEntryDialog.m_DialogTitleStaticText4 = "";

	INumericEntryDialog.vMaxValue = 100;
	INumericEntryDialog.vMinValue = 0;
	INumericEntryDialog.vIntegerOnly = false;
	//Pass control to dialog box and display
	int nResponse = INumericEntryDialog.DoModal();
	//dialog box is now closed, if user pressed select do this
	//if user pressed cancel, do nothing
	if (nResponse == IDOK)
	{
		TempCurrent = ATOF(INumericEntryDialog.vEditString);
	}

	double TempDouble = TempCurrent;
	if (TempDouble < 0)
		TempDouble = 0;

	double TempMaxValue = GetMaximumCurrentFromVoltage(vSystemData.vRampXRayVoltageAmount * 6);
	if (TempMaxValue > vConfigurationData->vMaximumCurrent)
		TempMaxValue = vConfigurationData->vMaximumCurrent;

	double TempMaxCurrentFromPower = GetMaximumCurrentFromPower(vSystemData.vRampXRayVoltageAmount * 6,
		vConfigurationData->vMaximumPower);
	if (TempMaxValue > TempMaxCurrentFromPower)
		TempMaxValue = TempMaxCurrentFromPower;

	if (TempDouble > TempMaxValue)
		TempDouble = TempMaxValue;

	ReportErrorMessage("Testing Set X-Ray Current to: " + dtoa(TempCurrent,2), cAction,0);
	if (vGlobalDXMXRayPort)
	{
		vGlobalDXMXRayPort->SetXRayCurrent(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempDouble == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayCurrent(TempDouble);
	}
	else
	if (vGlobalMonoBlockXRayPort)
	{
		vGlobalMonoBlockXRayPort->SetXRayCurrent(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempCurrent == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayCurrent(TempDouble);
	}
	else
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->SetXRayCurrent(TempDouble);
	}
}

void CScanTracDlg::TestingOnlySendSourceVoltageToUController()
{
	//Send X-Ray Current
	double TempVoltage = 0;

	CNumericEntryDialog INumericEntryDialog;  
	
	INumericEntryDialog.vEditString = dtoa(vConfigurationData->vSystemBodyTriggerToXRayBeam, 2);

	//Set dialog box data titles and number value
	INumericEntryDialog.m_DialogTitleStaticText1 = "Enter Test Voltage";
	INumericEntryDialog.m_DialogTitleStaticText2 = "Used to Test Error Messages";
	INumericEntryDialog.m_UnitsString = "";

	INumericEntryDialog.m_DialogTitleStaticText3 = "";
	INumericEntryDialog.m_DialogTitleStaticText4 = "";

	INumericEntryDialog.vMaxValue = 100;
	INumericEntryDialog.vMinValue = 0;
	INumericEntryDialog.vIntegerOnly = false;
	//Pass control to dialog box and display
	int nResponse = INumericEntryDialog.DoModal();
	//dialog box is now closed, if user pressed select do this
	//if user pressed cancel, do nothing
	if (nResponse == IDOK)
	{
		TempVoltage = ATOF(INumericEntryDialog.vEditString) / 6;
	}

	double TempDouble = TempVoltage;
	if (vGlobalDXMXRayPort)
	{
		vGlobalDXMXRayPort->SetXRayVoltage(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempVoltage == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayVoltage(TempDouble);
	}
	else
	if (vGlobalMonoBlockXRayPort)
	{
		vGlobalMonoBlockXRayPort->SetXRayVoltage(TempDouble);
		//must program XLF interface or uController will not indicate ready to run
		if (TempVoltage == 0)
		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SetXRayVoltage(TempDouble);
	}
	else
	if (vGlobaluCSerialPort)
	{
		vGlobaluCSerialPort->SetXRayVoltage(TempDouble);
	}

}
*/

//void CScanTracDlg::CheckForHalconLibrary()
//{
//	vGlobalUseHalconLibrary = false;
	
//#ifdef UseHalconLibraries
//	CString TempFileName = "c:\\Program Files\\MVTec";
//
//	CFileStatus TempFileStatus;
//
//	if ((CFile::GetStatus(TempFileName, TempFileStatus)))
//	{
//		vGlobalUseHalconLibrary = true;
//		Hobject TempHalconImage;
//		Herror TempResult = gen_image_const(&TempHalconImage, "byte", 1, 1);
//
//		if ((TempResult ==  2036) || (TempResult ==  2042))
//		{
//			ReportErrorMessage("Halcon Library Present, but no License, Trying MVTools", cError, 0);
//			vGlobalUseHalconLibrary = false;
//		}
//	}
//#endif
//}

//#ifdef UseHalconLibraries
//void ScanTracHalconExceptionHandler(const Halcon::HException& except)
//{
//	CString TempText = "Halcon Error: ";
//	ReportErrorMessage(TempText + except.message, cError, 32000);
//}
//#endif

void CScanTracDlg::SaveIPSettingsInConfigurationData()
{
	vConfigurationData->vIPAddressString = vGlobalIPAddressString;
	vConfigurationData->vIPSubNetMaskString = vGlobalIPSubNetMaskString;
	vConfigurationData->vIPDefaultGatewayString = vGlobalIPDefaultGatewayString;
	vConfigurationData->vIPDefaultDNSAddressString = vGlobalIPDNSAddressString1;
	vConfigurationData->vIPDHCPEnabled = vGlobalIPDHCPEnabled;

	WriteConfigurationDataToFile(false);
}

typedef bool (WINAPI *myGetCoreTempInfo)(CORE_TEMP_SHARED_DATA *pData); 

bool CScanTracDlg::GetCoreTempInfoAlternative(void)
{
	myGetCoreTempInfo GetCoreTempInfo;
	//HMODULE hCT; moved to ScanTracDlg.h
//	ULONG index;
	DWORD lastError = 0;
	wchar_t errMsg[100];
//	char tempType;
//	CString CStringTextA;
//	WORD vCPUTemperature;			global var, system configuration data
//	WORD vCPUTemperatureMaximum;	global var, system configuration data
//	WORD vCPUTemperatureMinimum;	global var, system configuration data
	WORD NextTemperatureRead;
	WORD NewCPUTemperature;
	bool Result;

	Result = false;
	memset(errMsg, 0 , sizeof(errMsg));
	CORE_TEMP_SHARED_DATA *CoreTempData = new CORE_TEMP_SHARED_DATA;
	if (CoreTempData)
	{
		memset(CoreTempData, 0, sizeof(CORE_TEMP_SHARED_DATA));

		//Clear screen.
		//	cls();
		//Load DLL.
		if (hCT == NULL)
			hCT = LoadLibrary(TEXT("C:\\Windows\\System32\\GetCoreTempInfo.dll"));
		//hCT = LoadLibrary(TEXT("GetCoreTempInfo.dll"));
		//	CStringTextA = " Core Temperature Read Fail.";
		if (hCT)
		{
			//Print caption.
			//CStringTextA = "Core Temp shared memory reader:\n\n";
			//		CStringTextA = " ";

			//Get the address of the function.
			GetCoreTempInfo = (myGetCoreTempInfo)GetProcAddress(hCT, "fnGetCoreTempInfoAlt");
			if (GetCoreTempInfo)
			{
				//Call the function, if it returns true continue to print the info.
				if (GetCoreTempInfo(CoreTempData))
				{
					//				tempType = CoreTempData->ucFahrenheit ? 'F' : 'C';
					//vSystemData.vF_TemperatureType = CoreTempData->ucFahrenheit ? true : false;

					NewCPUTemperature = (WORD)(CoreTempData->fTemp[0]);
					// read all cores, save highest core temperature in vNewCPUTemperature
					for (unsigned int i = 1; i < CoreTempData->uiCoreCnt; i++)		// cpu core count 0 to . . . but already read 0
					{
						NextTemperatureRead = (WORD)(CoreTempData->fTemp[i]);
						if (NewCPUTemperature < NextTemperatureRead)
						{
							NewCPUTemperature = NextTemperatureRead;
						}
					}
					Result = true;
					vSystemData.vTemperatureCPUData[vSystemData.TempCPUIndex] = NewCPUTemperature;
					vSystemData.TempCPUIndex++;
					if (vSystemData.TempCPUIndex >= cNumberOfVoltageSamples)
					{
						// generate a new average, reset counter
						vSystemData.TempCPUIndex = 0;
						vSystemData.UseCPUAverage = true;
						vSystemData.TemperatureCPUAverage = 0;
						for (int i = 0; i < cNumberOfVoltageSamples; i++)
						{
							vSystemData.TemperatureCPUAverage += vSystemData.vTemperatureCPUData[i];
						}
						if (vSystemData.TemperatureCPUAverage != 0)
						{
							vSystemData.TemperatureCPUAverage = vSystemData.TemperatureCPUAverage / cNumberOfVoltageSamples;
							vSystemData.vCPUTemperature = vSystemData.TemperatureCPUAverage;
						}
						else
						{
							vSystemData.TemperatureCPUAverage = 0;
							vSystemData.vCPUTemperature = 0;
						}
						// generate warnings if CPU too hot
						if (vSystemData.vGivenTemperatureWarning == false)
						{
							if (vSystemData.TemperatureCPUAverage > vConfigurationData->vMaximumCPUTemperature)
							{
								if (vSystemData.vSystemRunMode != cStoppedSystemMode)
								{
									::PostThreadMessage(vGlobalCallingThreadID, cEmergencyShutXRaysDownMessage, 0, 0);
									ReportErrorMessage("Error-CPU Too Hot - Inspection Stopped-Inside Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureAirInside,
										vConfigurationData->vTemperatureAirInsideAdjust) + ", CPU Temp: " + dtoa(vSystemData.vCPUTemperature, 0) + ", Limit: " + dtoa(vConfigurationData->vMaximumCPUTemperature, 0), cError, 4);

									ReportErrorMessage("CPU Too Hot-Inside Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureAirInside,
										vConfigurationData->vTemperatureAirInsideAdjust) + ", CPU Temp: " + dtoa(vSystemData.vCPUTemperature, 0) + ", Limit: " + dtoa(vConfigurationData->vMaximumCPUTemperature, 0), cEMailInspx, 32000);
#ifdef CompileInHTTPClientOperationsGuardian
								if (vConfigurationData->vEnableOperationsGuardian)
								{
									vGlobalOGErrorCode = 305;
									vGlobalOGLocationString = "cpu";
									vGlobalOGLimitString = dtoa(vConfigurationData->vMaximumCPUTemperature, 0);
									::PostThreadMessage(vGlobalCallingThreadID, cOGSevereMessage, cOGSevereMessageTemperatureFault, cOGSevereMessageTemperatureFault);
								}
#endif
							}
								else
								{
									ReportErrorMessage("Error-CPU Too Hot-Inside Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureAirInside,
										vConfigurationData->vTemperatureAirInsideAdjust) + ", CPU Temp: " + dtoa(vSystemData.vCPUTemperature, 0) + ", Limit: " + dtoa(vConfigurationData->vMaximumCPUTemperature, 0), cError, 4);

									ReportErrorMessage("CPU Too Hot-Inside Temp: " + ConvertToDegreesCString(vSystemData.vTemperatureAirInside,
										vConfigurationData->vTemperatureAirInsideAdjust) + ", CPU Temp: " + dtoa(vSystemData.vCPUTemperature, 0) + ", Limit: " + dtoa(vConfigurationData->vMaximumCPUTemperature, 0), cEMailInspx, 32000);
								}
								vSystemData.vGivenTemperatureWarning = true;
							}
						}

						if ((vSystemData.vCPUTemperatureMaximum < vSystemData.TemperatureCPUAverage) || (vSystemData.vCPUTemperatureMaximum >= 0xFFF)) //save maximum
						{
							vSystemData.vCPUTemperatureMaximum = vSystemData.TemperatureCPUAverage;
						}
						if ((vSystemData.vCPUTemperatureMinimum > vSystemData.TemperatureCPUAverage) || (vSystemData.vCPUTemperatureMaximum >= 0xFFF)) 	//save minimum
						{
							vSystemData.vCPUTemperatureMinimum = vSystemData.TemperatureCPUAverage;
						}
					}
					if (vSystemData.vCPUTemperature >= 0xFFF)
					{
						vSystemData.vCPUTemperature = NewCPUTemperature;
						//vSystemData.vCPUTemperatureMinimum = NewCPUTemperature;
						//vSystemData.vCPUTemperatureMaximum = NewCPUTemperature;
					}

					//Now print the output.
					//				CStringTextA = CStringTextA + "CPU Name: " + CoreTempData->sCPUName + "\n";
					//				char TempCharA [100];
					//				char TempCharB [100];
					//				char TempCharC [100];
					//				sprintf_s(TempCharA,"%.2f",CoreTempData->fCPUSpeed);
					//				sprintf_s(TempCharB,"%.2f",CoreTempData->fFSBSpeed);
					//				sprintf_s(TempCharC,"%.2f",CoreTempData->fMultipier);
					//				CStringTextA = CStringTextA +  "CPU Speed: " + _T(TempCharA) + "MHz (" + _T(TempCharB) +" x " +	_T(TempCharC) + ")\n" ;
					//					//CoreTempData->fCPUSpeed, CoreTempData->fFSBSpeed, CoreTempData->fMultipier);
					//				sprintf_s(TempCharA,"%.4f",CoreTempData->fVID);
					//				CStringTextA = CStringTextA +  "CPU VID: " + _T(TempCharA) + "v\n"; // CoreTempData->fVID);
					//				CStringTextA = CStringTextA +  "Physical CPUs: " + dtoa(CoreTempData->uiCPUCnt) + "\n"; // CoreTempData->uiCPUCnt);
					//				CStringTextA = CStringTextA +  "Cores per CPU: " + dtoa(CoreTempData->uiCoreCnt) + "\n";  // CoreTempData->uiCoreCnt);
					//				for (unsigned int i = 0; i < CoreTempData->uiCPUCnt; i++)
					//				{
					//					CStringTextA = CStringTextA +  "CPU #" + dtoa(i) + "\n";	//, i);
					//					CStringTextA = CStringTextA +  "Tj.Max: " + dtoa(CoreTempData->uiTjMax[i]) + tempType + "\n";   // CoreTempData->uiTjMax[i], tempType);
					//					for (UINT g = 0; g < CoreTempData->uiCoreCnt; g++)
					//					{
					//						index = g + (i * CoreTempData->uiCoreCnt);
					//						if (CoreTempData->ucDeltaToTjMax)
					//						{
					//							sprintf_s(TempCharA,"%.0f",CoreTempData->fTemp[index]);
					//							CStringTextA = CStringTextA + "Core " + dtoa(index) + "%: " +  _T(TempCharA) + tempType + " to TjMax, " + dtoa(CoreTempData->uiLoad[index]) + "% Load\n";
					//								//index, CoreTempData->fTemp[index], tempType, CoreTempData->uiLoad[index]);
					//						}
					//						else
					//						{
					//							sprintf_s(TempCharA,"%.0f",CoreTempData->fTemp[index]);
					//							CStringTextA = CStringTextA +  "Core #" + dtoa(index) + ": " + _T(TempCharA) + tempType + ", " + dtoa(CoreTempData->uiLoad[index]) + "% Load\n";
					//							CStringTextA = CStringTextA +  " Core " + dtoa((index + 1)) + ": " + _T(TempCharA) + tempType + ". " /*+ dtoa(CoreTempData->uiLoad[index]) + "% Load\n"*/;
					//								//index, CoreTempData->fTemp[index], tempType, CoreTempData->uiLoad[index]);
					//						}
					//					}
					//				}
				}
				//			else
				//			{
				//				//Display DLL related errors.
				//				lastError = GetLastError();
				//				CStringTextA = CStringTextA + "Error: Core Temp's shared memory could not be read.\n";
				//				CStringTextA = CStringTextA +  "Error number: " + dtoa(GetLastError()) + "\n";   // GetLastError();
				//				//if ((lastError & UNKNOWN_EXCEPTION) > 0)
				//				//{
				//				//	CStringTextA = CStringTextA +  "Error description: Unknown error occured while copying shared memory.\n");
				//				//}
				//				//else
				//				//{
				//				//	FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM,
				//				//					NULL, lastError, 0, errMsg, 100, NULL);
				//				//	CStringTextA = CStringTextA +  "Error description: %s\n", errMsg);
				//				//}
				//			}
			}
			//		else
			//		{
			//			CStringTextA = CStringTextA +  "Error: The function \"fnGetCoreTempInfo\" in \"GetCoreTempInfo.dll\" could not be found.";
			//		}
			//FreeLibrary(hCT);
			//hCT = NULL;
		}
		//	else
		//	{
		//		CStringTextA = CStringTextA + "Error: \"GetCoreTempInfo.dll\" could not be loaded.";
		//	}

		//Free resources.
		delete CoreTempData;
	}
	return(Result);

			// read file in and display to text screen
/*		CHelpDialog * IHelpDialog;
		IHelpDialog = new(CHelpDialog);
		IHelpDialog->vHelpContext = 16; //504;		//was 16
		IHelpDialog->vHelpType = 0;
		IHelpDialog->vWindowType = cTextWindow;
		IHelpDialog->vLocalSystemData = vLocalSystemData;
		IHelpDialog->vMainWindowPointer = vMainWindowPointer;
		IHelpDialog->vLocalConfigurationData = vLocalConfigurationData;
		IHelpDialog->vProductPointer = vGlobalCurrentProduct;

		IHelpDialog->vTitleString = "FBWF Files In Overlay";
		IHelpDialog->vTextString = CStringTextA ;
		int TempResult = IHelpDialog->DoModal();
		delete IHelpDialog;
*/
//	SetDlgItemText(IDC_StatusLine,CStringTextA);
//	m_StatusLine.ShowWindow(SW_SHOW);

}

void CScanTracDlg::CalculateSensitivity()
{
	this->Invalidate();

	for (BYTE TempLoop = 0; TempLoop < cMaximumNumberOfInspections; TempLoop++)
	{
		vSystemData.vSensitivities[TempLoop] = 0xFF;
		vSystemData.vLearnSensitivities[TempLoop] = 0xFF;
		vSystemData.vThresholdSensitivities[TempLoop] = 0xFF;
	}

#ifdef CompileInHTTPClientOperationsGuardian
	CString TempSensitivityJSON("{");
#endif

	vSystemData.vNumberOfSensitivities = 0;
	if (vGlobalCurrentProduct)
	//if (vConfigurationData->vShowSensitivityDisplays == cShowSensitivityDisplays)
	for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
	if (vGlobalCurrentProduct->vInspection[TempLoop])
	{
		vSystemData.vSensitivities[TempLoop] = vGlobalCurrentProduct->vInspection[TempLoop]->GetSensitivity(false, 0);
		vSystemData.vThresholdSensitivities[TempLoop] = vSystemData.vSensitivities[TempLoop];

		if (vSystemData.vSensitivities[TempLoop] < 255)
			vSystemData.vNumberOfSensitivities++;

		//calculate Learn Sensitivity
		if (vGlobalCurrentProduct->vInspection[TempLoop]->vAddStructure) //using learned algorithm
		{

			//exclude Top FM by only finding ones with bottom of ROI less than half container height
			if (vGlobalCurrentProduct->vInspection[TempLoop]->vROIPixelBottom < (vGlobalCurrentProduct->vReferenceTop / 2))
			{
				vSystemData.vLearnSensitivities[TempLoop] = vSystemData.vITIPCDig->CalculateStructureDensityForInspection(vGlobalCurrentProduct->vInspection[TempLoop]);
				//translate learn quality number into a %sensitivity of the learn
				if (vSystemData.vLearnSensitivities[TempLoop] == 0)
					vSystemData.vLearnSensitivities[TempLoop] = 255;
				else
					if (vSystemData.vLearnSensitivities[TempLoop] <= 20)
						vSystemData.vLearnSensitivities[TempLoop] = 100;
					else
						if (vSystemData.vLearnSensitivities[TempLoop] <= 100)
							vSystemData.vLearnSensitivities[TempLoop] = (100 - ((vSystemData.vLearnSensitivities[TempLoop] - 20) * 1.25)); //input range 20 to 100 //output range 100 to 0% green is 61 to 100%
						else
							vSystemData.vLearnSensitivities[TempLoop] = 0;

				if (vSystemData.vLearnSensitivities[TempLoop] < vSystemData.vSensitivities[TempLoop]) //take smaller of 2 sensitivities to show.
					vSystemData.vSensitivities[TempLoop] = vSystemData.vLearnSensitivities[TempLoop];
			}
#ifdef CompileInHTTPClientOperationsGuardian
			//sensitivity, {parameter, value} sensitivity, {, vSystemData.vThresholdSensitivities[TempLoop]
			if (vConfigurationData->vEnableOperationsGuardian)
			{
				TempSensitivityJSON += "\"";
				TempSensitivityJSON += vSystemData.vCriteriaString[TempLoop];
				TempSensitivityJSON += "\" : \"";
				TempSensitivityJSON += dtoa(vSystemData.vSensitivities[TempLoop], 0);
				TempSensitivityJSON += "\",";
			}
#endif
		}
	}
#ifdef CompileInHTTPClientOperationsGuardian
	if (vConfigurationData->vEnableOperationsGuardian)
	{
		TempSensitivityJSON += "}";
		if (TempSensitivityJSON.GetLength() > 3)
		if (vLastOGSensitivity != TempSensitivityJSON)
		{
			vLastOGSensitivity = TempSensitivityJSON;
			SendOGInfo(std::wstring(L"sensitivity"), vLastOGSensitivity, true);
		}
	}
#endif
}

void CScanTracDlg::DoBackGroundWork() //don't allow any background functions to bring up a modal dialog, as that will stop background functioning and stop serial communication causing a timeout.
{
	vBackgroundCount++;
	if (vBackgroundCount > 3)
		vBackgroundCount = 0;

	if (vSystemData.vSendDACValues)
	{
		vSystemData.vSendDACValues--;

		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendDACDetectorOffset(vSystemData.vSendDACValues);
		if (!vSystemData.vSendDACValues) //just finished programming the DACs
		if (vSystemData.vNeedToVerifyDACValues)
		if (vGlobalFPGAVersion15Point31OrHigher) //does a verify of the DACs against the last programmed value
		{
			//set a timer that will verify the DAC values in a second if nothing else is going on and started inspection
			ReportErrorMessage("Programmed DACs Done, so Need To Verify DACs soon", cWriteToLog, 0);
			int TempTimerResult = SetTimer(vNeedToTestDACsTimerHandle,1000,NULL);
			if (!TempTimerResult)
				ReportErrorMessage("Error-Hold Sent Test Display Timer Failed",cEMailInspx,32000);
		}
	}
	else
	if (vSystemData.vSendADCValues)
	{
		vSystemData.vSendADCValues--;

		//if (vSystemData.vLogFile.vLogSerialData) //temp for testing
		//	vSystemData.vLogFile.WriteToLogFile("BACKGROUND: Send ADC-Offsets Detectors: " + dtoa(vSystemData.vSendADCValues, 0),cDebugMessage);

		if (vGlobaluCSerialPort)
			vGlobaluCSerialPort->SendADCOffset(vSystemData.vSendADCValues, vSystemData.vADCDetectorOffset[vSystemData.vSendADCValues] + (int)vSystemData.vDriftCompensationADCOffset);
	}
	
	switch (vBackgroundCount)
	{
		case 0:
			if (vGlobalDXMXRayPort)
				vGlobalDXMXRayPort->DoBackGroundWork();
			else
			if (vGlobalMonoBlockXRayPort)
				vGlobalMonoBlockXRayPort->DoBackGroundWork();
		break;
		case 1:
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->DoBackGroundWork();
		break;
		case 2:
			if (vGlobalACPowerMoniter)
				vGlobalACPowerMoniter->DoBackGroundWork();//just error log work in this function
		break;
		case 3:
			if (vGlobalGuardMaster)
				vGlobalGuardMaster->DoBackGroundWork();//just error log work in this function
			//if (vGlobalPowerFlex40)
			//	vGlobalPowerFlex40->DoBackGroundWork();//just error log work in this function
			if (vSystemData.vITIPCDig)
				vSystemData.vITIPCDig->CheckWriteBackupLearnFile();
		break;
	}
}

void CScanTracDlg::SetABPixelToOtherEnd(bool TempSetABPixelToOtherEnd)
{
		tSerialCommand TempCommand;
		TempCommand[0] = 0x23;
		TempCommand[1] = 0xEE; //pre amplifier gain Middle Image
		TempCommand[2] = 0; 

		if (vConfigurationData->vPixelsPerDetector == 128) //.4mm Detectors
			TempCommand[3] = 1;
		else
		if (vConfigurationData->vDetectorLength == 4) //1.6mm Detectors
			TempCommand[3] = 2;
		else
		//if (vConfigurationData->vPixelsPerDetector == 64)
			TempCommand[3] = 0; //.8mm Detectors

		if (TempSetABPixelToOtherEnd)
			TempCommand[3] = TempCommand[3] + 0x80;

		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTime);
}

void CScanTracDlg::SendAllDACDetectorOffsets()
{
	vSystemData.vSendDACValues = vConfigurationData->vNumberOfXRayDetectors;  //set count of how many to send in background
	if (vGlobalFPGAVersion16point0orAbove)
	{
		vSystemData.vNeedToVerifyDACValues = true;
		ReportErrorMessage("Start Programming DACs, so Need To Verify after", cWriteToLog, 0);
	}
	else
		ReportErrorMessage("Start Programming DACs.", cWriteToLog, 0);
}

void CScanTracDlg::SendAllADCDetectorOffsetsToZero()
{
	for (BYTE TempLoop = 0; TempLoop < vConfigurationData->vNumberOfXRayDetectors; TempLoop++)
		vSystemData.vADCDetectorOffset[TempLoop] = 0;  //zero is actually zero as vSystemData.vCalibrationADCOffsetMaximumBit is subtracted from the value to get the center point

	SendAllADCOffsets();
}

void CScanTracDlg::SendAllADCOffsets()
{	//New ADC XRD9814
	vSystemData.vSendADCValues = vConfigurationData->vNumberOfXRayDetectors; //set count of how many to send in background

	//if (vSystemData.vLogFile.vLogSerialData) //temp for testing
	//	vSystemData.vLogFile.WriteToLogFile("Send All ADC-Offsets.  # of Detectors: " + dtoa(vConfigurationData->vNumberOfXRayDetectors, 0),cDebugMessage);
}

DWORD CalculateDirectorySize(CString TempString)
{
	//new code read scantrac serial log directory size kjh
		DWORD TempFileTotal;
		TempFileTotal = 0;
		CFileException TempFileException;
// sent in function call,		CString TempString = "C:\\C Projects\\ScanTrac2010DB 29 Pipe working 2012 09 25\\*.*" ;
		TempString += "*.*";
		LPTSTR TempDirectoryName = TempString.GetBuffer(TempString.GetLength());
		TRY
		{

			WIN32_FIND_DATA FindFileData;
			HANDLE hFind;
			hFind = FindFirstFile(TempDirectoryName, &FindFileData);	// first file in a directory read is generally "."

			if (hFind != INVALID_HANDLE_VALUE) // "\n\n\nNo files in directory"; 
			{
				while (FindNextFile(hFind,&FindFileData))
				{
					if ((FindFileData.cFileName != _T("..")) && ((FindFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) != FILE_ATTRIBUTE_DIRECTORY))
					{
						TempFileTotal += FindFileData.nFileSizeLow;		//TempFileTotal += FindFileData.nFileSizeHigh ??
					}
					else
					{
						TempFileTotal += 0;
					}
				}
/* below for debug, works good
				//TempText += "\nFile Size:  ";	
				if (TempFileTotal >= 0x40000000)
					//TempText += (dtoaWithCommas(TempFileTotal / 0x40000000, 0) + " GB");
					ReportErrorMessage("Serial Log Dir Size  " + dtoaWithCommas(TempFileTotal / 0x40000000, 0) + " GB", cEMailInspx, 32000);
				else if (TempFileTotal >= 0x100000)
					//TempText += (dtoaWithCommas(TempFileTotal / 0x100000, 0) + " MB");
					ReportErrorMessage("Serial Log Dir Size  " + dtoaWithCommas(TempFileTotal / 0x100000, 0) + " MB", cEMailInspx, 32000);
				else
					//TempText += (dtoaWithCommas(TempFileTotal, 0) + " Bytes");
					ReportErrorMessage("Serial Log Dir Size  "+ dtoaWithCommas(TempFileTotal, 0) + " Bytes", cEMailInspx, 32000);
*/
			}
			else
			{
				ReportErrorMessage("Directory Not Found, Read Failed", cEMailInspx, 32000);
			}
			FindClose(hFind);
		}
		CATCH_ALL(TempFileException)
		{
			ReportErrorMessage("Directory Size Read Failed", cEMailInspx, 32000);
		}
		END_CATCH_ALL

		return(TempFileTotal);
}

bool CScanTracDlg::ConditionTubeIfNeeded()
{
	//for MonoBlocks
	vConditioningBeforeRun = false;
	WORD TempMinutesToCondition = 0;
	WORD TempDaysUnUsed = 0;
	if (vConfigurationData->vTimeXRaysWereOnLast > 100)
		if ((vGlobalMonoBlockXRayPort) || ((vGlobalDXMXRayPort) && ((vConfigurationData->vHVPSType == c100WMonoBlockHVPS) || (vConfigurationData->vHVPSType == cCheyneyMonoBlock) || (vConfigurationData->vHVPSType == c100WVJTMonoBlockHVPS))))
	{
		CTime TempTime = CTime::GetCurrentTime();
		CTimeSpan TempDeltaTime;
		TempDeltaTime = TempTime - vConfigurationData->vTimeXRaysWereOnLast;
		LONGLONG TempSeconds = TempDeltaTime.GetTotalSeconds();
		if ((TempSeconds > 36000) && (!vConfigurationData->vDemoMode))  
			//if more than 10 hours since ran, should condition source
		{
			if ((vConfigurationData->vHVPSType == cXLFHVPS) || (vConfigurationData->vHVPSType == cDXMHVPS) || (vConfigurationData->vHVPSType == cCheyneyMonoBlock) || (vConfigurationData->vHVPSType == c100WVJTMonoBlockHVPS))
			{
				if (TempSeconds > 2592000)  //if more than 30 days since ran, should condition source
				{
					StartXRayTubeCondition(false, 1);
					TempMinutesToCondition = 60;
					TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
				}
			}

			if (vConfigurationData->vHVPSType == c100WMonoBlockHVPS)
			{
				//if (TempSeconds > 1555200)  //if more than 6 months since ran, should condition source
				if (TempSeconds > 1555200)  //if more than 6 months since ran, should condition source
				{
					StartXRayTubeCondition(false, 5);
					TempMinutesToCondition = 250;
					TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
				}
				else
				if (TempSeconds > 7776000)  //if more than 90 days since ran, should condition source
				{
					StartXRayTubeCondition(false, 5); //normally would be 1, for the Spellman 1 hour procedure, but dave said to do the 6 month procedure
					TempMinutesToCondition = 60;
					TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
				}
				else
				if (TempSeconds > 2592000)  //if more than 30 days since ran, should condition source
				{
					StartXRayTubeCondition(false, 1); //normally 2 for the spellman 10 minute procedure, but dave said to do the 3 month procedure
					TempMinutesToCondition = 10;
					TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
				}
				//Dave said not to do the next two procedures, the daily and 3 day
				//else
				//if (TempSeconds > 259200)  //if more than 3 days since ran, should condition source
				//{
				//	StartXRayTubeCondition(false, 3);//if more than 3 days since ran, should condition source
				//	TempMinutesToCondition = 5;
				//	TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
				//}
				//else
				//if (TempSeconds > 36000)  //if more than 10 hours since ran, should condition source
				//{
				//	StartXRayTubeCondition(false, 4);//if more than 3 days since ran, should condition source
				//	TempMinutesToCondition = 2;
				//	TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
				//}
			}

			if (vConfigurationData->vHVPSType == c210WMonoBlockHVPS)
			{
				if (TempSeconds > 1209600)  //if more than 14 days since ran, should condition source
				{
					StartXRayTubeCondition(false, 1);
					TempMinutesToCondition = 60;
					TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
				}
				else
				if (TempSeconds > 604800)  //if more than 7 days since ran, should condition source
				{
					StartXRayTubeCondition(false, 2);
					TempMinutesToCondition = 12;
					TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
				}
				else
				if (TempSeconds > 172800)  //if more than 2 days since ran, should condition source
				{
					StartXRayTubeCondition(false, 3);//if more than 3 days since ran, should condition source
					TempMinutesToCondition = 6;
					TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
				}
			}



			if (vSystemData.vSystemRunMode == cConditionXRayTubeMode)
				vConditioningBeforeRun = true;
		}
	}
	else //for RTW Tubes
	{
		CTime TempTime = CTime::GetCurrentTime();
		CTimeSpan TempDeltaTime;
		TempDeltaTime = TempTime - vConfigurationData->vTimeXRaysWereOnLast;
		LONGLONG TempSeconds = TempDeltaTime.GetTotalSeconds();
		//Alex did not want to condition unless not used for 30 days if ((TempSeconds > 259200) && (!vConfigurationData->vDemoMode))  
		if (!vConfigurationData->vDemoMode)  
		{
			if (TempSeconds > 2592000)  //if more than 30 days since ran, should condition source
			{
				StartXRayTubeCondition(false, 1);
				TempMinutesToCondition = 60;
				TempDaysUnUsed = (WORD)(TempSeconds / 60 / 24 / 60);
			}

			if (vSystemData.vSystemRunMode == cConditionXRayTubeMode)
				vConditioningBeforeRun = true;
		}
	}

	if (vConditioningBeforeRun)
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\nX-Ray Tube requires conditioning to prevent arcing.\nX-Ray Tube has not been used for " + dtoa(TempDaysUnUsed, 0) + 
			" days.\nLet conditioning finish before inspecting.\nConditioning will take " + dtoa(TempMinutesToCondition,0) + " minutes.";
		TempNoticeDialog.vType = cInformationMessage;
		TempNoticeDialog.DoModal();
	}

	return vConditioningBeforeRun;
}

void CScanTracDlg::SaveCheckWeighTrendPoint()
{
	// trend data is saved each minute, not after 500 points
	//check each inspection if has check weighing
	if (vGlobalCurrentProduct)
	for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
	if (vGlobalCurrentProduct->vInspection[TempLoop])
	if ((vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection) || (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection))
	if (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionNameForWeightTrendingName.GetLength() == 0) //don't do if pointing at another inspection for weight trending
	{
		CInspectionCheckWeigh *TempCheckWeighInspection = (CInspectionCheckWeigh *)vGlobalCurrentProduct->vInspection[TempLoop];

		if (vSystemData.vTotalContainers)
		if (TempCheckWeighInspection->vCheckWeighCurrentMinuteData)
		if (TempCheckWeighInspection->vCheckWeighTrendDataOnMinutes)
		if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock()) //must lock so can take data and change count without image thread changing it
		{
			double *TempDestinationDataPointer = TempCheckWeighInspection->vCheckWeighTrendDataOnMinutes + (TempCheckWeighInspection->vCheckWeighTrendDataIndexOnMinutes);

			if (!TempCheckWeighInspection->vCheckWeighCurrentMinuteNumberOfDataSamplesTaken) //if no samples this minute, then this trend data point is zero
				*TempDestinationDataPointer = 0;
			else
			if (!TempCheckWeighInspection->vCheckWeighCurrentMinuteNumberOfDataSamplesTaken == 1) //if one sample this minute, then set this trend data point to it
				*TempDestinationDataPointer = *TempCheckWeighInspection->vCheckWeighCurrentMinuteData;
			else
			{ //have more than 1 data points, so must average

				double TempAverage = 0;
				double *TempSourceDataPointer = TempCheckWeighInspection->vCheckWeighCurrentMinuteData;

				for (WORD TempLoop = 0; TempLoop < TempCheckWeighInspection->vCheckWeighCurrentMinuteNumberOfDataSamplesTaken; TempLoop++)
					TempAverage = TempAverage + *TempSourceDataPointer++;

				TempAverage = TempAverage / TempCheckWeighInspection->vCheckWeighCurrentMinuteNumberOfDataSamplesTaken;

				*TempDestinationDataPointer = TempAverage;
			}
			if (TempCheckWeighInspection->vCheckWeighTrendDataIndexOnMinutes < TempCheckWeighInspection->vCheckWeighTrendDataSizeOnMinutes - 1)
				TempCheckWeighInspection->vCheckWeighTrendDataIndexOnMinutes++;
			else
				TempCheckWeighInspection->vCheckWeighTrendDataIndexOnMinutes = 0;

			if (TempCheckWeighInspection->vCheckWeighTrendNumberOfDataSamplesTakenOnMinutes < TempCheckWeighInspection->vCheckWeighTrendDataSizeOnMinutes)
				TempCheckWeighInspection->vCheckWeighTrendNumberOfDataSamplesTakenOnMinutes++;

			TempCheckWeighInspection->vCheckWeighCurrentMinuteNumberOfDataSamplesTaken = 0; //start taking data for next minue next
			vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();
		}
		else
			ReportErrorMessage("Lock Failed, Did not save CheckWeigh Minute Data", cEMailInspx, 32000);
	}
}

void CScanTracDlg::InitializeDACs()
{	//setup offset compensation DAC
	if (vGlobaluCSerialPort)
	if (vConfigurationData->vScanTracType == cCaseInspectorScanTrac)
	{
		for (BYTE TempLoop = 0; TempLoop < 9; TempLoop++)
		{
			BYTE TempDetectorAddress = 0x6A;
			//combine system detector offset for this detector with the product offset and limit
			switch (TempLoop)
			{
				case 2: TempDetectorAddress = 0x20; break;
				case 1: TempDetectorAddress = 0x22; break;//uC Board back 3 detectors
				case 0: vGlobaluCSerialPort->StartMiddleBeamControl(); TempDetectorAddress = 0x24; break;
				case 5: TempDetectorAddress = 0x20; break;//for CaseInspector, center 3 detectors on daughter board
				case 4: TempDetectorAddress = 0x22; break;
				case 3: TempDetectorAddress = 0x24; break;

				case 8: TempDetectorAddress = 0x20; break; //for CaseInspector, front 3 detectors on daughter board
				case 7: TempDetectorAddress = 0x22; break;
				case 6: TempDetectorAddress = 0x24; break;

				//case 17: TempDetectorAddress = 0x6A; break; //back detector, uc
				//case 16: TempDetectorAddress = 0x68; break;
				//case 15: TempDetectorAddress = 0x26; break;
				//case 14: TempDetectorAddress = 0x6A; break; //middle detector daughter card is right beam from trio
				//case 13: TempDetectorAddress = 0x68; break;
				//case 12: TempDetectorAddress = 0x26; break;  
				//case 11: TempDetectorAddress = 0x6A; break;  //front detector on 36 inch is center beam from trio
				//case 10: TempDetectorAddress = 0x68; break;
				//case 9: vGlobaluCSerialPort->StartMiddleBeamControl(); TempDetectorAddress = 0x26; break;
			}

			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Initialize DAC-Offset: 0x4000 Detector: " + dtoa(TempLoop,0),cDebugMessage);

			tSerialCommand TempCommand;
			TempCommand[0] = 0x23;

			if (TempLoop > 5)
				TempCommand[1] = 0xDA; // uc board
			else
				TempCommand[1] = 0xAA; //daughter boards in front

			TempCommand[2] = 0x00;
			TempCommand[3] = TempDetectorAddress;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);

			if (TempLoop > 5)
				TempCommand[1] = 0xDC; //uC Board in back
			else
				TempCommand[1] = 0xAC; //daughter boards in front

			TempCommand[2] = 0x40;
			TempCommand[3] = 0x00;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);
	
			if (TempLoop == 2)
				vGlobaluCSerialPort->EndMiddleBeamControl();
		}
	}
	else
	{ //not a case inspector
		BYTE TempLoopCount = vConfigurationData->vNumberOfXRayDetectors;
		for (BYTE TempLoop = 0; TempLoop < TempLoopCount; TempLoop++)
		{
			BYTE TempDetectorAddress = 0x6A;
			//combine system detector offset for this detector with the product offset and limit
			if (vConfigurationData->vScanTracType == cSoloPlusScanTrac)
			{
				switch (TempLoop)
				{
					case 8: TempDetectorAddress = 0x24; break; //grand daughter top T2
					case 7: TempDetectorAddress = 0x22; break;
					case 6: TempDetectorAddress = 0x20; break; //grand daughter bottom
					case 5: TempDetectorAddress = 0x6A; break; //uC top
					case 4: TempDetectorAddress = 0x68; break;
					case 3: TempDetectorAddress = 0x26; break;
					case 2: TempDetectorAddress = 0x24; break; 
					case 1: TempDetectorAddress = 0x22; break;
					case 0: TempDetectorAddress = 0x20; break; //uC bottom
				}
			}
			else
			if (vConfigurationData->vScanTracType == cAllegroScanTrac) //Allegro
			{
				switch (TempLoop)
				{
					case 8: TempDetectorAddress = 0x20; break;
					case 7: TempDetectorAddress = 0x22; break;
					case 6: TempDetectorAddress = 0x24; break;
					case 5: TempDetectorAddress = 0x26; break;
					case 4: TempDetectorAddress = 0x68; break;
					case 3: TempDetectorAddress = 0x6A; break;
					case 2: TempDetectorAddress = 0x20; break; //for Allegro, front 3 detectors on daughter board
					case 1: TempDetectorAddress = 0x22; break;
					case 0: TempDetectorAddress = 0x24; break;
				}
			}
			else
			{
				switch (TempLoop)
				{
					case 0: TempDetectorAddress = 0x20; break; //uC board in back
					case 1: TempDetectorAddress = 0x22; break;
					case 2: TempDetectorAddress = 0x24; break;
					case 3: TempDetectorAddress = 0x26; break;
					case 4: TempDetectorAddress = 0x68; break;
					case 5: TempDetectorAddress = 0x6A; break;
					case 6: TempDetectorAddress = 0x20; break; //for forte, front 6 detectors on daughter board
					case 7: TempDetectorAddress = 0x22; break;
					case 8: TempDetectorAddress = 0x24; break;
					case 9: TempDetectorAddress = 0x26; break;
					case 10: TempDetectorAddress = 0x68; break;
					case 11: TempDetectorAddress = 0x6A; break;
				}
			}

			if (vSystemData.vLogFile.vLogSerialData)
				vSystemData.vLogFile.WriteToLogFile("Initialize DAC-Offset: 0x4000 Detector: " + dtoa(TempLoop,0),cDebugMessage);

			tSerialCommand TempCommand;
			TempCommand[0] = 0x23;
			if (vConfigurationData->vScanTracType == cSoloPlusScanTrac)
			{
				if (TempLoop < 6)
					TempCommand[1] = 0xDA; //uc Board on bottom
				else
					TempCommand[1] = 0xAA; //grand daughter board on top with only 3 detectors
			}
			else
			if (vConfigurationData->vScanTracType == cAllegroScanTrac)
			{
				if (TempLoop > 2)
					TempCommand[1] = 0xDA; //uc Board in back
				else
					TempCommand[1] = 0xAA; //daughter board in front with only 3 detectors
			}
			else
			{
				if (vConfigurationData->vNumberOfXRayDetectors == 6)
					TempCommand[1] = 0xDA; //only uc board
				else
				if (TempLoop > 5)
					TempCommand[1] = 0xDA; //uc Board in back
				else
					TempCommand[1] = 0xAA; //daughter board in front
			}
			TempCommand[2] = 0x00;
			TempCommand[3] = TempDetectorAddress;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);

			if (vConfigurationData->vScanTracType == cSoloPlusScanTrac)
			{
				if (TempLoop < 6)
					TempCommand[1] = 0xDC; //uc Board on bottom
				else
					TempCommand[1] = 0xAC; //grand daughter board on top with only 3 detectors
			}
			else
			if (vConfigurationData->vScanTracType == cAllegroScanTrac)
			{
				if (TempLoop > 2)
					TempCommand[1] = 0xDC; //uc board in back
				else
					TempCommand[1] = 0xAC; //daughter board with 3 detectors in front
			}
			else
			{
				if (vConfigurationData->vNumberOfXRayDetectors == 6)
					TempCommand[1] = 0xDC; //uc board only
				else
				if (TempLoop > 5)
					TempCommand[1] = 0xDC; //uc board in back
				else
					TempCommand[1] = 0xAC; //daughter board in front
			}
			TempCommand[2] = 0x40;
			TempCommand[3] = 0x00;
			if (vGlobaluCSerialPort)
				vGlobaluCSerialPort->SendSerialCommand(TempCommand);
			Sleep(cSendCommandSleepTime);
		}
	}
}

void CScanTracDlg::CreateProcessEvaluateImagesThread()
{
	vSystemData.vCompletedEvaluation = true;

	if (vSystemData.vLogFile.vLogSerialData)
		vSystemData.vLogFile.WriteToLogFile("Create Evaluate Images Thread",cDebugMessage);
	//thread lowest priority
	if (vSystemData.vMemoryOK)
	{
		vGlobalProcessEvaluateImagesThread = (CProcessEvaluateImagesThread *)AfxBeginThread(
			RUNTIME_CLASS(CProcessEvaluateImagesThread), THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);
			//THREAD_PRIORITY_LOWEST  // dont use lowest, makes it too slow
			//THREAD_PRIORITY_BELOW_NORMAL
	}
	if (!vGlobalProcessEvaluateImagesThread)
	{
		ReportErrorMessage("Error-Could Not Create Process Evaluate Thread", cEMailInspx,32000); 
	}
	else
	{
		ReportErrorMessage("Started Processing Evaluate Images: " + dtoa(cNumberOfImagesToEvaluate, 0), cAction,0);
		vGlobalProcessEvaluateImagesThread->vLocalSystemData = &vSystemData;
		vGlobalProcessEvaluateImagesThread->vLocalConfigurationData = vConfigurationData;
		vGlobalProcessEvaluateImagesThread->vMainWindowPointer = this;

		vGlobalProcessEvaluateImagesThread->ResumeThread();
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Created Evaluate Images Thread",cDebugMessage);
	}
}

BYTE CScanTracDlg::WhatIsSupportContractStatus()
{
	CTime TempTime;
	TempTime = CTime::GetCurrentTime();
	int TempDay = TempTime.GetDay();
	int TempMonth = TempTime.GetMonth();
	int TempYear = TempTime.GetYear();

	int TempDaysUntilExpired = 0;

	if (vConfigurationData->vSupportContractType == cHideSupportContractDisplay)
	{
		return cNone;
	}
	else
	if ((vConfigurationData->vSupportContractYearExpires) && (vConfigurationData->vSupportContractMonthExpires) && (vConfigurationData->vSupportContractDayExpires))
	{
		if ((vConfigurationData->vSupportContractYearExpires < TempYear) ||
			((vConfigurationData->vSupportContractYearExpires == TempYear) && (vConfigurationData->vSupportContractMonthExpires < TempMonth)) ||
			((vConfigurationData->vSupportContractYearExpires == TempYear) && (vConfigurationData->vSupportContractMonthExpires == TempMonth) && (vConfigurationData->vSupportContractDayExpires < TempDay)))
			return cExpired;
		else
		{
			int TempTodaysDateAsANumber = ((TempYear - 1970) * 365) + (TempMonth * 30) + TempDay;
			int TempExpirationDateAsANumber = ((vConfigurationData->vSupportContractYearExpires - 1970) * 365) + (vConfigurationData->vSupportContractMonthExpires * 30) + vConfigurationData->vSupportContractDayExpires;
			int TempDaysUntilExpire = TempExpirationDateAsANumber - TempTodaysDateAsANumber;


			if (TempDaysUntilExpire > 30)
				return cContractGood;
			else
			if (TempDaysUntilExpire > 0)
				return cContractLastMonth;
			else
				return cExpired;
		}
	}
	else
		return cExpired;

	//cExpired; cContractLastMonth, cNone, cContractGood
}

CString CScanTracDlg::SupportContracExpirationString()
{
	CString TempExpirationMonthString = "";
	CString TempExpirationString = "Expiration Not Set";
	if ((vConfigurationData->vSupportContractMonthExpires) && (vConfigurationData->vSupportContractDayExpires) && (vConfigurationData->vSupportContractYearExpires >= 2000))
	{
		switch (vConfigurationData->vSupportContractMonthExpires)
		{
			case 1: TempExpirationMonthString = "Jan"; break;
			case 2: TempExpirationMonthString = "Feb"; break;
			case 3: TempExpirationMonthString = "Mar"; break;
			case 4: TempExpirationMonthString = "Apr"; break;
			case 5: TempExpirationMonthString = "May"; break;
			case 6: TempExpirationMonthString = "June"; break;
			case 7: TempExpirationMonthString = "July"; break;
			case 8: TempExpirationMonthString = "Aug"; break;
			case 9: TempExpirationMonthString = "Sep"; break;
			case 10: TempExpirationMonthString = "Oct"; break;
			case 11: TempExpirationMonthString = "Nov"; break;
			case 12: TempExpirationMonthString = "Dec"; break;
			default: TempExpirationMonthString = "???"; break;
		}

		BYTE TempStatus = WhatIsSupportContractStatus();
		if (TempStatus == cExpired)
			TempExpirationString = "Expired: " + dtoa(vConfigurationData->vSupportContractDayExpires, 0) + " " + TempExpirationMonthString + " " + dtoa(vConfigurationData->vSupportContractYearExpires, 0);
		else
			TempExpirationString = "Expires: " + dtoa(vConfigurationData->vSupportContractDayExpires, 0) + " " + TempExpirationMonthString + " " + dtoa(vConfigurationData->vSupportContractYearExpires, 0);
	}
	return TempExpirationString;
}

void CScanTracDlg::DisplaySupportContractStatus()
{
	vSupportContractStatus = WhatIsSupportContractStatus();
	if (vConfigurationData->vSupportContractType == cHideSupportContractDisplay)//want to hide the support contract info.
	{
		SetDlgItemText(IDC_SupportContract, _T(""));
		SetDlgItemText(IDC_SupportContract2, _T(""));
	}
	else //enum {cSupportContractInvalid, cSupportContract8_5, cSupportContract16_5, cSupportContract24_7, cHideSupportContractDisplay, cSupportContractExpired};
	if (vConfigurationData->vSupportContractType == cSupportContractExpired)//want to hide the support contract info.
	{
		SetDlgItemText(IDC_SupportContract, _T("Support Contract"));
		SetDlgItemText(IDC_SupportContract2, _T("Expired"));
	}
	else //enum {cSupportContractInvalid, cSupportContract8_5, cSupportContract16_5, cSupportContract24_7, cHideSupportContractDisplay, cSupportContractExpired};
	{
		switch (vConfigurationData->vSupportContractType)
		{
			case cSupportContract8_5: SetDlgItemText(IDC_SupportContract, _T("Support Contract 8/5")); break;
			case cSupportContract16_5: SetDlgItemText(IDC_SupportContract, _T("Support Contract 16/5")); break;
			case cSupportContract24_7: SetDlgItemText(IDC_SupportContract, _T("Support Contract 24/7")); break;
			default: SetDlgItemText(IDC_SupportContract, _T("?????")); break;
		}

		if ((vSupportContractStatus == cExpired) || (vSupportContractStatus == cNone))
		{
			SetDlgItemText(IDC_SupportContract2, _T("Expired"));
			if (vConfigurationData->vSupportContractType == 0)
				SetDlgItemText(IDC_SupportContract, _T("Support Contract"));
		}
		else
		{
			SetDlgItemText(IDC_SupportContract2, SupportContracExpirationString());
		}
	}
}


void CScanTracDlg::OnSupportcontract2()
{
	// Clicked on Support Contract Expiration Date
	ShowSupportPhoneNumber();
}


void CScanTracDlg::OnSupportcontract()
{
	// Clicked on Support Contract Type Line
	ShowSupportPhoneNumber();
}

void CScanTracDlg::ShowSupportPhoneNumber()
{
	if (vConfigurationData->vSupportContractType != cHideSupportContractDisplay)
	{
		CString TempText = "\n\nInspx Customer Support During Business Hours:\n(510)226-6686 ext 0 then ask for Customer Support";
		if (vConfigurationData->vSupportContractType == cSupportContract24_7)
			TempText = "\nInspx Customer Support 24/7 After Business Hours:\n(510)226-6686 ext 6500\n\nInspx Customer Support During Business Hours:\n(510)226-6686 ext 0 then ask for Customer Support";

		vSupportContractStatus = WhatIsSupportContractStatus();
		if ((vSupportContractStatus == cExpired) || (vSupportContractStatus == cNone))
			TempText = "\n\n Call (510)226-6686 ext 3017\nwith Purchase Order to\nrenew Support Contract";

		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = TempText;
		TempNoticeDialog.vType = cInformationMessage;
		TempNoticeDialog.DoModal();
	}
}

void CScanTracDlg::ShowThresholds()
{
	CString TempString = " No Inspections Configured";

	if (vGlobalCurrentProduct)
	{
		CalculateSensitivity();
		CString TempLineText = "";

		const int cTab1 = 6;
		const int cTab2 = 20;
		const int cTab3 = 32;
		const int cTab4 = 45;
		const int cTab5 = 55;
		if (vGlobalCurrentProduct->vNumberOfInspections)
		{
			TempString = "";

			//TempString = TempLineText + "\n #         Sensitivity Threshold   Min Size      Inspection\n";
			TempLineText = " #";
			FillToTab(&TempLineText, cTab1);
			TempLineText = TempLineText + "Sensitivity";

			FillToTab(&TempLineText, cTab2);
			TempLineText = TempLineText + "Threshold";

			FillToTab(&TempLineText, cTab3);
			TempLineText = TempLineText + "Min Size";

			FillToTab(&TempLineText, cTab4);
			TempLineText = TempLineText + "Inspection Name";

			TempString = TempLineText;

			for (BYTE TempLoopInspection = 0; TempLoopInspection < vGlobalCurrentProduct->vNumberOfInspections; TempLoopInspection++)
			if (vGlobalCurrentProduct->vInspection[TempLoopInspection])
			{
				TempLineText = Pad(dtoa(TempLoopInspection + 1, 0), 2, 0);

				if ((vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cMissingLidInspectionOnSize) ||
					(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cItemCountInspection) || (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cSizeInspection))
				{
					FillToTab(&TempLineText, cTab2);
					TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vThreshold, 0), 4, 0);
					FillToTab(&TempLineText, cTab3);
					TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vSize, 0), 3, 0);
					//TempString = TempString + dtoa(TempLoopInspection + 1, 0) + "\t\t" +
					//	dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vThreshold, 2) +
					//	"\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vSize, 0) + "\t" + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName + "\n";
				}
				else
				if ((vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cUnderfillInspection) ||
					(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cMissingLidInspection) ||
					(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cUnderfillByWeightInspection) ||
					(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cStandardDeviationInspection))
				{
					FillToTab(&TempLineText, cTab2);
					TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->ConvertToWeight(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdUpper), 2), 4, 2);
					//TempString = TempString + dtoa(TempLoopInspection + 1, 0) + "\t\t" +
					//	dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->ConvertToWeight(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdUpper), 2) +
					//	"\t\t" + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName + "\n";
				}
				else
				if ((vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cOverfillInspection) ||
					(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cOverfillByWeightInspection))
				{
					FillToTab(&TempLineText, cTab2);
					TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->ConvertToWeight(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdLower), 2), 4, 2);
					//TempString = TempString + dtoa(TempLoopInspection + 1, 0) + "\t\t" + 
					//	dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->ConvertToWeight(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdLower), 2) + 
					//	"\t\t" + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName + "\n";
				}
				else
				if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cDensityInspection)
				{
					if ((vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdLower < 254) && (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdLower > 1))
					{ //Lower Threshold for Overfill
						if ((vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdUpper < 254) && (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdUpper > 1)) //have both Thresholds
						{
							FillToTab(&TempLineText, cTab2);
							TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdLower, 2), 4, 2) + ", " +
								Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdUpper, 2), 4, 2);
							//TempString = TempString + dtoa(TempLoopInspection + 1, 0) + "\t\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdLower, 2) + ", " +
							//	dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdUpper, 2) +
							//	"\t\t" + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName + "\n";
						}
						else
						{
							FillToTab(&TempLineText, cTab2);
							TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdLower, 2), 4, 2);
							//TempString = TempString + dtoa(TempLoopInspection + 1, 0) + "\t\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdLower, 2) +
							//	"\t\t" + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName + "\n";
						}
					}
					else //Upper threshold for underfill, Missing Lid
					{
						FillToTab(&TempLineText, cTab2);
						TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdUpper, 2), 4, 2);
						//TempString = TempString + dtoa(TempLoopInspection + 1, 0) + "\t\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDensityThresholdUpper, 2) +
						//	"\t\t" + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName + "\n";
					}
				}
				else
				{
					if (vSystemData.vLearnSensitivities[TempLoopInspection] == 255)
					{
						FillToTab(&TempLineText, cTab1);
						TempLineText = TempLineText + Pad(dtoa(vSystemData.vThresholdSensitivities[TempLoopInspection], 0), 3, 0);
						FillToTab(&TempLineText, cTab2);
						TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vThreshold, 0), 4, 0);
						FillToTab(&TempLineText, cTab3);
						TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vSize, 0), 3, 0);

						if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cSpotInROIContaminantInspection)
						TempLineText = TempLineText + ", " + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vFindSpotInSubROI, 0), 2, 0);

						//if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vPerformGlassAlgorithm = 2)
						if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vTrimEdgesOfJar)
						TempLineText = TempLineText + ", Trim";

						//TempString = TempString + dtoa(TempLoopInspection + 1, 0) + "\t" + dtoa(vSystemData.vThresholdSensitivities[TempLoopInspection], 0) +
						//	"%\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vThreshold, 0) + "\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vSize, 0) + "\t" + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName + "\n";
					}
					else
					{
						FillToTab(&TempLineText, cTab1);
						TempLineText = TempLineText + Pad(dtoa(vSystemData.vThresholdSensitivities[TempLoopInspection], 0), 3, 0) + "," + Pad(dtoa(vSystemData.vLearnSensitivities[TempLoopInspection], 0), 3, 0);
						FillToTab(&TempLineText, cTab2);
						TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vThreshold, 0), 4, 0);
						FillToTab(&TempLineText, cTab3);
						TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vSize, 0), 3, 0);
						//TempString = TempString + dtoa(TempLoopInspection + 1, 0) + "\t" + dtoa(vSystemData.vThresholdSensitivities[TempLoopInspection], 0) + "," + dtoa(vSystemData.vLearnSensitivities[TempLoopInspection], 0) +
						//	"%\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vThreshold, 0) + "\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vSize, 0) + "\t" + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName + "\n";
					}

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vTrimEdgesOfJar)
					TempLineText = TempLineText + ", Trim";

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vPreSmoothImage)
						TempLineText = TempLineText + ", M" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vPreSmoothImage, 0);

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vAddHistogram)
						TempLineText = TempLineText + ", H";

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDilationCount)
						TempLineText = TempLineText + ", D" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDilationCount, 0);

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vErodeCount)
						TempLineText = TempLineText + ", E" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vErodeCount, 0);

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDilationCountAtEnd)
						TempLineText = TempLineText + ", ED" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDilationCountAtEnd, 0);

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vErodeCountAtEnd)
						TempLineText = TempLineText + ", EE" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vErodeCountAtEnd, 0);

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cSpotInROIContaminantInspection)
						TempLineText = TempLineText + ", S" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vPixelsStepToNextROI, 0);

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cSpotInROIContaminantInspection)
					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDesensitizeIrregularArea)
						TempLineText = TempLineText + ", I" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDesensitizeIrregularArea, 0);

					if (vGlobalCurrentProduct->vInspection[TempLoopInspection]->vInspectionType == cSpotInROIContaminantInspection)
						TempLineText = TempLineText + ", D" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vDesensitizeEdgePixels, 0);

				}
				FillToTab(&TempLineText, cTab4);
				TempString = TempString + "\n" + TempLineText + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName;
			}
			//display ROIs
			//TempString = TempString + "\n-----------------------------------------------------------------------------\nInspection ROIs\n#\tLeft\tRight\tBottom\tTop\tInspection Name\n";
			TempString = TempString + "\n-----------------------------------------------------------------------------\nInspection ROIs";

			TempLineText = " #";

			FillToTab(&TempLineText, cTab1);
			TempLineText = TempLineText + "Left";

			FillToTab(&TempLineText, cTab2);
			TempLineText = TempLineText + "Right";

			FillToTab(&TempLineText, cTab3);
			TempLineText = TempLineText + "Bottom";

			FillToTab(&TempLineText, cTab4);
			TempLineText = TempLineText + "Top";

			FillToTab(&TempLineText, cTab5);
			TempLineText = TempLineText + "Inspection Name";

			TempString = TempString + "\n" + TempLineText;

			for (BYTE TempLoopInspection = 0; TempLoopInspection < vGlobalCurrentProduct->vNumberOfInspections; TempLoopInspection++)
			if (vGlobalCurrentProduct->vInspection[TempLoopInspection])
			{
				TempLineText = Pad(dtoa(TempLoopInspection + 1, 0), 2, 0);

				FillToTab(&TempLineText, cTab1);
				TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vROILeft, 2), 2, 2);

				FillToTab(&TempLineText, cTab2);
				TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vROIRight, 2), 2, 2);

				FillToTab(&TempLineText, cTab3);
				TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vROIBottom, 2), 2, 2);

				FillToTab(&TempLineText, cTab4);
				TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vROITop, 2), 2, 2);

				FillToTab(&TempLineText, cTab5);
				TempLineText = TempLineText + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName;

				TempString = TempString + "\n" + TempLineText;

				//TempString = TempString + dtoa(TempLoopInspection + 1,0) + "\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vROILeft, 2) + "\t" + 
				//	dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vROIRight, 2) + "\t" + dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vROIBottom, 2) + "\t" + 
				//	dtoa(vGlobalCurrentProduct->vInspection[TempLoopInspection]->vROITop, 2) + "\t" + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName + "\n";
			}

			TempString = TempString + "\n-----------------------------------------------------------------------------\nContainer Reference Locations";
			//\nImage\tLeft\tRight\tBottom\tTop\n";

			TempLineText = "";
			FillToTab(&TempLineText, cTab1);
			TempLineText = TempLineText + "Left";

			FillToTab(&TempLineText, cTab2);
			TempLineText = TempLineText + "Right";

			FillToTab(&TempLineText, cTab3);
			TempLineText = TempLineText + "Bottom";

			FillToTab(&TempLineText, cTab4);
			TempLineText = TempLineText + "Top";

			TempString = TempString + "\n" + TempLineText;

			//TempString = TempString + "\t" + dtoa(vGlobalCurrentProduct->vReferenceLeft / vGlobalPixelsPerUnit, 2) + "\t" + 
			//	dtoa(vGlobalCurrentProduct->vReferenceRight / vGlobalPixelsPerUnit, 2) + "\t" + dtoa(vGlobalCurrentProduct->vReferenceBottom / vGlobalPixelsPerUnit, 2) + "\t" + 
			//	dtoa(vGlobalCurrentProduct->vReferenceTop / vGlobalPixelsPerUnit, 2) + "\n";

			TempLineText = "";

			FillToTab(&TempLineText, cTab1);
			TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vReferenceLeft / vGlobalPixelsPerUnit, 2), 2, 2);

			FillToTab(&TempLineText, cTab2);
			TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vReferenceRight / vGlobalPixelsPerUnit, 2), 2, 2);

			FillToTab(&TempLineText, cTab3);
			TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vReferenceBottom / vGlobalPixelsPerUnit, 2), 2, 2);

			FillToTab(&TempLineText, cTab4);
			TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vReferenceTop / vGlobalPixelsPerUnit, 2), 2, 2);

			TempString = TempString + "\n" + TempLineText;

			TempString = TempString + "\n-----------------------------------------------------------------------------";

			TempLineText = "";

			FillToTab(&TempLineText, cTab1);
			TempLineText = TempLineText + "Image Size";

			FillToTab(&TempLineText, cTab2);
			TempLineText = TempLineText + "Width";

			FillToTab(&TempLineText, cTab3);
			TempLineText = TempLineText + "Height";

			TempString = TempString + "\n" + TempLineText;

			//TempString = TempString + "\t\t" + dtoa(vGlobalCurrentProduct->vProductImageWidthInInches, 2) + "\t\t" + dtoa(vGlobalCurrentProduct->vProductDisplayImageHeightInInches - vGlobalCurrentProduct->vProductImageHeightBottom, 2);

			TempLineText = "";
			FillToTab(&TempLineText, cTab2);
			TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vProductImageWidth, 2), 2, 2);

			FillToTab(&TempLineText, cTab3);
			TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vProductImageHeightTop - vGlobalCurrentProduct->vProductImageHeightBottom, 2), 2, 2);

			TempString = TempString + "\n" + TempLineText;
		}
		else
			TempString = " There are no Inspections for this Product.\n";

		TempString = TempString + "\n-----------------------------------------------------------------------------\nExposure Settings";
		TempLineText = " ";
		FillToTab(&TempLineText, cTab1);
		TempLineText = TempLineText + "Voltage (KV)";
		FillToTab(&TempLineText, cTab3);
		TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vXRaySourceVoltage * 6), 2, 2);
		TempString = TempString + "\n" + TempLineText;

		TempLineText = " ";
		FillToTab(&TempLineText, cTab1);
		TempLineText = TempLineText + "Current (mA)";
		FillToTab(&TempLineText, cTab3);
		TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vXRaySourceCurrent), 2, 2);
		TempString = TempString + "\n" + TempLineText;

		TempLineText = " ";
		FillToTab(&TempLineText, cTab1);
		TempLineText = TempLineText + "Integration Time (mSec)";
		FillToTab(&TempLineText, cTab3);
		TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vXRayIntegrationTime * .0004), 2, 2);
		TempString = TempString + "\n" + TempLineText;

		if (vGlobalCurrentProduct->vSetupHistoryAverageDensity > 0)
		{
			TempLineText = " ";
			FillToTab(&TempLineText, cTab1);
			TempLineText = TempLineText + "Learned Brightness";
			FillToTab(&TempLineText, cTab3 - 1);
			TempLineText = TempLineText + Pad(dtoa(vGlobalCurrentProduct->vSetupHistoryAverageDensity, 1), 3, 2);
			TempString = TempString + "\n" + TempLineText;
		}

		if (vGlobalCurrentProduct->vHistoryTookAverageDate)
		{
			TempLineText = " ";
			FillToTab(&TempLineText, cTab1);
			TempLineText = TempLineText + "Learned on";
			FillToTab(&TempLineText, cTab3);
			TempLineText = TempLineText + vGlobalCurrentProduct->vHistoryTookAverageDate;
			TempString = TempString + "\n" + TempLineText;
		}


		WriteStringToFile("ProductThresholds " + vSystemData.vCurrentProductName, TempString);
	}
	else
		TempString = " You Must Select A Product to see its Inspection Thresholds.\n";

	CHelpDialog IHelpDialog;
	IHelpDialog.vHelpContext = 16;
	IHelpDialog.vShowTable = true;
	IHelpDialog.vHelpType = 0;
	IHelpDialog.vWindowType = cTextWindow;
	IHelpDialog.vLocalProductCollection = &vProductCollection;
	IHelpDialog.vLocalSystemData = &vSystemData;
	IHelpDialog.vMainWindowPointer = this;
	IHelpDialog.vLocalConfigurationData = vConfigurationData;
	IHelpDialog.vProductPointer = vGlobalCurrentProduct;
	IHelpDialog.vTextString = TempString;

	if (vSystemData.vCurrentProductName.GetLength() > 18)
		IHelpDialog.vTitleString = "Product: " + vSystemData.vCurrentProductName;
	else
		IHelpDialog.vTitleString = "Inspection Thresholds for Product: " + vSystemData.vCurrentProductName;
	int TempResult = IHelpDialog.DoModal();

	OnFunction1Button();
}

void CScanTracDlg::ShowInspxButtons()
{
	m_Function3Button.ShowWindow(SW_SHOW);
	//m_Function3Button.ModifyStyle(NULL,SS_CENTERIMAGE,NULL);
	TempText.LoadString(IDS_Diagnostics);
	SetDlgItemText(IDC_Function3Button,TempText);

	UpdateClearYellowMessageButton();
}

//void CScanTracDlg::CheckIfDetectorCalibrationNeeded()
//{
//	bool TempOriginalValue = vSystemData.vDetectorCalibrationNeeded;
//	vSystemData.vDetectorCalibrationNeeded = false;
//
//	if (!vConfigurationData->vHideNeedDetectorCal)
//	{
//		WIN32_FIND_DATA FindFileData;
//		HANDLE hFind;
//		CString TempFileNameC = vConfigurationData->vScanTracCalibrationImagesDirectory + "CalibratePixelsData*.csv";
//		CString TempFileNameStringF = "Test";
//		LPTSTR TempFileFindNameString = TempFileNameC.GetBuffer(TempFileNameC.GetLength());
//		CFileStatus TempFileStatus;
//
//		hFind = FindFirstFile(TempFileFindNameString, &FindFileData);
//		if (hFind != INVALID_HANDLE_VALUE)
//		{
//			CString TempFileNameStringA = FindFileData.cFileName;
//			if (TempFileNameStringA.GetLength() > 20)
//			{
//				CTime TempMostRecentDate = FindFileData.ftLastWriteTime;
//				TempFileNameStringF = vConfigurationData->vScanTracCalibrationImagesDirectory + FindFileData.cFileName;
//				while (FindNextFile(hFind,&FindFileData))
//				{
//					if (TempMostRecentDate < FindFileData.ftLastWriteTime)
//					{
//						TempMostRecentDate = FindFileData.ftLastWriteTime;
//						TempFileNameStringF = vConfigurationData->vScanTracCalibrationImagesDirectory + FindFileData.cFileName;
//					}
//				}
//
//				LPTSTR TempFileNameString = TempFileNameStringF.GetBuffer(TempFileNameStringF.GetLength());
//				CFileStatus TempStatus;
//				if (CFile::GetStatus(TempFileNameString, TempStatus))
//				{
//					//vTextString = vTextString + "\nDetectors last calibrated on: " + TempMostRecentDate.Format("%B %d %Y %H:%M:%S");//24 hour time format
//					//vTextString = vTextString + "\nDetectors calibrated file: " + TempStatus.m_szFullName;
//
//					CTime TempTime;
//					TempTime = CTime::GetCurrentTime();
//
//					if (TempTime >= TempMostRecentDate + (31536000 / 2)) // 365 days * 24 hrs * 60 min * 60 sec/min = 31536000 seconds in a year
//						vSystemData.vDetectorCalibrationNeeded = true;
//				}
//				else
//					vSystemData.vDetectorCalibrationNeeded = true;  //can't find calibration file, so say required
//			}
//			else
//				vSystemData.vDetectorCalibrationNeeded = true;  //can't find calibration file, so say required
//		}
//		else
//			vSystemData.vDetectorCalibrationNeeded = true;  //can't find calibration file, so say required
//	}
//	if (TempOriginalValue != vSystemData.vDetectorCalibrationNeeded)
//	{
//		SetInterlockStatus();
//		UpdateClearYellowMessageButton();
//	}
//}

void CScanTracDlg::SetupMenu() //resize all windows, just for main menu
{
	if ((vGlobalDisplaySizeH != 640) || (vGlobalDisplaySizeV != 480))
	{
		for (BYTE TempLoop = 0; TempLoop < vLocalCWndCollection.GetCount(); TempLoop++)
		{
			RECT TempRectCoor;
			vLocalCWndCollection[TempLoop]->GetWindowRect(&TempRectCoor);
			if (ItemRECTArray[TempLoop].bottom == 0) //initial setup
			{
				if (vLocalCWndCollection[TempLoop] == &m_LearnState)
				{
					LOGFONT TempLogFont;
					if ((vLocalCWndCollection[TempLoop]->GetFont())->GetLogFont(&TempLogFont) == 0 && TempLogFont.lfHeight <= 0)
						continue;

					if ((vGlobalDisplaySizeH != 640) || (vGlobalDisplaySizeV != 480))
						vLocalCWndCollection[TempLoop]->SetWindowPos(NULL,ResizeXCoor(TempRectCoor.left), 
											(ResizeYCoor(TempRectCoor.top) + (TempLogFont.lfHeight/2)),
											ResizeXCoor(TempRectCoor.right-TempRectCoor.left),
											ResizeYCoor(TempRectCoor.bottom-TempRectCoor.top),
											SWP_NOZORDER);
				}
				else
				if ((vGlobalDisplaySizeH != 640) || (vGlobalDisplaySizeV != 480))
					::SetupItem(vLocalCWndCollection[TempLoop]);
				vLocalCWndCollection[TempLoop]->GetWindowRect(&TempRectCoor);
				ItemRECTArray[TempLoop] = TempRectCoor;
			}
			//If the background changes after the first call to this function
			else 
			if ((TempRectCoor.right != ItemRECTArray[TempLoop].right || TempRectCoor.top != ItemRECTArray[TempLoop].top ||
					 TempRectCoor.bottom != ItemRECTArray[TempLoop].bottom || TempRectCoor.left != ItemRECTArray[TempLoop].left) 
					 && (vLocalCWndCollection[TempLoop] == &m_MainBackground2 || vLocalCWndCollection[TempLoop] == &m_MainBackground))
			{
			if ((vGlobalDisplaySizeH != 640) || (vGlobalDisplaySizeV != 480))
					::SetupItem(vLocalCWndCollection[TempLoop]);
				vLocalCWndCollection[TempLoop]->GetWindowRect(&TempRectCoor);
				ItemRECTArray[TempLoop] = TempRectCoor;
			}
			//If the size of anything else changes after the first call to this function
			else 
			if ((TempRectCoor.right-TempRectCoor.left != ItemRECTArray[TempLoop].right-ItemRECTArray[TempLoop].left || 
					 TempRectCoor.bottom-TempRectCoor.top != ItemRECTArray[TempLoop].bottom-ItemRECTArray[TempLoop].top)
					  && (vLocalCWndCollection[TempLoop] != &m_MainBackground2 && vLocalCWndCollection[TempLoop] != &m_MainBackground))
			{
			if (vLocalCWndCollection[TempLoop] == &m_LearnState)
			{
				LOGFONT TempLogFont;
				if ((vLocalCWndCollection[TempLoop]->GetFont())->GetLogFont(&TempLogFont) == 0)
					continue;

				if ((vGlobalDisplaySizeH > 1024) || (vGlobalDisplaySizeV > 768))
					vLocalCWndCollection[TempLoop]->SetWindowPos(NULL,ResizeXCoor(TempRectCoor.left), 
											(ResizeYCoor(TempRectCoor.top) + (TempLogFont.lfHeight/2) + 7),
											ResizeXCoor(TempRectCoor.right-TempRectCoor.left),
											ResizeYCoor(TempRectCoor.bottom-TempRectCoor.top),
											SWP_NOZORDER);
				else if ((vGlobalDisplaySizeH > 640) || (vGlobalDisplaySizeV > 480))
					vLocalCWndCollection[TempLoop]->SetWindowPos(NULL,ResizeXCoor(TempRectCoor.left), 
											(ResizeYCoor(TempRectCoor.top) + (TempLogFont.lfHeight/2) + 5),
											ResizeXCoor(TempRectCoor.right-TempRectCoor.left),
											ResizeYCoor(TempRectCoor.bottom-TempRectCoor.top),
											SWP_NOZORDER);
															//if ((vGlobalDisplaySizeH != 640) || (vGlobalDisplaySizeV != 480))
				//	vLocalCWndCollection[TempLoop]->SetWindowPos(NULL,ResizeXCoor(TempRectCoor.left), 
				//						ResizeYCoor(TempRectCoor.top) + (TempLogFont.lfHeight),
				//						ResizeXCoor(TempRectCoor.right-TempRectCoor.left),
				//						(vGlobalRunningData->vGlobalMonitorSizeY),
				//						SWP_NOZORDER);
			}
			else 
			if ((vGlobalDisplaySizeH != 640) || (vGlobalDisplaySizeV != 480))
					::SetupItem(vLocalCWndCollection[TempLoop]);

				vLocalCWndCollection[TempLoop]->GetWindowRect(&TempRectCoor);
				ItemRECTArray[TempLoop] = TempRectCoor;
			}
		}
	}
}

void SetupMenu(tCWndCollection& TempCWndCollection)
{
	if ((vGlobalDisplaySizeH != 640) && (vGlobalDisplaySizeV != 480))
	{
		for (WORD TempLoop = 0; TempLoop < TempCWndCollection.GetCount(); TempLoop++)
		{
			SetupItem(TempCWndCollection[TempLoop]);
		}
	}
}

void SetupItem(CWnd* TempCWnd)
{
	RECT TempRectCoor;
	TempCWnd->GetWindowRect(&TempRectCoor);
	TempCWnd->SetWindowPos(NULL,
							ResizeXCoor(TempRectCoor.left), 
							ResizeYCoor(TempRectCoor.top),
							ResizeXCoor(TempRectCoor.right-TempRectCoor.left),
							ResizeYCoor(TempRectCoor.bottom-TempRectCoor.top),
							SWP_NOCOPYBITS | SWP_NOACTIVATE | SWP_NOZORDER);
}

DWORD ResizeXCoor(int TempIntToResize)
{
	if (vGlobalPercentToResizeX == 1.0)
		return(DWORD(TempIntToResize));
	else
		return(DWORD(TempIntToResize * vGlobalPercentToResizeX));
}

DWORD ResizeYCoor(int TempIntToResize)
{
	if (vGlobalPercentToResizeY == 1.0)
		return(DWORD(TempIntToResize));
	else
		return(DWORD(TempIntToResize * vGlobalPercentToResizeY));
}

// CTestTextDialog message handlers
int GetLongestWordFromString(CString TempInString, CString *TempOutString, int TempLength)
{
	if (TempLength > 0)
	{
		int i = 0, TempStarti, TempLongestLength, TempCurrentLength, TempLongestStarti;
		TempStarti = 0;
		TempLongestLength = 0;
		TempCurrentLength = 0;
		TempLongestStarti = 0;
		for (i = 0; i <= TempLength; i++)
		{
			if ((TempInString[i] == ' ') || (TempInString[i] == '\n') || TempInString[i] == 0)
			{
				if (TempCurrentLength >= TempLongestLength)
				{
					TempLongestStarti = TempStarti;
					TempLongestLength = TempCurrentLength;
				}
				TempStarti = i + 1;
				TempCurrentLength = 0;
			}
			else
			{
				TempCurrentLength++;
			}
		}
		*TempOutString = TempInString.Mid(TempLongestStarti, TempLongestLength);
		return TempLongestLength;
	}
	else
		return 0;
}

int GetNumberOfWordsInString(CString TempInString, int TempLength)
{
	int TempNumberOfWordsInString = 1;
	int TempPosition = TempInString.Find(_T(" "), 0);
	while (TempPosition >= 0)
	{
		TempNumberOfWordsInString++;
		TempPosition = TempInString.Find(_T(" "), TempPosition + 1);
	}

	TempPosition = TempInString.Find(_T("\n"), 0);
	while (TempPosition >= 0)
	{
		TempNumberOfWordsInString++;
		TempPosition = TempInString.Find(_T("\n"), TempPosition + 1);
	}

	return TempNumberOfWordsInString;
}

void FillToTab(CString *TempString, WORD TempTabPlace)
{
	WORD TempLength = TempString->GetLength();
	if (TempTabPlace)
	{
		while (TempLength < TempTabPlace)
		{
			*TempString = *TempString + " ";
			TempLength = TempString->GetLength();
		}
	}
}

int SetTextSizeSingleLineDisplay(HWND TempDialogHwnd, CWnd* pWnd, CDC* pDC, CWnd* m_TempControlVariable, int TempMaxTextSize)
{
	HDC vHDeviceContext = *pDC;
	LPSIZE TempSizeStruct;
	TempSizeStruct = (LPSIZE)malloc(sizeof(LPSIZE));
	
	if (TempSizeStruct)
	{
		RECT TempRect;
		m_TempControlVariable->GetWindowRect(&TempRect);
		int TempTextBoxWidth = TempRect.right - TempRect.left - 4;
		int TempTextBoxHeight = TempRect.bottom - TempRect.top;

		if (TempTextBoxWidth < 4)
			TempTextBoxWidth = 4;
		if (TempTextBoxHeight < 4)
			TempTextBoxHeight = 4;

		CString TempString = "                                                                                             ";
		int TempLength = TempString.GetLength();
		LPTSTR TempLptstr = TempString.GetBuffer(TempLength);
		TempLength = GetDlgItemText(TempDialogHwnd, pWnd->GetDlgCtrlID(), TempLptstr, 93);
		bool TempRepeat = false;

		do
		{
			if (vGlobalCurrentFonts)
				pDC->SelectObject(vGlobalCurrentFonts[TempMaxTextSize]);
			bool TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempString, TempLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx
		if (TempSizeStruct->cx > (TempTextBoxWidth) || (TempSizeStruct->cy > (TempTextBoxHeight)))
			{
				TempMaxTextSize--;
				if (TempMaxTextSize < 0)
				{
					//				ReportErrorMessage("Error - Text \"" + TempString + "\"is clipping", cEMailInspx, 32000);	//write error message to log
					TempRepeat = false;
				}
				else
					TempRepeat = true;
			}
			else
			{
				m_TempControlVariable->ModifyStyle(NULL, SS_CENTERIMAGE, NULL);
				TempRepeat = false;
			}
		} while (TempRepeat);

		DeleteObject(TempSizeStruct);
	}
	return TempMaxTextSize;
}

int GetTextSizeForASingleLineDisplay(HWND TempDialogHwnd, CWnd* pWnd, CDC* pDC, CWnd* m_TempControlVariable, int TempMaxTextSize)
{
	HDC vHDeviceContext = *pDC;
	LPSIZE TempSizeStruct;
	TempSizeStruct = (LPSIZE)malloc(sizeof(LPSIZE));
	int TempReturnSize = 100;

	if (TempSizeStruct)
	{
		CString TempString = "                                                                                             ";
		int TempLength = TempString.GetLength();
		LPTSTR TempLptstr = TempString.GetBuffer(TempLength);
		TempLength = GetDlgItemText(TempDialogHwnd, pWnd->GetDlgCtrlID(), TempLptstr, 93);

		if (vGlobalCurrentFonts)
			pDC->SelectObject(vGlobalCurrentFonts[TempMaxTextSize]);
		bool TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempString, TempLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx
		if (TempSuccess)
			TempReturnSize = TempSizeStruct->cx;

		DeleteObject(TempSizeStruct);
	}
	return TempReturnSize;
}

int SetTextSizeSubFunctionButton(HWND TempDialogHwnd, CWnd* pWnd, CDC* pDC,  CWnd* m_TempControlVariable, int TempMaxTextSize) //has 3 lines of text normally
{
	HDC vHDeviceContext = *pDC;
	LPSIZE TempSizeStruct;
	TempSizeStruct = (LPSIZE)malloc(sizeof(LPSIZE));
	
	if (TempSizeStruct)
	{
		RECT TempRect;
		m_TempControlVariable->GetWindowRect(&TempRect);
		int TempTextBoxWidth = TempRect.right - TempRect.left - 4;
		int TempTextBoxHeight = TempRect.bottom - TempRect.top;

		CString TempString = "                                                                          ", TempLongestWordString = " ";
		int TempLength = TempString.GetLength();
		LPTSTR TempLptstr = TempString.GetBuffer(TempLength);
		TempLength = GetDlgItemText(TempDialogHwnd, pWnd->GetDlgCtrlID(), TempLptstr, 74);

		int TempLongestWordLength = GetLongestWordFromString(TempString, &TempLongestWordString, TempLength);
		int TempNumberOfWordsInString = GetNumberOfWordsInString(TempString, TempLength);

		bool TempRepeat = true, TempSuccess = false;

		do
		{
			if (vGlobalCurrentFonts)
				pDC->SelectObject(vGlobalCurrentFonts[TempMaxTextSize]);

			TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempString, TempLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx
			int TempWholeStringPixelLength = TempSizeStruct->cx;

			TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempLongestWordString, TempLongestWordLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx
			int TempLongestWordPixelLength = TempSizeStruct->cx;

			int TempNumberOfLinesThatWillFitInBoxAtThisSize = 3;
			if (TempSizeStruct->cy)
				TempNumberOfLinesThatWillFitInBoxAtThisSize = TempTextBoxHeight / TempSizeStruct->cy;

			//if this text will fit in the box at this size, then we are done
			if ((TempLongestWordPixelLength <= TempTextBoxWidth) && (TempWholeStringPixelLength < TempTextBoxWidth * TempNumberOfLinesThatWillFitInBoxAtThisSize))
				//if ((TempLongestWordPixelLength < TempTextBoxWidth) && (TempWholeStringPixelLength < TempTextBoxWidth * TempNumberOfLinesThatWillFitInBoxAtThisSize) && 
				//	(TempNumberOfWordsInString <= TempNumberOfLinesThatWillFitInBoxAtThisSize + 1))
			{
				if ((TempWholeStringPixelLength <= TempTextBoxWidth) && (TempString.Find('\n') == -1)) //if all text fits in box width and no carrage return in text
				{
					m_TempControlVariable->ModifyStyle(NULL, SS_CENTERIMAGE, NULL);
					break;
				}
				else
					m_TempControlVariable->ModifyStyle(SS_CENTERIMAGE, NULL, NULL);

				int *TempIntArray = NumberOfWords(TempString, TempLength);	//get number of words [0] and number of letters in each word
				if (TempIntArray)
				{
					int i, TempStart = 0, TempWordLength = 0, TempLineNumber = 1, TempWidthOfSpace, TempWidthOfCurrentLine = 0;
					CString TempWordString;
					bool TempAreMultipleWordsOverflowingOntoAThirdLine = false;

					TempSuccess = GetTextExtentPoint32(vHDeviceContext, _T(" "), 1, TempSizeStruct) != 0; //find width of space
					TempWidthOfSpace = TempSizeStruct->cx;

					for (i = 1; i <= TempIntArray[0]; i++)	//change letter count in TempIntArray to widths
					{
						TempWordLength = TempIntArray[i];
						TempWordString = TempString.Mid(TempStart, TempWordLength);
						TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempWordString, TempWordLength, TempSizeStruct) != 0;

						if (TempWidthOfCurrentLine == 0)
							TempWidthOfCurrentLine = TempSizeStruct->cx;
						else
							TempWidthOfCurrentLine = TempWidthOfSpace + TempWidthOfCurrentLine + TempSizeStruct->cx;

						wchar_t TempWhitespace = ' ';
						if (TempStart > 0)
							TempWhitespace = TempString.GetAt(TempStart - 1);

						if ((TempWidthOfCurrentLine > (TempTextBoxWidth))
							|| (TempWhitespace == 10))
						{
							TempLineNumber++;
							TempWidthOfCurrentLine = TempSizeStruct->cx;
							if (TempLineNumber > TempNumberOfLinesThatWillFitInBoxAtThisSize)
							{
								TempMaxTextSize--;
								TempRepeat = true;
								TempAreMultipleWordsOverflowingOntoAThirdLine = true;
								break;
							}
						}

						TempStart = TempStart + TempWordLength + 1;
					}

					if (TempAreMultipleWordsOverflowingOntoAThirdLine == false)
					{
						m_TempControlVariable->ModifyStyle(SS_CENTERIMAGE, NULL, NULL);	//remove center justification
						TempRepeat = false;

						//if ((TempLineNumber == 2) && (TempIntArray[0] > 2))	//if there are more than two words on only two lines, push to three lines
						//{
						//	TempString.SetAt(TempIntArray[1], '\n');
						//	if (TempIntArray[TempIntArray[0]] > 1)
						//		TempString.SetAt(TempStart - TempIntArray[TempIntArray[0]] - 2, '\n');	//start is currently at end of string minus last word minus one for the null char at end of string and - 1 for whitespace before word
						//	SetDlgItemText(TempDialogHwnd, pWnd->GetDlgCtrlID(), TempString);
						//}
					}
					free(TempIntArray);
				}
			}
			else
			{
				if (TempMaxTextSize)
				{
					TempMaxTextSize--;
					TempRepeat = true;
				}
				else
				{
					//			ReportErrorMessage("Error - Text \"" + TempString + "\"is clipping", cEMailInspx, 32000);	//write error message to log
					TempRepeat = false;
				}
			}
		} while (TempRepeat);

		DeleteObject(TempSizeStruct);
	}
	return TempMaxTextSize;
}


int SetTextSizeMultilineDisplay(HWND TempDialogHwnd, CWnd* pWnd, CDC* pDC,  CWnd* m_TempControlVariable, int TempMaxTextSize)
{
	HDC vHDeviceContext = *pDC;
	LPSIZE TempSizeStruct;
	TempSizeStruct = (LPSIZE)malloc(sizeof(LPSIZE));
	
	if (TempSizeStruct)
	{
		RECT TempRect;
		m_TempControlVariable->GetWindowRect(&TempRect);
		int TempTextBoxWidth = TempRect.right - TempRect.left - 4;
		int TempTextBoxHeight = TempRect.bottom - TempRect.top;

		//CString TempString = "                                                                                                                                                                                                                                                                  ";
		char TempCharArray[1000];
		for (int i = 0; i < 1000; i++)
			TempCharArray[i] = ' ';
		CString TempString = (CString)TempCharArray;
		CString TempLongestWordString = " ";
		int TempLength = TempString.GetLength();
		LPTSTR TempLptstr = TempString.GetBuffer(TempLength);
		TempLength = GetDlgItemText(TempDialogHwnd, pWnd->GetDlgCtrlID(), TempLptstr, TempLength - 3);

		int TempLongestWordLength = GetLongestWordFromString(TempString, &TempLongestWordString, TempLength);
		bool TempRepeat = false, TempSuccess = false;

		do
		{
			if (vGlobalCurrentFonts)
				pDC->SelectObject(vGlobalCurrentFonts[TempMaxTextSize]);
			TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempString, TempLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx

			int TempNumberOfLinesInTextBoxAtThisSize = 0;
			if (TempSizeStruct->cy)
				TempNumberOfLinesInTextBoxAtThisSize = (TempTextBoxHeight) / TempSizeStruct->cy;

			int *TempIntArray = NumberOfWords(TempString, TempLength);	//get number of words [0] and number of letters in each word
			if (TempIntArray)
			{
				int i, TempStart = 0, TempWordLength = 0, TempLineNumber = 1, TempWidthOfSpace, TempWidthOfCurrentLine = 0;
				CString TempWordString;
				bool TempAreMultipleWordsOverflowingOntoAThirdLine = false;

				TempSuccess = GetTextExtentPoint32(vHDeviceContext, _T(" "), 1, TempSizeStruct) != 0; //find width of space
				TempWidthOfSpace = TempSizeStruct->cx;

				wchar_t TempChar = ' ';
				for (i = 0; i < TempLength; i++)
				{
					TempChar = TempString.GetAt(i);
					if (TempChar == ' ')	//get through whitespace at front
					{
						TempStart++;
					}
					else
						if (TempChar == 10)
						{
							TempLineNumber++;
							TempStart++;
						}
						else
							break;
				}

				for (i = 1; i <= TempIntArray[0]; i++)	//go through each word to see how many lines the words use
				{
					TempWordLength = TempIntArray[i];
					TempWordString = TempString.Mid(TempStart, TempWordLength);
					TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempWordString, TempWordLength, TempSizeStruct) != 0;
					TempIntArray[i] = TempSizeStruct->cx;

					if (TempWidthOfCurrentLine == 0)
						TempWidthOfCurrentLine = TempSizeStruct->cx;
					else
						TempWidthOfCurrentLine = TempWidthOfSpace + TempWidthOfCurrentLine + TempSizeStruct->cx;

					wchar_t TempWhitespace = ' ';
					if (i > 1)
						TempWhitespace = TempString.GetAt(TempStart - 1);

					if ((TempWidthOfCurrentLine > TempTextBoxWidth) || (TempWhitespace == 10))
					{
						TempLineNumber++;
						TempWidthOfCurrentLine = TempSizeStruct->cx;
						if (TempLineNumber > TempNumberOfLinesInTextBoxAtThisSize)
						{
							TempMaxTextSize--;
							TempRepeat = true;
							TempAreMultipleWordsOverflowingOntoAThirdLine = true;
							break;
						}
					}

					TempStart = TempStart + TempWordLength + 1;
				}

				if (TempAreMultipleWordsOverflowingOntoAThirdLine == false)
				{
					m_TempControlVariable->ModifyStyle(SS_CENTERIMAGE, NULL, NULL);	//remove center justification
					TempRepeat = false;
				}
				free(TempIntArray);
			}
		} while (TempRepeat);

		DeleteObject(TempSizeStruct);
	}
	return TempMaxTextSize;
}

int SetTextSizeSubFunctionButton(HWND TempDialogHwnd, CWnd* pWnd, CDC* pDC,  CWnd* m_TempControlVariable, int TempMaxTextSize, BYTE TempArrowsAreSet) //has 1 line of text normally when arrows are set, 3 lines otherwise
{
	HDC vHDeviceContext = *pDC;
	LPSIZE TempSizeStruct;
	TempSizeStruct = (LPSIZE)malloc(sizeof(LPSIZE));
	
	if (TempSizeStruct)
	{
		RECT TempRect;
		m_TempControlVariable->GetWindowRect(&TempRect);
		int TempTextBoxWidth = TempRect.right - TempRect.left - 4;
		int TempTextBoxHeight = TempRect.bottom - TempRect.top;

		CString TempString = "                                                                          ", TempLongestWordString = " ";
		int TempLength = TempString.GetLength();
		LPTSTR TempLptstr = TempString.GetBuffer(TempLength);
		TempLength = GetDlgItemText(TempDialogHwnd, pWnd->GetDlgCtrlID(), TempLptstr, 74);

		int TempLongestWordLength = GetLongestWordFromString(TempString, &TempLongestWordString, TempLength);
		int TempNumberOfWordsInString = GetNumberOfWordsInString(TempString, TempLength);

		bool TempRepeat = true, TempSuccess = false;

		do
		{
			if (vGlobalCurrentFonts)
				pDC->SelectObject(vGlobalCurrentFonts[TempMaxTextSize]);

			TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempString, TempLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx
			int TempWholeStringPixelLength = TempSizeStruct->cx;

			TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempLongestWordString, TempLongestWordLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx
			int TempLongestWordPixelLength = TempSizeStruct->cx;

			int TempNumberOfLinesThatWillFitInBoxAtThisSize = 3;
			if (TempSizeStruct->cy)
				TempNumberOfLinesThatWillFitInBoxAtThisSize = TempTextBoxHeight / TempSizeStruct->cy;

			//if this text will fit in the box at this size, then we are done
			if ((TempLongestWordPixelLength <= TempTextBoxWidth) && (TempWholeStringPixelLength < TempTextBoxWidth * TempNumberOfLinesThatWillFitInBoxAtThisSize))
				//if ((TempLongestWordPixelLength < TempTextBoxWidth) && (TempWholeStringPixelLength < TempTextBoxWidth * TempNumberOfLinesThatWillFitInBoxAtThisSize) && 
				//	(TempNumberOfWordsInString <= TempNumberOfLinesThatWillFitInBoxAtThisSize + 1))
			{
				if ((TempWholeStringPixelLength <= TempTextBoxWidth) && (TempString.Find('\n') == -1)) //if all text fits in box width and no carrage return in text
				{
					if (TempArrowsAreSet)
						m_TempControlVariable->ModifyStyle(SS_CENTERIMAGE, NULL, NULL);
					else //TempArrowsAreSet is false
						m_TempControlVariable->ModifyStyle(NULL, SS_CENTERIMAGE, NULL);
					break;
				}
				else
					m_TempControlVariable->ModifyStyle(SS_CENTERIMAGE, NULL, NULL);

				int *TempIntArray = NumberOfWords(TempString, TempLength);	//get number of words [0] and number of letters in each word
				if (TempIntArray)
				{
					int i, TempStart = 0, TempWordLength = 0, TempLineNumber = 1, TempWidthOfSpace, TempWidthOfCurrentLine = 0;
					CString TempWordString;
					bool TempAreMultipleWordsOverflowingOntoAThirdLine = false;

					TempSuccess = GetTextExtentPoint32(vHDeviceContext, _T(" "), 1, TempSizeStruct) != 0; //find width of space
					TempWidthOfSpace = TempSizeStruct->cx;

					for (i = 1; i <= TempIntArray[0]; i++)	//change letter count in TempIntArray to widths
					{
						TempWordLength = TempIntArray[i];
						TempWordString = TempString.Mid(TempStart, TempWordLength);
						TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempWordString, TempWordLength, TempSizeStruct) != 0;

						if (TempWidthOfCurrentLine == 0)
							TempWidthOfCurrentLine = TempSizeStruct->cx;
						else
							TempWidthOfCurrentLine = TempWidthOfSpace + TempWidthOfCurrentLine + TempSizeStruct->cx;

						wchar_t TempWhitespace = ' ';
						if (TempStart > 0)
							TempWhitespace = TempString.GetAt(TempStart - 1);

						if ((TempWidthOfCurrentLine > (TempTextBoxWidth))
							|| (TempWhitespace == 10))
						{
							TempLineNumber++;
							TempWidthOfCurrentLine = TempSizeStruct->cx;
							if (TempLineNumber > TempNumberOfLinesThatWillFitInBoxAtThisSize)
							{
								TempMaxTextSize--;
								TempRepeat = true;
								TempAreMultipleWordsOverflowingOntoAThirdLine = true;
								break;
							}
						}

						TempStart = TempStart + TempWordLength + 1;
					}

					if (TempAreMultipleWordsOverflowingOntoAThirdLine == false)
					{
						m_TempControlVariable->ModifyStyle(SS_CENTERIMAGE, NULL, NULL);	//remove center justification
						TempRepeat = false;

						if ((TempLineNumber == 2) && (TempIntArray[0] > 2))	//if there are more than two words on only two lines, push to three lines
						{
							TempString.SetAt(TempIntArray[1], '\n');
							TempString.SetAt(TempStart - TempIntArray[TempIntArray[0]] - 2, '\n');	//start is currently at end of string minus last word minus one for the null char at end of string and - 1 for whitespace before word
							SetDlgItemText(TempDialogHwnd, pWnd->GetDlgCtrlID(), TempString);
						}
					}
					free(TempIntArray);
				}
			}
			else
			{
				if (TempMaxTextSize)
				{
					TempMaxTextSize--;
					TempRepeat = true;
				}
				else
				{
					//			ReportErrorMessage("Error - Text \"" + TempString + "\"is clipping", cEMailInspx, 32000);	//write error message to log
					TempRepeat = false;
				}
			}
		} while (TempRepeat);

		DeleteObject(TempSizeStruct);
	}
	return TempMaxTextSize;
}

int SetTextSizeFunctionButton(HWND TempDialogHwnd, CWnd* pWnd, CDC* pDC, CWnd* m_TempControlVariable, int TempMaxTextSize)  //has 2 lines of text normally
{
	HDC vHDeviceContext = *pDC;
	LPSIZE TempSizeStruct;
	TempSizeStruct = (LPSIZE)malloc(sizeof(LPSIZE));

	if (TempSizeStruct)
	{
		RECT TempRect;
		m_TempControlVariable->GetWindowRect(&TempRect);
		int TempTextBoxWidth = TempRect.right - TempRect.left - 2;
		int TempTextBoxHeight = TempRect.bottom - TempRect.top;

		CString TempString = "                                                                          ", TempLongestWordString = " ";
		int TempLength = TempString.GetLength();
		LPTSTR TempLptstr = TempString.GetBuffer(TempLength);
		TempLength = GetDlgItemText(TempDialogHwnd, pWnd->GetDlgCtrlID(), TempLptstr, 74);
		//	SetDlgItemText(TempDialogHwnd, pWnd->GetDlgCtrlID(), " yes");
		int TempLongestWordLength = GetLongestWordFromString(TempString, &TempLongestWordString, TempLength);
		BYTE TempNumberOfLinesThatWillFitInBoxAtThisSize = 2;

		int TempNumberOfWordsInString = 1;
		int TempPosition = TempString.Find(_T(" "), 0);
		if (TempPosition >= 0)
		{
			TempNumberOfWordsInString = 2;
		}

		bool TempRepeat = false, TempSuccess = false;
		do
		{
			if (vGlobalCurrentFonts)
				pDC->SelectObject(vGlobalCurrentFonts[TempMaxTextSize]);
			TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempString, TempLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx

			if (TempSizeStruct->cy)
				TempNumberOfLinesThatWillFitInBoxAtThisSize = (BYTE)(TempTextBoxHeight / TempSizeStruct->cy);

			if (TempSizeStruct->cx <= (TempTextBoxWidth))
			{
				if (TempString.Find('\n') == -1)	//if there are no new line characters in the string
				{
					m_TempControlVariable->ModifyStyle(NULL, SS_CENTERIMAGE, NULL);	//center image vertically
					break;
				}
			}

			if ((TempSizeStruct->cx / 2) > (TempTextBoxWidth) || (TempSizeStruct->cy * 2 > (TempTextBoxHeight)))
			{
				TempMaxTextSize--;
				if (TempMaxTextSize < 0)
				{
					//			ReportErrorMessage("Error - Text \"" + TempString + "\"is clipping", cEMailInspx, 32000);	//write error message to log
					TempRepeat = false;
				}
				else
					TempRepeat = true;
			}
			else	//if the length of the button text fits on 3 lines, check if the biggest word fits on one line
			{
				TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempString, TempLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx
				int TempWholeStringPixelLength = TempSizeStruct->cx;

				TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempLongestWordString, TempLongestWordLength, TempSizeStruct) != 0;	//https://msdn.microsoft.com/en-us/library/dd144938(VS.85).aspx
				int TempLongestWordPixelLength = TempSizeStruct->cx;
				if ((TempLongestWordPixelLength > TempTextBoxWidth) || (TempWholeStringPixelLength > TempTextBoxWidth * 2))
				{
					TempMaxTextSize--;
					if (TempMaxTextSize == 0)
					{
						//				ReportErrorMessage("Error - Text \"" + TempString + "\"is clipping", cEMailInspx, 32000);	//write error message to log
						TempRepeat = false;
					}
					else
						TempRepeat = true;
				}
				else
				{
					bool TempAreMultipleWordsOverflowingOntoAThirdLine = false;
					int *TempIntArray = NumberOfWords(TempString, TempLength);	//get number of words [0] and number of letters in each word
					if (TempIntArray)
					{
						int i, TempStart = 0, TempWordLength = 0, TempLineNumber = 1, TempWidthOfSpace, TempWidthOfCurrentLine = 0;
						CString TempWordString;

						TempSuccess = GetTextExtentPoint32(vHDeviceContext, _T(" "), 1, TempSizeStruct) != 0; //find width of space
						TempWidthOfSpace = TempSizeStruct->cx;

						for (i = 1; i <= TempIntArray[0]; i++)	//change letter count in TempIntArray to widths
						{
							TempWordLength = TempIntArray[i];
							TempWordString = TempString.Mid(TempStart, TempWordLength);
							TempSuccess = GetTextExtentPoint32(vHDeviceContext, TempWordString, TempWordLength, TempSizeStruct) != 0;
							//TempIntArray[i] = TempSizeStruct->cx;

							if (TempWidthOfCurrentLine == 0)
								TempWidthOfCurrentLine = TempSizeStruct->cx;
							else
								TempWidthOfCurrentLine = TempWidthOfSpace + TempWidthOfCurrentLine + TempSizeStruct->cx;

							wchar_t TempWhitespace = ' ';
							if (TempStart > 0)
								TempWhitespace = TempString.GetAt(TempStart - 1);

							if ((TempWidthOfCurrentLine + 5 > (TempTextBoxWidth)) || (TempWhitespace == 10))
							{
								TempLineNumber++;
								TempWidthOfCurrentLine = TempSizeStruct->cx;
								if (TempLineNumber > TempNumberOfLinesThatWillFitInBoxAtThisSize)
								{
									TempMaxTextSize--;
									TempRepeat = true;
									TempAreMultipleWordsOverflowingOntoAThirdLine = true;
								}
							}
							TempStart = TempStart + TempWordLength + 1;
						}

						if (!TempAreMultipleWordsOverflowingOntoAThirdLine)
						{
							if ((TempWholeStringPixelLength < TempTextBoxWidth) && (TempString.Find('\n') == -1))
							{
								m_TempControlVariable->ModifyStyle(NULL, SS_CENTERIMAGE, NULL); //one line
							}
							else
							{
								m_TempControlVariable->ModifyStyle(SS_CENTERIMAGE, NULL, NULL); //multiple lines
							}
							TempRepeat = false;
						}
						else
						{
							m_TempControlVariable->ModifyStyle(NULL, SS_CENTERIMAGE, NULL);
						}
						free(TempIntArray);
					}
				}
			}
		} while (TempRepeat);

		DeleteObject(TempSizeStruct);
	}
	return TempMaxTextSize;
}

int * NumberOfWords(CString TempString, int TempLength)
{
	int i, TempNumberOfWords= 0, TempWordLength = 0, TempCurrentWord = 0;
	for (i = 0; i <= TempLength; i++)
	{
		if ((TempString[i] == ' ') || (TempString[i] == '\n')
			|| (TempString[i] == 10) || (TempString[i] == 0))
		{
			if (TempWordLength > 0)
			{
				TempWordLength = 0;
				TempNumberOfWords++;
			}
		}
		else
			TempWordLength++;
	}
	TempWordLength = 0;
	int *TempIntArray = (int*)malloc(sizeof(int) * (TempNumberOfWords + 1));
	if (TempIntArray)
	{
		TempIntArray[0] = TempNumberOfWords;

		for (i = 0; i <= TempLength; i++)
		{
			if ((TempString[i] == ' ') || (TempString[i] == '\n')
				|| (TempString[i] == 0))
			{
				if (TempWordLength > 0)
				{
					TempCurrentWord++;
					TempIntArray[TempCurrentWord] = TempWordLength;
					TempWordLength = 0;
				}
			}
			else
			{
				TempWordLength++;
			}
		}
	}
	return TempIntArray;
}

BOOL MByteToUnicode(LPCSTR multiByteStr, LPWSTR unicodeStr, DWORD size)
{
  // Get the required size of the buffer that receives the Unicode string. 
  DWORD minSize;
  minSize = MultiByteToWideChar (CP_ACP, 0, multiByteStr, -1, NULL, 0);
 
  if (size < minSize)
  {
   return FALSE;
  } 
  
  // Convert string from multi-byte to Unicode.
  MultiByteToWideChar (CP_ACP, 0, multiByteStr, -1, unicodeStr, minSize); 
  return TRUE;
}


UserPasswords* PasswordExist(tUserCollection &TempUserCollection, CString PasswordToFind)
{
	for (POSITION TempPosition = TempUserCollection.GetHeadPosition(); TempPosition ; TempUserCollection.GetNext(TempPosition))
	if (TempPosition) 
	if ((*(TempUserCollection.GetAt(TempPosition))).vPassword == PasswordToFind)
		return TempUserCollection.GetAt(TempPosition);
	return NULL;
}

POSITION InsertAlphabetically(tUserCollection &TempUserCollection, UserPasswords* UserToInsert)
{
	POSITION TempInsertPosition = TempUserCollection.GetHeadPosition();
	while ((TempInsertPosition) && (UserToInsert->vUserName > (*(TempUserCollection.GetAt(TempInsertPosition))).vUserName))
		TempUserCollection.GetNext(TempInsertPosition);
	if (TempInsertPosition && TempUserCollection.GetSize() > 0)
		TempUserCollection.InsertBefore(TempInsertPosition, UserToInsert);
	else
		TempUserCollection.AddTail(UserToInsert);
	return TempInsertPosition;
}

void CScanTracDlg::ReadInProductionReport(bool TempFromServer)
{
	vProductionReportString = "";

	CFileException TempFileException;
	CString TempFilePath = cScanTracProductionReportDirectory;
	if (TempFromServer)
		TempFilePath = vConfigurationData->vScanTracProductionReportDirectory;
	TempFilePath += "ScanTracProductionReportSummary.CSV";
	LPCTSTR TempFileName = TempFilePath;

	CString TempDriveLetter = TempFilePath.GetAt(0);
	if ((!TempFromServer) || ((TempDriveLetter != "C") && (TempDriveLetter != "c")))
	if (ThereIsEnoughMemory(sizeof(CFile), "Production Report"))
	{
		CFile TempProductionReportFile;
		if (TempProductionReportFile)
		if (TempProductionReportFile.Open(TempFileName, (CFile::modeRead | CFile::shareDenyNone), &TempFileException))
		{
			UINT TempLength;
			char TempChars[120];

			TempProductionReportFile.SeekToBegin();
			bool TempStillMoreToRead = true;

			while (TempStillMoreToRead)
			{
				TempLength = TempProductionReportFile.Read(TempChars, 100);
				if (TempLength < 100) //something not right, didn't get back expected amount of chars from read
					TempStillMoreToRead = false;

				for (BYTE TempLoop = 0; TempLoop < TempLength; TempLoop++)
					vProductionReportString = vProductionReportString + TempChars[TempLoop];
			}
			TempProductionReportFile.Close();
		}
	}
}

void CScanTracDlg::WriteOutProductionReport(bool TempFromServer)
{
	CFileException TempFileException;
	CString TempFilePath = cScanTracProductionReportDirectory;
	if (TempFromServer)
		TempFilePath = vConfigurationData->vScanTracProductionReportDirectory;
	TempFilePath += "ScanTracProductionReportSummary.CSV";
	LPCTSTR TempFileName = TempFilePath;
	long TempReportLength = vProductionReportString.GetLength();
	TRY
	{
		if (ThereIsEnoughMemory(sizeof(CFile), "Production Report"))
		{
			//delete the original report
			if (!DeleteFile(TempFileName))
				ReportErrorMessage("Could not delete Production Report File before updating", cEMailInspx, 32000);

			CFile TempProductionReportFile;
			if (TempProductionReportFile)
			if (TempProductionReportFile.Open(TempFileName, (CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException))
			{
				TempProductionReportFile.SeekToBegin();

				CW2A TempProductionReportString(vProductionReportString);
				TempProductionReportFile.Write(TempProductionReportString, TempReportLength);
				TempProductionReportFile.Flush();
				TempProductionReportFile.Close();
			}
		}
	}
	CATCH_ALL(TempException)
	{
		ReportErrorMessage("Could not Write Production Report",cEMailInspx,32000);
	}
	END_CATCH_ALL
}

void CScanTracDlg::FinalizeProductionReport(bool TempOnFileServer)
{
	int TempPosition = -1;
	long TempReportLength = vProductionReportString.GetLength();

	ReadInProductionReport(TempOnFileServer);
	TempReportLength = vProductionReportString.GetLength();

	if (TempReportLength > 20)
	{
		TempPosition = vProductionReportString.Find(_T("Stop-Run Incomplete"), 0);

		if (TempPosition != -1) //found a temporary production report, so replace it with "Run Complete"
		{
			int TempNumberOfCharactersToDelete = 19;
			vProductionReportString.Delete(TempPosition, TempNumberOfCharactersToDelete); //remove old temporary section to replace with "Run Complete"
			vProductionReportString.Insert(TempPosition, _T("Run Complete"));

			WriteOutProductionReport(TempOnFileServer);
		}
		else
		{
			TempPosition = vProductionReportString.Find(_T("Time Update-Run Incomplete"), 0);
			if (TempPosition != -1)
			{
				int TempNumberOfCharactersToDelete = 26;
				vProductionReportString.Delete(TempPosition, TempNumberOfCharactersToDelete); //remove old temporary section to replace with "Run Interrupted-Info Incomplete"
				vProductionReportString.Insert(TempPosition, _T("Run Interrupted-Info Incomplete"));
				ReportErrorMessage("Detected previous production report was incomplete", cEMailInspx, 32000);

				WriteOutProductionReport(false);
			}
		}
	}
}

void CScanTracDlg::MakeProductionReportIfNeeded()
{
	if (vSystemData.vTotalContainers > 0)
	{
		GenerateProductionReport(cSelectProductProductionReport);
		SendProductionReport(cSelectProductProductionReport);
		ResetCounters();
	}
}

void CScanTracDlg::RenameProductionReportIfNeeded(bool TempOnFileServer)
{
	CTime TempTime;
	TempTime = CTime::GetCurrentTime();
	DWORD TempCurrentDay = TempTime.GetDay();
	DWORD TempCurrentMonth = TempTime.GetMonth();
	DWORD TempCurrentYear = TempTime.GetYear();

	CString TempBackupName = "2012-1stHalf";

	CFileException TempFileException;
	CString TempFilePath = cScanTracProductionReportDirectory;
	if (TempOnFileServer)
		TempFilePath = vConfigurationData->vScanTracProductionReportDirectory;

	CString TempFileNameOriginal = TempFilePath + "ScanTracProductionReportSummary.CSV";

	LPTSTR TempOriginalFileName = TempFileNameOriginal.GetBuffer(TempFileNameOriginal.GetLength());

	CFile TempFile;
	CFileStatus TempFileStatus;
	if (CFile::GetStatus(TempOriginalFileName, TempFileStatus))
	{
		DWORD TempFileDay = TempFileStatus.m_mtime.GetDay();
		DWORD TempFileMonth = TempFileStatus.m_mtime.GetMonth();
		DWORD TempFileYear = TempFileStatus.m_mtime.GetYear();

		if ((TempFileYear != TempCurrentYear) || ((TempCurrentMonth > 6) && (TempFileMonth <= 6)))
		{
			//rename file
			TempBackupName = dtoa(TempFileYear);
			if (TempFileMonth > 6)
				TempBackupName = TempBackupName + "-2nd Half";
			else
				TempBackupName = TempBackupName + "-1st Half";

			CString TempFileNameNew =  TempFilePath + "ScanTracProductionReportSummary" + TempBackupName + ".CSV";
			LPTSTR TempNewFileName = TempFileNameNew.GetBuffer(TempFileNameNew.GetLength());

			if (CFile::GetStatus(TempNewFileName, TempFileStatus))
				ReportErrorMessage("File Exists, can not make Production Report Backup: " + TempFileNameNew, cEMailInspx, 32000);
			else
			{
				if (CFile::GetStatus(TempOriginalFileName, TempFileStatus))
						TempFile.Rename(TempOriginalFileName, TempNewFileName);

				ReportErrorMessage("Made Production Report Backup to file: " + TempFileNameNew, cAction, 0);
			}
		}
	}
	if (CFile::GetStatus(TempOriginalFileName, TempFileStatus))
	{
		if (TempFileStatus.m_size > 50000)  //production report too big, just rename it
		{
			TempBackupName = TempTime.Format("%Y %B %d");
			CString TempFileNameNew =  TempFilePath + "ScanTracProductionReportSummary Pre " + TempBackupName + ".CSV";
			TempFile.Rename(TempOriginalFileName, TempFileNameNew);
		}
		else
		if (TempFileStatus.m_size > 200000)
		{ //file very big, so split up
			if (!vGlobalDisplayDialogThread)
			{
				vGlobalDisplayDialogThread = (CDisplayDialogThread *)AfxBeginThread(RUNTIME_CLASS(CDisplayDialogThread), THREAD_PRIORITY_NORMAL, 0, CREATE_SUSPENDED);

				if (!vGlobalDisplayDialogThread)
				{
					ReportErrorMessage("Error-Could Not Create Backup Display Dialog Thread", cEMailInspx,32000); 
				}
				else
				{
					CString TempText = " ";
					TempText.LoadString(IDS_BackingupSetupFilesPleaseWait);
					vGlobalDisplayDialogThread->vMessageToDisplay = "\n\nBacking up Production Report\n\nPlease Wait....";
					vGlobalDisplayDialogThread->ResumeThread();
				}
			}
			ReadInProductionReport(false);
			int TempReportLength = vProductionReportString.GetLength();
			if (TempReportLength > 200000)
			{
				int TempTargetSize = TempReportLength - 100000;
				CString TempBackupFileString = vProductionReportString;
				int TempSplitPosition = 0;

				int TempProductCodePosition = vProductionReportString.Find(_T("Product Code"), TempTargetSize);
				if (TempProductCodePosition != -1)
				{
					TempSplitPosition = TempProductCodePosition;
				}

				if (TempSplitPosition == 0) //did not find a "Product Code" header
				for (int TempLoop = TempTargetSize; TempLoop < TempReportLength; TempLoop++)
				if (vProductionReportString.GetAt(TempLoop) == char(13))
				{
					TempSplitPosition = TempLoop + 1;
					TempLoop = TempReportLength;
				}
				if ((TempSplitPosition) && (TempSplitPosition < TempReportLength - 1000))
				{
					int TempAmountToDelete = TempReportLength - TempSplitPosition + 5;
					TempBackupFileString.Delete(TempSplitPosition, TempAmountToDelete);

					vProductionReportString.Delete(0, TempSplitPosition);
					WriteOutProductionReport(false);

					//make old report file
					int TempPosition = 0;
					TempReportLength = TempBackupFileString.GetLength();
					for (int TempLoop = TempReportLength - 20; TempLoop > 20; TempLoop--) //look for last carrage return in file
					if (TempBackupFileString.GetAt(TempLoop) == char(13))
					{
						TempPosition = TempLoop;
						TempLoop = 10;
					}
					if (TempPosition)
					{
						int Temp3rdCommaPosition = 0;
						int Temp4thCommaPosition = 0;
						int TempCommaCounter = 0;
						for (int TempLoop = TempPosition; TempLoop < TempReportLength; TempLoop++) //look for commas on the last line
						{
							if (TempBackupFileString.GetAt(TempLoop) == char(44)) //if got a comma
							{
								TempCommaCounter++;
								if (TempCommaCounter == 3)
									Temp3rdCommaPosition = TempLoop;
								else
								if (TempCommaCounter == 4)
								{
									Temp4thCommaPosition = TempLoop;
									TempLoop = TempReportLength;
								}
							}
						}
						if (Temp4thCommaPosition)
						{
							CFileException TempFileException;
							int TempLength =Temp4thCommaPosition - Temp3rdCommaPosition - 1;
							CString TempBackupName = TempBackupFileString.Mid(Temp3rdCommaPosition + 1, TempLength);
							TempBackupName.Replace(_T(":"), _T(" "));

							CString TempFilePath = cScanTracProductionReportDirectory;
							TempFilePath += "ScanTracProductionReportsBefore" + TempBackupName + ".CSV";
							LPCTSTR TempFileName = TempFilePath;
							long TempReportLength = TempBackupFileString.GetLength();
							TRY
							{
								if (ThereIsEnoughMemory(sizeof(CFile), "Production Report"))
								{
									//delete the original backup name but do not expect it to be there
									DeleteFile(TempFileName);

									CFile TempProductionReportFile;
									if (TempProductionReportFile)
									if (TempProductionReportFile.Open(TempFileName, (CFile::modeCreate | CFile::modeReadWrite | CFile::shareDenyNone), &TempFileException))
									{
										TempProductionReportFile.SeekToBegin();
										CW2A TempStringToWrite(TempBackupFileString);
										TempProductionReportFile.Write(TempStringToWrite, TempReportLength);
										TempProductionReportFile.Flush();
										TempProductionReportFile.Close();
									}
								}
							}
							CATCH_ALL(TempException)
							{
								ReportErrorMessage("Could not Write Production Report",cEMailInspx,32000);
							}
							END_CATCH_ALL
						}
					}
				}
			}
			if (vGlobalDisplayDialogThread)
			{
				vGlobalDisplayDialogThread->ExitDisplayThread();
				vGlobalDisplayDialogThread = NULL;
			}
		}
	}
	if (!TempOnFileServer)
	if ((vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'C') && (vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'D') &&
		(vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'c') && (vConfigurationData->vScanTracProductionReportDirectory.GetAt(0) != 'd'))
	{
		LPTSTR TempStringDirectoryServerSSDP = vConfigurationData->vScanTracProductionReportDirectory.GetBuffer(vConfigurationData->vScanTracProductionReportDirectory.GetLength());
		CFileStatus TempFileServerStatus;
		if (CFile::GetStatus(TempStringDirectoryServerSSDP, TempFileServerStatus))
		{
			RenameProductionReportIfNeeded(true);
		}
	}
}


//void CScanTracDlg::OnActivateApp(BOOL bActive, DWORD dwThreadID)
//{
//	CDialog::OnActivateApp(bActive, dwThreadID);
//	// TODO: Add your message handler code here
//	CString TempForeGroundWindowName = "-";
//	CWnd *TempForeGroundWindow = GetForegroundWindow();  //gives name of application window that does have the focus
//	if (TempForeGroundWindow)
//	{
//		TempForeGroundWindow->GetWindowText(TempForeGroundWindowName);
//
//		ReportErrorMessage("Application Changed: " + TempForeGroundWindowName, cWriteToLog, 0);
//	}
//	else
//		ReportErrorMessage("Application Changed: No ForeGround Window", cWriteToLog, 0);
//}

bool CScanTracDlg::IfTubeHasBeenOffLongEnough()
{
	CTime TempTime = CTime::GetCurrentTime();
	CTimeSpan TempDeltaTime;
	TempDeltaTime = TempTime - vConfigurationData->vTimeXRaysWereOnLast;
	LONGLONG TempSeconds = TempDeltaTime.GetTotalSeconds();
	if ((TempSeconds > 10) || (TempSeconds < 0) || (vSystemData.vStartRunningAfterLoadProduct) || (vSystemData.vInAutoSetup))
		return true;
	else
	{
		TempSeconds = 10 - TempSeconds + 1;

		if (TempSeconds < 3)
			TempSeconds = 3;
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nTube cooling down.\nWill start in " + dtoa((double)(TempSeconds), 0) + " seconds.";
		TempNoticeDialog.vType = cInformationMessage;
		TempNoticeDialog.vAutoClose = (WORD)(TempSeconds * 1000);
		TempNoticeDialog.DoModal();

		return true;
	}
}

void CScanTracDlg::StartDACTest()
{
	int TempTimerResult = SetTimer(vTestDACsTimerHandle,100,NULL);
	if (!TempTimerResult)
		ReportErrorMessage("Error-Hold Sent Test Display Timer Failed",cEMailInspx,32000);
}

void CScanTracDlg::StopDACTest()
{
	KillTimer(vTestDACsTimerHandle);
}

void CScanTracDlg::StartADCTest()
{
	int TempTimerResult = SetTimer(vTestADCsTimerHandle,100,NULL);
	if (!TempTimerResult)
		ReportErrorMessage("Error-Hold Sent Test Display Timer Failed",cEMailInspx,32000);
}

void CScanTracDlg::StopADCTest()
{
	KillTimer(vTestADCsTimerHandle);
}

void CScanTracDlg::ClearRedStatusIndicator()
{
	if (PasswordOK(cTemporaryInspxPassword,false))
	{
		//if (vSystemData.vHadABrownOut)
		//{
		//	vSystemData.vHadABrownOut = false;
		//	vSystemData.vHadAPowerMoniterMessageError = 0;	//all flags cleared
		//	if (vGlobalACPowerMoniter)
		//	{
		//		vGlobalACPowerMoniter->vGaveBrownOutError = 0;
		//		for (int TempIndex = 0; TempIndex < cNumberOfACVoltageSamples; TempIndex++)
		//			vGlobalACPowerMoniter->vACInputVoltageData[TempIndex] = 0;
		//	}
		//	SetInterlockStatus();
		//	CNoticeDialog TempNoticeDialog;
		//	TempNoticeDialog.vNoticeText = "\n\n\nCleared Brownout Indicator.";
		//	TempNoticeDialog.vAutoClose = 2000;
		//	TempNoticeDialog.vType = cNoticeMessage;
		//	TempNoticeDialog.DoModal();
		//}
		//else
		//if (vSystemData.vHadAnACPowerDropOut)
		//{
		//	vSystemData.vHadAnACPowerDropOut = false;
		//	SetInterlockStatus();
		//	CNoticeDialog TempNoticeDialog;
		//	TempNoticeDialog.vNoticeText = "\n\n\nCleared A/C Power DropOut Indicator. (DXM had gone to Local)";
		//	TempNoticeDialog.vAutoClose = 2000;
		//	TempNoticeDialog.vType = cNoticeMessage;
		//	TempNoticeDialog.DoModal();
		//}
		//else
		if (vSystemData.vMissingRAM)
		{
			vSystemData.vMissingRAM = false;
			SetInterlockStatus();
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nCleared Upper RAM Indicator.";
			TempNoticeDialog.vAutoClose = 2000;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		else
		if (vSystemData.vEjectTooLateMessageGivenThisRun)
		{
			vSystemData.vEjectTooLateMessageGivenThisRun = false;
			SetInterlockStatus();
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nCleared Late Eject Indicator.\nSetup Password was required to run";
			TempNoticeDialog.vAutoClose = 2000;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		else
		if (vSystemData.vAirConditionerFailed)
		{
			vSystemData.vAirConditionerFailed = false;
			SetInterlockStatus();
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nCleared Air Conditioner Failed Indicator.";
			TempNoticeDialog.vAutoClose = 2000;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		else
		if (vSystemData.vProductHasAPoorLearn)
		{
			vSystemData.vProductHasAPoorLearn = false;
			SetInterlockStatus();
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nCleared Poor Learn Indicator.";
			TempNoticeDialog.vAutoClose = 2000;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		else
		if (vSystemData.vOperationsGuardianError)
		{
			vSystemData.vOperationsGuardianError = 0;
			SetInterlockStatus();
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nCleared Operations Guardian Server Transmit Error.";
			TempNoticeDialog.vAutoClose = 2000;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		else
		
		if (vSystemData.vProductHasAnOldInspection)
		{
			vSystemData.vProductHasAnOldInspection = false;
			SetInterlockStatus();
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nCleared Old Inspection Indicator.";
			TempNoticeDialog.vAutoClose = 2000;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		else
		//if (vSystemData.vDetectorCalibrationNeeded)
		//{
		//	vSystemData.vDetectorCalibrationNeeded = false;
		//	SetInterlockStatus();
		//	CNoticeDialog TempNoticeDialog;
		//	TempNoticeDialog.vNoticeText = "\n\n\nCleared Detector Calibration Needed.";
		//	TempNoticeDialog.vAutoClose = 2000;
		//	TempNoticeDialog.vType = cNoticeMessage;
		//	TempNoticeDialog.DoModal();
		//}
		//else
		if (vSystemData.vDisplayingAnEncoderError)
		{
			vSystemData.vDisplayingAnEncoderError = false;
			SetInterlockStatus();
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nCleared Encoder Faulty Indicator.";
			TempNoticeDialog.vAutoClose = 2000;
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		UpdateClearYellowMessageButton();
	}
}

void CScanTracDlg::SelectValveMonitoringInspection()
{
	BYTE TempNewInspection = 0xFF;
	if (!vGlobalCurrentProduct->vFillerMonitorInspection) //if inspection not configured, pick one
	if (vSystemData.vFillerIndexPulseBitMap)
	if (vSystemData.vCurrentValveData)
	{
		for (BYTE TempInspectionLoop = 0; TempInspectionLoop < vGlobalCurrentProduct->vNumberOfInspections; TempInspectionLoop++)
		if (vGlobalCurrentProduct->vInspection[TempInspectionLoop])
		if ((vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionType == cUnderfillInspection) || (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionType == cOverfillInspection) ||
			(vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionType == cUnderfillByWeightInspection) || (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionType == cOverfillByWeightInspection) ||
			(vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionType == cDensityInspection) || (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionType == cCheckWeighInspection))
		{
			TempNewInspection = TempInspectionLoop;
			TempInspectionLoop = vGlobalCurrentProduct->vNumberOfInspections;
		}

		if (!vSystemData.vFillerIndexPulseBitMap)
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nNo Underfill Inspection found for Filler Monitoring\nFiller Monitoring Disabled";
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();

			free(vSystemData.vCurrentValveData);
		}
	}
	vSystemData.vValveMonitorInspection = TempNewInspection;
}

void CScanTracDlg::AllocateValveMonitoringData()
{
	if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
	{
		if (vSystemData.vCurrentValveData)
		{
			free (vSystemData.vCurrentValveData);
			vSystemData.vCurrentValveData = NULL;
		}
		
		if (vSystemData.vHoldValveDataForNextIndexPulse)
		{
			free (vSystemData.vHoldValveDataForNextIndexPulse);
			vSystemData.vHoldValveDataForNextIndexPulse = NULL;
		}
		if (vSystemData.vValveAverages)
		{
			free (vSystemData.vValveAverages);
			vSystemData.vValveAverages = NULL;
		}
		if (vSystemData.vValveStandardDeviations)
		{
			free (vSystemData.vValveStandardDeviations);
			vSystemData.vValveStandardDeviations = NULL;
		}
		
		if (vSystemData.vValveData)
		{
			free (vSystemData.vValveData);
			vSystemData.vValveData = NULL;
		}

		if (vSystemData.vSamplingIndexErrorData[cFillerSamplingType])
		{
			free (vSystemData.vSamplingIndexErrorData[cFillerSamplingType]);
			vSystemData.vSamplingIndexErrorData[cFillerSamplingType] = NULL;
		}
		vSystemData.vFillerIndexPulseBitMap = 0;
		vSystemData.vSeamerObjectPulseBitMap = 0;
		vSystemData.vSeamerPocketSensorBitMap = 0;
		vSystemData.vLastTimeObjectToPocketPulse = 0;
		vSystemData.vLastPocketTime = 0;
		vSystemData.vLastTimePocketToObjectPulse = 0;
		vSystemData.vLastObjectTime = 0;
		
		if (vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType])
		{
			for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
			if (vGlobalCurrentProduct->vExternalDetectorEnable[TempLoop])
			{
				if (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cValveMonitorIndexPulseInput)
				if (vConfigurationData->vExternalDetector[TempLoop].vEnabled)
				if (vConfigurationData->vExternalDetector[TempLoop].vLineBitMask > 0)
				{
					vSystemData.vFillerIndexPulseBitMap = vConfigurationData->vExternalDetector[TempLoop].vLineBitMask;
					vSystemData.vSamplingAuxiliaryDetector[cFillerSamplingType] = TempLoop;
				}
				
				if (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cSeamerObjectPulseInput)
				if (vConfigurationData->vExternalDetector[TempLoop].vEnabled)
				if (vConfigurationData->vExternalDetector[TempLoop].vLineBitMask > 0)
				{
					vSystemData.vSeamerObjectPulseBitMap = vConfigurationData->vExternalDetector[TempLoop].vLineBitMask;
					vSystemData.vUseSamplingFIFO = true;
				}

				if (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cSeamerPocketPulseInput)
				if (vConfigurationData->vExternalDetector[TempLoop].vEnabled)
				if (vConfigurationData->vExternalDetector[TempLoop].vLineBitMask > 0)
				{
					vSystemData.vSeamerPocketSensorBitMap = vConfigurationData->vExternalDetector[TempLoop].vLineBitMask;
				}
			}
		
			if (vSystemData.vFillerIndexPulseBitMap)
			{
				if (ThereIsEnoughMemory(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double), "vCurrentValveData"))
				{
					vSystemData.vCurrentValveData = (double *)malloc(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));
					vSystemData.vCurrentValveDataMaximum = vSystemData.vCurrentValveData + vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType];
				}
				if (ThereIsEnoughMemory(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double), "vValveAverages"))
				{
					vSystemData.vValveAverages = (double *)malloc(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));
					vSystemData.vValveAveragesMaximum = vSystemData.vValveAverages + vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType];
				}
				if (ThereIsEnoughMemory(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double), "vValveStandardDeviations"))
				{
					vSystemData.vValveStandardDeviations = (double *)malloc(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));
					vSystemData.vValveStandardDeviationsMaximum = vSystemData.vValveStandardDeviations + vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType];
				}
				if (ThereIsEnoughMemory(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double), "vHoldValveDataForNextIndexPulse"))
				{
					vSystemData.vHoldValveDataForNextIndexPulse = (double *)malloc(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));
					vSystemData.vHoldValveDataForNextIndexPulseMaximum = vSystemData.vHoldValveDataForNextIndexPulse + vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType];
				}
				
				if (ThereIsEnoughMemory(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * cMaximumValveDataRows * sizeof(double), "vValveData"))
				{
					vSystemData.vValveData = (double *)malloc(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * cMaximumValveDataRows * sizeof(double));
					vSystemData.vValveDataMaximum = vSystemData.vValveData + (vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * cMaximumValveDataRows);
				}

				if (ThereIsEnoughMemory(cMaximumValveDataRows * sizeof(int), "vValveIndexData"))
				{
					vSystemData.vSamplingIndexErrorData[cFillerSamplingType] = (int *)malloc(cMaximumValveDataRows * sizeof(int));
					vSystemData.vSamplingIndexErrorDataMaximum[cFillerSamplingType] = vSystemData.vSamplingIndexErrorData[cFillerSamplingType] + cMaximumValveDataRows;
				}

				SelectValveMonitoringInspection();
			}
			else
			if (vGlobalCurrentProduct)
			if (!CurrentProductIsInspxProduct())
			{
				ReportErrorMessage("No Aux Det Selected for Filler Sampling-Disabled", cEMailMaintenance, 0);
				//CNoticeDialog TempNoticeDialog;
				//TempNoticeDialog.vNoticeText = "\n\n\nNo Auxiliary Sensor Input Selected for Filler Monitoring\nFiller Monitoring Disabled";
				//TempNoticeDialog.vType = cNoticeMessage;
				//TempNoticeDialog.DoModal();
			}
		}
		else
		if (vConfigurationData->vNumberOfHeadsToMonitor[cRandomSamplingType])
		{
			for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
			if (vGlobalCurrentProduct->vExternalDetectorEnable[TempLoop])
			{
				if (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cValveMonitorIndexPulseInput)
				if (vConfigurationData->vExternalDetector[TempLoop].vEnabled)
				if (vConfigurationData->vExternalDetector[TempLoop].vLineBitMask > 0)
				{
					vSystemData.vFillerIndexPulseBitMap = vConfigurationData->vExternalDetector[TempLoop].vLineBitMask;
					vSystemData.vSamplingAuxiliaryDetector[cRandomSamplingType] = TempLoop;
					TempLoop = cNumberOfExternalDetectors;
				}
			}
		}

		if (!vDisplayingVersion)
		//if (vSystemData.vValveData)
		//{
		//	//m_SubFunction7Button.ModifyStyle(SS_CENTERIMAGE,NULL,NULL);
		//	SetDlgItemText(IDC_SubFunction7Button, "Sampling\nand Filler\nMonitor");
		//	m_SubFunction7Button.ShowWindow(SW_SHOW);
		//}
		//else
		//if (vConfigurationData->vNumberOfHeadsToMonitor[cRandomSamplingType] == 1)
		//{
		//	SetDlgItemText(IDC_SubFunction7Button, "Sampling");
		//	//m_SubFunction7Button.ModifyStyle(NULL,SS_CENTERIMAGE,NULL);
		//	m_SubFunction7Button.ShowWindow(SW_SHOW);
		//}
		//else
		//{
		//	m_SubFunction7Button.ShowWindow(SW_HIDE);
		//}

		if (vSystemData.vSamplingIndexErrorData[cSeamerSamplingType])
		{
			free (vSystemData.vSamplingIndexErrorData[cSeamerSamplingType]);
			vSystemData.vSamplingIndexErrorData[cSeamerSamplingType] = NULL;
		}
		if (vSystemData.vSamplingIndexErrorData[0])
		{
			free (vSystemData.vSamplingIndexErrorData[0]);
			vSystemData.vSamplingIndexErrorData[0] = NULL;
		}
		vSystemData.vSeamerIndexPulseBitMap = 0;
		if (vConfigurationData->vNumberOfHeadsToMonitor[cSeamerSamplingType])
		{
			for (BYTE TempLoop = 0; TempLoop < cNumberOfExternalDetectors; TempLoop++)
			if (vGlobalCurrentProduct->vExternalDetectorEnable[TempLoop])
			{
				if (vGlobalCurrentProduct->vExternalDetectorMode[TempLoop] == cSeamerIndexPulseInput)
				if (vConfigurationData->vExternalDetector[TempLoop].vEnabled)
				if (vConfigurationData->vExternalDetector[TempLoop].vLineBitMask > 0)
				{
					vSystemData.vSeamerIndexPulseBitMap = vConfigurationData->vExternalDetector[TempLoop].vLineBitMask;
					vSystemData.vSamplingAuxiliaryDetector[cSeamerSamplingType] = TempLoop;
					TempLoop = cNumberOfExternalDetectors;
				}
			}
		
			if (vSystemData.vSeamerIndexPulseBitMap)
			{
				if (ThereIsEnoughMemory(cMaximumValveDataRows * sizeof(int), "vSeamerIndexData"))
				{
					vSystemData.vSamplingIndexErrorData[cSeamerSamplingType] = (int *)malloc(cMaximumValveDataRows * sizeof(int));
					vSystemData.vSamplingIndexErrorDataMaximum[cSeamerSamplingType] = vSystemData.vSamplingIndexErrorData[cSeamerSamplingType] + cMaximumValveDataRows;
				}
				if (ThereIsEnoughMemory(cMaximumValveDataRows * sizeof(int), "vSeamerIndexData"))
				{
					vSystemData.vSamplingIndexErrorData[0] = (int *)malloc(cMaximumValveDataRows * sizeof(int));
					vSystemData.vSamplingIndexErrorDataMaximum[0] = vSystemData.vSamplingIndexErrorData[0] + cMaximumValveDataRows;
				}
			}
			else
			if (vGlobalCurrentProduct)
			if (!CurrentProductIsInspxProduct())
			{
				ReportErrorMessage("No Aux Det Selected for Seamer Sampling-Disabled", cEMailMaintenance, 0);
				//CNoticeDialog TempNoticeDialog;
				//TempNoticeDialog.vNoticeText = "\n\n\nNo Auxiliary Sensor Input Selected for Seamer Sampling\nSeamer Sampling Disabled";
				//TempNoticeDialog.vType = cNoticeMessage;
				//TempNoticeDialog.DoModal();
			}
		}

		if (vSystemData.vUseSamplingFIFO)
		{
			for (BYTE TempLoop = 1; TempLoop < 3; TempLoop++)
			if (vConfigurationData->vNumberOfHeadsToMonitor[TempLoop])
			{
				if (!vSystemData.vSamplingFIFO[TempLoop])
				if (ThereIsEnoughMemory(cSamplingFIFOLength, "vSamplingFIFO"))
				{
					vSystemData.vSamplingFIFO[TempLoop] = (BYTE *)malloc(cSamplingFIFOLength);
					if (vSystemData.vSamplingFIFO[TempLoop])
					{
						vSystemData.vSamplingFIFOMaximumPointer[TempLoop] = vSystemData.vSamplingFIFO[TempLoop] + cSamplingFIFOLength;
						ZeroMemory(vSystemData.vSamplingFIFO[TempLoop], cSamplingFIFOLength);
					}
				}
			}
			else
			{
				if (vSystemData.vSamplingFIFO[TempLoop])
				{
					free(vSystemData.vSamplingFIFO[TempLoop]);
					vSystemData.vSamplingFIFO[TempLoop] = NULL;
				}
			}
		}
		vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();
	}
}

void CScanTracDlg::ClearValveMonitoringFIFO()
{
	vSystemData.vHaveFillerIndexError = 0;
	if (vSystemData.vUseSamplingFIFO)
	{
		for (BYTE TempLoop = 0; TempLoop < 3; TempLoop++)
		{
			if (vSystemData.vSamplingFIFO[TempLoop])
				ZeroMemory(vSystemData.vSamplingFIFO[TempLoop], cSamplingFIFOLength);

			vSystemData.vSamplingFIFOHead[TempLoop] = 0; //points at the memory location to write the next value into
			vSystemData.vSamplingFIFOTail[TempLoop] = 0; //points at the memory location to read the next value out of.  If Head and Tail are the same then the FIFO is empty
		}
	}
	for (BYTE TempLoop = 0; TempLoop < 3; TempLoop++) //clear filler monitor FIFO
	{
		vSystemData.vNextHeadToProcess[TempLoop] = 0;
		vSystemData.vPreviousHeadProcessed[TempLoop] = 0;
		vSystemData.vNextHeadToPutInFIFO[TempLoop] = 0;
		vSystemData.vCountPutInFIFOThisRevolution[TempLoop] = 0;
		vSystemData.vHeadCountAfterIndexPulse[TempLoop] = 0;
		vSystemData.vCurrentSampleDataCount[TempLoop] = 0;
		vSystemData.vRecievedFirstIndexPulse[TempLoop] = false;
		vSystemData.vLastIndexPulseWasCorrect[TempLoop] = false;
	}
	vSystemData.vBeltPositionLastPutItemInSamplingFIFO = 0;
}

void CScanTracDlg::ResetValveMonitoringData()
{
	vSystemData.vLastTimeObjectToPocketPulse = 0;
	vSystemData.vLastPocketTime = 0;
	vSystemData.vLastTimePocketToObjectPulse = 0;
	vSystemData.vLastObjectTime = 0;
	//if (vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] > 1)
	if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
	{
		if (vSystemData.vCurrentValveData)
			ZeroMemory(vSystemData.vCurrentValveData, vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));

		if (vSystemData.vHoldValveDataForNextIndexPulse)
			ZeroMemory(vSystemData.vHoldValveDataForNextIndexPulse, vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));
		
		if (vSystemData.vValveData)
			ZeroMemory(vSystemData.vValveData, vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * cMaximumValveDataRows * sizeof(double));

		for (BYTE TempLoop = 0; TempLoop < 255; TempLoop++)
			vSystemData.vFillerLowFillHeadCounts[TempLoop] = 0;

		vSystemData.vFillerAverageWeight = 0;
		vSystemData.vValveDataRowIndex = 0;
		vSystemData.vNumberValveRowDataHave = 0;
		vSystemData.vMissedIndexCount = 0;

		vSystemData.vMissedSeamerIndexCount = 0;

		for (BYTE TempLoop = 0; TempLoop < 3; TempLoop++)
		{
			//vSystemData.vCurrentSampleDataCount[TempLoop] = 0;
			if (vSystemData.vSamplingIndexErrorData[TempLoop])
				ZeroMemory(vSystemData.vSamplingIndexErrorData[TempLoop], cMaximumValveDataRows * sizeof(int));

			vSystemData.vSamplingIndexErrorDataIndex[TempLoop] = 0;
			vSystemData.vSamplingIndexErrorDataHave[TempLoop] = 0;
			vSystemData.vSamplesEjectedCount[TempLoop] = 0;
			vSystemData.vSampleIndexErrorsX[TempLoop] = 0;
			vSystemData.vSampleIndexErrorsY[TempLoop] = 0;
			vSystemData.vMostRecentTimeBeforeIndexPulse[TempLoop] = 0;
			vSystemData.vMostRecentTimeAfterIndexPulse[TempLoop] = 0;
			//vSystemData.vHeadCountAfterIndexPulse[TempLoop] = 0;
			vSystemData.vSamplingPulseLog[TempLoop] = "Pulse Log-While Logging Serial Data-Most Recent At Bottom\n";
			vSystemData.vSamplingPulseIndexCounter[TempLoop] = 0;

		}
		vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();
	}
}

void CScanTracDlg::ShowValveMonitorData(WORD TempNumberOfDataPoints)
{
	BYTE TempValvesNeedAttention = 0;
	if (vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType])
	if (vSystemData.vValveData)
	{
		if ((vSystemData.vNumberValveRowDataHave == 0) && ((vSystemData.vNextHeadToProcess[cFillerSamplingType] == 0) || (!PasswordOK(cTemporaryInspxPassword,false))))
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nNo " + vSystemData.vSamplingName[cFillerSamplingType] + " Data collected yet";
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		else
		if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
		{
			DWORD TempStringLength = 10 * vSystemData.vNumberValveRowDataHave * vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] + 
				(100 * (vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] / 8));
			int *TempColors = NULL;
			if (ThereIsEnoughMemory(sizeof(int) * TempStringLength, "Color array in help dialog"))
				TempColors = (int *)malloc(sizeof(int) * TempStringLength);
			else
				ReportErrorMessage("Not Enough Memory for Color Array Alloc in Help Dialog",cEMailInspx, 32000);
			if (TempColors)
			{
				ZeroMemory(TempColors, TempStringLength * sizeof(int));

				//bool TempSetGreen = true;
				//for (WORD TempLoop = 0; TempLoop < TempStringLength; TempLoop++)
				//{
				//	if (TempSetGreen)
				//		TempColors[TempLoop] = 3; //green
				//	else
				//		TempColors[TempLoop] = 1; //red

				//	TempSetGreen = !TempSetGreen;
				//}
				CInspection *TempInspection = NULL;
				if (vSystemData.vValveMonitorInspection <= vGlobalCurrentProduct->vNumberOfInspections)
					TempInspection = vGlobalCurrentProduct->vInspection[vSystemData.vValveMonitorInspection];
				if (!TempInspection)
					TempInspection = vGlobalCurrentProduct->vFillerMonitorInspection;

				double Temp3SDs = 15;
				double TempLowThreshold = 0;
				double TempHighThreshold = 0;
				CString TempLowText = "Lo";
				CString TempHiText = "Hi";
				CString TempUnderText = "Lo";
				CString TempOverText = "Hi";
				double *TempValveAverages = NULL;
				double *TempValveStandardDieviations = NULL;
				double *TempValveDataToAverage = NULL;
				if (ThereIsEnoughMemory(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double), "TempValveAverages"))
					TempValveAverages = (double *)malloc(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));
				if (ThereIsEnoughMemory(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double), "TempValveStandardDieviations"))
					TempValveStandardDieviations = (double *)malloc(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));
				if (ThereIsEnoughMemory(vSystemData.vNumberValveRowDataHave * sizeof(double), "TempValveDataToAverage"))
					TempValveDataToAverage = (double *)malloc(vSystemData.vNumberValveRowDataHave * sizeof(double));

				if ((TempValveAverages) && (TempValveStandardDieviations) && (TempValveDataToAverage))
				{
					//calculate Average and SD for each valve
					for (BYTE TempValveLoop = 0; TempValveLoop < vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]; TempValveLoop++)
					{
						double *TempSourcePointer = vSystemData.vValveData + TempValveLoop;
						double *TempDestinationPointer = TempValveDataToAverage;

						WORD TempGoodDataCount = 0;
						for (WORD TempDataLoop = 0; TempDataLoop < vSystemData.vNumberValveRowDataHave; TempDataLoop++)
						if (TempSourcePointer < vSystemData.vValveDataMaximum)
						{
							if (*TempSourcePointer > 0)
							{
								TempGoodDataCount++;
								*TempDestinationPointer = *TempSourcePointer;
								TempDestinationPointer++;
							}
							TempSourcePointer = TempSourcePointer + vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType];
						}
						else
							ReportErrorMessage("Filler Monitor Pointer Error 1", cEMailInspx, 32000);

						double *TempPointerToValveStandardDeviation = TempValveStandardDieviations + TempValveLoop;
						double *TempPointerToValveAverage = TempValveAverages + TempValveLoop;
						if (TempGoodDataCount)
							*TempPointerToValveStandardDeviation = CalculateStandardDeviation(TempValveDataToAverage,TempGoodDataCount, TempPointerToValveAverage);
						else
						{
							*TempPointerToValveAverage = 0;
							*TempPointerToValveStandardDeviation = 0;
						}

						//b rh for testing only
						//*TempPointerToValveStandardDeviation = 200.1 + TempValveLoop;
						//*TempPointerToValveAverage = 300.6 + TempValveLoop;
					}
					double TempAverage = 0;

					//Temp3SDs = CalculateStandardDeviation(TempValveAverages, vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType], &TempAverage);
					Temp3SDs = CalculateStandardDeviation(TempValveStandardDieviations, vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType], &TempAverage);
					Temp3SDs = Temp3SDs * 3;
					if (Temp3SDs < .2)
						Temp3SDs = .2;

					if (vGlobalCurrentProduct->vFillerTolerance)
						Temp3SDs = vGlobalCurrentProduct->vFillerTolerance;

					if (TempInspection)
					{
						if ((TempInspection->vInspectionType == cUnderfillInspection) ||
							(TempInspection->vInspectionType == cDensityInspection))
						{
							TempHighThreshold = TempInspection->vDensityThresholdUpper;
							TempLowText = "Hi";
							TempHiText = "Lo";
							TempUnderText = "Over";
							TempOverText = "Under";
						}

						if ((TempInspection->vInspectionType == cOverfillInspection) ||
							(TempInspection->vInspectionType == cDensityInspection))
						{
							TempLowThreshold = TempInspection->vDensityThresholdLower;
							TempLowText = "Hi";
							TempHiText = "Lo";
							TempUnderText = "Over";
							TempOverText = "Under";
						}

						if (TempInspection->vInspectionType == cUnderfillByWeightInspection)
							TempLowThreshold = TempInspection->ConvertToWeight(TempInspection->vDensityThresholdUpper);

						if (TempInspection->vInspectionType == cOverfillByWeightInspection)
							TempHighThreshold = TempInspection->ConvertToWeight(TempInspection->vDensityThresholdLower);

						if ((TempHighThreshold == 0) && (TempLowThreshold))
							if (TempInspection->vInspectionType == cUnderfillByWeightInspection)
							{
								for (BYTE TempInspectionLoop = 0; TempInspectionLoop < vGlobalCurrentProduct->vNumberOfInspections; TempInspectionLoop++)
									if (vGlobalCurrentProduct->vInspection[TempInspectionLoop])
										if (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionNameForWeightTrendingName.GetLength())
											if (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionNameForWeightTrendingName == TempInspection->vName)
												TempHighThreshold = TempInspection->ConvertToWeight(vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vDensityThresholdLower);
							}

						if ((TempHighThreshold) && (TempLowThreshold == 0))
							if (TempInspection->vInspectionType == cOverfillByWeightInspection)
							{
								for (BYTE TempInspectionLoop = 0; TempInspectionLoop < vGlobalCurrentProduct->vNumberOfInspections; TempInspectionLoop++)
									if (vGlobalCurrentProduct->vInspection[TempInspectionLoop])
										if (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionNameForWeightTrendingName.GetLength())
											if (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionNameForWeightTrendingName == TempInspection->vName)
												TempLowThreshold = TempInspection->ConvertToWeight(vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vDensityThresholdUpper);
							}
					}
				}

				//const int cTab1 = 6;
				//const int cTab2 = 20;
				//const int cTab3 = 32;
				//const int cTab4 = 45;
				//const int cTab5 = 55;
				WORD TempCurrentStringLength();
				CString TempDataString = "";
				CString TempTitleString = vSystemData.vSamplingName[cFillerSamplingType] + " Monitor";
				if ((TempValveAverages) && (TempValveStandardDieviations) && (TempValveDataToAverage))
					if ((TempNumberOfDataPoints == 0) && (vSystemData.vNumberValveRowDataHave > 4)) //have enough data to calculate standard dieviations
					{
						TempTitleString = vSystemData.vSamplingName[cFillerSamplingType] + " Monitor - Average, SD, Status - " + dtoa(vSystemData.vNumberValveRowDataHave, 0) + " Rotations";
						//display average and SD for all valves
						bool TempHaveMoreValvesToDisplay = true;
						BYTE TempValvesDisplayed = 0;
						while (TempHaveMoreValvesToDisplay)
						{
							CString TempValueString = "0";
							BYTE TempValvesToShowOnThisLine = vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] - TempValvesDisplayed;
							if (TempValvesToShowOnThisLine > 8)
								TempValvesToShowOnThisLine = 8;

							CString TempLineString = "";
							for (BYTE TempValveLoop = 0; TempValveLoop < TempValvesToShowOnThisLine; TempValveLoop++)
							{
								FillToTab(&TempLineString, TempValveLoop * 8);
								TempLineString = TempLineString + "  H" + dtoa(TempValveLoop + 1 + TempValvesDisplayed, 0);
							}
							TempDataString = TempDataString + TempLineString;

							double *TempValveAveragePointer = TempValveAverages + TempValvesDisplayed;
							//display averages
							TempLineString = "";
							for (BYTE TempValveLoop = 0; TempValveLoop < TempValvesToShowOnThisLine; TempValveLoop++)
							{
								TempValueString = Pad(dtoa(*TempValveAveragePointer, 2), 0, 0);
								FillToTab(&TempLineString, TempValveLoop * 8);

								if (((TempHighThreshold) && (*TempValveAveragePointer > TempHighThreshold)) || ((TempLowThreshold) && (*TempValveAveragePointer < TempLowThreshold)))
								{ //make average number in display red if high or low
									WORD TempStartPosition = TempDataString.GetLength() + TempLineString.GetLength() + 1;
									WORD TempLength = TempValueString.GetLength() + 1;
									for (WORD TempLoop = TempStartPosition + 1; TempLoop < TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 1; //red
								}

								TempLineString = TempLineString + TempValueString;
								TempValveAveragePointer++;
							}
							TempDataString = TempDataString + "\n" + TempLineString;

							//display SD
							double *TempValveStandardDeviationPointer = TempValveStandardDieviations + TempValvesDisplayed;
							TempLineString = "";
							for (BYTE TempValveLoop = 0; TempValveLoop < TempValvesToShowOnThisLine; TempValveLoop++)
							{
								TempValueString = Pad(dtoa(*TempValveStandardDeviationPointer, 2), 0, 0);
								FillToTab(&TempLineString, TempValveLoop * 8);

								if (*TempValveStandardDeviationPointer > Temp3SDs)
								{ //make standard dieviation number red in display if too high
									WORD TempStartPosition = TempDataString.GetLength() + TempLineString.GetLength() + 1;
									WORD TempLength = TempValueString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 1; //red
								}

								TempLineString = TempLineString + TempValueString;
								TempValveStandardDeviationPointer++;
							}
							TempDataString = TempDataString + "\n" + TempLineString;

							//display Valve Status
							TempValveAveragePointer = TempValveAverages + TempValvesDisplayed;
							TempValveStandardDeviationPointer = TempValveStandardDieviations + TempValvesDisplayed;

							TempLineString = "";
							for (BYTE TempValveLoop = 0; TempValveLoop < TempValvesToShowOnThisLine; TempValveLoop++)
							{

								CString TempStatusString = "OK";
								FillToTab(&TempLineString, TempValveLoop * 8);

								if ((TempLowThreshold) && (*TempValveAveragePointer < TempLowThreshold))
								{
									TempStatusString = TempLowText;

									WORD TempStartPosition = TempDataString.GetLength() + TempLineString.GetLength() + 1;
									WORD TempLength = TempStatusString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 1; //red
								}

								if ((TempHighThreshold) && (*TempValveAveragePointer > TempHighThreshold))
								{
									TempStatusString = TempHiText;

									WORD TempStartPosition = TempDataString.GetLength() + TempLineString.GetLength() + 1;
									WORD TempLength = TempStatusString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 1; //red
								}

								if (*TempValveStandardDeviationPointer > Temp3SDs)
								{
									if (TempStatusString == "OK")
										TempStatusString = "Var";
									else
										TempStatusString = TempStatusString + "-Var";

									WORD TempStartPosition = TempDataString.GetLength() + TempLineString.GetLength() + 1;
									WORD TempLength = TempStatusString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 1; //red
								}

								if (((TempLowThreshold) && (*TempValveAveragePointer < TempLowThreshold)) || ((TempHighThreshold) && (*TempValveAveragePointer > TempHighThreshold)) || (*TempValveStandardDeviationPointer > Temp3SDs))
									TempValvesNeedAttention++;

								TempLineString = TempLineString + TempStatusString;

								TempValveAveragePointer++;
								TempValveStandardDeviationPointer++;
							}
							TempDataString = TempDataString + "\n" + TempLineString;

							TempValvesDisplayed = TempValvesDisplayed + TempValvesToShowOnThisLine;

							if (TempValvesDisplayed < vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType])
								TempDataString = TempDataString + "\n\n";
							else
							{
								TempHaveMoreValvesToDisplay = false;

								TempDataString = TempDataString + "\n";

								if (TempLowThreshold)
								{
									CString TempThresholdString = dtoa(TempLowThreshold, 2);
									TempDataString = TempDataString + "\n" + TempUnderText + " Fill Threshold: ";

									WORD TempStartPosition = TempDataString.GetLength();
									WORD TempLength = TempThresholdString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 3; //green

									TempDataString = TempDataString + TempThresholdString;
								}

								if (TempHighThreshold)
								{
									CString TempThresholdString = dtoa(TempHighThreshold, 2);
									TempDataString = TempDataString + "\n" + TempOverText + " Fill Threshold: ";

									WORD TempStartPosition = TempDataString.GetLength();
									WORD TempLength = TempThresholdString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 3; //green

									TempDataString = TempDataString + TempThresholdString;
								}

								if (Temp3SDs)
								{
									CString TempThresholdString = dtoa(Temp3SDs, 2);
									TempDataString = TempDataString + "\nToo Variable Limit: ";

									WORD TempStartPosition = TempDataString.GetLength();
									WORD TempLength = TempThresholdString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 3; //green

									TempDataString = TempDataString + TempThresholdString;
								}
							}
						}
						vSystemData.vNumberOfValvesThatNeedAttention = TempValvesNeedAttention;
					}
					else //don't have enough data to calculate standard dieviations so show the individual data pointer
					{
						WORD TempNumberOfDataPointsToDisplay = vSystemData.vNumberValveRowDataHave;

						if (TempNumberOfDataPointsToDisplay > 100)
							TempNumberOfDataPointsToDisplay = 100;

						if (!vGlobalShiftKeyDown)
							if (TempNumberOfDataPointsToDisplay > 21)
								TempNumberOfDataPointsToDisplay = 21;

						TempTitleString = vSystemData.vSamplingName[cFillerSamplingType] + " Monitor - Fill Values - Recent " + dtoa(TempNumberOfDataPointsToDisplay, 0) + " Rotations";
						bool TempHaveMoreValvesToDisplay = true;
						BYTE TempValvesDisplayed = 0;
						while (TempHaveMoreValvesToDisplay) //do for each valve set rotation to show
						{
							BYTE TempValvesToShowOnThisLine = vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] - TempValvesDisplayed;
							if (TempValvesToShowOnThisLine > 8)
								TempValvesToShowOnThisLine = 8;

							CString TempLineString = "";
							for (BYTE TempValveLoop = 0; TempValveLoop < TempValvesToShowOnThisLine; TempValveLoop++)  //show the valve labels
							{
								FillToTab(&TempLineString, TempValveLoop * 8);
								TempLineString = TempLineString + "  H" + dtoa(TempValveLoop + 1 + TempValvesDisplayed, 0);
							}
							TempDataString = TempDataString + TempLineString;

							for (WORD TempDataLoop = 0; TempDataLoop < TempNumberOfDataPointsToDisplay; TempDataLoop++) //display each data point
							{
								int TempDataRowToGetDataFrom = vSystemData.vValveDataRowIndex - 1 - TempDataLoop;
								if (TempDataRowToGetDataFrom < 0)
									TempDataRowToGetDataFrom = TempDataRowToGetDataFrom + cMaximumValveDataRows;

								//int TempDataPointToShow = vSystemData.vValveDataRowIndex - TempDataLoop - 1;
								int TempDataPointToShow = (TempDataRowToGetDataFrom * vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]) + TempValvesDisplayed;
								TempLineString = "";
								double *TempValveDataPointer = vSystemData.vValveData + TempDataPointToShow;
								for (BYTE TempValveLoop = 0; TempValveLoop < TempValvesToShowOnThisLine; TempValveLoop++) //show all the valves on this line
								{
									FillToTab(&TempLineString, TempValveLoop * 8);

									//double TempDataValue = TempInspection->ConvertToWeight(*TempValveDataPointer);
									double TempDataValue = *TempValveDataPointer;
									CString TempValueToShow = dtoa(TempDataValue, 2);

									if (((TempHighThreshold) && (TempDataValue > TempHighThreshold)) || ((TempLowThreshold) && (TempDataValue < TempLowThreshold)))
									{ //make number in display red if high or low
										WORD TempStartPosition = TempDataString.GetLength() + TempLineString.GetLength() + 1;
										WORD TempLength = TempValueToShow.GetLength();
										for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
											if (TempLoop < TempStringLength)
												TempColors[TempLoop] = 1; //red
									}
									TempLineString = TempLineString + TempValueToShow;
									TempValveDataPointer++;
								}
								
								TempDataString = TempDataString + "\n" + TempLineString;
							}
							TempValvesDisplayed = TempValvesDisplayed + TempValvesToShowOnThisLine;

							if (TempValvesDisplayed < vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType])
								TempDataString = TempDataString + "\n\n";
							else
							{
								TempHaveMoreValvesToDisplay = false;

								TempDataString = TempDataString + "\n";

								if (TempLowThreshold)
								{
									CString TempThresholdString = dtoa(TempLowThreshold, 2);
									TempDataString = TempDataString + "\n" + TempUnderText + " Fill Threshold: ";

									WORD TempStartPosition = TempDataString.GetLength();
									WORD TempLength = TempThresholdString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 3; //green

									TempDataString = TempDataString + TempThresholdString;
								}

								if (TempHighThreshold)
								{
									CString TempThresholdString = dtoa(TempHighThreshold, 2);
									TempDataString = TempDataString + "\n" + TempOverText + " Fill Threshold: ";

									WORD TempStartPosition = TempDataString.GetLength();
									WORD TempLength = TempThresholdString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 3; //green

									TempDataString = TempDataString + TempThresholdString;
								}

								if (Temp3SDs)
								{
									CString TempThresholdString = dtoa(Temp3SDs, 2);
									TempDataString = TempDataString + "\nToo Variable Limit: ";

									WORD TempStartPosition = TempDataString.GetLength();
									WORD TempLength = TempThresholdString.GetLength();
									for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
										if (TempLoop < TempStringLength)
											TempColors[TempLoop] = 3; //green

									TempDataString = TempDataString + TempThresholdString;
								}
							}
						}
					}
				//write averages, standarddeviation, data, and thresholds to systemdata

				vSystemData.vFillerHighThreshold = TempHighThreshold;
				vSystemData.vFillerLowThreshold = TempLowThreshold;
				CopyMemory(vSystemData.vValveAverages, TempValveAverages, sizeof(double)*vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]);
				CopyMemory(vSystemData.vValveStandardDeviations, TempValveStandardDieviations, sizeof(double)*vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]);
				//vSystemData.vValveDataToAverage = TempValveDataToAverage;
				if (TempValveAverages)
					free(TempValveAverages);
				if (TempValveStandardDieviations)
					free(TempValveStandardDieviations);
				if (TempValveDataToAverage)
					free(TempValveDataToAverage);

				//if (PasswordOK(cTemporaryInspxPassword,false)) //show index error data
				//{
				//	CString TempValveErrorString = "\n\nList of Index Pulse Errors:\n";
				//	
				//	int *TempErrorPointer = vSystemData.vSamplingIndexErrorData[cFillerSamplingType] + vSystemData.vSamplingIndexErrorDataIndex[cFillerSamplingType] - 1;
				//	for (BYTE TempValveLoop = 0; TempValveLoop < vSystemData.vSamplingIndexErrorDataHave[cFillerSamplingType]; TempValveLoop++)
				//	{
				//		if (TempValveLoop % 8 == 0)
				//			TempValveErrorString = TempValveErrorString + "\n";
				//		else
				//			TempValveErrorString = TempValveErrorString + "\t";

				//		TempValveErrorString = TempValveErrorString + dtoa(*TempErrorPointer, 0);
				//		TempErrorPointer--;
				//		if (TempErrorPointer < vSystemData.vSamplingIndexErrorData[cFillerSamplingType])
				//			TempErrorPointer = vSystemData.vSamplingIndexErrorDataMaximum[cFillerSamplingType] - 1;
				//	}
				//				
				//	TempDataString = TempDataString + TempValveErrorString;
				//}

				vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();

				CHelpDialog IHelpDialog;
				IHelpDialog.vHelpContext = 16;
				IHelpDialog.vHelpType = 0;
				IHelpDialog.vColor = TempColors;  //TempColors is freed by HelpDialog
				IHelpDialog.vMakeRedTextBoldAndUnderLined = true;
				IHelpDialog.vWindowType = cTextWindow;
				IHelpDialog.vLocalProductCollection = &vProductCollection;
				IHelpDialog.vLocalSystemData = &vSystemData;
				IHelpDialog.vMainWindowPointer = this;
				IHelpDialog.vLocalConfigurationData = vConfigurationData;
				IHelpDialog.vProductPointer = vGlobalCurrentProduct;
				IHelpDialog.vShowTable = true;
				IHelpDialog.vTextString = TempDataString;
				IHelpDialog.vTitleString = TempTitleString;
				int TempResult = IHelpDialog.DoModal();

				OnFunction1Button();
			}
		}
	}
}

void CScanTracDlg::ShowSamplingIndexErrors(BYTE TempShowFiller)
{
	if ((vConfigurationData->vNumberOfHeadsToMonitor[TempShowFiller]) || (TempShowFiller == 0))
	{
		if (vSystemData.vSamplingIndexErrorDataHave[TempShowFiller] == 0)
		{
			CNoticeDialog TempNoticeDialog;
			TempNoticeDialog.vNoticeText = "\n\n\nNo " + vSystemData.vSamplingName[TempShowFiller] + " Index Pulses have occured yet";
			TempNoticeDialog.vType = cNoticeMessage;
			TempNoticeDialog.DoModal();
		}
		else
		if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
		{
			DWORD TempStringLength = 200000;
			int *TempColors = NULL;
			if (ThereIsEnoughMemory(sizeof(int) * TempStringLength, "Color array in help dialog"))
				TempColors = (int *)malloc(sizeof(int) * TempStringLength);
			else
				ReportErrorMessage("Not Enough Memory for Color Array Alloc in Help Dialog",cEMailInspx, 32000);
			if (TempColors)
			{
				ZeroMemory(TempColors, TempStringLength * sizeof(int));
			}

			CString TempDataString = "\n\nList of Index Pulse Errors:\n";
			CString TempTitleString = vSystemData.vSamplingName[TempShowFiller] + " Sampling";
				
			int *TempErrorPointer = vSystemData.vSamplingIndexErrorData[TempShowFiller] + vSystemData.vSamplingIndexErrorDataIndex[TempShowFiller] - 1;
			CString TempValueString;
			for (DWORD TempValveLoop = 0; TempValveLoop < vSystemData.vSamplingIndexErrorDataHave[TempShowFiller]; TempValveLoop++)
			{
				if (TempValveLoop % 8 == 0)
					TempDataString = TempDataString + "\n";
				//else
					//TempDataString = TempDataString + "\t";

				if ((*TempErrorPointer == vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]) && (!vSystemData.vUseSamplingFIFO))
					TempValueString = "Speed";
				else
					TempValueString = dtoa(*TempErrorPointer, 0);
				if (*TempErrorPointer != 0)
				{
					DWORD TempLength = TempValueString.GetLength();
					DWORD TempStartPosition = TempDataString.GetLength() + 1 + 8 - TempLength;
					for (DWORD TempLoop = TempStartPosition; TempLoop < TempStartPosition + TempLength; TempLoop++)
					if (TempLoop < TempStringLength)
						TempColors[TempLoop] = 1; //red
				}

				TempDataString = TempDataString + Pad(TempValueString, 8, 0);
				TempErrorPointer--;
				if (TempErrorPointer < vSystemData.vSamplingIndexErrorData[TempShowFiller])
					TempErrorPointer = vSystemData.vSamplingIndexErrorDataMaximum[TempShowFiller] - 1;
			}

			if (vSystemData.vLastIndexPulseWasCorrect[TempShowFiller])
			{
				CString TempStringToAdd = "\n\nLast Index Pulse was correct";

				WORD TempStartPosition = TempDataString.GetLength();
				WORD TempLength = TempStringToAdd.GetLength();
				for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
				if (TempLoop < TempStringLength)
					TempColors[TempLoop] = 3; //green, 2 is blue

				TempDataString = TempDataString + TempStringToAdd;
			}
			else
			{
				CString TempStringToAdd = "\n\nLast Index Pulse was off";

				WORD TempStartPosition = TempDataString.GetLength();
				WORD TempLength = TempStringToAdd.GetLength();
				for (WORD TempLoop = TempStartPosition + 1; TempLoop <= TempStartPosition + TempLength; TempLoop++)
				if (TempLoop < TempStringLength)
					TempColors[TempLoop] = 1; //red

				TempDataString = TempDataString + TempStringToAdd;
			}

			if ((vSystemData.vMostRecentTimeBeforeIndexPulse[TempShowFiller]) && (vSystemData.vMostRecentTimeAfterIndexPulse[TempShowFiller]))
			{
				BYTE TempDigitsBefore = 6;
				BYTE TempDigitsAfter = 6;
				//brh temp
				//if (vSystemData.vMostRecentTimeBeforeIndexPulse[TempShowFiller] > .01)
				//	TempDigitsBefore = 3;
				//if (vSystemData.vMostRecentTimeAfterIndexPulse[TempShowFiller] > .01)
				//	TempDigitsAfter = 3;
				TempDataString = TempDataString + "\n\n\n" + dtoa(vSystemData.vMostRecentTimeBeforeIndexPulse[TempShowFiller] / 1000000, TempDigitsBefore) + " seconds before Index Pulse from container";
				TempDataString = TempDataString + "\n" + dtoa(vSystemData.vMostRecentTimeAfterIndexPulse[TempShowFiller] / 1000000, TempDigitsAfter) + " seconds after Index Pulse to container";
				if (vSystemData.vSeamerPocketSensorBitMap)
				{
					TempDataString = TempDataString + "\n\n\n" + dtoa(vSystemData.vLastTimeObjectToPocketPulse / 1000000, TempDigitsBefore) + " seconds Object to Pocket Sensor Pulse";
					TempDataString = TempDataString + "\n" + dtoa(vSystemData.vLastTimePocketToObjectPulse / 1000000, TempDigitsAfter) + " seconds Pocket to Object Sensor Pulse";
				}
			}

			vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();

			CHelpDialog IHelpDialog;
			IHelpDialog.vHelpContext = 16;
			IHelpDialog.vHelpType = 0;
			IHelpDialog.vColor = TempColors; //TempColors is freed by HelpDialog
			IHelpDialog.vMakeRedTextBoldAndUnderLined = true;
			IHelpDialog.vWindowType = cTextWindow;
			IHelpDialog.vLocalProductCollection = &vProductCollection;
			IHelpDialog.vLocalSystemData = &vSystemData;
			IHelpDialog.vMainWindowPointer = this;
			IHelpDialog.vLocalConfigurationData = vConfigurationData;
			IHelpDialog.vProductPointer = vGlobalCurrentProduct;
			IHelpDialog.vTextString = TempDataString;
			IHelpDialog.vTitleString = TempTitleString;
			int TempResult = IHelpDialog.DoModal();

//			if (TempColors)		//freed in help in DestroyWindow
//				free(TempColors);
		}
	}
	else
	{
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nNot Configured";
		TempNoticeDialog.vType = cNoticeMessage;
		TempNoticeDialog.DoModal();
	}
}

void CScanTracDlg::CalculateValveStatus()
{
	BYTE TempValvesNeedAttention = 0;

	if (vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType])
	if (vSystemData.vValveData)
	if (vSystemData.vNumberValveRowDataHave > 4)
	if (vSystemData.vITIPCDig->vContainerCollectionLock.Lock())
	{
		CInspection *TempInspection = NULL;
		if (vSystemData.vValveMonitorInspection <= vGlobalCurrentProduct->vNumberOfInspections)
			TempInspection = vGlobalCurrentProduct->vInspection[vSystemData.vValveMonitorInspection];
		if (!TempInspection)
			TempInspection = vGlobalCurrentProduct->vFillerMonitorInspection;

		double *TempValveAverages = NULL;
		double *TempValveStandardDieviations = NULL;
		double *TempValveData = NULL;
		double Temp3SDs = 15;
		double TempAverage = 0;

		if (ThereIsEnoughMemory(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double), "TempValveAverages"))
			TempValveAverages = (double *)malloc(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));
		double *TempValveAveragesMaximum = TempValveAverages + vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType];

		if (ThereIsEnoughMemory(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double), "TempValveStandardDieviations"))
			TempValveStandardDieviations = (double *)malloc(vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType] * sizeof(double));
		double *TempValveStandardDieviationsMaximum = TempValveStandardDieviations + vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType];

		if (ThereIsEnoughMemory(vSystemData.vNumberValveRowDataHave * sizeof(double), "TempValveDataToAverage"))
			TempValveData = (double *)malloc(vSystemData.vNumberValveRowDataHave * sizeof(double));
		double *TempValveDataMaximum = TempValveData + vSystemData.vNumberValveRowDataHave;
	

		if ((TempValveAverages) && (TempValveStandardDieviations) && (TempValveData))
		{
			//calculate Average and SD for each valve
			for (BYTE TempValveLoop = 0; TempValveLoop < vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]; TempValveLoop++)
			{
				double *TempSourcePointer = vSystemData.vValveData + TempValveLoop;
				double *TempDestinationPointer = TempValveData;

				WORD TempGoodDataCount = 0;
				for (WORD TempDataLoop = 0; TempDataLoop < vSystemData.vNumberValveRowDataHave; TempDataLoop++)
				{
					if ((TempDestinationPointer < TempValveDataMaximum) && (TempSourcePointer < vSystemData.vValveDataMaximum))
					{
						if (*TempSourcePointer > 0)
						{
							TempGoodDataCount++;
							*TempDestinationPointer = *TempSourcePointer; //don't convert to weight because values were saved as converted weights originally
							TempDestinationPointer++;
						}
						TempSourcePointer = TempSourcePointer + vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType];
					}
					else
						ReportErrorMessage("Filler Monitor Pointer Error 2", cEMailInspx, 32000);
				}

				double *TempPointerToValveStandardDeviation = TempValveStandardDieviations + TempValveLoop;
				double *TempPointerToValveAverage = TempValveAverages + TempValveLoop;
				if (TempGoodDataCount)
					*TempPointerToValveStandardDeviation = CalculateStandardDeviation(TempValveData, TempGoodDataCount, TempPointerToValveAverage);
				else
				{
					*TempPointerToValveAverage = 0;
					*TempPointerToValveStandardDeviation = 0;
				}

				double TempAverageValueForThisHead = *TempPointerToValveAverage;
				double TempSDValueForThisHead = *TempPointerToValveStandardDeviation;
				TempAverageValueForThisHead = *TempPointerToValveAverage;

				//b rh for testing only
				//*TempPointerToValveStandardDeviation = 200.1 + TempValveLoop;
				//*TempPointerToValveAverage = 300.6 + TempValveLoop;
			}
						
			CalculateStandardDeviation(TempValveAverages, vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType], &vSystemData.vFillerAverageWeight);

			//Temp3SDs = CalculateStandardDeviation(TempValveAverages, vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType], &TempAverage);
			Temp3SDs = CalculateStandardDeviation(TempValveStandardDieviations, vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType], &TempAverage);
			Temp3SDs = Temp3SDs * 3;
			if (Temp3SDs < .2)
				Temp3SDs = .2;

			if (vGlobalCurrentProduct->vFillerTolerance)
					Temp3SDs = vGlobalCurrentProduct->vFillerTolerance;

			double TempLowThreshold = 0;
			double TempHighThreshold = 0;

			if (TempInspection)
			{
				if ((TempInspection->vInspectionType == cUnderfillInspection) ||
					(TempInspection->vInspectionType == cDensityInspection))
					TempHighThreshold = TempInspection->vDensityThresholdUpper;

				if ((TempInspection->vInspectionType == cOverfillInspection) ||
					(TempInspection->vInspectionType == cDensityInspection))
					TempLowThreshold = TempInspection->vDensityThresholdLower;

				if (TempInspection->vInspectionType == cUnderfillByWeightInspection)
					TempLowThreshold = TempInspection->ConvertToWeight(TempInspection->vDensityThresholdUpper);

				if (TempInspection->vInspectionType == cOverfillByWeightInspection)
					TempHighThreshold = TempInspection->ConvertToWeight(TempInspection->vDensityThresholdLower);

				if ((TempHighThreshold == 0) && (TempLowThreshold))
				if (TempInspection->vInspectionType == cUnderfillByWeightInspection)
				{
					for (BYTE TempInspectionLoop = 0; TempInspectionLoop < vGlobalCurrentProduct->vNumberOfInspections; TempInspectionLoop++)
					if (vGlobalCurrentProduct->vInspection[TempInspectionLoop])
					if (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionNameForWeightTrendingName.GetLength())
					if (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionNameForWeightTrendingName == TempInspection->vName)
					TempHighThreshold = TempInspection->ConvertToWeight(vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vDensityThresholdLower);
				}

				if ((TempHighThreshold) && (TempLowThreshold == 0))
				if (TempInspection->vInspectionType == cOverfillByWeightInspection)
				{
					for (BYTE TempInspectionLoop = 0; TempInspectionLoop < vGlobalCurrentProduct->vNumberOfInspections; TempInspectionLoop++)
					if (vGlobalCurrentProduct->vInspection[TempInspectionLoop])
					if (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionNameForWeightTrendingName.GetLength())
					if (vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vInspectionNameForWeightTrendingName == TempInspection->vName)
					TempLowThreshold = TempInspection->ConvertToWeight(vGlobalCurrentProduct->vInspection[TempInspectionLoop]->vDensityThresholdUpper);
				}
			}

			//check Valve Status
			double *TempValveAveragePointer = TempValveAverages;
			double *TempValveStandardDeviationPointer = TempValveStandardDieviations;
			for (BYTE TempValveLoop = 0; TempValveLoop < vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]; TempValveLoop++)
			{
				//crash
				if (((TempLowThreshold) && (*TempValveAveragePointer < TempLowThreshold)) || ((TempHighThreshold) && (*TempValveAveragePointer > TempHighThreshold)) || (*TempValveStandardDeviationPointer > Temp3SDs))
					TempValvesNeedAttention++;

				TempValveAveragePointer++;
				TempValveStandardDeviationPointer++;
			}
			vSystemData.vFillerHighThreshold = TempHighThreshold;
			vSystemData.vFillerLowThreshold = TempLowThreshold;
			CopyMemory(vSystemData.vValveAverages, TempValveAverages, sizeof(double)*vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]);
			CopyMemory(vSystemData.vValveStandardDeviations, TempValveStandardDieviations, sizeof(double)*vConfigurationData->vNumberOfHeadsToMonitor[cFillerSamplingType]);
		}
		if (TempValveAverages)
			free(TempValveAverages);
		if (TempValveStandardDieviations)
			free(TempValveStandardDieviations);
		if (TempValveData)
			free(TempValveData);
		vSystemData.vITIPCDig->vContainerCollectionLock.Unlock();		
	}
	vSystemData.vNumberOfValvesThatNeedAttention = TempValvesNeedAttention;
}

void CScanTracDlg::StartCalibrateDetectorEdgesForXScanPoint4Mode()
{
	CreateBackupGainAndPixelAdjustments();

	vSystemData.vApplyGainAndOffsetDuringCalibration = false;
	LoadCalibrateEdgesProduct();
	vSystemData.vFindingProductBrightness = true;
	vSystemData.vModeToRunAfterCalibrateOffset = cCalibratingDetectorEdgesMode;
	//this will calibrate detectors, then do gain adjustments
	vSystemData.vCalibrateErrorCount = 0;
	//calibrate offsets, then it will calibrate pixels
	ReportErrorMessage("Just Detector Pixel Calibration Started for X-Scan .4", cWriteToLog,0);
	vSystemData.vCalibrateADCAfterDAC = true;
	vSystemData.vAutoCalibrate = true;
	vSystemData.vAutoCalibrateWhileRunning = false;
	if (vConfigurationData->vUseDACAndADCinDensityCompensation)
		CalibrateDACDetectorOffset();
	else
		CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
}

void CScanTracDlg::SendResolutionSettingsTouCHardware()
{
	tSerialCommand TempCommand;
	if (vGlobalFPGAVersion16point0orAbove)
	{ //send a 1 if (X-Scan .8) or (DT .4 or .8)
		TempCommand[0] = 0x23;
		TempCommand[1] = 0x81;
		TempCommand[2] = 0x00;
		TempCommand[3] = 0x01; // all DT and X-scan .4

		if ((vConfigurationData->vUseXScanDetectors) && (vConfigurationData->vPixelsPerDetector == 64)) //if X-Scan and .8 mm detector make a zero
			TempCommand[3] = 0x00;

		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
		Sleep(cSendCommandSleepTimeSetup);
	}

	//Send Detector size .8 or .4 mm
	TempCommand[0] = 0x23;
	TempCommand[1] = 0xEE;
	TempCommand[2] = 0;
	if (vConfigurationData->vPixelsPerDetector == 128) //.4mm Detectors
		TempCommand[3] = 1;
	else
	if (vConfigurationData->vDetectorLength == 4) //1.6mm Detectors
		TempCommand[3] = 2;
	else
	//if (vLocalConfigurationData->vPixelsPerDetector == 64)
		TempCommand[3] = 0; //.8mm Detectors
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);
}



void CScanTracDlg::OnDialogtitlestatictext()
{
	// TODO: Add your control notification handler code here
	BYTE TempHiddenKeys = 8;
	if (!PasswordOK(cTemporaryInspxPassword,false))
		TempHiddenKeys = 10;
	DisplaySoftKeyMenu(TempHiddenKeys);
}

void CScanTracDlg::DisplaySoftKeyMenu(BYTE TempKeyDisables)
{
	// TODO: Add your control notification handler code here
	CSoftKeyMenu TempSoftKeyMenu;
	TempSoftKeyMenu.vMenuType = 0;
	TempSoftKeyMenu.vDisableKeys = TempKeyDisables;
	if (this->IsWindowEnabled())	//if the soft key menu was called from main menu, show button 4 to change language
	{
		TempSoftKeyMenu.vOnMainMenu = true;
		//TempSoftKeyMenu.vLanguageString = "";
		switch (vConfigurationData->vLanguage)
		{
			case 1:
				TempSoftKeyMenu.vLanguageString = "English";
				break;
			case 2:
				TempSoftKeyMenu.vLanguageString = "French";
				break;
			case 3: 
				TempSoftKeyMenu.vLanguageString = "Spanish";
				break;
			default:
				TempSoftKeyMenu.vLanguageString = "Language";
				break;
		}
	}
	int TempResult = TempSoftKeyMenu.DoModal();
	//if user said OK delete files in log directory 
	if (TempResult == IDOK)
	{
		if (TempSoftKeyMenu.vResultKey)
			SendSoftKey(TempSoftKeyMenu.vResultKey);
	}
}

void CScanTracDlg::SendSoftKey(BYTE TempKey)
{
	PostThreadMessage(vGlobalCallingThreadID, cSoftKeyPressed, TempKey, TempKey);
}

void CScanTracDlg::HandleSoftKeyPress(int TempKey1, int TempKey2)
{
	MSG TempMessage;
	int TempTimerResult = 0;
	switch (TempKey1)
	{
		case 1: //enter password or Clear password
			HandleClearButtonPress();
		break;
		case 2: //shift or hidden keypressed
			TempMessage.message = WM_KEYDOWN;
			TempMessage.lParam = 16;  //code for shift key
			TempMessage.wParam = 16;
			PreTranslateMessage(&TempMessage);
		break;
		case 3: //Help
			//TempMessage.message = WM_KEYDOWN;
			//TempMessage.lParam = cPageDown;  //code for Help Button
			//TempMessage.wParam = cPageDown;
			//PreTranslateMessage(&TempMessage);
			PostThreadMessage(vGlobalCallingThreadID, WM_KEYDOWN, cPageDown, cPageDown);
		break;
		case 4: 
//			vSystemData.vTouchScreen = true;
			//if (this->IsWindowVisible())
			//{
			//	vSoftKeyFourPressed = true;
			//}
			//PostThreadMessage(vGlobalCallingThreadID, WM_KEYDOWN, 113, 113);  //113 is subfunction 5 key, keyboard mode
			SelectLanguage();
		
		//Image
			//TempMessage.message = WM_KEYDOWN;
			//TempMessage.lParam = 35;  //code for Image key
			//TempMessage.wParam = 35;
			//PreTranslateMessage(&TempMessage);
		//	PostThreadMessage(vGlobalCallingThreadID, WM_KEYDOWN, 35, 35);
		break;
		case 5: //Print Screen
			//TempMessage.message = WM_KEYDOWN;
			//TempMessage.lParam = 36;  //code for Print Screen Button
			//TempMessage.wParam = 36;
			//PreTranslateMessage(&TempMessage);

			TempTimerResult = SetTimer(vSendPrintScreenMessageSoon,200,NULL);
			if (!TempTimerResult)
				ReportErrorMessage("Error-Send Print Screen Message Timer Failed",cEMailInspx,32000);
		break;
	}
}

void CScanTracDlg::HandleClearButtonPress()
{
	if (vGlobalPasswordLevel)
	{
		PasswordOK(cNoPassword, false);
		vPasswordEntryString = "";
	}
	else
	{
		//if (vSystemData.vMainDisplayMode == cMainDisplayProductionSummary)
		//{
			PasswordOK(cAnyPasswordToEnter, true);
			WriteLifeTimeCounter();
		//}
		//else
		//{
		//	vPasswordEntryString = "";
		//	vEnteringPecoPasswordMode = true;
		//}
	}
	CWnd *TempWindow = CWnd::GetDlgItem(IDC_DialogTitleStaticText1);
	if (TempWindow)
		TempWindow->Invalidate(false);		

	::PostThreadMessage(vGlobalCallingThreadID,cUpdateTitleBarMessage, 0, 0);
}

void CScanTracDlg::OnDialogtitlestatictext1()
{
	if (vGlobalShiftKeyDown)
		OnDialogTitleStaticText();
	else
	{
		BYTE TempHiddenKeys = 0;
		//if multi image, show image key
		if (!PasswordOK(cTemporaryInspxPassword,false))
			TempHiddenKeys = 2;
		DisplaySoftKeyMenu(TempHiddenKeys);
	}
}

int CScanTracDlg::GetCurrentFillerIndexOffset()
{
	if (vSystemData.vUseSamplingFIFO)
	{
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[0];	//if current encoder rate > vEncoderRateBoundry
	}
	else
	if ((((double)(100 + vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[0] > vSystemData.vActualEncoderRate)
		&& (((double)(100 - vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[0] < vSystemData.vActualEncoderRate))
	{	
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Encoder rate within tolerances for Index 1 filler pulse offset",cDebugMessage);
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[0];	//if current encoder rate > vEncoderRateBoundry
	}
	else if ((((double)(100 + vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[1] > vSystemData.vActualEncoderRate)
		&& (((double)(100 - vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[1] < vSystemData.vActualEncoderRate))
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Encoder rate within tolerances for Index 2 filler pulse offset",cDebugMessage);
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[1];
	}
	else if ((((double)(100 + vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[2] > vSystemData.vActualEncoderRate)
		&& (((double)(100 - vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[2] < vSystemData.vActualEncoderRate))
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Encoder rate within tolerances for Index 3 filler pulse offset",cDebugMessage);
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[2];
	}
	else if ((((double)(100 + vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[3] > vSystemData.vActualEncoderRate)
		&& (((double)(100 - vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[3] < vSystemData.vActualEncoderRate))
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Encoder rate within tolerances for Index 4 filler pulse offset",cDebugMessage);
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[3];
	}
	else
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Encoder rate not within tolerances for filler",cDebugMessage);
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[0];
	}
}

int CScanTracDlg::GetCurrentSeamerIndexOffset()
{
	if (vSystemData.vUseSamplingFIFO)
	{
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[4];	//if current encoder rate > vEncoderRateBoundry
	}
	else
	if ((((double)(100 + vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[0] > vSystemData.vActualEncoderRate)
		&& (((double)(100 - vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[0] < vSystemData.vActualEncoderRate))
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[4];
	else 
	if ((((double)(100 + vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[1] > vSystemData.vActualEncoderRate)
		&& (((double)(100 - vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[1] < vSystemData.vActualEncoderRate))
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[5];	//if current encoder rate > vEncoderRateBoundry
	else 
	if ((((double)(100 + vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[2] > vSystemData.vActualEncoderRate)
		&& (((double)(100 - vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[2] < vSystemData.vActualEncoderRate))
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[6];
	else 
	if ((((double)(100 + vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[3] > vSystemData.vActualEncoderRate)
		&& (((double)(100 - vConfigurationData->vEncoderRateTolerance) / 100.0) * (double)vGlobalCurrentProduct->vEncoderRateIndexesForFillerSeamerSampling[3] < vSystemData.vActualEncoderRate))
		return vGlobalCurrentProduct->vHeadOffsetFromIndexPulse[7];
	else
	{
		if (vSystemData.vLogFile.vLogSerialData)
			vSystemData.vLogFile.WriteToLogFile("Encoder rate not within tolerances for seamer",cDebugMessage);
		return vConfigurationData->vNumberOfHeadsToMonitor[cSeamerSamplingType];
	} 
}

BYTE CScanTracDlg::CalculateHeadNumber(int TempNextHeadToProcess, BYTE TempWhichDevice)
{
	int TempReturn = TempNextHeadToProcess;
	if (vConfigurationData->vNumberOfHeadsToMonitor[TempWhichDevice])
	{
		int TempOffset = 0;
		if (TempWhichDevice == cFillerSamplingType)
			TempOffset = GetCurrentFillerIndexOffset();
		else 
		if (TempWhichDevice == cSeamerSamplingType)
			TempOffset = GetCurrentSeamerIndexOffset();

		if (TempOffset) //don't do if no offset
		{
			TempReturn = (int)TempNextHeadToProcess + (int)TempOffset;
		}
		if (TempReturn < 1)
			TempReturn = TempReturn + vConfigurationData->vNumberOfHeadsToMonitor[TempWhichDevice];
		if (TempReturn > vConfigurationData->vNumberOfHeadsToMonitor[TempWhichDevice])
			TempReturn = TempReturn - vConfigurationData->vNumberOfHeadsToMonitor[TempWhichDevice];
	}
	return (BYTE)TempReturn;
}

void CScanTracDlg::SetupBulkModeAndMainMenuScreen()
{
	if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
	{
		vSystemData.vWorkStopTimePeriod = 10;
	}
	else
	{
		vConfigurationData->vUsePipeFlowInput = false;
		vSystemData.vWorkStopTimePeriod = 60;
	}

	if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) 
		vSystemData.vContainerString = "Image";
	else
		vSystemData.vContainerString = "Container";

	if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
	{
		CString TempText = " ";
		TempText.LoadString(IDS_RunTime);
		TempText = TempText + ":";
		SetDlgItemText(IDC_TotalContainersLabel,TempText);
		if (vSystemData.vOldRunDuration)
			SetDlgItemText(IDC_TotalContainers,FormatRunTimeCounterString(vSystemData.vOldRunDuration));// if a pipe show run duration for total
		else
			SetDlgItemText(IDC_TotalContainers, _T(""));// if a pipe show blank if total zero
		CString TempText2 = " ";
		TempText2.LoadString(IDS_LastReject);
		TempText2 = TempText2 + ":";
		SetDlgItemText(IDC_PercentRejectLabel,TempText2);
		SetDlgItemText(IDC_PercentRejected, _T(""));
	}
	else
	{
		TempText.LoadString(IDS_Total);
		SetDlgItemText(IDC_TotalContainersLabel,TempText + ":");
		SetDlgItemText(IDC_TotalContainers,IToAWithComma(vSystemData.vOldTotalContainers));// if not a pipe show total

		CString TempText2 = " ";
		TempText2.LoadString(IDS_Ejected);
		SetDlgItemText(IDC_PercentRejectLabel,"% " + TempText2 + ":");

		if (vSystemData.vTotalContainers > 0)
		{
			vSystemData.vPercentEjected = ((double)vSystemData.vEjectCountTotal / (double)vSystemData.vTotalContainers) * 100.0;
			if (vSystemData.vPercentEjected > 100)
				vSystemData.vPercentEjected = 100;
		}
		else
			vSystemData.vPercentEjected = 0;
	}

	if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
		m_PercentRejectedControl.SetWindowPos(NULL,232,108,200,20,SWP_NOZORDER);
	else
	{
		m_PercentRejectedControl.SetWindowPos(NULL, 232, 108, 90, 20, SWP_NOZORDER);
		SetDlgItemText(IDC_PercentRejected, _T("0"));
	}

	if ((vGlobalDisplaySizeH == 800) || (vGlobalDisplaySizeV == 600))
		m_TotalEjectsStaticText.SetWindowPos(NULL,232,126,90,20,SWP_NOZORDER);

	SetupMenu();
}

void CScanTracDlg::SetupLanguage()
{
	if (vConfigurationData->vLanguage == cFrench)
	{
		vSystemData.vRegionalLocale = _wsetlocale(LC_ALL, _T("French"));
		vGlobalUseCommaForDecimalPoint = true;

		WORD TempLID = MAKELANGID(LANG_FRENCH, SUBLANG_FRENCH);
		if (vGlobalPCRunningWindowsXP <= cWindowsXP)
		{
			DWORD TempCLID = MAKELCID(TempLID, SORT_DEFAULT);
			int TempResult = SetThreadLocale(TempCLID);		//replace with SetThreadUILanguage - https://social.msdn.microsoft.com/Forums/office/en-US/48307680-0f40-445a-9d6a-d9bb3368a3ee/issue-with-cfiledialog-on-windows-server-2008-machine?forum=vcgeneral
		}
		else
			int TempResult = SetThreadUILanguage(TempLID);

		vGlobalLanguage = cFrench;
	}
	else
	if (vConfigurationData->vLanguage == cSimplifiedChinese)
	{
		vSystemData.vRegionalLocale = _wsetlocale(LC_ALL, _T("chinese-simplified"));
		vGlobalUseCommaForDecimalPoint = false;
		WORD TempLID = MAKELANGID(LANG_CHINESE_SIMPLIFIED, SUBLANG_CHINESE_SIMPLIFIED);
		if (vGlobalPCRunningWindowsXP <= cWindowsXP)
		{
			DWORD TempCLID = MAKELCID(TempLID, SORT_DEFAULT);
			int TempResult = SetThreadLocale(TempCLID);		//replace with SetThreadUILanguage - https://social.msdn.microsoft.com/Forums/office/en-US/48307680-0f40-445a-9d6a-d9bb3368a3ee/issue-with-cfiledialog-on-windows-server-2008-machine?forum=vcgeneral
		}
		else
			int TempResult = SetThreadUILanguage(TempLID);

		vGlobalLanguage = cSimplifiedChinese;
	}
	else
	if (vConfigurationData->vLanguage == cPolish)
	{
		vGlobalUseCommaForDecimalPoint = true;
		vSystemData.vRegionalLocale = _wsetlocale(LC_ALL, _T("Polish"));
		if (vGlobalPCRunningWindowsXP <= cWindowsXP)
			int TempResult = SetThreadLocale(0x0415);
		else
			int TempResult = SetThreadUILanguage(0x0415);
		
		vGlobalLanguage = cPolish;
	}
	else
	if (vConfigurationData->vLanguage == cSpanish)
	{
		vSystemData.vRegionalLocale = _wsetlocale(LC_ALL, _T("Spanish")); //sets date to spanish language

		WORD TempLID = MAKELANGID(LANG_SPANISH, SUBLANG_SPANISH);
		if (vGlobalPCRunningWindowsXP <= cWindowsXP)
		{
			DWORD TempCLID = MAKELCID(TempLID, SORT_DEFAULT);
			int TempResult = SetThreadLocale(TempCLID);
		}
		else
			int TempResult = SetThreadUILanguage(TempLID);
		
		vGlobalLanguage = cSpanish;
	}
	else
	if (vConfigurationData->vLanguage == cGerman)
	{
		vGlobalUseCommaForDecimalPoint = true;
		vSystemData.vRegionalLocale = _wsetlocale(LC_ALL, _T("German")); //sets date to spanish language

		WORD TempLID = MAKELANGID(LANG_GERMAN, SUBLANG_GERMAN);
		if (vGlobalPCRunningWindowsXP <= cWindowsXP)
		{
			DWORD TempCLID = MAKELCID(TempLID, SORT_DEFAULT);
			int TempResult = SetThreadLocale(TempCLID);
		}
		else
			int TempResult = SetThreadUILanguage(TempLID);

		vGlobalLanguage = cGerman;
	}
	else //English
	{
		vGlobalUseCommaForDecimalPoint = false;
		vSystemData.vRegionalLocale = _wsetlocale(LC_ALL, _T("English")); //sets date to spanish language

		WORD TempLID = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US);
		if (vGlobalPCRunningWindowsXP <= cWindowsXP)
		{
			DWORD TempCLID = MAKELCID(TempLID, SORT_DEFAULT);
			int TempResult = SetThreadLocale(TempCLID);
		}
		else
			int TempResult = SetThreadUILanguage(TempLID);
		vGlobalLanguage = cEnglish;
	}

	vDialogTitleString.LoadString(IDS_MainMenu);
#ifdef _DEBUG
	vDialogTitleString = "Test Version";
#endif
	SetDlgItemText(IDC_DialogTitleStaticText1,vDialogTitleString);

	TempText.LoadString(IDS_Run);
	SetDlgItemText(IDC_SubFunction4Button,TempText);

	TempText.LoadString(IDS_Stop);
	SetDlgItemText(IDC_SubFunction1Button,TempText);

	TempText.LoadString(IDS_SelectAProduct);//Select\nA\nProduct
	SetDlgItemText(IDC_SubFunction3Button,TempText);
	
	TempText.LoadString(IDS_CurrentProduct);

	//chinese test only
	//TempText.LoadString(IDS_RenSymbol);
	//TempText.LoadString(IDS_YenSymbol);
	
	SetDlgItemText(IDC_CurrentProductLabel,TempText + ":");

	TempText.LoadString(IDS_TotalEjected);
	SetDlgItemText(IDC_TotalEjectsLabelStaticText,TempText + ":");
	CString TempText2 = " ";
	TempText2.LoadString(IDS_Rejected);
	SetDlgItemText(IDC_TotalRejectsPercentLabel,"% " + TempText2 + ":");
	TempText2.LoadString(IDS_Unconfirmed);
	SetDlgItemText(IDC_TotalUnConfirmLabel,TempText2 + ":");
	TempText2.LoadString(IDS_TotalRejects);
	SetDlgItemText(IDC_TotalRejectsLabelStaticText,TempText2 + ":");
	
	TempText2.LoadString(IDS_TotalGood);
	SetDlgItemText(IDC_TotalGoodLabelStaticText,TempText2 + ":");

	TempText.LoadString(IDS_TestModesActive);
	SetDlgItemText(IDC_TestModesActive,TempText);

	TempText.LoadString(IDS_DemoHelp);
	SetDlgItemText(IDC_DemoHelpButton,TempText);
	TempText.LoadString(IDS_XRAYSON);
	SetDlgItemText(IDC_XRaysOn,TempText);
	SetDlgItemText(IDC_Calibrating,TempText);
	SetDlgItemText(IDC_uControllerStatus,vSystemData.vOldOpenInterlock);

	if (!vDisplayingVersion)
	{
		UpdateDisplay();
		UpdateClearYellowMessageButton();
		UpdateDisableEjectorsButton();
		UpdateSubFunction8Button();
		UpdateRunButton();
		UpdateCustomerNameLine();
		UpdateRejectReasonOnScreen();
		ChangeDisplays();
	}

	if ((vConfigurationData->vContinuousFeedContainerRate) || (vConfigurationData->vBulkProductMode) || ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vBulkProductMode))) //Continuous Feed, or a Pipeline
	{
		TempText.LoadString(IDS_RunTime);
		TempText = TempText + ":";
		SetDlgItemText(IDC_TotalContainersLabel,TempText);
		if (vSystemData.vOldRunDuration)
			SetDlgItemText(IDC_TotalContainers,FormatRunTimeCounterString(vSystemData.vOldRunDuration));// if a pipe show run duration for total
		else
			SetDlgItemText(IDC_TotalContainers, _T(""));// if a pipe show blank if total zero
		TempText2.LoadString(IDS_LastEject);
		TempText2 = TempText2 + ":";
		SetDlgItemText(IDC_PercentRejectLabel,TempText2);
		SetDlgItemText(IDC_PercentRejected, _T(" "));
	}
	else
	{
		TempText.LoadString(IDS_Total);
		SetDlgItemText(IDC_TotalContainersLabel,TempText + ":");

		TempText2.LoadString(IDS_Ejected);
		SetDlgItemText(IDC_PercentRejectLabel,"% " + TempText2 + ":");
	}
	if (vConfigurationData->vAutoImproveEnabled)
	if (vLastLearnState)
	if (!(vSystemData.vYellowMessageButtonYellow)) //not showing yellow message, so SHOW auto improve message
	{
		CString TempText = "-";
		TempText.LoadString(IDS_ImprovingLearnDonottestsmallcontaminants);
		SetDlgItemText(IDC_StatusLine, TempText);
	}
	if ((vConfigurationData->vScanTracType == cAtempoScanTrac) || (vConfigurationData->vScanTracType == cForteScanTrac) || (vGlobalScanTracType == cAllegroScanTrac) || 
		(vConfigurationData->vScanTracType == cCaseInspectorScanTrac))
	{
		vGlobalTopString.LoadString(IDS_Back);
		vGlobalBottomString.LoadString(IDS_Front);
	}
	else
	{
		vGlobalTopString.LoadString(IDS_Top);
		vGlobalBottomString.LoadString(IDS_Bottom);
	}
	SetupRejectReasonNames();
}

void CScanTracDlg::EnableCamLinkImages()
{
	CYesNoDialog TempYesNoDialog;
	TempYesNoDialog.vNoticeText = _T("Enable CamLink Images?");
	TempYesNoDialog.vQuestionType = cConfirmAbandon;
	TempYesNoDialog.vYesButtonText = "Enable";
	TempYesNoDialog.vNoButtonText = "Cancel";
	int TempResult = TempYesNoDialog.DoModal();
	//if user said OK
	if (TempResult == IDOK)
	{
		//TurnOnOffCamLinkTestImages(true);
		vSystemData.vSimulatingCamLinkImage = true;
		ReportErrorMessage("Inspx Enabled CamLink Simulated Images", cWriteToLog, 32000);
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		for (BYTE TempLoop = 0; TempLoop < 5; TempLoop++)
		{
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFC, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
		}
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
	}
}

void CScanTracDlg::DisableCamLinkImages()
{
	CYesNoDialog TempYesNoDialog;
	TempYesNoDialog.vNoticeText = _T("Disable CamLink Images?");
	TempYesNoDialog.vQuestionType = cConfirmAbandon;
	TempYesNoDialog.vYesButtonText = "Disable";
	TempYesNoDialog.vNoButtonText = "Cancel";
	int TempResult = TempYesNoDialog.DoModal();
	//if user said OK
	if (TempResult == IDOK)
	{
		//TurnOnOffCamLinkTestImages(false);
		vSystemData.vSimulatingCamLinkImage = false;
		ReportErrorMessage("Disabled CamLink Simulated Images", cWriteToLog, 32000);
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
		Sleep(10);
		for (BYTE TempLoop = 0; TempLoop < 5; TempLoop++)
		{
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFA, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
			vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFE, LNK_PARALLEL_IO_CHAN);
			Sleep(10);
		}
		vSystemData.vITIPCDig->vCaptureModule->OutportVal(0xFF, LNK_PARALLEL_IO_CHAN);
	}
}

void CScanTracDlg::CheckIfShouldMeasureSourceStrength()
{
	CTime TempTime = CTime::GetCurrentTime();
	CTimeSpan TempDeltaTime;
	TempDeltaTime = TempTime - vConfigurationData->vTimeLastMeasuredSourceStrength;
	LONGLONG TempSeconds = TempDeltaTime.GetTotalSeconds();
	//Jay wants to Measure Source Strength every 2 months
	if (InterlocksOK())
	if ((TempSeconds > 5184000) && (!vConfigurationData->vDemoMode))  
	{
		CYesNoDialog TempYesNoDialog;
		TempYesNoDialog.vNoticeText = _T("Can the ScanTrac Measure the Source Strength now?\nThe Source Strength should be measured every 2 months\nto track detector wear.\nNo containers should go through for 2 minutes.");
		TempYesNoDialog.vYesButtonText = "Measure Strength!";
		TempYesNoDialog.vNoButtonText = "Will Do Later";
		TempYesNoDialog.vQuestionType = cConfirmQuestion;
		int TempResult = TempYesNoDialog.DoModal();
		if (TempResult == IDOK)
		{
			//MeasureSourceStrength();
			ReportErrorMessage("Save Original Product so can restore after calibration complete", cWriteToLog, 0);
			vCalibrateHoldCurrentProduct = vGlobalCurrentProduct;
								
			LoadMeasureSourceStrengthProduct();

			vSystemData.vCalibratingXScanPoint4mmDetectors = 0;
			if ((vConfigurationData->vUseXScanDetectors) && (vConfigurationData->vScanTracType != cForteScanTrac) && (vConfigurationData->vScanTracType != cCaseInspectorScanTrac))
				vSystemData.vCalibratingXScanPoint4mmDetectors = vGlobalCurrentProduct->vUsingXScanPoint4mmDetectors;

			//set gains to 10
			SendADCGainsAndOffsets(true);

			if (vGlobalFPGAVersion10Point0OrHigher)
				SendPreAmpGain(1);//preamp gain of 2 
			else
				SendPreAmpGain(2);//preamp gain of 4 

			vSystemData.vApplyGainAndOffsetDuringCalibration = false;
			vSystemData.vModeToRunAfterCalibrateOffset = cMeasureSourceStrengthMode;

			//this will calibrate detectors, then do measure source strength
			vSystemData.vCalibrateErrorCount = 0;
			vSystemData.vCalibrateADCAfterDAC = true;
			vSystemData.vAutoCalibrate = true;
			vSystemData.vAutoCalibrateWhileRunning = false;
			vSystemData.vFullDetectorCalibration = false;
			if (vConfigurationData->vUseDACAndADCinDensityCompensation)
				CalibrateDACDetectorOffset();
			else
				CalibrateADCDetectorOffset(vSystemData.vAutoCalibrate, false);
		}
	}
}
void CScanTracDlg::TurnOffEjectorIn100mSec(long TempEjectorNumber)
{
	vEjectorNumberToTurnOff = (BYTE)TempEjectorNumber;
	int TempTimerResult = SetTimer(vTurnOffEjectorIn100mSecTimerHandle,100,NULL);
	if (!TempTimerResult)
		ReportErrorMessage("Error-Turn Off Ejector Message Timer Failed",cEMailInspx,32000);
}

void CScanTracDlg::StartCheckWeighingMenu(bool TempGoToOffsetCalibration)
{
	vNumberOfWeighInspections = 0;
	if (vGlobalCurrentProduct)
	for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
	if (vGlobalCurrentProduct->vInspection[TempLoop])
	{
		//if (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection)
		//	vHaveCheckWeighInspection++;
		if ((vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection) || (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection) ||
			(vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection))
		if (!vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionNameForWeightTrendingPointer) //if wieght trending inspection, use other inspections settings
			vNumberOfWeighInspections++;
	}
	if (vNumberOfWeighInspections)
	if (vGlobalCurrentProduct)
	if (PasswordOK(cOperatorPassword, true))
	{
		int TempCheckWeighInspection = -1;
		if (vNumberOfWeighInspections > 1)
		{ //have more than 1 Weight Trending inspection, so ask user for which one
			CSelectItemDialog ISelectItemDialog;

			//Set dialog box data titles and number value
			ISelectItemDialog.vTitleString.LoadString(IDS_CheckWeigh);
			ISelectItemDialog.vNumberOfItems = 0;
			ISelectItemDialog.vBackgroundColor = cGreen;

			for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
			if (vGlobalCurrentProduct->vInspection[TempLoop])
			if ((vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection) || (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection) ||
				(vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection))
			if (!vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionNameForWeightTrendingPointer)
			{
				ISelectItemDialog.vItems[ISelectItemDialog.vNumberOfItems] = vGlobalCurrentProduct->vInspection[TempLoop]->vName;
				ISelectItemDialog.vNumberOfItems++;
			}
			ISelectItemDialog.m_DialogTitleStaticText2 = "Select Which Weight Trending Inspection Data To View";
			ISelectItemDialog.m_DialogTitleStaticText3 = "";

			//Pass control to dialog box and display
			int nResponse = ISelectItemDialog.DoModal();
			//dialog box is now closed, if user pressed select do this
			//if user pressed cancel, do nothing
			if (nResponse == IDOK)
			{
				BYTE TempWhichOne = 0;
				for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
				if (vGlobalCurrentProduct->vInspection[TempLoop])
				if ((vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection) || (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection) ||
					(vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection))
				if (!vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionNameForWeightTrendingPointer)
				{
					if (TempWhichOne == ISelectItemDialog.vItemNumberSelected - 1)
					{
						TempCheckWeighInspection = TempLoop;
						TempLoop = vGlobalCurrentProduct->vNumberOfInspections;
					}
					TempWhichOne++;
				}
			}
			else
			if (nResponse == 10)
			{
				//Main Menu button pressed
				Sleep(1); //is the equivelent of a yeild statement;
				CDialog::EndDialog(10);
			}
		}
		else
		{
			if (vGlobalCurrentProduct)
			for (BYTE TempLoop = 0; TempLoop < vGlobalCurrentProduct->vNumberOfInspections; TempLoop++)
			if (vGlobalCurrentProduct->vInspection[TempLoop])
			if ((vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cCheckWeighInspection)
				|| (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cUnderfillByWeightInspection)
				|| (vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionType == cOverfillByWeightInspection))
			if (!vGlobalCurrentProduct->vInspection[TempLoop]->vInspectionNameForWeightTrendingPointer)
				TempCheckWeighInspection = TempLoop;
		}
		if (TempCheckWeighInspection >= 0)
		{
			CCheckWeighDialog TempCheckWeighDialog;
			TempCheckWeighDialog.vCheckWeighInspectionNumber = TempCheckWeighInspection;
			TempCheckWeighDialog.vCheckWeighInspection = (CInspectionCheckWeigh *)vGlobalCurrentProduct->vInspection[TempCheckWeighInspection];
			TempCheckWeighDialog.vMainWindowPointer = this;
			TempCheckWeighDialog.vLocalSystemData = &vSystemData;
			TempCheckWeighDialog.vLocalConfigurationData = vConfigurationData;
			TempCheckWeighDialog.vStartInCalibrateOffset = TempGoToOffsetCalibration;
			int nResponse = TempCheckWeighDialog.DoModal();
			if (nResponse == 10)  //main menu
				OnFunction1Button();
		}
	}
}

void CScanTracDlg::ClearXScanProducts()
{
	//must go through every product and clear X-Scan
	int TempNumberOfProducts = vProductCollection.GetSize();
	for (WORD TempLoop = 1; TempLoop <= TempNumberOfProducts; TempLoop++)
	{
		CProduct *TempProductPointer = GetProductByNumber(TempLoop);
		if (TempProductPointer)
				TempProductPointer->vUsingXScanPoint4mmDetectors = 0;
	}
}

void CScanTracDlg::UpdateAllInspectionNames()
{
	CYesNoDialog TempYesNoDialog;
	TempYesNoDialog.vNoticeText = _T("Update all inspection names\nin all products with new names?\nContaminant P, Q, R will be Small, Medium, and Large Contaminant.\nContaminant T will be Metal Contaminant.");
	TempYesNoDialog.vQuestionType = cConfirmAbandon;
	TempYesNoDialog.vYesButtonText = "Update Names";
	TempYesNoDialog.vNoButtonText = "Cancel";
	int TempResult = TempYesNoDialog.DoModal();
	//if user said OK
	if (TempResult == IDOK)
	{
		WORD TempProductNumber = 0;
		CProduct *TempProductPointer = NULL;
		int TempNumberOfProducts = vProductCollection.GetSize();
		//need to loop until end of file
		for (BYTE TempLoop=1; TempLoop <= TempNumberOfProducts ; TempLoop++)
		{
			TempProductPointer = GetProductByNumber(TempLoop);
			if (TempProductPointer)
				TempProductPointer->ChangeInspectionNames();
		}
		CNoticeDialog TempNoticeDialog;
		TempNoticeDialog.vNoticeText = "\n\n\nAll Inspection Names Updated";
		TempNoticeDialog.vType = cInformationMessage;
		TempNoticeDialog.DoModal();
	}
}

void CScanTracDlg::TickleWatchDogs()
{
	double TempCurrentTime = CIFCOS::GetSystimeMillisecs();
	if (TempCurrentTime > vSystemData.vLastTickleTime + 500) // if it has been more than a half second, then send tickles
	{
		vSystemData.vLastTickleTime = TempCurrentTime;

		if ((vGlobalDXMXRayPort) && ((vConfigurationData->vHVPSType == cCheyneyMonoBlock) || (vConfigurationData->vHVPSType == c100WMonoBlockHVPS) || (vConfigurationData->vHVPSType == c100WVJTMonoBlockHVPS)))
			vGlobalDXMXRayPort->TickleWatchDog();  //if do before system is initialized, then will time out as takes more than 10 seconds to initialize

		if (vGlobalMonoBlockXRayPort)
			vGlobalMonoBlockXRayPort->TickleXRayWatchDog();

 		if (vSystemData.vLogFile.vLogSyncData)
			SendSynchronizeCommand();
	}
}

void CScanTracDlg::SelectLanguage()
{
	CSelectItemDialog ISelectItemDialog;
	ISelectItemDialog.vTitleString = "Select Language for User Menus";
	ISelectItemDialog.vNumberOfItems = 6;
	ISelectItemDialog.vBackgroundColor = cGreen;

	ISelectItemDialog.vItems[0] = "English";
	ISelectItemDialog.vItems[1] = "French";
	ISelectItemDialog.vItems[2] = "Spanish";
	ISelectItemDialog.vItems[3] = "Polish";
	ISelectItemDialog.vItems[4] = "German";
	ISelectItemDialog.vItems[5] = "Chinese Simplified";
	ISelectItemDialog.m_DialogTitleStaticText2 = "";
	ISelectItemDialog.vGreenItem = vConfigurationData->vLanguage;
	ISelectItemDialog.m_DialogTitleStaticText3 = "";
	//Pass control to dialog box and display
	int nResponse = ISelectItemDialog.DoModal();
	//dialog box is now closed, if user pressed select do this
	//if user pressed cancel, do nothing
	if (nResponse == IDOK)
	{
		if (ISelectItemDialog.vItemNumberSelected != vConfigurationData->vLanguage)
		{
			CYesNoDialog TempYesNoDialog;
			CString TempString = ISelectItemDialog.vItems[ISelectItemDialog.vItemNumberSelected - 1];
			TempString = "\nAre you sure you want to change the display language?\nConfirming will display the Main Menu in " 
														+ TempString + ".";
			TempYesNoDialog.vNoticeText = TempString;
			TempYesNoDialog.vYesButtonText = "Change Language";
			TempYesNoDialog.vNoButtonText = "Cancel";
			TempYesNoDialog.vQuestionType = cConfirmQuestion;
			int TempResult = TempYesNoDialog.DoModal();
			if (TempResult == IDOK)
			{
				vConfigurationData->vLanguage = ISelectItemDialog.vItemNumberSelected;
				vGlobalLanguage = vConfigurationData->vLanguage;
				if (vConfigurationData->vLanguage == cSpanish)
				{
					CYesNoDialog TempYesNoDialog;
					TempYesNoDialog.vNoticeText = _T("\n\n\nUse . or , in numbers?");
					TempYesNoDialog.vQuestionType = cQuestion;
					TempYesNoDialog.vYesButtonText = ".";
					TempYesNoDialog.vNoButtonText = ",";
					int TempResult = TempYesNoDialog.DoModal();
					//if user said OK
					if (TempResult != IDOK)
					{
						vGlobalUseCommaForDecimalPoint = true;
					}
				}
				SetupLanguage();
			}
		}
	}
}

void CScanTracDlg::ShowMultiLaneCounts()
{
	CString TempString = "";
	BYTE TempRowsOnScreen = 6;
	if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
	{
		if (vGlobalCurrentProduct)
		{
			BYTE TempStartLane = 0;
			bool TempMoreToDo = true;
			while (TempMoreToDo)
			{
				BYTE TempEndLane = vGlobalCurrentProduct->vMultiLaneNumberOfLanes;
				if (vGlobalCurrentProduct->vMultiLaneNumberOfLanes > TempRowsOnScreen)
				{
					TempEndLane = TempStartLane + TempRowsOnScreen;
					if (TempEndLane > vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
						TempEndLane = vGlobalCurrentProduct->vMultiLaneNumberOfLanes;
				}
				CString TempLineText = "Test";

				TempLineText = "\nLane";
				FillToTab(&TempLineText, 10);
				for (BYTE TempLaneLoop = TempStartLane; TempLaneLoop < TempEndLane; TempLaneLoop++)
				{
					TempLineText = TempLineText + Pad(dtoa(TempLaneLoop + 1, 0), 10, 0);
				}
				TempString = TempString + TempLineText;

				TempLineText = "\nTotal";
				FillToTab(&TempLineText, 10);
				for (BYTE TempLaneLoop = TempStartLane; TempLaneLoop < TempEndLane; TempLaneLoop++)
				{
					TempLineText = TempLineText + Pad(dtoa(vSystemData.vMultiLaneTotalCounts[TempLaneLoop], 0), 10, 0);
				}
				TempString = TempString + TempLineText;

				TempLineText = "\nEjected";
				FillToTab(&TempLineText, 10);
				for (BYTE TempLaneLoop = TempStartLane; TempLaneLoop < TempEndLane; TempLaneLoop++)
				{
					TempLineText = TempLineText + Pad(dtoa(vSystemData.vMultiLaneTotalEjectsCounts[TempLaneLoop], 0), 10, 0);
				}
				TempString = TempString + TempLineText;

				TempLineText = "\n*Disabled";
				FillToTab(&TempLineText, 10);
				for (BYTE TempLaneLoop = TempStartLane; TempLaneLoop < TempEndLane; TempLaneLoop++)
				{
					TempLineText = TempLineText + Pad(dtoa(vSystemData.vMultiLaneTotalDisabledEjectsCounts[TempLaneLoop], 0), 10, 0);
				}
				TempString = TempString + TempLineText;

				TempLineText = "\nGood";
				FillToTab(&TempLineText, 10);
				for (BYTE TempLaneLoop = TempStartLane; TempLaneLoop < TempEndLane; TempLaneLoop++)
				{
					TempLineText = TempLineText + Pad(dtoa(vSystemData.vMultiLaneTotalCounts[TempLaneLoop] - vSystemData.vMultiLaneTotalEjectsCounts[TempLaneLoop] -
						vSystemData.vMultiLaneTotalDisabledEjectsCounts[TempLaneLoop], 0), 10, 0);
				}
				TempString = TempString + TempLineText;

				TempString = TempString + "\n-----------------------------------------------------------------------------";

				if (vGlobalCurrentProduct->vNumberOfInspections)
				for (BYTE TempLoopInspection = 0; TempLoopInspection < vGlobalCurrentProduct->vNumberOfInspections; TempLoopInspection++)
				if (vGlobalCurrentProduct->vInspection[TempLoopInspection])
				{
					TempLineText = "\nInsp. " + Pad(dtoa(TempLoopInspection + 1, 0), 2, 0);
					FillToTab(&TempLineText, 10);
					for (BYTE TempLaneLoop = TempStartLane; TempLaneLoop < TempEndLane; TempLaneLoop++)
					{
						TempLineText = TempLineText + Pad(dtoa(vSystemData.vMultiLaneInspectionCounts[TempLaneLoop][TempLoopInspection], 0), 10, 0);
					}
					TempLineText = TempLineText + "  " + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName;
					TempString = TempString + TempLineText;

					TempLineText = "\n*Disabled";
					FillToTab(&TempLineText, 10);
					for (BYTE TempLaneLoop = TempStartLane; TempLaneLoop < TempEndLane; TempLaneLoop++)
					{
						TempLineText = TempLineText + Pad(dtoa(vSystemData.vMultiLaneInspectionDisabledCounts[TempLaneLoop][TempLoopInspection], 0), 10, 0);
					}
					TempLineText = TempLineText + "  " + vGlobalCurrentProduct->vInspection[TempLoopInspection]->vName;
					TempString = TempString + TempLineText;
				}
				TempStartLane = TempStartLane + TempRowsOnScreen;
				if (TempStartLane >= vGlobalCurrentProduct->vMultiLaneNumberOfLanes)
					TempMoreToDo = false;
				else
					TempString = TempString + "\n\n\n";

			}
		}
		else
			TempString = " You Must Select A Product to see its Inspection Thresholds.\n";

		CHelpDialog IHelpDialog;
		IHelpDialog.vHelpContext = 16;
		IHelpDialog.vShowTable = true;
		IHelpDialog.vHelpType = 0;
		IHelpDialog.vWindowType = cTextWindow;
		IHelpDialog.vLocalProductCollection = &vProductCollection;
		IHelpDialog.vLocalSystemData = &vSystemData;
		IHelpDialog.vMainWindowPointer = this;
		IHelpDialog.vLocalConfigurationData = vConfigurationData;
		IHelpDialog.vProductPointer = vGlobalCurrentProduct;
		IHelpDialog.vTextString = TempString;

		CString TempText = _T("-");
		TempText.LoadString(IDS_LaneCounts);
		IHelpDialog.vTitleString = vSystemData.vCurrentProductName + " " + TempText;
		int TempResult = IHelpDialog.DoModal();
	}
}

void CScanTracDlg::UpdateButtons()
{
	if (!vDisplayingVersion)
	{
		CString TempText = _T("-");
		if (vSystemData.vValveData)
		{
			TempText.LoadString(IDS_SamplingandFillerMonitor);
			SetDlgItemText(IDC_SubFunction7Button, TempText);
			m_SubFunction7Button.ShowWindow(SW_SHOW);
		}
		else
		if (vConfigurationData->vNumberOfHeadsToMonitor[cRandomSamplingType] == 1)
		{
			TempText.LoadString(IDS_Sampling);
			SetDlgItemText(IDC_SubFunction7Button, TempText);
			m_SubFunction7Button.ShowWindow(SW_SHOW);
		}
		else
		if ((vGlobalCurrentProduct) && (vGlobalCurrentProduct->vMultiLaneNumberOfLanes))
		{
			TempText.LoadString(IDS_DisplayLaneCounts);
			SetDlgItemText(IDC_SubFunction7Button, TempText);
			m_SubFunction7Button.ShowWindow(SW_SHOW);
		}
		else
		{
			m_SubFunction7Button.ShowWindow(SW_HIDE);
			this->InvalidateRect(&m_SubFunction7Button.GetRectToInvalidateArrow());
		}
	}
}

void CScanTracDlg::OnStnClickedTotalcontainerslabel()
{
	ShowMultiLaneCounts();
}

#ifdef CompileInHTTPClientOperationsGuardian
void CScanTracDlg::SendOGInfo(std::wstring TempKeyWord, CString TempMessage, bool TempMultiItemFormat)
{
	//check if OG communications are enabled
	if (vConfigurationData->vEnableOperationsGuardian)
	{
		//queue up string to send out in background
		WORD TempCheckNext = vGlobalOGQueueHead;
		if (TempCheckNext < cOGQueueLength - 1)
			TempCheckNext++;
		else
			TempCheckNext = 0;

		if (TempCheckNext != vGlobalOGQueueTail)
		{
			//make it a JSON message for the OG Server
			if (TempMultiItemFormat)
				TempMessage = "{ \"current\" : " + TempMessage + " , \"machineID\" : \"" + vConfigurationData->vScanTracID + "\" }";
			else
				TempMessage = "{ \"current\" : \"" + TempMessage + "\" , \"machineID\" : \"" + vConfigurationData->vScanTracID + "\" }";

			vGlobalOGQueueMessage[vGlobalOGQueueHead] = TempMessage;
			vGlobalOGQueueKeyWord[vGlobalOGQueueHead] = TempKeyWord;

			vGlobalOGQueueHead = TempCheckNext; //head always points to the next spot to write in
			vGaveOGOverFlowError = false;
		}
		else
		if (!vGaveOGOverFlowError)
		{
			vGaveOGOverFlowError = true;
			ReportErrorMessage("Operations Guardian Queue Overflow", cEMailInspx, 32000);
		}
	}
}

void CScanTracDlg::SendOGInfoWithoutCurrent(std::wstring TempKeyWord, CString TempMessage, bool TempMultiItemFormat)
{
	//check if OG communications are enabled
	if (vConfigurationData->vEnableOperationsGuardian)
	{
		//queue up string to send out in background
		WORD TempCheckNext = vGlobalOGQueueHead;
		if (TempCheckNext < cOGQueueLength - 1)
			TempCheckNext++;
		else
			TempCheckNext = 0;

		if (TempCheckNext != vGlobalOGQueueTail)
		{
			//make it a JSON message for the OG Server
			if (TempMultiItemFormat)
				TempMessage = "{ " + TempMessage + " , \"machineID\" : \"" + vConfigurationData->vScanTracID + "\" }";
			else
				TempMessage = "{ " + TempMessage + " , \"machineID\" : \"" + vConfigurationData->vScanTracID + "\" }";

			vGlobalOGQueueMessage[vGlobalOGQueueHead] = TempMessage;
			vGlobalOGQueueKeyWord[vGlobalOGQueueHead] = TempKeyWord;

			vGlobalOGQueueHead = TempCheckNext; //head always points to the next spot to write in
			vGaveOGOverFlowError = false;
		}
		else
		if (!vGaveOGOverFlowError)
		{
			vGaveOGOverFlowError = true;
			ReportErrorMessage("Operations Guardian Queue Overflow", cEMailInspx, 32000);
		}
	}
}

void CScanTracDlg::CreateOGServerSendMessageThread()
{
	//if (vConfigurationData->vEnableOperationsGuardian)
	if (vGlobalSendNextOGMessageThread == NULL)
	{
		vGlobalSendNextOGMessageThread = (CSendNextOGMessageThread *)AfxBeginThread(RUNTIME_CLASS(CSendNextOGMessageThread), THREAD_PRIORITY_IDLE, 0, CREATE_SUSPENDED);
		if (!vGlobalSendNextOGMessageThread)
			ReportErrorMessage("Error-Could Not Create Thread to send Operations Guardian Messages", cEMailInspx, 32000); 
		else
		{
			vGlobalSendNextOGMessageThread->ResumeThread();
			ReportErrorMessage("Created Thread to send Operations Guardian Messages", cWriteToLog, 0); 
			vSystemData.vOperationsGuardianConnected = true;
		}
	}
}

void CScanTracDlg::CloseOGServerSendMessageThread()
{
	if (vGlobalSendNextOGMessageThread)
	{
		vGlobalSendNextOGMessageThread->vShutDown = true;
		vSystemData.vOperationsGuardianConnected = false;
	}
}

void CScanTracDlg::DisplayOGStatus()
{
	if (vOldLastOGServerWriteStatusCode != vGlobalLastOGServerWriteStatusCode)
	{
		vOldLastOGServerWriteStatusCode = vGlobalLastOGServerWriteStatusCode;
		if ((vOldLastOGServerWriteStatusCode >= 200) && (vOldLastOGServerWriteStatusCode <= 202))
		{
			ReportErrorMessage("Operations Guardian Server Write Status = Success", cWriteToLog, 0);
			if (vSystemData.vOperationsGuardianError)
			{
				vSystemData.vOperationsGuardianError = 0;
				SetInterlockStatus();
			}
		}
		else
		{
			if (vOldLastOGServerWriteStatusCode == 404)
				ReportErrorMessage("Operations Guardian Write Failed 404-Maybe ScanTrac Serial Number not in OG Database", cError, 0);
			else
			if (vOldLastOGServerWriteStatusCode == 1)
				ReportErrorMessage("Operations Guardian Write Failed 1-Data Invalid", cError, 0);
			else
				ReportErrorMessage("Operations Guardian Server Write Status = Failed.  Error Code: " + dtoa(vOldLastOGServerWriteStatusCode, 0), cError, 0);

			if (!vSystemData.vOperationsGuardianError)
			{
				vSystemData.vOperationsGuardianError = 1;
				SetInterlockStatus();
			}
		}
	}
}

void CScanTracDlg::SendOGOneMinueData(bool TempSendAll)
{
	if (vConfigurationData->vEnableOperationsGuardian)
	{
		if (vSystemData.vCountTimeAsRunning)  //if no containers going through, then count time as stopped
		{
			if ((TempSendAll) || (vLastOGRunDuration != vSystemData.vRunDuration))
			{
				vLastOGRunDuration = vSystemData.vRunDuration;
				SendOGInfo(std::wstring(L"runduration"), dtoa(vLastOGRunDuration), false);
			}
		}
		else
		{
			if ((TempSendAll) || (vLastOGStopDuration != vSystemData.vOldStopDuration))
			{
				vLastOGStopDuration = vSystemData.vOldStopDuration;
				SendOGInfo(std::wstring(L"stopduration"), dtoa(vLastOGStopDuration, 0), false);
			}
		}

		if ((TempSendAll) || (vLastOGRejectCountTotal != vSystemData.vRejectCountTotal))
		{
			vLastOGRejectCountTotal = vSystemData.vRejectCountTotal;
			SendOGInfo(std::wstring(L"rejecttotal"), dtoa(vLastOGRejectCountTotal, 0), false);
		}

		if ((TempSendAll) || (vLastOGEjectCountTotal != vSystemData.vEjectCountTotal))
		{
			vLastOGEjectCountTotal = vSystemData.vEjectCountTotal;
			SendOGInfo(std::wstring(L"ejecttotal"), dtoa(vLastOGEjectCountTotal, 0), false);
		}

		if ((TempSendAll) || (vLastOGPercentEjected != vSystemData.vOldPercentEjected))
		{
			vLastOGPercentEjected = vSystemData.vOldPercentEjected;
			SendOGInfo(std::wstring(L"ejectrate"), dtoa(vLastOGPercentEjected, 0), false);
		}

		//if ((TempSendAll) || (vLastOGXRaySourceRunDuration != vGlobalLifeTimeCounters->vXRaySourceRunDuration))
		//{
		//	vLastOGXRaySourceRunDuration = vGlobalLifeTimeCounters->vXRaySourceRunDuration;
		//	SendOGInfo(std::wstring(L"xraysourceduration"), dtoa(vLastOGXRaySourceRunDuration, 0), false);
		//}

		//if ((TempSendAll) || (((vLastOGBeltRate * 1.1) < vSystemData.vBeltRate) || ((vLastOGShiftRateCPM * 0.9) > vSystemData.vBeltRate)))
		//{
		//	vLastOGBeltRate = vSystemData.vBeltRate;
		//	SendOGInfo(std::wstring(L"conveyorspeed"), dtoa(vLastOGBeltRate / 12, 0), false);
		//}

		//if ((TempSendAll) || (vLastOGTimeSinceLastStop != vSystemData.vTimeSinceLastStop))
		//{
		//	vLastOGTimeSinceLastStop = vSystemData.vTimeSinceLastStop;
		//	SendOGInfo(std::wstring(L"timesincelaststop"), dtoa(vLastOGTimeSinceLastStop, 0), false);
		//}

		if ((TempSendAll) || (vLastOGTotalContainers != vSystemData.vTotalContainers))
		{
			vLastOGTotalContainers = vSystemData.vTotalContainers;
			SendOGInfo(std::wstring(L"totalcontainers"), dtoa(vLastOGTotalContainers, 0), false);
		}

		if ((TempSendAll) || (vLastOGContainerRate != vSystemData.vOldContainerRate))
		{
			vLastOGContainerRate = vSystemData.vOldContainerRate;
			SendOGInfo(std::wstring(L"cpm"), dtoa(vLastOGContainerRate, 0), false);
		}

		if ((TempSendAll) || (((vLastOGShiftRateCPM * 1.1) < vSystemData.vShiftRateCPM) || ((vLastOGShiftRateCPM * 0.9) > vSystemData.vShiftRateCPM)))
		{
			vLastOGShiftRateCPM = vSystemData.vShiftRateCPM;
			SendOGInfo(std::wstring(L"shiftrate"), dtoa(vLastOGShiftRateCPM, 0), false);
		}

		CString rejectcriteriaJSON("[");
		//update inspection count displays on screen if need to
		for (BYTE TempLoop = 0; TempLoop < vSystemData.vTotalNumberOfInspections; TempLoop++)
		{
			rejectcriteriaJSON += "{\"inspection_name\":\"";
			rejectcriteriaJSON += vSystemData.vCriteriaString[TempLoop];
			rejectcriteriaJSON += "\",\"ejector_status\":\"Enabled\",\"count\":";
			rejectcriteriaJSON += IToAWithComma(vSystemData.vOldXRayCriteriaCount[TempLoop]);
			rejectcriteriaJSON += "} , ";
		}
		//display inspection disabled counts
		for (BYTE TempLoop = 0; TempLoop < vSystemData.vTotalNumberOfInspections; TempLoop++)
		{
			rejectcriteriaJSON += "{\"inspection_name\":\"";
			rejectcriteriaJSON += vSystemData.vCriteriaString[TempLoop];
			rejectcriteriaJSON += "\",\"ejector_status\":\"Disabled\",\"count\":";
			rejectcriteriaJSON += dtoa(vSystemData.vOldXRayCriteriaCountButDisabled[TempLoop], 0);
			rejectcriteriaJSON += "}";
			if (TempLoop < vSystemData.vTotalNumberOfInspections - 1) //don't put comma after last item
				rejectcriteriaJSON += ",";
		}
		rejectcriteriaJSON += "]";
		SendOGInfo(std::wstring(L"rejectcriteria"), rejectcriteriaJSON, true);
	}
}

void CScanTracDlg::SendOGTimeZoneData()
{
	if (vConfigurationData->vEnableOperationsGuardian)
	{
		size_t TempLength = 0;
		char TempTimeZoneString[101];
		int TempIndex = 0;
		int errno_t = _get_tzname(&TempLength, TempTimeZoneString, 100, TempIndex);
		if (errno_t == 0)
		{
			CString TempTimeZoneCode = TempTimeZoneString[0]; // + TempTimeZoneString[1] + TempTimeZoneString[2];
			TempTimeZoneCode = TempTimeZoneCode + TempTimeZoneString[1] + TempTimeZoneString[2];
			CString TempJSONString("\"timezone\" : \"");
			TempJSONString += TempTimeZoneCode;
			TempJSONString += "\"";

			SendOGInfoWithoutCurrent(std::wstring(L"configuration"), TempJSONString, false);
		}
		else
			ReportErrorMessage("Operations Guardian, Send Time Zone Message Failed", cEMailInspx, 32000);
	}
}

void CScanTracDlg::SendOGSevereEvent(BYTE TempEventType)
{
	if (vConfigurationData->vEnableOperationsGuardian)
	{
		CString TempEventTypeString = "interlock_broken";

		switch (TempEventType)
		{
			case cOGSevereMessageInterlockBroken:	TempEventTypeString = "interlock_broken"; break;
			case cOGSevereMessageXRayFault:	TempEventTypeString = "xray_fault"; break;
			case cOGSevereMessageImageFault:	TempEventTypeString = "image_fault"; break;
			case cOGSevereMessageEjectorFault:	TempEventTypeString = "ejector_fault"; break;
			case cOGSevereMessageTemperatureFault:	TempEventTypeString = "over_temperature"; break;
			case cOGSevereMessageComFault:	TempEventTypeString = "com_fault"; break;
			case cOGSevereMessagePowerFault:	TempEventTypeString = "power_fault"; break;
		}

		CString TempJSONString("\"type\" : \"severe_event\" , \"event_type\" : \"");
		TempJSONString += TempEventTypeString;
		TempJSONString += "\"";
		if (vGlobalOGLocationString.GetLength() > 1)
		{
			TempJSONString += ", \"location\" : \"";
			TempJSONString += vGlobalOGLocationString;
			TempJSONString += "\"";
		}
		if (vGlobalOGLimitString.GetLength() > 1)
		{
			TempJSONString += ", \"limit\" : \"";
			TempJSONString += vGlobalOGLimitString;
			TempJSONString += "\"";
		}
		if (vGlobalOGErrorCode > 0)
		{
			TempJSONString += ", \"error_code\" : \"";
			TempJSONString += dtoa(vGlobalOGErrorCode, 0);
			TempJSONString += "\"";
		}
		
		SendOGInfoWithoutCurrent(std::wstring(L"alert"), TempJSONString, false);
		vGlobalOGLimitString = "";
		vGlobalOGLocationString = "";
		vGlobalOGErrorCode = 0;
	}
}
#endif
void CScanTracDlg::TestDTOA()
{
	for (DWORD TempLoop = 0; TempLoop < 64000; TempLoop++)
	{
		CString TempString = dtoa(TempLoop, 4);
		vSystemData.vTotalContainers++;

		//USES_CONVERSION;
		//LPSTR TempStringToWrite = W2A(TempString);
		CW2A TempStringToWrite(TempString);
	}
}

void CScanTracDlg::SendRetriggerLockout(WORD TempLockout)
{
	tSerialCommand TempCommand;
	TempCommand[0] = 0x15;
	TempCommand[1] = (BYTE)(TempLockout >> 8);
	TempCommand[2] = (BYTE)TempLockout;
	TempCommand[3] = 0;
	if (vGlobaluCSerialPort)
		vGlobaluCSerialPort->SendSerialCommand(TempCommand);
	Sleep(cSendCommandSleepTimeSetup);
}

void CScanTracDlg::HandleRFIDEASBadgeRead()
{
	bool TempRFIDNotFound = true;
	int nResponse;
	CString TempBadgeRead = vGlobalBadgeReaderRFIDString;
	TempBadgeRead.Remove(':');
	DWORD TempRFIDFromBadgeRead = (DWORD)ATOF(TempBadgeRead);

	//loop through users to find RFID Badge Read match
	for (POSITION TempPosition = vSystemData.vUserCollection.GetHeadPosition(); TempPosition; vSystemData.vUserCollection.GetNext(TempPosition))
	{
		DWORD TempRFID = vSystemData.vUserCollection.GetAt(TempPosition)->vRFID;
		
		if (TempRFID == TempRFIDFromBadgeRead)	//user badge rfid matched user
		{
			TempRFIDNotFound = false;//cnotice box close in 2 seconds username logged in & report error message
			//try toggling to log out user if already logged in
			if (vGlobalCurrentUser == vSystemData.vUserCollection.GetAt(TempPosition)->vUserName)
			{
				ReportErrorMessage(vSystemData.vUserCollection.GetAt(TempPosition)->vUserName + " Logged out, Badge RFID: " + vGlobalBadgeReaderRFIDString, cUserAction, 0);

				EnumWindows(LogoutToMainMenuAfterBadgeOut, NULL);

				vGlobalPasswordLevel = 0;
				vGlobalCurrentUser = "";
				vGlobalDialogTitleColor = cDarkBlue;
				::PostThreadMessage(vGlobalCallingThreadID, cUpdateTitleBarMessage, 0, 0);

				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\nLogged out User: " + vSystemData.vUserCollection.GetAt(TempPosition)->vUserName;
				TempNoticeDialog.vType = cNoticeMessage;
				TempNoticeDialog.vAutoClose = 2000;
				TempNoticeDialog.DoModal();
			}
			else
			{
				vGlobalPasswordLevel = vSystemData.vUserCollection.GetAt(TempPosition)->vLevel;
				vGlobalCurrentUser = vSystemData.vUserCollection.GetAt(TempPosition)->vUserName;
				::PostThreadMessage(vGlobalCallingThreadID, cStartPasswordTimerMessage, 0, 0);
				switch (vGlobalPasswordLevel)
				{
					case cResetPassword:
					case cOperatorPassword:
					case	cNoPassword:
						vGlobalDialogTitleColor = cDarkBlue;
					break;
					case cSetupPassword:
					case cAdvancedSetupPassword:
					case cCertifiedPassword:
					case cAllansPassword:
						vGlobalDialogTitleColor = cDarkGreen;
					break;
					case cTemporaryInspxPassword:
					case cInspxPassword:
					case cSuperInspxPassword:
						vGlobalDialogTitleColor = cBrilliantBlue;
					break;
					default:
						vGlobalDialogTitleColor = cDarkBlue;
					break;
				}
				ReportErrorMessage(vSystemData.vUserCollection.GetAt(TempPosition)->vUserName + " Logged in, Badge RFID: " + vGlobalBadgeReaderRFIDString, cUserAction, 0);
			
				//check if password dialog is open, if so close it.
				CRuntimeClass  *TempClassPointer = NULL;
				CWnd *TempActiveWindow = this->GetForegroundWindow();
				CString TempString = "";
				if (TempActiveWindow)
					TempActiveWindow->GetWindowText(TempString);
				//if password dialog is open, destroy so other windows can display
				if (TempString == "Password")
				{
					vGlobalClosePasswordDialog = true;
					//TempActiveWindow->DestroyWindow();
					//this->SetActiveWindow();
				}
				::PostThreadMessage(vGlobalCallingThreadID, cUpdateTitleBarMessage, 0, 0);

				CNoticeDialog TempNoticeDialog;
				TempNoticeDialog.vNoticeText = "\n\nLogged in User: " + vSystemData.vUserCollection.GetAt(TempPosition)->vUserName;
				TempNoticeDialog.vType = cNoticeMessage;
				TempNoticeDialog.vAutoClose = 2000;
				TempNoticeDialog.DoModal();
			}
		}
	}

	//if no match, ask if want to add new user
	if (TempRFIDNotFound == true)
	{
		ReportErrorMessage("Badge RFID: " + vGlobalBadgeReaderRFIDString + " not in this ScanTrac user database", cUserAction, 0);

		CYesNoDialog TempYesNoDialog;
		CString TempNoticeText = "\n\nThis Badge RFID:"  + dtoa(TempRFIDFromBadgeRead) + "\nIs not in User database.";
		TempYesNoDialog.vNoticeText = TempNoticeText;
		TempYesNoDialog.vQuestionType = cConfirmQuestion;
		TempYesNoDialog.vYesButtonText = "Add User";
		TempYesNoDialog.vNoButtonText = "Close";
		int TempResult = TempYesNoDialog.DoModal();
		if (TempResult == IDOK)
		{
			//if pswd not in, ask for password entry to add new user
			if (PasswordOK(cCertifiedPassword,true))
			{
				CEditUser IEditUser;
				IEditUser.vShowMainMenuButton = false;
				IEditUser.vCurrentUser.vLevel = cSetupPassword;
				IEditUser.vCurrentUser.vRFID = TempRFIDFromBadgeRead;
				IEditUser.vLocalSystemData = &vSystemData;
				IEditUser.vLocalUserCollection =  &vSystemData.vUserCollection; //&(this->vLocalUserCollection);
				nResponse = IEditUser.DoModal();
				if (nResponse == IDOK)
				{
					UserPasswords* TempUser = new UserPasswords; 
					*TempUser = IEditUser.vCurrentUser;
					InsertAlphabetically(vSystemData.vUserCollection, TempUser);
					ReportErrorMessage("Operator added Badge user: " + TempUser->vUserName + ", RFID: " + vGlobalBadgeReaderRFIDString, cUserChanges, 0);
					vSystemData.StoreUserList();
					ReportErrorMessage("User saved the updated the user list", cUserChanges, 0);
					::PostThreadMessage(vGlobalCallingThreadID, cUpdateTitleBarMessage, 0, 0);
				}
				else 
				if (nResponse == 10)	//USER PRESSED MAIN MENU
				{
					CWnd *TempActiveWindow = this->GetForegroundWindow();
					CString TempString = "";
					if (TempActiveWindow)
					{
						TempActiveWindow->GetWindowText(TempString);
						//if main menu was pressed, and another menu had focus, then destroy window
						if (TempString != "Inspx-ScanTrac")
						{
							TempActiveWindow->DestroyWindow();
							this->SetActiveWindow();
						}
					}
				}
			}
		}
	}
}

BOOL CALLBACK LogoutToMainMenuAfterBadgeOut(HWND hwnd, LPARAM lParam)
{
	CWnd* pWnd = CWnd::FromHandle(hwnd);
	CWnd *TempWindow = pWnd->GetDlgItem(IDC_DialogTitleStaticText1);
	
	CString TempString = "";
	pWnd->GetWindowText(TempString);
	if (TempString != "Inspx-ScanTrac")
		pWnd->DestroyWindow();
	else
	{
		pWnd->SetActiveWindow();
		return FALSE;
	}
return TRUE;

}